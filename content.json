[{"title":"javascript数据结构与算法八（树）","date":"2019-02-28T08:08:07.000Z","path":"2019/02/28/cjsu6q1i1000nhgvb2tporm16/","text":"到目前为止，我们学习了一些顺序数据结构，学习的第一个非顺序数据结构是散列表。在节章，我们将要学习另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用。 一、 树数据结构树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图，如下图所示： 二、 树的相关术语一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点： 位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。 一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）。 三、 二叉树和二叉搜索树二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。 二叉搜索树将是我们在本章中要研究的数据结构。 3.1 创建 BinarySearchTree 类让我们开始创建自己的BinarySearchTree类。首先，声明它的结构： 12345678function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125;&#125; 下图展现了二叉搜索树数据结构的组织方式： 和链表一样，将通过指针来表示节点之间的关系（术语称其为边）。在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树，使用同样的方式（也使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。因此，将声明一个Node类来表示树中的每个节点（行{1}）。值得注意的一个小细节是，不同于在之前的章节中将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼。 我们将会遵循和LinkedList类中相同的模式，这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是根元素（行{2}） 然后，我们需要实现一些方法。下面是将要在树类中实现的方法。 insert(key)：向树中插入一个新的键。 search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。 inOrderTraverse：通过中序遍历方式遍历所有节点。 preOrderTraverse：通过先序遍历方式遍历所有节点。 postOrderTraverse：通过后序遍历方式遍历所有节点。 min：返回树中最小的值/键。 max：返回树中最大的值/键。 remove(key)：从树中移除某个键。 3.1.1 向树中插入一个键下面的代码是用来向树插入一个新键的算法的第一部分： 12345678this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125;&#125;; 要向树中插入一个新的节点（或项），要经历三个步骤。 第一步是创建用来表示新节点的Node类实例（行{1}）。只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针的值会由构造函数自动设置为null。 第二步要验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点（行{2}）。如果是，就将根节点指向新节点 第三步是将节点加在非根节点的其他位置。这种情况下，需要一个私有的辅助函数（行{3}），函数定义如下： 123456789101112131415var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125;&#125;; 如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入树的根节点和要插入的节点。 如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}），那么需要检查当前节点的左侧子节点。如果它没有左侧子节点（行{5}），就在那里插入新的节点。 如果有左侧子节点，需要通过递归调用insertNode方法（行{7}）继续找到树的下一层。在这里，下次将要比较的节点将会是当前节点的左侧子节点。 如果节点的键比当前节点的键大，同时当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。如果有右侧子节点，同样需要递归调用insertNode方法，但是要用来和新节点比较的节点将会是右侧子节点。 让我们通过一个例子来更好地理解这个过程。 考虑下面的情景：我们有一个新的树，并且想要向它插入第一个值。 12var tree = new BinarySearchTree();tree.insert(11); 这种情况下，树中有一个单独的节点，根指针将会指向它。源代码的行{2}将会执行。 现在，来考虑下图所示树结构的情况： 创建上图所示的树的代码如下，它们接着上面一段代码（插入了键为11的节点）之后输入执行： 12345678910111213tree.insert(7);tree.insert(15);tree.insert(5);tree.insert(3);tree.insert(9);tree.insert(8);tree.insert(10);tree.insert(13);tree.insert(12);tree.insert(14);tree.insert(20);tree.insert(18);tree.insert(25); 同时我们想要插入一个值为6的键，执行下面的代码： tree.insert(6); 下面的步骤将会被执行。 树不是空的，行{3}的代码将会执行。insertNode方法将会被调用（root, key[6]）。 算法将会检测行{4}（key[6] &lt; root[11]为真），并继续检测行{5}（node.left[7]不是null），然后将到达行{7}并调用insertNode（node.left[7], key[6]）。 将再次进入insertNode方法内部，但是使用了不同的参数。它会再次检测行{4}（key[6]&lt; node[7]为真），然后再检测行{5}（node.left[5]不是null），接着到达行{7}，调用insertNode（node.left[5], key[6]）。 将再一次进入insertNode方法内部。它会再次检测行{4}（key[6] &lt; node[5]为假），然后到达行{8}（node.right是null 然后，方法调用会依次出栈，代码执行过程结束 这是插入键6后的结果： 四、树的遍历遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做呢？应该从树的顶端还是底端开始呢？从左开始还是从右开始呢？访问树的所有节点有三种方式：中序、先序和后序。 4.1 中序遍历中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。我们来看它的实现： 123this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback); //&#123;1&#125;&#125;; inOrderTraverse方法接收一个回调函数作为参数。回调函数用来定义我们对遍历到的每个节点进行的操作（这也叫作访问者模式，要了解更多关于访问者模式的信息，请参考http://en.wikipedia.org/wiki/Visitor_pattern）。由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）。 1234567var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125;&#125;; 要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为null（这就是停止递归继续执行的判断条件——行{2}——递归算法的基本条件）。 然后，递归调用相同的函数来访问左侧子节点（行{3}）。接着对这个节点进行一些操作（callback），然后再访问右侧子节点（行{5}）。 我们试着在之前展示的树上执行下面的方法： 1234function printNode(value)&#123; //&#123;6&#125; console.log(value);&#125;tree.inOrderTraverse(printNode); //&#123;7&#125; 但首先，需要创建一个回调函数（行{6}）。我们要做的，是在浏览器的控制台上输出节点的值。然后，调用inOrderTraverse方法并将回调函数作为参数传入（行{7}）。当执行上面的代码后，下面的结果将会在控制台上输出（每个数字将会输出在不同的行）： 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25 完整案例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//创建 BinarySearchTree 类function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125; //私有的辅助函数 var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125; &#125;; //insert向树中插入一个键 this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125; &#125;; //inOrderTraverse中序遍历 this.inOrderTraverse = function (callback) &#123; // console.log(callback) inOrderTraverseNode(root, callback); //&#123;1&#125; &#125;; var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125; &#125;; // tree.inOrderTraverse(printNode); //&#123;7&#125; &#125; let binarySearchTree = new BinarySearchTree();function printNode(value) &#123; //&#123;6&#125; console.log(value);&#125;binarySearchTree.insert(7);binarySearchTree.insert(15);binarySearchTree.insert(5);binarySearchTree.insert(3);binarySearchTree.insert(9);binarySearchTree.insert(8);binarySearchTree.insert(10);binarySearchTree.insert(13);binarySearchTree.insert(12);binarySearchTree.insert(14);binarySearchTree.insert(20);binarySearchTree.insert(18);binarySearchTree.insert(25); binarySearchTree.insert(6); binarySearchTree.inOrderTraverse(printNode) 下面的图描绘了inOrderTraverse方法的访问路径： 4.2 先序遍历先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。 我们来看实现: 1234567891011this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback);&#125;; //preOrderTraverseNode方法的实现如下：var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key); //&#123;1&#125; preOrderTraverseNode(node.left, callback); //&#123;2&#125; preOrderTraverseNode(node.right, callback); //&#123;3&#125; &#125;&#125;; 先序遍历和中序遍历的不同点是，先序遍历会先访问节点本身（行{1}），然后再访问它的左侧子节点（行{2}），最后是右侧子节点（行{3}），而中序遍历的执行顺序是：{2}、{1}和{3}。 下面是控制台上的输出结果（每个数字将会输出在不同的行）： 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25 下面的图描绘了preOrderTraverse方法的访问路径： 4.3 后序遍历后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。 我们来看它的实现： 1234567891011this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback);&#125;;//postOrderTraverseNode方法的实现如下：var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); //&#123;1&#125; postOrderTraverseNode(node.right, callback); //&#123;2&#125; callback(node.key); //&#123;3&#125; &#125;&#125;; 这个例子中，后序遍历会先访问左侧子节点（行{1}），然后是右侧子节点（行{2}），最后是父节点本身（行{3}）。 你会发现，中序、先序和后序遍历的实现方式是很相似的，唯一不同的是行{1}、{2}和{3}的执行顺序。 下面是控制台的输出结果（每个数字将会输出在不同行）： 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11 下面的图描绘了postOrderTraverse方法的访问路径：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法七（字典和散列表）","date":"2019-01-18T11:40:59.000Z","path":"2019/01/18/cjsu6q1mu0015hgvb6brc4ibp/","text":"字典和散也是用来存储唯一值（不重复的值）的数据结构。 集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。 一、 字典前面已经学习过，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。 1.1 创建字典首先创建Dictionary类的骨架： 123function Dictionary() &#123; var items = &#123;&#125;;&#125; 与Set类类似，我们将在一个Object的实例而不是数组中存储元素。然后，我们需要声明一些映射/字典所能使用的方法。 set(key,value)：向字典中添加新元素。delete(key)：通过使用键值来从字典中移除键值对应的数据值。has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。get(key)：通过键值查找特定的数值并返回。clear()：将这个字典中的所有元素全部删除。size()：返回字典所包含元素的数量。与数组的length属性类似。keys()：将字典所包含的所有键名以数组形式返回。values()：将字典所包含的所有数值以数组形式返回。 1.1.1 has 和 set 方法我们首先来实现has(key)方法。之所以要先实现这个方法，是因为它会被set和remove等其他方法调用。我们可以通过如下代码来实现： 123this.has = function(key) &#123; return key in items;&#125;; 这个方法的实现和我们之前在Set类中的实现是一样的。我们使用JavaScript中的in操作符来验证一个key是否是items对象的一个属性。 然后是set方法的实现： 123this.set = function(key, value) &#123; items[key] = value; //&#123;1&#125;&#125;; 该方法接受一个key和一个value作为参数。我们直接将value设为items对象的key属性的值。它可以用来给字典添加一个新的值，或者用来更新一个已有的值。 1.1.2 delete方法接下来，我们实现delete方法。它和Set类中的delete方法很相似，唯一的不同点在于我们将先搜索key（而不是value）： 1234567this.delete= function(key) &#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false;&#125;; 然后我们可以使用JavaScript的delete操作符来从items对象中移除key属性。 1.1.3 get和values方法如果我们想在字典中查找一个特定的项，并检索它的值，可以使用下面的方法： 123this.get = function(key) &#123; return this.has(key) ? items[key] : undefined;&#125;; get方法首先会验证我们想要检索的值是否存在（通过查找key值），如果存在，将返回该值，反之将返回一个undefined值（请记住undefined值和null值是不一样的 下一个是values方法。这个方法以数组的形式返回字典中所有values实例的值： 123456789this.values = function() &#123; let values = []; for(var key in items) &#123; //&#123;1&#125; if(this.has(key)) &#123; values.push(items[key]) //&#123;2&#125; &#125; &#125; return values&#125; 首先，我们遍历items对象的所有属性值（行{1}）。为了确定值存在，我们使用has函数来验证key确实存在，然后将它的值加入values数组（行{2}）。最后，我们就能返回所有找到的值。 我们不能仅仅使用for-in语句来遍历items对象的所有属性，还需要使用hasOwnProperty方法（验证items对象是否包含某个属性），因为对象的原型也会包含对象的其他属性（JavaScript基本的Object类中的属性将会被继承，并存在于当前对象中，而对于这个数据结构来说，我们并不需要它们）。 1.1.4 clear、size、keys和getItems方法clear和size 方法与前面介绍的Set类中对应的方法是完全一样的。 keys方法返回在Dictionary类中所有用于标识值的键名。要取出一个JavaScript对象中所有的键名，可以把这个对象作为参数传入Object类的keys方法（到目前为止，书中创建的类，包括Dictionary在内，都是JavaScript对象），如下： 123this.keys = function() &#123; return object.keys(items)&#125; 最后，我们来验证items属性的输出值。我们可以实现一个返回items变量的方法，叫作getItems： 123this.getItems = function() &#123; return items;&#125; 1.1.5 使用Dictionary首先，我们来创建一个Dictionary类的实例，然后给它添加三条电子邮件地址。我们将会使用这个dictionary实例来实现一个电子邮件地址簿。 使用我们创建的类来执行如下代码： 1234var dictionary = new Dictionary();dictionary.set('Gandalf', 'gandalf@email.com');dictionary.set('John', 'johnsnow@email.com');dictionary.set('Tyrion', 'tyrion@email.com'); 如果执行了如下代码，输出结果将会是true： console.log(dictionary.has(‘Gandalf’)); 下面的代码将会输出3，因为我们向字典实例中添加了三个元素： console.log(dictionary.size()); 现在，执行下面的几行代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.get(‘Tyrion’)); 输出结果分别如下所示： [“Gandalf”, “John”, “Tyrion”][“gandalf@email.com“, “johnsnow@email.com“, “tyrion@email.com“]tyrion@email.com 最后，再执行几行代码： dictionary.delete(‘John’); 再执行下面的代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.getItems()); 输出结果如下所示： [“Gandalf”, “Tyrion”][“gandalf@email.com“, “tyrion@email.com“]Object {Gandalf: “gandalf@email.com“, Tyrion:”tyrion@email.com“} 移除了一个元素后，现在的dictionary实例中只包含两个元素了。 二、 散列表接下来我们会学到HashTable类，也叫HashMap类，它是Dictionary类的一种散列表实现方式。 散列算法的作用是尽可能快地在数据结构中找到一个值。在前面我们已经知道如果要在数据结构中获得一个值（使用get方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址 举个例子，我们继续使用字典中的案例使用电子邮件地址簿。我们将要使用最常见的散列函数——“lose lose”散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。 2.1 创建散列表我们将使用数组来表示我们的数据结构，该数据结构的图表（“lose lose”）所用的非常相似。 和之前一样，我们从搭建类的骨架开始： 123function HashTable() &#123; var table = [];&#125; 然后，给类添加一些方法。我们给每个类实现三个基本方法 put(key,value)：向散列表增加一个新的项（也能更新散列表）。remove(key)：根据键值从散列表中移除值。get(key)：返回根据键值检索到的特定的值。 在实现这三个方法之前，要实现的第一个方法是散列函数，它是HashTable类中的一个私有方法： 1234567var loseloseHashCode = function (key) &#123; var hash = 0; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash += key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 37; //&#123;4&#125;&#125;; 给定一个key参数，我们就能根据组成key的每个字符的ASCII码值的和得到一个数字。所以，首先需要一个变量来存储这个总和（行{1}）。然后，遍历key（行{2}）并将从ASCII表中查到的每个字符对应的ASCII值加到hash变量中（可以使用JavaScript的String类中的charCodeAt方法——行{3}）。最后，返回hash值。为了得到比较小的数值，我们会使用hash值和一个任意数做除法的余数（mod）。 现在，有了散列函数，我们就可以实现put方法了： 12345this.put = function (key, value) &#123; var position = loseloseHashCode(key); //&#123;5&#125; console.log(position + ' - ' + key); //&#123;6&#125; table[position] = value; //&#123;7&#125;&#125;; 首先，根据给定的key，我们需要根据所创建的散列函数计算出它在表中的位置（行{5}）。为了便于展示信息，我们将计算出的位置输出至控制台（行{6}）。由于它不是必需的，我们也可以将这行代码移除。然后要做的，是将value参数添加到用散列函数计算出的对应的位置上。（行{7}）。 从HashTable实例中查找一个值也很简单。为此，我们将会实现一个get方法： 123this.get = function (key) &#123; return table[loseloseHashCode(key)];&#125;; 首先，我们会使用所创建的散列函数来求出给定key所对应的位置。这个函数会返回值的位置，因此我们所要做的就是根据这个位置从数组table中获得这个值。 我们要实现的最后一个方法是remove方法： 123this.remove = function(key) &#123; table[loseloseHashCode(key)] = undefined;&#125;; 要从HashTable实例中移除一个元素，只需要求出元素的位置（可以使用散列函数来获取）并赋值为undefined。 对于HashTable类来说，我们不需要像ArrayList类一样从table数组中将位置也移除。由于元素分布于整个数组范围内，一些位置会没有任何元素占据，并默认为undefined值。我们也不能将位置本身从数组中移除（这会改变其他元素的位置），否则，当下次需要获得或移除一个元素的时候，这个元素会不在我们用散列函数求出的位置上。 2.2 使用 HashTable 类让我们执行一些代码来测试HashTable类: var hash = new HashTable();hash.put(‘Gandalf’, &#39;gandalf@email.com‘);hash.put(‘John’, &#39;johnsnow@email.com‘);hash.put(‘Tyrion’, &#39;tyrion@email.com‘); 执行上述代码，会在控制台中获得如下输出： 19 - Gandalf29 - John16 - Tyrion 下面的图表展现了包含这三个元素的HashTable数据结构： 现在来测试get方法： console.log(hash.get(‘Gandalf’));console.log(hash.get(‘Loiane’)); 获得如下的输出： gandalf@email.comundefined 由于Gandalf是一个在散列表中存在的键，get方法将会返回它的值。而由于Loiane是一个不存在的键，当我们试图在数组中根据位置获取值的时候（一个由散列函数生成的位置），返回值将会是undefined（即不存在）。 然后，我们试试从散列表中移除Gandalf： hash.remove(‘Gandalf’);console.log(hash.get(‘Gandalf’)); 由于Gandalf不再存在于表中，hash.get(‘Gandalf’)方法将会在控制台上给出undefined的输出结果。 2.3 散列表和散列集合散列表和散列映射是一样的，我们学习过这种数据结构了。 在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是散列函数。我们可以重用本章实现HashTable的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。 2.4 处理散列表中的冲突有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。例如，我们看看下面的代码会得到怎样的输出结果： 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 注意，Tyrion和Aaron有相同的散列值（16）。Donnie和Ana有相同的散列值（13），Jonathan、Jamie和Sue有相同的散列值（5），Mindy和Paul也有相同的散列值（32）。 那HashTable实例会怎样呢？执行之前的代码后散列表中会有哪些值呢？ 为了获得结果，我们来实现一个叫作print的辅助方法，它会在控制台上输出HashTable中的值： 1234567this.print = function () &#123; for (var i = 0; i &lt; table.length; ++i) &#123; //&#123;1&#125; if (table[i] !== undefined) &#123; //&#123;2&#125; console.log(i + \": \" + table[i]);//&#123;3&#125; &#125; &#125;&#125;; 现在来使用这个方法： hash.print(); 在控制台上得到如下的输出结果： 12345675: sue @email.com10: nathan@email.com13: ana@email.com16: aaron@email.com19: gandalf@email.com29: johnsnow@email.com32: paul@email.com Jonathan、Jamie和Sue有相同的散列值，也就是5。由于Sue是最后一个被添加的，Sue将是在HashTable实例中占据位置5的元素。首先，Jonathan会占据这个位置，然后Jamie会覆盖它，然后Sue会再次覆盖。这对于其他发生冲突的元素来说也是一样的。 使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接、线性探查和双散列法。在本节中，我们会介绍前两种方法。 2.4.1 分离链接分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。 例如，我们在之前的测试代码中使用分离链接的话，输出结果将会是这样： 在位置5上，将会有包含三个元素的LinkedList实例；在位置13、16和32上，将会有包含两个元素的LinkedList实例；在位置10、19和29上，将会有包含单个元素的LinkedList实例。 对于分离链接和线性探查来说，只需要重写三个方法：put、get和remove。这三个方法在每种技术实现中都是不同的。 为了实现一个使用了分离链接的HashTable实例，我们需要一个新的辅助类来表示将要加入LinkedList实例的元素。我们管它叫ValuePair类（在HashTable类内部定义）： 1234567var ValuePair = function (key, value) &#123; this.key = key; this.value = value; this.toString = function () &#123; return '[' + this.key + ' - ' + this.value + ']'; &#125;&#125;; 这个类只会将key和value存储在一个Object实例中。我们也重写了toString方法，以便之后在浏览器控制台中输出结果。 put方法 我们来实现第一个方法，put方法，代码如下： 1234567this.put = function (key, value) &#123; var position = loseloseHashCode(key); if (table[position] == undefined) &#123; //&#123;1&#125; table[position] = new LinkedList(); &#125; table[position].append(new ValuePair(key, value)); //&#123;2&#125;&#125;; 在这个方法中，将验证要加入新元素的位置是否已经被占据（行{1}）。如果这个位置是第一次被加入元素，我们会在这个位置上初始化一个LinkedList类的实例（你已经在第5章中学习过）。然后，使用第5章中实现的append方法向LinkedList实例中添加一个ValuePair实例（键和值）（行{2}）。 (2) get方法 然后，我们实现用来获取特定值的get方法： 123456789101112131415161718this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;3&#125; //遍历链表来寻找键/值 var current = table[position].getHead(); //&#123;4&#125; while (current.next) &#123; //&#123;5&#125; if (current.element.key === key) &#123; //&#123;6&#125; return current.element.value; //&#123;7&#125; &#125; current = current.next; //&#123;8&#125; &#125; //检查元素在链表第一个或最后一个节点的情况 if (current.element.key === key) &#123; //&#123;9&#125; return current.element.value; &#125; &#125; return undefined; //&#123;10&#125;&#125;; 我们要做的第一个验证，是确定在特定的位置上是否有元素存在（行{3}）。如果没有，则返回一个undefined表示在HashTable实例中没有找到这个值（行{10}）。如果在这个位置上有值存在，我们知道这是一个LinkedList实例。现在要做的是遍历这个链表来寻找我们需要的元素。在遍历之前先要获取链表表头的引用（行{4}），然后就可以从链表的头部遍历到尾部（行{5}，current.next将会是null）。 Node链表包含next指针和element属性。而element属性又是ValuePair的实例，所以它又有value和key属性。可以通过current.element.key来获得Node链表的key属性，并通过比较它来确定它是否就是我们要找的键（行{6}）。（这就是要使用ValuePair这个辅助类来存储元素的原因。我们不能简单地存储值本身，这样就不能确定哪个值对应着特定的键。）如果key值相同，就返回Node的值（行{7}）；如果不相同，就继续遍历链表，访问下一个节点（行{8}）。 如果要找的元素是链表的第一个或最后一个节点，那么就不会进入while循环的内部。因此，需要在行{9}处理这种特殊的情况 remove方法 使用分离链接法从HashTable实例中移除一个元素和之前在本章实现的remove方法有一些不同。现在使用的是链表，我们需要从链表中移除一个元素。来看看remove方法的实现： 12345678910111213141516171819202122232425this.remove = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; var current = table[position].getHead(); while (current.next) &#123; if (current.element.key === key) &#123; //&#123;11&#125; table[position].remove(current.element); //&#123;12&#125; if (table[position].isEmpty()) &#123; //&#123;13&#125; table[position] = undefined; //&#123;14&#125; &#125; return true; //&#123;15&#125; &#125; current = current.next; &#125; // 检查是否为第一个或最后一个元素 if (current.element.key === key) &#123; //&#123;16&#125; table[position].remove(current.element); if (table[position].isEmpty()) &#123; table[position] = undefined; &#125; return true; &#125; &#125; return false; //&#123;17&#125;&#125;; 在remove方法中，我们使用和get方法一样的步骤找到要找的元素。遍历LinkedList实例时，如果链表中的current元素就是要找的元素（行{11}），使用remove方法将其从链表中移除。然后进行一步额外的验证：如果链表为空了（行{13}——链表中不再有任何元素了），就将散列表这个位置的值设为undefined（行{14}），这样搜索一个元素或打印它的内容的时候，就可以跳过这个位置了。最后，返回true表示这个元素已经被移除（行{15}）或者在最后返回false表示这个元素在散列表中不存在（行{17}）。同样，需要和get方法一样，处理元素在第一个或最后一个的情况（行{16}）。 重写了这三个方法后，我们就拥有了一个使用了分离链接法来处理冲突的HashMap实例。 2.4.1 线性探查另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推 然后重写put、get、remove方法 put方法 123456789101112this.put = function (key, value) &#123; var position = loseloseHashCode(key); // &#123;1&#125; if (table[position] == undefined) &#123; // &#123;2&#125; table[position] = new ValuePair(key, value); // &#123;3&#125; &#125; else &#123; var index = ++position; // &#123;4&#125; while (table[index] != undefined) &#123; // &#123;5&#125; index++; // &#123;6&#125; &#125; table[index] = new ValuePair(key, value); // &#123;7&#125; &#125;&#125;; 和之前一样，先获得由散列函数生成的位置（行{1}），然后验证这个位置是否有元素存在（如果这个位置被占据了，将会通过行{2}的验证）。如果没有元素存在，就在这个位置加入新元素（行{3}——一个ValuePair的实例）。 如果这个位置已经被占据了，需要找到下一个没有被占据的位置（position的值是undefined），因此我们声明一个index变量并赋值为position+1（行{4}——在变量名前使用自增运算符++会先递增变量值然后再将其赋值给index）。然后验证这个位置是否被占据（行{5}），如果被占据了，继续将index递增（行{6}），直到找到一个没有被占据的位置。然后要做的，就是将值分配到这个位置（行{7}）。 如果再次执行插入数据的代码: 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 下图展示使用了线性探查的散列表的最终结果： 让我们来模拟一下散列表中的插入操作。 (1) 试着插入Gandalf。它的散列值是19，由于散列表刚刚被创建，位置19还是空的——可以在这里插入数据。(2) 试着在位置29插入John。它也是空的，所以可以插入这个姓名。(3) 试着在位置16插入Tyrion。它是空的，所以可以插入这个姓名。(4) 试着插入Aaron，它的散列值也是16。位置16已经被Tyrion占据了，所以需要检查索引值为position+1的位置（16+1）。位置17是空的，所以可以在位置17插入Aaron。(5) 接着，试着在位置13插入Donnie。它是空的，所以可以插入这个姓名。(6) 想在位置13插入Ana，但是这个位置被占据了。因此在位置14进行尝试，它是空的，所以可以在这里插入姓名。(7) 然后，在位置5插入Jonathan，这个位置是空的，所以可以插入这个姓名。(8) 试着在位置5插入Jamie，但是这个位置被占了。所以跳至位置6，这个位置是空的，因此可以在这个位置插入姓名。(9) 试着在位置5插入Sue，但是位置被占据了。所以跳至位置6，但也被占了。接着跳至位置7，这里是空的，所以可以在这里插入姓名。以此类推。 get方法 现在插入了所有的元素，让我们实现get方法来获取它们的值吧： 1234567891011121314151617this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;8&#125; if (table[position].key === key) &#123; //&#123;9&#125; return table[position].value; //&#123;10&#125; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key) &#123; //&#123;11&#125; index++; &#125; if (table[index].key === key) &#123; //&#123;12&#125; return table[index].value; //&#123;13&#125; &#125; &#125; &#125; return undefined; //&#123;14&#125; &#125;; 要获得一个键对应的值，先要确定这个键存在（行{8}）。如果这个键不存在，说明要查找的值不在散列表中，因此可以返回undefined（行{14}）。如果这个键存在，需要检查我们要找的值是否就是这个位置上的值（行{9}）。如果是，就返回这个值（行{10}）。 如果不是，就在散列表中的下一个位置继续查找，直到找到一个键值与我们要找的键值相同的元素（行{11}）。然后，验证一下当前项就是我们要找的项（行{12}——只是为了确认一下）并且将它的值返回（行{13}）。 我们无法确定要找的元素实际上在哪个位置，这就是使用ValuePair来表示HashTable元素的原因。 remove方法 remove方法和get方法基本相同，不同之处在于行{10}和{13}，它们将会由下面的代码代替： table[index] = undefined; 要移除一个元素，只需要给其赋值为undefined，来表示这个位置不再被占据并且可以在必要时接受一个新元素。 2.5 创建更好的散列函数我们实现的“lose lose”散列函数并不是一个表现良好的散列函数，因为它会产生太多的冲突。如果我们使用这个函数的话，会产生各种各样的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。我们可以在网上找到一些不同的实现方法，或者也可以实现自己的散列函数。 另一个可以实现的比“lose lose”更好的散列函数是djb2： 1234567var djb2HashCode = function (key) &#123; var hash = 5381; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 1013; //&#123;4&#125;&#125;; 它包括初始化一个hash变量并赋值为一个质数（行{1}——大多数实现都使用5381），然后迭代参数key（行{2}），将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加（行{3}）。 最后，我们将使用相加的和与另一个随机质数（比我们认为的散列表的大小要大——在本例中，我们认为散列表的大小为1000）相除的余数。 如果再次执行插入数据的代码，这将是使用djb2HashCode代替loseloseHashCode的最终结果： 123456789101112798 - Gandalf838 - John624 - Tyrion215 - Aaron278 - Donnie925 - Ana288 - Jonathan962 - Jamie502 - Sue804 - Mindy54 - Paul223 - Nathan 这并不是最好的散列函数，但这是最受社区推崇的散列函数之一。 三、es6——Map类我们看看原生的Map类怎么用。 还是用我们原来测试Dictionary类的例子： 123456789var map = new Map();map.set('Gandalf', 'gandalf@email.com');map.set('John', 'johnsnow@email.com');map.set('Tyrion', 'tyrion@email.com');console.log(map.has('Gandalf')); //输出trueconsole.log(map.size); //输出3console.log(map.keys()); //输出[\"Gandalf\", \"John\", \"Tyrion\"]console.log(map.values()); //输出[\"gandalf@email.com\", s\"johnsnow@email.com\", \"tyrion@email.com\"]console.log(map.get('Tyrion')); //输出tyrion@email.com 和我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator（第2章提到过），而不是值或键构成的数组。另一个区别是，我们实现的size方法返回字典中存储的值的个数，而ES6的Map类则有一个size属性。 删除map中的元素可以用delete方法： map.delete(‘John’); clear方法会重置map数据结构，这跟我们在Dictionary类里实现的一样。 四、ES6——WeakMap 类和 WeakSet 类除了Set和Map这两种新的数据结构，ES6还增加了它们的弱化版本，WeakSet和WeakMap。 基本上，Map和Set与其弱化版本之间仅有的区别是： WeakSet或WeakMap类没有entries、keys和values等方法； 只能用对象作为键。 创建和使用这两个类主要是为了性能。WeakSet和WeakMap是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。 另一个优点是，必须用键才可以取出值。这些类没有entries、keys和values等迭代器方法，因此，除非你知道键，否则没有办法取出值。这印证了我们在前面的做法，即使用WeakMap类封装ES6类的私有属性。 使用WeakMap类的例子如下： 12345678910var map = new WeakMap();var ob1 = &#123;name:'Gandalf'&#125;, //&#123;1&#125;ob2 = &#123;name:'John'&#125;,ob3 = &#123;name:'Tyrion'&#125;;map.set(ob1, 'gandalf@email.com'); //&#123;2&#125;map.set(ob2, 'johnsnow@email.com');map.set(ob3, 'tyrion@email.com');console.log(map.has(ob1)); //&#123;3&#125; 输出trueconsole.log(map.get(ob3)); //&#123;4&#125; 输出tyrion@email.commap.delete(ob2); //&#123;5&#125; WeakMap类也可以用set方法，但不能使用数字、字符串、布尔值等基本数据类型，需要将名字转换为对象（行{1}和行{2}）。搜索（行{3}）、读取（行{4}）和删除值（行{5}），也要传入作为键的对象。同样的逻辑也适用于WeakSet类。 五、小结在本节中，我们学习了字典的相关知识，了解了如何添加、移除和获取元素以及其他的一些方法。我们还了解了字典和集合的不同之处。 我们也学习了散列运算，怎样创建一个散列表（或者说散列映射）数据结构，如何添加、移除和获取元素，以及如何创建散列函数。我们学习了怎样使用两种不同的方法解决散列表中的冲突问题。 我们还介绍了如何使用ES6的Map、WeakMap和WeakSet类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法六（集合）","date":"2018-12-28T08:10:32.000Z","path":"2018/12/28/cjsu6q1lo0012hgvbcle3lnuv/","text":"一、构建数据集合集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。 在深入学习集合的计算机科学实现之前，我们先看看它的数学概念。在数学中，集合是一组不同的对象（的集）。 比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6, …}。集合中的对象列表用“{}”（大括号）包围。 还有一个概念叫空集。空集就是不包含任何元素的集合。比如24和29之间的素数集合。由于24和29之间没有素数（除了1和自身，没有其他正因数的大于1的自然数），这个集合就是空集。空集用“{ }”表示。 你也可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。 在数学中，集合也有并集、交集、差集等基本操作。在本片文章中我们也会介绍这些操作 二、创建集合首先创建set类，Set类的骨架如下： 123function Set() &#123; let items = &#123;&#125;;&#125; 有一个非常重要的细节，我们使用对象而不是数组来表示集合（items）。但也可以用数组实现。在这里我们用对象来实现，稍微有点儿不一样，也学习一下实现相似数据结构的新方法。同时，JavaScript的对象不允许一个键指向两个不同的属性，也保证了集合里的元素都是唯一的。 接下来，需要声明一些集合可用的方法（我们会尝试模拟与ECMAScript 6实现相同的Set类）。 add(value)：向集合添加一个新的项。delete(value)：从集合移除一个值。has(value)：如果值在集合中，返回true，否则返回false。clear()：移除集合中的所有项。size()：返回集合所包含元素的数量。与数组的length属性类似。values()：返回一个包含集合中所有值的数组。 2.1 has(value)方法首先要实现的是has(value)方法。这是因为它会被add、remove等其他方法调用。下面看看它的实现： 123this.has = function(value)&#123; return value in items;&#125;; 既然我们使用对象来存储集合的值，就可以用JavaScript的in操作符来验证给定的值是否是items对象的属性。 但这个方法还有更好的实现方式，如下： 123this.has = function(value)&#123; return items.hasOwnProperty(value);&#125;; 所有JavaScript对象都有hasOwnProperty方法。这个方法返回一个表明对象是否具有特定属性的布尔值。 2.2 add方法接下来要实现add方法： 1234567this.add = function(value)&#123; if (!this.has(value))&#123; items[value] = value; //&#123;1&#125; return true; &#125; return false;&#125;; 对于给定的value，可以检查它是否存在于集合中。如果不存在，就把value添加到集合中（行{1}），返回true，表示添加了这个值。如果集合中已经有这个值，就返回false，表示没有添加它。 添加一个值的时候，把它同时作为键和值保存，因为这样有利于查找这个值。 2.3 remove 和 clear 方法下面要实现remove方法： 1234567this.remove = function(value)&#123;if (this.has(value))&#123; delete items[value]; //&#123;2&#125; return true;&#125;return false;&#125;; 在remove方法中，我们会验证给定的value是否存在于集合中。如果存在，就从集合中移除value（行{2}），返回true，表示值被移除；否则返回false。 既然用对象来存储集合的items对象，就可以简单地使用delete操作符从items对象中移除属性（行{2}）。 使用Set类的示例代码如下： 123let set = new Set();set.add(1); //trueset.add(2); //true 如果想移除集合中的所有值，可以用clear方法： 123this.clear = function()&#123; items = &#123;&#125;; // &#123;3&#125;&#125;; 要重置items对象，需要做的只是把一个空对象重新赋值给它（行{3}）。我们也可以迭代集合，用remove方法依次移除所有的值，但既然有更简单的方法，那样做就太麻烦了 2.4 size 方法下一个要实现的是size方法（返回集合中有多少项）。这个方法有三种实现方式。 第一种方法是使用一个length变量，每当使用add或remove方法时控制它，就像在上一章中使用LinkedList类一样。 第二种方法，使用JavaScript内建的Object类的一个内建函数（ECMAScript 5以上版本）： 123this.size = function()&#123; return Object.keys(items).length; //&#123;4&#125;&#125;; JavaScript的Object类有一个keys方法，它返回一个包含给定对象所有属性的数组。在这种情况下，可以使用这个数组的length属性（行{4}）来返回items对象的属性个数。以上代码只能在现代浏览器中运行（比如IE9以上版本、Firefox 4以上版本、Chrome 5以上版本、Opera 12以上版本、Safari 5以上版本，等等）。 第三种方法是手动提取items对象的每一个属性，记录属性的个数并返回这个数字。这个方法可以在任何浏览器上运行，和之前的代码是等价的： 12345678this.sizeLegacy = function()&#123; let count = 0; for(let key in items) &#123; //&#123;5&#125; if(items.hasOwnProperty(key)) //&#123;6&#125; ++count; //&#123;7&#125; &#125; return count;&#125;; 遍历items对象的所有属性（行{5}），检查它们是否是对象自身的属性（避免重复计数——行{6}）。如果是，就递增count变量的值（行{7}），最后在方法结束时返回这个数字。 不能简单地使用for-in语句遍历items对象的属性，并递增count变量的值。还需要使用hasOwnProperty方法（以验证items对象具有该属性），因为对象的原型包含了额外的属性（属性既有继承自JavaScript的Object类的，也有属于对象自身，未用于数据结构的）。 2.5 values 方法values方法也应用了相同的逻辑，提取items对象的所有属性，以数组的形式返回： 123456789this.values = function () &#123; let values = []; for (let key in items) &#123; //&#123;7&#125; if (items.hasOwnProperty(key)) &#123; //&#123;8&#125; values.push(items[key]); &#125; &#125; return values; &#125; 首先遍历items对象的所有属性（行{7}），把它们添加一个数组中（行{8}），并返回这个数组。该方法类似于我们开发的sizeLegacy方法，但我们添加一个数组，而不是计算属性个数。 2.6 使用 Set 类现在数据结构已经完成了，执行Set类的方法，测试我们的Set类： 12345678910111213let set = new Set();set.add(1);console.log(set.values()); //输出[\"1\"]console.log(set.has(1)); //输出trueconsole.log(set.size()); //输出1 set.add(2);console.log(set.values()); //输出[\"1\", \"2\"]console.log(set.has(2)); //trueconsole.log(set.size()); //2set.remove(1);console.log(set.values()); //输出[\"2\"]set.remove(2);console.log(set.values()); //输出[] 三、 集合操作对集合可以进行如下操作。 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。子集：验证一个给定集合是否是另一集合的子集。 3.1 并集并集的数学概念是集合A和集合B的并集，表示为： A∪B 该集合定义如下： A∪B = { x | x ∈ A∨x ∈ B } 意思是x（元素）存在于A中，或x存在于B中。下图展示了并集操作： 现在来实现Set类的union方法： 12345678910111213//union 方法this.union = function (otherSet) &#123; let unionSet = new Set(); //&#123;1&#125; let values = this.values(); //&#123;2&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); //&#123;3&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet;&#125;; 首先需要创建一个新的集合，代表两个集合的并集（行{1}）。接下来，获取第一个集合（当前的Set类实例）所有的值（values），遍历并全部添加到代表并集的集合中（行{2}）。然后对第二个集合做同样的事（行{3}）。最后返回结果。 测试一下上面的代码： 1234567891011let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(3);setB.add(4);setB.add(5);setB.add(6);let unionAB = setA.union(setB);console.log(unionAB.values()); //[1, 2, 3, 4, 5, 6] 输出为[“1”, “2”, “3”, “4”, “5”, “6”]。注意元素3同时存在于A和B中，它在结果的集合中只出现一次。 3.2 交集交集的数学概念是集合A和集合B的交集，表示为： A∩B 该集合定义如下： A∩B = { x | x ∈ A∧x ∈ B } 意思是x（元素）存在于A中，且x存在于B中。下图展示了交集操作： 现在来实现Set类的intersection方法： 12345678910this.intersection = function(otherSet)&#123; let intersectionSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; //&#123;2&#125; if (otherSet.has(values[i]))&#123; //&#123;3&#125; intersectionSet.add(values[i]); //&#123;4&#125; &#125; &#125; return intersectionSet;&#125; intersection方法需要找到当前Set实例中，所有也存在于给定Set实例中的元素。首先创建一个新的Set实例，这样就能用它返回共有的元素（行{1}）。接下来，遍历当前Set实例所有的值（行{2}），验证它们是否也存在于otherSet实例（行{3}）之中。可以用前面实现的has方法来验证元素是否存在于Set实例中。然后，如果这个值也存在于另一个Set实例中，就将其添加到创建的intersectionSet变量中（行{4}），最后返回它。 测试一下intersection方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let intersectionAB = setA.intersection(setB);console.log(intersectionAB.values()); 输出为[“2”, “3”]，因为2和3同时存在于两个集合中。 3.3 差集差集的数学概念是集合A和集合B的差集，表示为：AB，定义如下图： 意思是x（元素）存在于A中，且x不存在于B中。下图展示了集合A和B的差集操作： 现在来实现Set类的difference方法： 12345678910this.difference = function (otherSet) &#123; let differenceSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; differenceSet.add(values[i]); //&#123;4&#125; &#125; &#125; return differenceSet;&#125;; intersection方法会得到所有同时存在于两个集合中的值。而difference方法会得到所有存在于集合A但不存在于B的值。因此这两个方法在实现上唯一的区别就是行{3}。只获取不存在于otherSet实例中的值，而不是也存在于其中的值。行{1}、{2}和{4}是完全相同的。 测试difference方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let differenceAB = setA.difference(setB);console.log(differenceAB.values()); 输出为[“1”]，因为1是唯一一个仅存在于setA的元素。 3.4 子集子集的数学概念是集合A是集合B的子集（或集合B包含了A），表示为 A⊆B 该集合定义如下： ∀x { x ∈ A → x ∈ B } 意思是集合A中的每一个x（元素），也需要存在于B中。下图展示了集合A是集合B的子集： 现在来实现Set类的subset方法： 12345678910111213this.subset = function (otherSet) &#123; if (this.size() &gt; otherSet.size()) &#123; //&#123;1&#125; return false; &#125; else &#123; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; return false; //&#123;4&#125; &#125; &#125; return true; //&#123;5&#125; &#125;&#125;; 首先需要验证的是当前Set实例的大小。如果当前实例中的元素比otherSet实例更多，它就不是一个子集（行{1}）。子集的元素个数需要小于或等于要比较的集合。 接下来要遍历集合中的所有元素（行{2}），验证这些元素也存在于otherSet中（行{3}）。如果有任何元素不存在于otherSet中，就意味着它不是一个子集，返回false（行{4}）。如果所有元素都存在于otherSet中，行{4}就不会被执行，那么就返回true（行{5}）。 检验一下上面的代码效果如何： 12345678910111213let setA = new Set();setA.add(1); setA.add(2);let setB = new Set();setB.add(1);setB.add(2);setB.add(3);let setC = new Set();setC.add(2);setC.add(3);setC.add(4);console.log(setA.subset(setB));console.log(setA.subset(setC)); 我们有三个集合：setA是setB的子集（因此输出为true），然而setA不是setC的子集（setC只包含了setA中的2，而不包含1），因此输出为false。 四、 ES6——Set 类我们先看看原生的Set类怎么用。 还是用我们原来测试Set类的例子： 12345let set = new Set();set.add(1);console.log(set.values()); // 输出@Iteratorconsole.log(set.has(1)); // 输出trueconsole.log(set.size); // 输出1 和我们的Set不同，ES6的Set的values方法返回Iterator（第2章提到过），而不是值构成的数组。另一个区别是，我们实现的size方法返回set中存储的值的个数，而ES6的Set则有一个size属性。 可以用delete方法删除set中的元素： set.delete(1); clear方法会重置set数据结构，这跟我们实现的功能一样 4.1 ES6 Set 类的操作我们的Set类实现了并集、交集、差集、子集等数学操作，然而ES6原生的Set并没有这些功能。不过，有需要的话，我们也可以模拟。 我们的例子会用到下面两个集合 12345678let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4); 4.1.1 模拟并集操作我们可以创建一个新的集合，用来添加两个集合中所有的元素（行{1}）。迭代这两个集合（行{2}、行{3}），把所有元素都添加到并集的集合中。代码如下： 123let unionAb = new Set(); //&#123;1&#125;for (let x of setA) unionAb.add(x); //&#123;2&#125;for (let x of setB) unionAb.add(x); //&#123;3&#125; 4.1.2 模拟交集操作模拟交集操作需要创建一个辅助函数，来生成包含setA和setB都有的元素的新集合（行{1}）。代码如下： 12345678910let intersection = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if (setB.has(x)) &#123; //&#123;1&#125; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;;let intersectionAB = intersection(setA, setB); 交集可以用更简单的语法实现，代码如下： intersectionAb = new Set([x for (x of setA) if (setB.has(x))]); 这和intersection函数的效果完全一样。 4.1.3 模拟差集操作交集操作创建的集合包含setA和setB都有的元素，差集操作创建的集合包含的则是setA有而setB没有的元素。看下面的代码： 12345678910let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; //&#123;1&#125; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;;let differenceAB = difference(setA, setB); intersection函数和difference函数只有行{1}不同，因为差集中只添加setA有而setB没有的元素。 差集也可以用更简单的语法实现，代码如下： differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); 目前只有Firefox支持简化的语法，但在所有支持ES6的现代浏览器中都可以执行difference函数 五、小结在这片文章中，我们学习了如何从头实现一个与ECMAScript 6中定义的类似的Set类。我们还介绍了在其他编程语言的集合数据结构的实现中不常见的一些方法，比如并集、交集、差集和子集。因此，相比于其他编程语言目前的Set实现，我们实现了一个非常完备的Set类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法五（链表）","date":"2018-11-18T11:41:53.000Z","path":"2018/11/18/cjsu6q1mv0016hgvbdsnf3k88/","text":"一、链表数据结构要存储多个元素，数组（或列表）可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管JavaScript的array类方法做这些事，但背后的情况同样是这样）。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展示了一个链表的结构： 相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。 另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法，就是从起点（第一条线索）顺着列表寻找。 还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或移除它。下图演示了一列火车。每节车皮都是列表的元素，车皮间的连接就是指针： 二、创建链表理解了链表是什么之后，现在就要开始实现我们的数据结构了，以下是我们的LinkedList类的骨架： 123456789101112131415161718function LinkedList() &#123; let Node = function (element) &#123; // &#123;1&#125; this.element = element; this.next = null; &#125;; let length = 0; // &#123;2&#125; let head = null; // &#123;3&#125; this.append = function (element) &#123; &#125;; this.insert = function (position, element) &#123; &#125;; this.removeAt = function (position) &#123; &#125;; this.remove = function (element) &#123; &#125;; this.indexOf = function (element) &#123; &#125;; this.isEmpty = function () &#123; &#125;; this.size = function () &#123; &#125;; this.getHead = function () &#123; &#125;; this.toString = function () &#123; &#125;; this.print = function () &#123; &#125;;&#125; LinkedList数据结构还需要一个Node辅助类（行{1}）。Node类表示要加入列表的项。它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。 LinkedList类也有存储列表项的数量的length属性（内部/私有变量）（行{2}）。 另一个重要的点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在一个称为head的变量中（行{3}） 然后就是LinkedList类的方法。在实现这些方法之前，先来看看它们的职责。 append(element)：向列表尾部添加一个新的项。 insert(position, element)：向列表的特定位置插入一个新的项。 remove(element)：从列表中移除一项。 indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 removeAt(position)：从列表的特定位置移除一项。 isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。 size()：返回链表包含的元素个数。与数组的length属性类似。 toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 2.1 向链表尾部追加元素向LinkedList对象尾部添加一个元素时，可能有两种场景：列表为空，添加的是第一个元素，或者列表不为空，向其追加元素。 下面是我们实现的append方法： 1234567891011121314151617181920212223242526// LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; // this.element = element; this.next = null; &#125;; let length = 0; // let head = null; // //实现LinkedList类的append方法 this.append = function (element) &#123; let node = new Node(element), //&#123;1&#125; current; //&#123;2&#125; if (head === null) &#123; //列表中第一个节点 //&#123;3&#125; head = node; &#125; else &#123; current = head; //&#123;4&#125; //循环列表，直到找到最后一项 while (current.next) &#123; current = current.next; &#125; //找到最后一项，将其next赋为node，建立链接 current.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 //&#123;6&#125; &#125;;&#125; 首先需要做的是把element作为值传入，创建Node项（行{1}）。 先来实现第一个场景：向为空的列表添加一个元素。当我们创建一个LinkedList对象时，head会指向null： 如果head元素为null（列表为空——行{3}），就意味着在向列表添加第一个元素。因此要做的就是让head元素指向node元素。下一个node元素将会自动成为null。 列表最后一个节点的下一个元素始终是null。 再来看看第二个场景，也就是向一个不为空的列表尾部添加元素。 要向列表的尾部添加一个元素，首先需要找到最后一个元素。记住，我们只有第一个元素的引用（行{4}），因此需要循环访问列表，直到找到最后一项。为此，我们需要一个指向列表中current项的变量（行{2}）。 循环访问列表时，当current.next元素为null时，我们就知道已经到达列表尾部了。然后要做的就是让当前（也就是最后一个）元素的next指针指向想要添加到列表的节点（行{5}）。下图展示了这个行为： 而当一个Node元素被创建时，它的next指针总是null。这没问题，因为我们知道它会是列表的最后一项。 当然，别忘了递增列表的长度，这样就能控制它，轻松地得到列表的长度（行{6}）。 我们可以通过以下代码来使用和测试目前创建的数据结构： let list = new LinkedList();list.append(15);list.append(10); 2.2 从链表中移除元素现在，让我们看看如何从LinkedList对象中移除元素。移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种remove方法：第一种是从特定位置移除一个元素，第二种是根据元素的值移除元素。 123456789101112131415161718192021222324252627282930313233//LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; &#125;; let length = 0; let head = null; //实现LinkedList类的append方法 this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; // &#123;1&#125; let current = head, // &#123;2&#125; previous, // &#123;3&#125; index = 0; // &#123;4&#125; //移除第一项 if (position === 0) &#123; // &#123;5&#125; head = current.next; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;6&#125; previous = current; // &#123;7&#125; current = current.next; // &#123;8&#125; &#125; //将previous与current的下一项链接起来：跳过current，从而移除它 previous.next = current.next; // &#123;9&#125; &#125; length--; // &#123;10&#125; return current.element; &#125; else &#123; return null; // &#123;11&#125; &#125; &#125;; &#125; 一步一步来看这段代码。该方法要得到需要移除的元素的位置，就需要验证这个位置是有效的（行{1}）。从0（包括0）到列表的长度（size – 1，因为索引是从零开始的）都是有效的位置。如果不是有效的位置，就返回null（意即没有从列表中移除元素）。 首先为第一种场景编写代码：我们要从列表中移除第一个元素（position === 0——行{5}）。下图展示了这个过程： 因此，如果想移除第一个元素，要做的就是让head指向列表的第二个元素。我们将用current变量创建一个对列表中第一个元素的引用（行{2}——我们还会用它来迭代列表，但稍等一下再说）。这样current变量就是对列表中第一个元素的引用。如果把head赋为current.next，就会移除第一个元素 现在，假设我们要移除列表的最后一项或者中间某一项。为此，需要依靠一个细节来迭代列表，直到到达目标位置（行{6}——我们会使用一个用于内部控制和递增的index变量）：current变量总是为对所循环列表的当前元素的引用（行{8}）。我们还需要一个对当前元素的前一个元素的引用（行{7}）；它被命名为previous（行{3}）。 因此，要从列表中移除当前元素，要做的就是将previous.next和current.next链接起来（行{9}）。这样，当前元素就会被丢弃在计算机内存中，等着被垃圾回收器清除。 我们试着通过一些图表来更好地理解。首先考虑移除最后一个元素： 对于最后一个元素，当我们在行{6}跳出循环时，current变量将是对列表中最后一个元素的引用（要移除的元素）。current.next的值将是null（因为它是最后一个元素）。由于还保留了对previous元素的引用（当前元素的前一个元素），previous.next就指向了current。那么要移除current，要做的就是把previous.next的值改变为current.next。 现在来看看，对于列表中间的元素是否可以应用相同的逻辑： current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。那么要移除current元素，需要做的就是将previous.next与current.next链接起来。因此，我们的逻辑对这两种情况都管用。 2.3 在任意位置插入元素接下来，我们要实现insert方法。使用这个方法可以在任意位置插入一个元素。我们来看一看它的实现： 123456789101112131415161718192021222324this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; //&#123;1&#125; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 node.next = current; //&#123;2&#125; head = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;3&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;4&#125; previous.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; //&#123;6&#125; &#125;&#125;; 由于我们处理的是位置，就需要检查越界值（行{1}，跟removeAt方法类似）。如果越界了，就返回false值，表示没有添加项到列表中（行{6}）。 现在我们要处理不同的场景。第一种场景，需要在列表的起点添加一个元素，也就是第一个位置。下图展示了这种场景： current变量是对列表中第一个元素的引用。我们需要做的是把node.next的值设为current（列表中第一个元素）。现在head和node.next都指向了current。接下来要做的就是把head的引用改为node（行{2}），这样列表中就有了一个新元素。 现在来处理第二种场景：在列表中间或尾部添加一个元素。首先，我们需要循环访问列表，找到目标位置（行{3}）。当跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用，而previous将是对想要插入新元素的位置之前一个元素的引用。在这种情况下，我们要在previous和current之间添加新项。因此，首先需要把新项（node）和当前项链接起来（行{4}），然后需要改变previous和current之间的链接。我们还需要让previous.next指向node（行{5}）。 我们通过一张图表来看看代码所做的事： 如果我们试图向最后一个位置添加一个新元素，previous将是对列表最后一项的引用，而current将是null。在这种情况下，node.next将指向current，而previous.next将指向node，这样列表中就有了一个新的项。 现在来看看如何向列表中间添加一个新元素： 在这种情况下，我们试图将新的项（node）插入到previous和current元素之间。首先，我们需要把node.next的值指向current。然后把previous.next的值设为node。这样列表中就有了一个新的项。 使用变量引用我们需要控制的节点非常重要，这样就不会丢失节点之间的链接。我们可以只使用一个变量（previous），但那样会很难控制节点之间的链接。由于这个原因，最好是声明一个额外的变量来帮助我们处理这些引用。 2.4 实现链表的其他方法2.4.1 toString方法toString方法会把LinkedList对象转换成一个字符串。下面是toString方法的实现： 123456789this.toString = function () &#123; let current = head, //&#123;1&#125; string = ''; //&#123;2&#125; while (current) &#123; //&#123;3&#125; string += current.element + (current.next ? 'n' : '');//&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return string; //&#123;6&#125;&#125;; 首先，要循环访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引（行{1}），控制循环访问列表。我们还需要初始化用于拼接元素值的变量（行{2}）。 接下来就是循环访问列表中的每个元素（行{3}）。我们要用current来检查元素是否存在（如果列表为空，或是到达列表中最后一个元素的下一位（null），while循环中的代码就不会执行）。然后我们就得到了元素的内容，将其拼接到字符串中（行{4}）。最后，继续迭代下一个元素（行{5}）。最后，返回列表内容的字符串（行{6}）。 2.4.2 indexOf方法indexOf方法接收一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回-1。 123456789101112this.indexOf = function(element)&#123; let current = head, //&#123;1&#125; index = -1; while (current) &#123; //&#123;2&#125; if (element === current.element) &#123; return index; //&#123;3&#125; &#125; index++; //&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return -1;&#125;; 一如既往，我们需要一个变量来帮助我们循环访问列表，这个变量是current，它的初始值是head（列表的第一个元素——我们还需要一个index变量来计算位置数（行{1}））。然后循环访问元素（行{2}），检查当前元素是否是我们要找的。如果是，就返回它的位置（行{3}）；如果不是，就继续计数（行{4}），检查列表中下一个节点（行{5}）。 如果列表为空，或是到达列表的尾部（current = current.next将是null），循环就不会执行。如果没有找到值，就返回-1。 2.4.3 remove方法实现了indexOf方法就可以实现remove方法了 1234this.remove = function(element)&#123; let index = this.indexOf(element); return this.removeAt(index);&#125;; 我们已经有一个移除给定位置的一个元素的removeAt方法了。现在有了indexOf方法，如果传入元素的值，就能找到它的位置，然后调用removeAt方法并传入找到的位置。这样非常简单，如果需要更改removeAt方法的代码，这样也更容易——两个方法都会被更改（这就是重用代码的妙处）。这样，我们就不需要维护两个从列表中移除一项的方法，只需要一个！同时，removeAt方法将会检查边界约束。 2.4.4 isEmpty、size和getHead方法isEmpty方法检查链表是否为空、size获取链表长度，这两个方法与队列中的isEmpty方法、size方法类似，如下实现： 123this.isEmpty = function() &#123; return length === 0;&#125;; 如果列表中没有元素，isEmpty方法就返回true，否则返回false。 123this.size = function() &#123; return length;&#125;; size方法返回列表的length。和已经实现的Queue类、Stack类有所不同，列表的length是内部控制的，因为LinkedList是从头构建的。 最后还有getHead方法： 123this.getHead = function()&#123; return head;&#125;; head变量是LinkedList类的私有变量（这意味着它不能在LinkedList实例外部被访问和更改，只有通过LinkedList实例才可以）。但是，如果我们需要在类的外部循环访问列表，就需要提供一种获取类的第一个元素的方法。 三、双向链表双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素，如下图所示 先从实现DoublyLinkedList类所需的变动开始 123456789101112//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法&#125; 在代码中可以看到，LinkedList类和DoublyLinkedList类之间的区别标为新增的。在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一项的引用的tail属性。 双向链表提供了两种迭代列表的方法：从头到尾，或者反过来。我们也可以访问一个特定节点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。 3.1 在任意位置插入新元素向双向链表中插入一个新项跟（单向）链表非常类似。区别在于，链表只要控制一个next指针，而双向链表则要同时控制next和prev（previous，前一个）这两个指针。 这是向任意位置插入一个新元素的算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法 this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 if (!head) &#123; //新增的 &#123;1&#125; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; //新增的 &#123;2&#125; head = node; &#125; &#125; else if (position === length) &#123; //最后一项 //新增的 current = tail; // &#123;3&#125; current.next = node; node.prev = current; tail = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;4&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;5&#125; previous.next = node; current.prev = node; //新增的 node.prev = previous; //新增的 &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; &#125; &#125;;&#125; 我们来分析第一种场景：在列表的第一个位置（列表的起点）插入一个新元素。如果列表为空（行{1}），只需要把head和tail都指向这个新节点。如果不为空，current变量将是对列表中第一个元素的引用。就像我们在链表中所做的，把node.next设为current，而head将指向node（它将成为列表中的第一个元素）。不同之处在于，我们还需要为指向上一个元素的指针设一个值。current.prev指针将由指向null变为指向新元素（node——行{2}）。node.prev指针已经是null，因此不需要再更新任何东西。下图演示了这个过程： 现在来分析一下，假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current变量将引用最后一个元素（行{3}）。然后开始建立第一个链接：node.prev将引用current。current.next指针（指向null）将指向node（由于构造函数，node.next已经指向了null）。然后只剩一件事了，就是更新tail，它将由指向current变为指向node。下图展示了这些行为： 然后还有第三种场景：在列表中间插入一个新元素。就像我们在之前的方法中所做的，迭代列表，直到到达要找的位置（行{4}）。我们将在current和previous元素之间插入新元素。首先，node.next将指向current（行{5}），而previous.next将指向node，这样就不会丢失节点之间的链接。然后需要处理所有的链接：current.prev将指向node，而node.prev将指向previous。下图展示了这一过程： 3.2 从任意位置移除元素从双向链表中移除元素跟链表非常类似。唯一的区别就是还需要设置前一个位置的指针。我们来看一下它的实现： 12345678910111213141516171819202122232425262728293031323334this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; //移除第一项 if (position === 0) &#123; head = current.next; // &#123;1&#125; //如果只有一项，更新tail //新增的 if (length === 1) &#123; // &#123;2&#125; tail = null; &#125; else &#123; head.prev = null; // &#123;3&#125; &#125; &#125; else if (position === length - 1) &#123; //最后一项 //新增的 current = tail; // &#123;4&#125; tail = current.prev; tail.next = null; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;5&#125; previous = current; current = current.next; &#125; //将previous与current的下一项链接起来——跳过current previous.next = current.next; // &#123;6&#125; current.next.prev = previous; //新增的 &#125; length--; return current.element; &#125; else &#123; return null; &#125;&#125;; 我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。 我们来看看如何移除第一个元素。current变量是对列表中第一个元素的引用，也就是我们想移除的元素。需要做的就是改变 head 的引用，将其从 current 改为下一个元素（current.next——行{1}）。但我们还需要更新current.next指向上一个元素的指针（因为第一个元素的prev指针是null）。因此，把head.prev的引用改为null（行{3}——因为head也指向列表中新的第一个元素，或者也可以用current.next.prev）。由于还需要控制tail的引用，我们可以检查要移除的元素是否是第一个元素，如果是，只需要把tail也设为null（行{2}）。 下图勾画了从双向链表移除第一个元素的过程： 下一种场景是从最后一个位置移除元素。既然已经有了对最后一个元素的引用（tail），我们就不需要为找到它而迭代列表。这样我们也就可以把tail的引用赋给current变量（行{4}）。接下来，需要把tail的引用更新为列表中倒数第二个元素（current.prev，或者tail.prev也可以）。既然tail指向了倒数第二个元素，我们就只需要把next指针更新为null（tail.next= null）。下图演示了这一行为： 第三种也是最后一种场景：从列表中间移除一个元素。首先需要迭代列表，直到到达要找的位置（行{5}）。current变量所引用的就是要移除的元素。那么要移除它，我们可以通过更新previous.next和current.next.prev的引用，在列表中跳过它。因此，previous.next将指向current.next，而current.next.prev将指向previous，如下图所示： 3.3 循环列表循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用null，而是指向第一个元素（head），如下图所示。 双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev。 四、小结本篇文章主要介绍链表这种数据结构，及其变体双向链表和循环链表。我们学习了如何在任意位置添加和移除元素，以及如何循环访问链表。还学习了链表相比数组最重要的优点，那就是无需移动链表中的元素，就能轻松地添加和移除元素。因此，当我们需要添加和移除很多元素时，最好的选择就是链表，而非数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法四（队列）","date":"2018-10-12T11:31:39.000Z","path":"2018/10/12/cjsu6q1i6000uhgvbg8xw34xz/","text":"一、队列数据结构队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 在现实中，最常见的队列的例子就是排队： 1.1 创建队列首先需要创建自己的类表示队列，先从最基本的声明开始： 123function quene() &#123; //这里是属性和方法&#125; 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像在Stack类中那样使用（你会发现Queue类和Stack类非常类似，只是添加和移除元素的原则不同）： let items = []; 接下来需要声明一些队列可用的方法: 123456789enqueue(element(s))：向队列尾部添加一个（或多个）新的项。dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。front()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）。isEmpty()：如果队列中不包含任何元素，返回true，否则返回false。size()：返回队列包含的元素个数，与数组的length属性类似。 1.2 向队列添加元素首先要实现的是enqueue方法。这个方法负责向队列添加新元素。这里有一个非常重要的细节，新的项只能添加到队列末尾： 123this.enqueue = function(element)&#123; items.push(element);&#125;; 1.2 从队列移除元素接下来要实现dequeue方法。这个方法负责从队列移除项。由于队列遵循先进先出原则，最先添加的项也是最先被移除的。 123this.dequeue = function()&#123; return items.shift();&#125;; 只有enqueue方法和dequeue方法可以添加和移除元素，这样就确保了Queue类遵循先进先出原则。 1.3 查看队列头元素现在来为我们的类实现一些额外的辅助方法。如果想知道队列最前面的项是什么，可以用front方法。这个方法会返回队列最前面的项（数组的索引为0）： 123this.front = function()&#123; return items[0];&#125;; 1.4 检查队列是否为空下一个是isEmpty方法。如果队列为空，它会返回true，否则返回false（注意这个方法和Stack类里的一样）： 123this.isEmpty = function() &#123; return items.length == 0&#125; 对于isEmpty方法，可以简单地验证内部数组的length是否为0。 我们也可以为Queue类实现类似于array类的length属性的方法。size方法也跟Stack类里的一样： 123this.size = function()&#123; return items.length;&#125;; 1.5 打印队列元素我们的Queue类已经实现好了。为了方便也可以像Stack类一样增加一个print方法： 123this.print = function()&#123; console.log(items.toString());&#125;; 1.6 使用quene类首先要做的是实例化我们刚刚创建的Queue类，然后就可以验证它为空（输出为true，因为我们还没有向队列添加任何元素）： 1234567891011121314151617181920212223242526let items = [];function Queue() &#123; this.enqueue = function(element) &#123; return items.push(element); &#125; this.dequeue = function() &#123; return items.shift(); &#125; this.front = function() &#123; return items[0]; &#125; this.isEmpty = function() &#123; return items.length == 0; &#125; this.size = function() &#123; return items.length; &#125; this.print = function() &#123; return console.log(items.toString()); &#125;&#125;let queue = new Queue();console.log(queue.isEmpty()); //输出true 接下来，添加一些元素（添加”John”和”Jack”两个元素——你可以向队列添加任何类型的元素）： queue.enqueue(“John”); queue.enqueue(“Jack”); 添加另一个元素： queue.enqueue(&quot;Camila&quot;); 再执行一些其他的命令： 1234567891011queue.print(); //[\"John\", \"Jack\", \"Camila\"]console.log(queue.size()); //输出3console.log(queue.isEmpty()); //输出falsequeue.dequeue(); //\"John\"queue.dequeue(); //\"Jack\"queue.print(); //[\"Camila\"] 如果打印队列的内容，就会得到John、Jack和Camila这三个元素。因为我们向队列添加了三个元素，所以队列的大小为3（当然也就不为空了）。 下图展示了目前为止执行的所有入列操作，以及队列当前的状态： 然后，出列两个元素（执行两次dequeue方法）。下图展示了dequeue方法的执行过程： 最后，再次打印队列内容时，就只剩Camila一个元素了。前两个入列的元素出列了，最后入列的元素也将是最后出列的。也就是说，我们遵循了先进先出原则。 二、用ECMAscript6语法实现的Queue类和Stack类一样，我们也可以用ECMAScript 6语法编写Queue类。在这种方法中，我们要用一个WeakMap来保存私有属性items，并用外层函数（闭包）来封装Queue类。 123456789101112131415161718192021let Queue = (function() &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; items.get(this).push(element) return items.get(this); &#125; dequeue() &#123; items.get(this).shift(); return items.get(this) &#125; &#125; return Queue&#125;)();let queue = new Queue();console.log(queue.enqueue(10)); //[10]console.log(queue.enqueue(11)); //[10,11]console.log(queue.dequeue()); //[11] 三、优先队列队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和妇（或带小孩的妇女）登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的（急诊科）候诊室。医生会优先处理病情比较严重的患者。通常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此可以对它们使用默认的出列操作： 12345678910111213141516171819202122232425262728293031323334function PriorityQueue() &#123; let items = []; function QueueElement(element, priority) &#123; // &#123;1&#125; this.element = element; this.priority = priority; &#125; this.enqueue = function (element, priority) &#123; console.log(items) let queueElement = new QueueElement(element, priority); let added = false; for (let i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; // &#123;2&#125; items.splice(i, 0, queueElement); // &#123;3&#125; added = true; break; // &#123;4&#125; &#125; &#125; if (!added) &#123; items.push(queueElement); //&#123;5&#125; &#125; &#125;; this.print = function () &#123; for (let i = 0; i &lt; items.length; i++) &#123; console.log(`$&#123;items[i].element&#125; - $&#123;items[i].priority&#125;`); &#125; &#125;; //其他方法和默认的Queue实现相同&#125; let priorityQueue = new PriorityQueue();priorityQueue.enqueue(\"John\", 2);priorityQueue.enqueue(\"Jack\", 1);priorityQueue.enqueue(\"Camila\", 1);priorityQueue.print(); 默认的Queue类和PriorityQueue类实现上的区别是，要向PriorityQueue添加元素，需要创建一个特殊的元素（行{1}）。这个元素包含了要添加到队列的元素（它可以是任意类型）及其在队列中的优先级。 如果队列为空，可以直接将元素入列（行{2}）。否则，就需要比较该元素与其他元素的优先级。当找到一个比要添加的元素的priority值更大（优先级更低）的项时，就把新元素插入到它之前（根据这个逻辑，对于其他优先级相同，但是先添加到队列的元素，我们同样遵循先进先出的原则）。要做到这一点，我们可以用第2章学习过的JavaScript的array类的splice方法。一旦找到priority值更大的元素，就插入新元素（行{3}）并终止队列循环（行{4}）。这样，队列也就根据优先级排序了。 如果要添加元素的priority值大于任何已有的元素，把它添加到队列的末尾就行了（行{5}）: let priorityQueue = new PriorityQueue();priorityQueue.enqueue(“John”, 2);priorityQueue.enqueue(“Jack”, 1);priorityQueue.enqueue(“Camila”, 1);priorityQueue.print(); 以上代码是一个使用PriorityQueue类的示例。在下图中可以看到每条命令的结果（以上代码的结果） 第一个被添加的元素是优先级为2的John。因为此前队列为空，所以它是队列中唯一的元素。接下来，添加了优先级为1的Jack。由于Jack的优先级高于John，它就成了队列中的第一个元素。然后，添加了优先级也为1的Camila。Camila的优先级和Jack相同，所以它会被插入到Jack之后（因为Jack先被插入队列）；Camila的优先级高于John，所以它会被插入到John之前。 我们在这里实现的优先队列称为最小优先队列，因为优先级的值较小的元素被放置在队列最前面（1代表更高的优先级）。最大优先队列则与之相反，把优先级的值较大的元素放置在队列最前面。 四、循环队列——击鼓传花还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏（HotPotato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子（胜者）。 在下面这个示例中，我们要实现一个模拟的击鼓传花游戏： 123456789101112131415161718192021222324252627282930313233343536373839404142let Queue = (function () &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; return items.get(this).push(element) // return items.get(this); &#125; dequeue() &#123; return items.get(this).shift(); // return items.get(this); &#125; size() &#123; return items.get(this).length; &#125; print() &#123; console.log(items.get(this).toString()); &#125; &#125; return Queue&#125;)();function hotPotato(nameList, num) &#123; let queue = new Queue(); // &#123;1&#125; for (let i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); // &#123;2&#125; &#125; let eliminated = ''; while (queue.size() &gt; 1) &#123; for (let i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); // &#123;3&#125; John queue.print() &#125; eliminated = queue.dequeue();// &#123;4&#125; // console.log(eliminated + '在击鼓传花游戏中被淘汰。'); //Camila,Jack,Carl,Ingrid &#125; return queue.dequeue();// &#123;5&#125;&#125;let names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; let winner = hotPotato(names, 7); console.log('The winner is: ' + winner); //The winner is: John 实现一个模拟的击鼓传花游戏，要用到实现的Queue类（行{1}）。我们会得到一份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被淘汰的威胁立刻就解除了）。一旦传递次数达到给定的数字，拿着花的那个人就被淘汰了（从队列中移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）。 以上算法的输出如下： Camila在击鼓传花游戏中被淘汰。Jack在击鼓传花游戏中被淘汰。Carl在击鼓传花游戏中被淘汰。Ingrid在击鼓传花游戏中被淘汰。胜利者：John 下图模拟了这个输出过程：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法三（栈）","date":"2018-09-28T09:58:31.000Z","path":"2018/09/28/cjsu6q1i2000ohgvbcscurwsh/","text":"一、栈数据结构栈是一种遵从后进先出(LIFO)原则的有序数据集合。新添加的或者待删除的元素保存在栈的同一端称为栈顶，另一端称为栈底。在栈里新添加的元素都靠近栈顶，旧添加的元素都接近栈底 1.1 创建栈先创建一个类表示栈，先声明一个类： function Stack() { //各种属性和方法的声明 } 首先，我们需要一种数据结构来保存栈里的元素。可以选择数组： let items = []; 接下来，要为我们的栈声明一些方法。 push(element(s))：添加一个（或几个）新元素到栈顶。 pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。 isEmpty()：如果栈里没有任何元素就返回true，否则返回false。 clear()：移除栈里的所有元素。 size()：返回栈里的元素个数。这个方法和数组的length属性很类似。 1.2 像栈中添加元素我们要实现的第一个方法是push。这个方法负责往栈里添加新元素，有一点很重要：该方法只添加元素到栈顶，也就是栈的末尾。push方法可以这样写： this.push = function(element){ items.push(element); }; 1.3 从栈中移除元素接着，我们来实现pop方法。这个方法主要用来移除栈里的元素。栈遵从LIFO原则，因此移出的是最后添加进去的元素。因此，我们可以用数组的pop方法。栈的pop方法可以这样写： this.pop = function(){ return items.pop(); }; 1.4 查看栈顶元素现在，为我们的类实现一些额外的辅助方法。如果想知道栈里最后添加的元素是什么，可以用peek方法。这个方法将返回栈顶的元素： this.peek = function(){ return items[items.length-1]; }; 1.5 检测栈是否为空下一个要实现的方法是 isEmpty，如果栈为空的话将返回true，否则就返回false： this.isEmpty = function(){ return items.length == 0; }; 使用isEmpty方法，我们能简单地判断内部数组的长度是否为0。 类似于数组的length属性，我们也能实现栈的length。对于集合，最好用size代替length。因为栈的内部使用数组保存元素，所以能简单地返回栈的长度： this.size = function(){ return items.length; }; 1.6 清空和打印栈元素最后，我们来实现clear方法。clear方法用来移除栈里所有的元素，把栈清空。实现这个方法最简单的方式是： this.clear = function(){ items = []; }; 另外也可以多次调用pop方法，把数组中的元素全部移除，这样也能实现clear方法。 如下案例，为了检查栈里的内容，实现一个辅助方法print。它会把栈里的元素都输出到控制台： this.print = function(){ console.log(items.toString()); }; 1.7 使用Stack类首先，我们需要初始化Stack类。然后，验证一下栈是否为空（输出是true，因为还没有往栈里添加元素）。 function Stack(){ this.push = function (element) { return items.push(element) } this.pop = function () { return items.pop(); }; this.peek = function () { return items[items.length - 1]; }; this.isEmpty = function () { return items.length == 0; }; this.size = function () { return items.length; }; this.clear = function(){ items = []; }; this.print = function(){ console.log(items.toString()); }; } let items = []; let stack = new Stack(); console.log(stack.isEmpty()); //true 接下来，往栈里添加一些元素（这里我们添加数字5和8；你可以添加任意类型的元素）: Stack.push(5); Stack.push(8); 如果调用peek方法，将会输出8，因为它是往栈里添加的最后一个元素： console.log(stack.peek()); //输出8 再添加一个元素： stack.push(11); console.log(stack.size()); //输出3 console.log(stack.isEmpty()); //输出false 我们往栈里添加了11。如果调用size方法，输出为3，因为栈里有三个元素（5、8和11）。如果我们调用isEmpty方法，会看到输出了false（因为栈里有三个元素，不是空栈）。最后，我们再添加一个元素： stack.push(15); 下图描绘了目前为止我们对栈的操作，以及栈的当前状态： 然后，调用两次pop方法从栈里移除2个元素： stack.pop(); stack.pop(); console.log(stack.size()); //输出2 stack.print(); //输出[5, 8] 在两次调用pop方法前，我们的栈里有四个元素。调用两次后，现在栈里仅剩下5和8了。下图描绘这个过程的执行： 二、ECMAScript 6 和 Stack 类2.1 用 ES6 语法声明 Stack 类class Stack { constructor () { this.items = []; //{1} } push(element){ this.items.push(element); } //其他方法 } 我们只是用ES6的简化语法把Stack函数转换成Stack类。这种方法不能像其他语言（Java、C++、C#）一样直接在类里面声明变量，只能在类的构造函数constructor里声明（行{1}，在类的其他函数里用this.nameofVariable就可以引用这个变量。 尽管代码看起来更简洁、更漂亮，变量items却是公共的。ES6的类是基于原型的。虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性（变量）或方法。而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法。否则，就有可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。 2.1.1 用ES6的限定作用域Symbol实现类ES6新增了一种叫作Symbol的基本类型，它是不可变的，可以用作对象的属性。 let _items = Symbol(); //{1} class Stack { constructor () { this[_items] = []; //{2} } //Stack方法 } 在上面的代码中，我们声明了Symbol类型的变量_items（行{1}），在类的constructor函数中初始化它的值（行{2}）。要访问_items，只需把所有的this.items都换成this[_items]。 这种方法创建了一个假的私有属性，因为ES6新增的Object.getOwnPropertySymbols方法能够取到类里面声明的所有Symbols属性。下面是一个破坏Stack类的例子： let _items = Symbol(); class Stack { constructor() { this[_items] = []; } push(element) { return this[_items].push(element); }; print() { console.log(this[_items].toString()); }; } let stack = new Stack(); stack.push(5); stack.push(8); let objectSymbols = Object.getOwnPropertySymbols(stack); console.log(objectSymbols.length); // 1 console.log(objectSymbols); // [Symbol()] console.log(objectSymbols[0]); // Symbol() stack[objectSymbols[0]].push(1); stack.print(); //输出 5, 8, 1 从以上代码可以看到，访问stack[objectSymbols[0]]是可以得到_items的。并且，_items属性是一个数组，可以进行任意的数组操作，比如从中间删除或添加元素。我们操作的是栈，不应该出现这种行为。 2.1.2 用ES6的WeakMap实现类有一种数据类型可以确保属性是私有的，这就是WeakMap。WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。 如果用WeakMap来存储items变量，Stack类就是这样的： const items = new WeakMap(); //{1} class Stack { constructor () { items.set(this, []); //{2} } push(element) { let s = items.get(this); //{3} s.push(element); } pop() { let s = items.get(this); let r = s.pop(); return r; } //其他方法 } //行{1}，声明一个WeakMap类型的变量items。 //行{2}，在constructor中，以this（Stack类自己的引用）为键，把代表栈的数组存入items。 //行{3}，从WeakMap中取出值，即以this为键（行{2}设置的）从items中取值。 现在我们知道，items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap： let Stack = (function () { const items = new WeakMap(); class Stack { constructor () { items.set(this, []); } //其他方法 } return Stack; //{5} })(); //当Stack函数里的构造函数被调用时，会返回Stack类的一个实例（行{5}）。 现在，Stack类有一个名为items的私有属性。虽然它很丑陋，但毕竟实现了私有属性。然而，用这种方法的话，扩展类无法继承私有属性。鱼与熊掌不可兼得！ 把上面的代码跟本章最初实现的Stack类做个比较，我们会发现有一些相似之处： function Stack() { let items = []; //其他方法 } 事实上，尽管ES6引入了类的语法，我们仍然不能像在其他编程语言中一样声明私有属性或方法。有很多种方法都可以达到相同的效果，但无论是语法还是性能，这些方法都有各自的优点和缺点 哪种方法更好？这取决于你在实际项目中如何使用本书中这些算法，要处理的数据量，要创建的实例个数，以及其他约束条件。最终，还是取决于你。 2.2 用栈解决问题栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后续再讨论图和回溯问题时，我们会学习如何应用这个例子）。Java和C#用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 2.2.1 从十进制到二进制现实生活中，我们主要使用十进制。但在计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的（0和1）。没有十进制和二进制相互转化的能力，与计算机交流就很困难。 要把十进制转化成二进制，我们可以将该十进制数字和2整除（二进制是满二进一），直到结果是0为止。举个例子，把十进制的数字10转化成二进制的数字，过程大概是这样： 大学的计算机课一般都会先教这个进制转换。下面是对应的算法描述： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop(); } isEmpty() { return items.get(this).length == 0; }; } return Stack; })(); function divideBy2(decNumber) { var remStack = new Stack(), rem, binaryString = &apos;&apos;; while (decNumber &gt; 0) { //{1} rem = Math.floor(decNumber % 2); //{2} remStack.push(rem); //{3} decNumber = Math.floor(decNumber / 2); //{4} } while (!remStack.isEmpty()) { binaryString += remStack.pop().toString(); //{5} } return binaryString; } console.log(divideBy2(13)); //1101 在这段代码里，当结果满足和2做整除的条件时（行{2}），我们会获得当前结果和2的余数，放到栈里（行{2}、{3}）。然后让结果和2做整除（行{4}）。另外请注意：JavaScript有数字类型，但是它不会区分究竟是整数还是浮点数。因此，要使用Math.floor函数让除法的操作仅返回整数部分。最后，用pop方法把栈中的元素都移除，把出栈的元素变成连接成字符串（行{5}）。 2.2.2 进制转换算法我们很容易修改之前的算法，使之能把十进制转换成任何进制。除了让十进制数字和2整除转成二进制数，还可以传入其他任意进制的基数为参数，就像下面算法这样： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop() } isEmpty() { return items.get(this).length == 0; }; } return Stack; //{5} })(); function baseConverter(decNumber, base) { var remStack = new Stack(), rem, baseString = &apos;&apos;, digits = &apos;0123456789ABCDEF&apos;; //{6} while (decNumber &gt; 0) { rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); } while (!remStack.isEmpty()) { baseString += digits[remStack.pop()]; //{7} } return baseString; } console.log(baseConverter(13,2)); //1101 console.log(baseConverter(13,8)); //15 我们只需要改变一个地方。在将十进制转成二进制时，余数是0或1；在将十进制转成八进制时，余数是0到7之间的数；但是将十进制转成16进制时，余数是0到9之间的数字加上A、B、C、D、E和F（对应10、11、12、13、14和15）。因此，我们需要对栈中的数字做个转化才可以（行{6}和行{7}）。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法二（数组的使用）","date":"2018-09-10T11:24:31.000Z","path":"2018/09/10/cjsu6q1ln0011hgvbauo2sgu7/","text":"一、创建和初始化数组1.1 创建数组用JavaScript声明、创建和初始化数组有两种方式 //使用new创建数组 var daysOfWeek = new Array(); //{1} var daysOfWeek = new Array(7); //{2} var daysOfWeek = new Array(&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;); //{3} 使用new关键字，就能简单地声明并初始化一个数组（行{1}）。用这种方式，还可以创建一 个指定长度的数组（行{2}）。另外，也可以直接将数组元素作为参数传递给它的构造器（行{3}）。 //使用[]创建数组 var daysOfWeek = []; 也可使用一些元素初始化数组，如下： var daysOfWeek = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; 使用数组的length属性获取数组的长度 console.log(daysOfWeek.length); //7 1.2 访问元素和迭代数组要访问数组里特定位置的元素，可以用中括号传递数值位置，得到想知道的值或者赋新的值。如下： for (var i=0; i&lt;daysOfWeek.length; i++){ console.log(daysOfWeek[i]); } 我们来看另一个例子：求斐波那契数列的前20个数字。已知斐波那契数列中第一个数字是1，第二个是2，从第三项开始，每一项都等于前两项之和： var fibonacci = []; //{1} fibonacci[1] = 1; //{2} fibonacci[2] = 2; //{3} for(var i = 3; i &lt; 20; i++){ fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]; ////{4} } for(var i = 1; i&lt;fibonacci.length; i++){ //{5} console.log(fibonacci[i]); //{6} } 在行{1}处，我们声明并创建了一个数组。 在行{2}和行{3}，把斐波那契数列中的前两个数字分别赋给了数组的第二和第三位（在JavaScript中，数组的第一位是0，这里我们略过，从第二位开始分别保存斐波那契数列中对应位置的元素）。 然后，我们需要做的就是想办法得到斐波那契数列的第三到第二十位的数字（前两个值我们已经初始化过了）。我们可以用循环来处理，把数组中前两位上的元素相加，结果赋给当前位置上的元素（行{4}——从数组中的索引3到索引19）。 最后，看看输出（行{6}），我们只需要循环遍历数组的各个元素（行{5}）。 1.3 添加元素1.3.1 使用数组索引直接添加var numbers = [0,1,2,3,4,5,6,7,8,9]; 如果想要给数组添加一个元素（比如10），只要把值赋给数组中最后一个空位上的元素即可。 numbers[numbers.length] = 10; 1.3.2 使用push方法push方法，能把元素添加到数组的末尾 numbers.push(11); numbers.push(12, 13); 1.3.3 插入元素到数组首位现在，我们希望在数组中插入一个值，不像之前那样插入到最后，而是放到数组的首位。为了实现这个需求，首先我们要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位+1（长度）开始，将其对应的前一个元素的值赋给它，依次处理，最后把我们想要的值赋给第一个位置（-1）上。 for (var i=numbers.length; i&gt;=0; i--){ numbers[i] = numbers[i-1]; } numbers[0] = -1; 下面这张图描述了我们刚才的操作过程： ; 也可以使用unshift方法 numbers.unshift(-2); numbers.unshift(-4, -3); 1.4 删除元素1.4.1 删除数组里最靠后的元素删除数组里最靠后的元素使用pop方法： numbers.pop(); 1.4.2 从数组首位删除元素如果要移除数组里的第一个元素，可以用下面的代码： for (var i = 0; i &lt; numbers.length; i++){ numbers[i] = numbers[i+1]; } 下面这张图呈现了这段代码的执行过程： 我们把数组里所有的元素都左移了一位。但数组的长度依然是17，这意味着数组中有额外的 一个元素（值是undefined）。在最后一次循环里，i + 1引用了一个数组里还未初始化的位置。 在Java、C/C+或C#等一些语言里，这样写可能就会抛出异常了，因此不得不在 numbers.length - 1处停止循环。 可以看到，我们只是把数组第一位的值用第二位覆盖了，并没有删除元素（因为数组的长度 和之前还是一样的，并且了多一个未定义元素）。 使用unshift()方法 numbers.shift(); //通过shift和unshift方法，就能用数组模拟基本的队列数据结构， 1.4.3 在任意位置添加或删除元素使用splice方法，简单地通过指定位置/索引，就可以删除相应位置和数量的元素： //如下 numbers.splice(5,3); //这行代码删除了从数组索引5开始的3个元素。这就意味着numbers[5]、numbers[6]和numbers[7]从数组中删除了。 splice方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除元素的个数（这个例子里，我们的目的不是删除元素，所以传入0）。第三个参数往后，就是要添加到数组里的值（元素2、3、4）。输出会发现值又变成了从3到12。 numbers.splice(5,3,2,3,4);//我们从索引5开始删除了3个元素，但也从索引5开始添加了元素2、3、4 对于JavaScript数组和对象，我们还可以用delete操作符删除数组中的元素，例如delete numbers[0]。然而，数组位置0的值会变成undefined，也就是说，以上操作等同于numbers[0] = undefined。因此，我们应该始终使用splice、pop或shift（马上就会学到）方法来删除数组元素。 二、 二维和多维数组JavaScript只支持一维数组，并不支持矩阵(二维数组)。但是，我们可以用数组套数组，实现矩阵或任一多维数组。代码也可以写成这样： var averageTemp = []; averageTemp[0] = []; averageTemp[0][0] = 72; averageTemp[0][1] = 75; averageTemp[0][2] = 79; averageTemp[0][3] = 79; averageTemp[0][4] = 81; averageTemp[0][5] = 81; //day 2 averageTemp[1] = []; averageTemp[1][0] = 81; averageTemp[1][1] = 79; averageTemp[1][2] = 75; averageTemp[1][3] = 75; averageTemp[1][4] = 73; averageTemp[1][5] = 72; 上面的代码里，我们分别指定了每天和每小时的数据。数组中的内容如下图所示： 每行就是每天的数据，每列是当天不同时段的气温 2.1 迭代二维数组的元素如果想看矩阵的输出，我们可以创建一个通用函数，专门输出其中的值： function printMatrix(myMatrix) { for (var i=0; i&lt;myMatrix.length; i++){ for (var j=0; j&lt;myMatrix[i].length; j++){ console.log(myMatrix[i][j]); } } } 需要遍历所有的行和列。因此，我们需要使用一个嵌套的for循环来处理，其中变量i为行，变量j为列。 使用以下代码查看矩阵averageTemp的输出： printMatrix(averageTemp); 2.2 多维数组我们也可以用这种方式来处理多维数组。假如我们要创建一个3×3×3的矩阵，每一格里包含矩阵的i（行）、j（列）及z（深度）之和： var matrix3x3x3 = []; for (var i=0; i&lt;3; i++){ matrix3x3x3[i] = []; for (var j=0; j&lt;3; j++){ matrix3x3x3[i][j] = []; for (var z=0; z&lt;3; z++){ matrix3x3x3[i][j][z] = i+j+z; } } } 数据结构中有几个维度都没关系，我们都可以用循环遍历每个维度来访问所有格子。3×3×3的矩阵也可用立体图表示如下： 可以用以下代码输出这个矩阵的内容： for (var i=0; i&lt;matrix3x3x3.length; i++){ for (var j=0; j&lt;matrix3x3x3[i].length; j++){ for (var z=0; z&lt;matrix3x3x3[i][j].length; z++){ console.log(matrix3x3x3[i][j][z]); } } } 如果是一个3×3×3×3的矩阵，代码中就会用四层嵌套的for语句，以此类推。 2.3 JavaScript 的数组方法参考 方法名 语法 concat 连接数组（一个或多个），返回连接后的结果 every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach 遍历数组 join 将所有的数组元素连接成一个字符串 indexOf 从数组开始查找数组元素在数组中的的位置，并返回，没有找到则返回-1 lastIndexOf 从数组结尾查找数组元素在数组中的的位置，并返回，没有找到则返回-1 map 遍历数组元素，并返回 reverse 颠倒数组中元素的顺序 slice 截取数组中的元素 some 对数组中的每一项运行给定函数，如果任一项返回true，则返回true sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 toString 将数组作为字符串返回 valueOf 和toString类似，将数组作为字符串返回 2.3.1 数组合并concat方法可以向一个数组传递数组、对象或是元素。数组会按照该方法传入的参数顺序连接指定数组。如下： var zero = 0; var positiveNumbers = [1,2,3]; var negativeNumbers = [-3,-2,-1]; var numbers = negativeNumbers.concat(zero, positiveNumbers); //[3,2,1,0,1,2,3] 2.3.1 迭代器函数迭代数组中的元素可以使用for循环，同样JavaScript内置了许多数组可用的迭代方法 解决如下案例： 假如有一个数组，它值是从1到15，如果数组里的元素可以被2整除（偶数），函数就返回true，否则返回false： var isEven = function (x) { // 如果x是2的倍数，就返回true console.log(x); return (x % 2 == 0) ? true : false; }; var numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; 用every方法迭代 numbers.every(isEven); //false //数组numbers的第一个元素是1，它不是2的倍数（1是奇数），因此isEven 函数返回false，然后every执行结束。 用some方法迭代 some方法会迭代数组的每个元素，直到函数返回true： numbers.some(isEven); //numbers数组中第一个偶数是2（第二个元素）。第一个被迭代的元素是1， isEven会返回false。第二个被迭代的元素是2，isEven返回true——迭代结束。 用forEach方法迭代 numbers.forEach(function(x){ console.log((x % 2 == 0)); }); 使用map和filter方法 var myMap = numbers.map(isEven); //[false, true, false, true, false, true, false, true,false, true, false, true, false, true, false]。 filter方法返回新数组由使函数返回true的元素组成： var evenNumbers = numbers.filter(isEven); //[2, 4, 6, 8, 10, 12, 14] 使用reduce方法 reduce方法接收一个函数作为参数，这个函数有四个参数：previousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器 numbers.reduce(function(previous, current, index){ return previous + current; //120 }); 2.4 ECMAScript 6 和数组的新功能下标展示了一些ES6和ES7新增的数组方法 方法 描述 @@iterator 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 copyWithin 复制数组中一系列元素到同一数组指定的起始位置 entries 返回包含数组所有键值对的@@iterator includes 如果数组中存在某个元素则返回true，否则返回false。ES7新增 find 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素 findIndex 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引-1 fill 用静态值填充数组-1 from 根据已有数组创建一个新数组 keys 返回包含数组所有索引的@@iterator of 根据传入的参数创建一个新数组 values 返回包含数组中所有值的@@iterator sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 除了这些新的方法，还有一种用for…of循环来迭代数组的新做法，以及可以从数组实例得到的迭代器对象 2.4.1 使用forEach和箭头函数迭代箭头函数可以简化使用forEach迭代数组元素的做法，如下 numbers.forEach(function (x) { console.log(x % 2 == 0); }); //这段代码可以简化如下： numbers.forEach(x =&gt; { console.log((x % 2 == 0)); }); 2.4.2 使用for…of循环迭代for (let n of numbers) { console.log((n % 2 == 0) ? &apos;even&apos; : &apos;odd&apos;); } 2.4.3 ES6新的迭代器（@@iterator）ES6还为Array类增加了一个@@iterator属性，需要通过Symbol.iterator来访问。代码如下: let iterator = numbers[Symbol.iterator](); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 console.log(iterator.next().value); // 4 console.log(iterator.next().value); // 5 然后，不断调用迭代器的next方法，就能依次得到数组中的值,数组中所有值都迭代完之后，iterator.next().value会返回undefined。 2.4.4 数组的entries、keys和values方法 entries: 返回包含键值对的@@iterator，如下案例： let numbers = [1,2,3] let aEntries = numbers.entries(); // 得到键值对的迭代器,key是数组中的位置，value是保存在数组索引的值。 console.log(aEntries.next().value); // [0, 1] - 位置0的值为1 console.log(aEntries.next().value); // [1, 2] - 位置1的值为2 console.log(aEntries.next().value); // [2, 3] - 位置2的值为3 entries方法会返回numbers数组位置以及对应的值，如果没有可迭代的值则返回undefined。 entries：方法返回包含数组索引的@@iterator，如下案例： let numbers = [1,2,3] let aKeys = numbers.keys(); // 得到数组索引的迭代器 console.log(aKeys.next()); // {value: 0, done: false } console.log(aKeys.next()); // {value: 1, done: false } console.log(aKeys.next()); // {value: 2, done: false } console.log(aKeys.next()); // {value: undefined, done: true } keys方法会返回numbers数组的索引。一旦没有可迭代的值，aKeys.next()就会返回一个value属性为undefined，done属性为true的对象。如果done属性的值为false，就意味着还有可迭代的值。 values：方法返回的@@iterator则包含数组的值 let numbers = [1,2,3] let aValues = numbers.values(); console.log(aValues.next()); // {value: 1, done: false } console.log(aValues.next()); // {value: 2, done: false } console.log(aValues.next()); // {value: 3, done: false } console.log(aValues.next()); // {value: undefined, done: true } 2.4.5 from方法Array.from方法根据已有的数组创建一个新数组，参数为过滤Array中元素的函数 let evens = Array.from(numbers, x =&gt; (x % 2 == 0)); 2.4.6 用Array.of方法Array.of方法根据传入的参数创建一个新数组 let numbers4 = Array.of(1, 2, 3, 4, 5, 6); //[1,2,3,4,5,6] 也可以用这个方法复制已有的数组 let numbersCopy = Array.of(...numbers4); //[1,2,3,4,5,6] 2.4.7 使用fill方法fill方法用静态值填充数组,参数为要添加的位置范围 let numbersCopy = Array.of(1, 2, 3, 4, 5, 6); numbersCopy.fill(0); //（[0, 0, 0, 0, 0, 0] numbersCopy.fill(1, 3, 5); //[0, 0, 0, 1, 1, 0] 创建数组并初始化值的时候，fill方法非常方便，如下： let ones = Array(6).fill(1); //[1, 1, 1, 1, 1, 1] 2.4.8 copyWithin方法copyWithin方法复制数组中的一系列元素到同一数组指定的起始位置 let copyArray = [1, 2, 3, 4, 5, 6]; copyArray.copyWithin(0, 3); // [4, 5, 6, 4, 5, 6] copyArray.copyWithin(1, 3, 5); //[4,4,5,4,5,6] 2.4.9 排序元素 反转数组reverse： let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. 15]; numbers.reverse(); //[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]; 对数组进行排序sort： numbers.sort(); //[1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9] //sort方法在对数组做排序时，把元素默认成字符串进行相互比较。 //所以在使用的时候传入自己写的比较函数 numbers.sort(function(a, b){ return a-b; }); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 自定义排序 我们可以对任何对象类型的数组排序，也可以创建compareFunction来比较元素。例如，对象Person有名字和年龄属性，我们希望根据年龄排序，就可以这么写： var friends = [ {name: &apos;John&apos;, age: 30}, {name: &apos;Ana&apos;, age: 20}, {name: &apos;Chris&apos;, age: 25} ]; function comparePerson(a, b){ if (a.age &lt; b.age){ return -1 } if (a.age &gt; b.age){ return 1 } return 0; } console.log(friends.sort(comparePerson)); //在这个例子里，最后会输出Ana(20), Chris(25), John(30)。 字符串排序 JavaScript在做字符比较的时候，是根据字符对应的ASCII值来比较的。 如下案例： var names =[&apos;Ana&apos;, &apos;ana&apos;, &apos;john&apos;, &apos;John&apos;]; console.log(names.sort()); //[&quot;Ana&quot;, &quot;John&quot;, &quot;ana&quot;, &quot;john&quot;] //因为A、J、a、j对应的ASCII值分别是65、75、97、106。 现在，如果给sort传入一个忽略大小写的比较函数，将会输出[“Ana”, “ana”, “John”,”john”]： names.sort(function(a, b){ if (a.toLowerCase() &lt; b.toLowerCase()){ return -1 } if (a.toLowerCase() &gt; b.toLowerCase()){ return 1 } return 0; }); 假如对带有重音符号的字符做排序的话，我们可以用localeCompare来实现： var names2 = [&apos;Maève&apos;, &apos;Maeve&apos;]; console.log(names2.sort(function(a, b){ return a.localeCompare(b); })); //[&quot;Maeve&quot;, &quot;Maève&quot;] 搜索（indexOf/lastIndexOf） 搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引,如果没有匹配的元素则返回-1。 console.log(numbers.indexOf(10)); //9 console.log(numbers.indexOf(100)); //-1 搜索（ECMAScript 6——find和findIndex方法） find和findIndex方法接收一个回调函数，搜索一个满足回调函数条件的值。 let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; function multipleOf13(element, index, array) { return (element % 13 == 0) ? true : false; } console.log(numbers.find(multipleOf13)); //13 console.log(numbers.findIndex(multipleOf13)); //12 //find和findIndex的不同之处在于，find方法返回第一个满足条件的值。 //findIndex方法则返回这个值在数组里的索引。 //如果没有满足条件的值，find会返回undefined，而findIndex返回-1。 搜索（ECMAScript 7——使用includes方法） 如果数组里存在某个元素，includes方法会返回true，否则返回false。 console.log(numbers.includes(15)); //true console.log(numbers.includes(20)); //false 如果给includes方法传入一个起始索引，搜索会从索引指定的位置开始： let numbers2 = [7, 6, 5, 4, 3, 2, 1]; console.log(numbers2.includes(4, 5)); //false 2.4.10 输出数组为字符串 toString 把数组里所有元素输出为一个字符串 let numbers = [1, 2, 3, 4] console.log(numbers.toString()); //1,2,3,4 如果想用一个不同的分隔符（比如-）把元素隔开，可以用join方法： var numbersString = numbers.join(&apos;-&apos;); console.log(numbersString); //1-2-3-4 三、 类型数组JavaScript数组不是强类型的，因此它可以存储任意类型的数据。而类型数组则用于存储单一类型的数据。它的语法是let myArray = new TypedArray(length)，其中TypedArray需替换为下表所列之一。 类型数组 数据类型 Int8Array 8位二进制补码整数 Uint8Array 8位无符号整数 Uint8ClampedArray 8位无符号整数 Int16Array 16位二进制补码整数 Uint16Array 16位无符号整数 Int32Array 32位二进制补码整数 Uint32Array 32位无符号整数 Float32Array 32位IEEE浮点数 Float64Array 64位IEEE浮点数 代码示例如下： let length = 5; let int16 = new Int16Array(length); for (let i=0; i&lt;length; i++){ int16[i] = i+1; } console.log(int16); //[1, 2, 3, 4, 5] 使用WebGL API、进行位操作、处理文件和图像时，类型数组都可以大展拳脚。它用起来和普通数组也毫无二致，本章所学的数组方法和功能都可以用于类型数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法一（javascript基础）","date":"2018-08-16T11:20:30.000Z","path":"2018/08/16/cjsu6q1gx0005hgvb58nr3xw5/","text":"一、相等操作符（==和===）1.相等操作符（==）在使用==时，不同类型的值也可以被看作相等下面表格展示了不同类型的值用相等操作符比较后的结果。 类型（x） 类型（y） 结 果 null undefined true undefined null true 数字 字符串 x == toNumber(y) 字符串 数字 toNumber(x) == y 布尔值 任意类型 toNumber(x) == y 任意类型 布尔值 x == toNumber(y) 字符串或数字 对象 x == toPrimitive(y) 对象 字符串或数字 toPrimitive(x) == y 如果x和y是相同类型，JavaScript会比较它们的值或对象值。其他没有列在这个表格中的情况都会返回false。toNumber和toPrimitive方法是内部的，并根据以下表格对其进行估值。toNumber方法对不同类型返回的结果如下： 值类型 结 果 undefined NAN null +0 布尔值 如果是true，返回1；如果是false，返回+0 数字 数字对应的值 字符串 将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字 对象 Number(toPrimitive(vale)) toPrimitive方法对不同类型返回的结果如下： 值类型 结 果 对象 如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误 例：console.log(&apos;packt&apos; == true); //输出false 首先，布尔值会被toNumber方法转成数字，因此得到packt == 1。 其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式就变成了NaN == 1，结果就是false。 1.相等操作符（===）如果比较的两个值或者类型不同则返回false，如果比较的两个值类型相同，结果会根据下表判断。 类型（x） 类型（y） 结 果 数字 x和y数值相同（但不是NaN） true 字符串 x和y是相同的字符 true 布尔值 x和y都是true或false true 对象 x和y引用同一个对象 true 例：console.log(&apos;packt&apos; === true); //false console.log(&apos;packt&apos; === &apos;packt&apos;); //true 二、声明展开和剩余参数2.1展开操作符在es5中使用apply()函数将数组转化为参数，在es6中使用展开操作符(…); 例： var params = [1, 3, 5] function sum(a=1, b=3, c=4) { return a+b+c } console.log(sum(...params)); //es6使用扩展符传入数组 console.log(sum.apply(null, params)); //es5使用apply传入数组 在函数中也可以使用展开操作符(…)代替arguments，当做剩余参数使用，如下案例： function restParamaterFunction (x, y, ...a) { return (x + y) * a.length; } console.log(restParamaterFunction(1, 2, &quot;hello&quot;, true, 7)); //输出9; es5中实现 function restParamaterFunction(x, y) { var a = Array.prototype.slice.call(arguments, 2); console.log(a) return (x + y) * a.length; }; 2.2数组解构es6引入数组解构的概念，可以一次初始化多个变量，如下： var [x, y] = [&apos;a&apos;, &apos;b&apos;]; 等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; 数组解构也可以用来进行值的互换，而不需要创建临时变量，如下： [x, y] = [y, x]; //等同于 var temp = x, x = y, y = temp; 对象也可以解构，如下： //属性简写的功能， var [x, y] = [&apos;a&apos;, &apos;b&apos;]; var obj = { x, y }; console.log(obj); // { x: &quot;a&quot;, y: &quot;b&quot; } //等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; var obj2 = { x: x, y: y }; console.log(obj2); // { x: &quot;a&quot;, y: &quot;b&quot; } //方法属性 var hello = { name : &apos;abcdef&apos;, printHello() { console.log(&apos;Hello&apos;); } } console.log(hello.printHello()); //等同于 var hello = { name: &apos;abcdef&apos;, printHello: function printHello() { console.log(&apos;Hello&apos;); } }; 三、使用类进行面向对象编程声明一个book类的方式 function Book(title, pages, isbn){ //{1} this.title = title; this.pages = pages; this.isbn = isbn; } Book.prototype.printTitle = function(){ console.log(this.title); }; 使用es6可以简化为一下语法 只需要使用class关键字声明一个constructor函数和其他函数 class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } //以上两种声明据用相同的效果和输出 let book = new Book(&apos;title&apos;, &apos;pag&apos;, &apos;isbn&apos;); console.log(book.title); //输出图书标题 book.title = &apos;new title&apos;; //更新图书标题 console.log(book.title); //输出图书标题 3.1继承es6简化声明类的方式 如下： class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } class ITBook extends Book { //{扩展book并继承其行为 constructor (title, pages, isbn, technology) { super(title, pages, isbn); //引用父类的构造函数 this.technology = technology; } printTechnology(){ console.log(this.technology); } } let jsBook = new ITBook(&apos;学习JS算法&apos;, &apos;200&apos;, &apos;1234567890&apos;, &apos;JavaScript&apos;); console.log(jsBook.title); console.log(jsBook.printTechnology()); //我们可以使用extends关键字扩展一个类并继承它的行为。在构造函数中，也可以通过super关键字引用父类的构造函数。 3.2使用属性存取器使用新的类语法也可以为属性创建存取器函数。如下： class Person { constructor(name) { this._name = name; //{1} } get name() { //{2} return this._name; } set name(value) { //{3} this._name = value; } } let lotrChar = new Person(&apos;Frodo&apos;); console.log(lotrChar.name); //Frodo lotrChar.name = &apos;Gandalf&apos;; console.log(lotrChar.name); //Gandalf lotrChar._name = &apos;Sam&apos;; console.log(lotrChar.name); //Sam //要声明get和set函数，只需要在我们要暴露和使用的函数名前面加上get或set关键字。可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的。 然后，只要像普通的属性一样，引用它们的名字，就可以执行get和set函数。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"认识es6","date":"2018-08-05T11:02:07.000Z","path":"2018/08/05/cjsu6q1i4000qhgvbp5kq24ea/","text":"es6常用api介绍一、let和const命令介绍及区别1. let命令：1）、基本用法： es5只有两种方式声明变量var以及function，es6新增了四种let、const、import、class； let声明的变量的方式与var相似，但是声明的变量，只在let命令所在的代码块中生效; { let a = 1; var b = 2; } console.log(a);//Error in created hook: &quot;ReferenceError: a is not defined&quot; console.log(b);//2 上面在代码块中使用let，var分别声明了连个变量，然后再代码块外面调用，let声明的变量会报错，var声明的 返回值正常，表明let只在它所在的代码块中生效； 2）、let不存在变量提升问题 我们知道使用var声明的变量会存在变量提升问题，但是在let中不存在这种现象 console.log(a);//undefined var a = 1; console.log(b);//报错 let b = 2; 上述代码中，使用let声明了变量b，在声明之前使用会报错，而使用var声明的变量，在使用前值是undefined； 3）、暂时性死区在es6中规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，在声明前使用这些变量就会报错； var a = 1; { a = 3; console.log(a);//报错 let a; } 4）、不允许重复声明let不允许在相同作用域内重复声明同一个变量 // 报错 function fn1() { let a = 1; var a = 2; } // 报错 function fn2() { let a = 1; let a = 2; } function fn3(argements) { let argements; // 也会报错 } es6规定暂时性死区，以及let，const语句不提升变量，主要是为了减少运行时错误，防止在变量声明前就是用这个变量。从而导致意料之外的行为； 1. const命令：const声明一个常量，一旦声明，常量的值就不能改变了，所以const在声明是必须立即初始化，不能留到以后赋值，如果修改它的值会报错 const index = 1; console.log(index)//1 index = 3;// 报错 const num;报错 const声明的常量也不存在变量提升，同样的也是有暂时性死区，也不能重复声明变量 二、块级作用域1、块级作用域的用处在es5中只有全局作用域以及函数作用域，在许多情况下使用很不方便 var num = 1; function f() { console.log(num); if (false) { var num = 2; } } f(); // undefined //在上述代码中在函数内部声明的变量覆盖了外层声明的变量； var index = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 //在for循环中的计数变量会泄露到全局 2、es6中的块级作用域function fn1() { let i = 5; if (true) { let i = 10; } console.log(n); // 5 } //上述代码中存在两个代码块，都声明了变量i，在运行后输出5，说明function声明的代码块不受if(){}代码块的影响 { { {let i = 5}； console.log(i)//报错 } } //let只在当前代码块中生效,其他代码块中是无法使用的，在es6中允许使用作用域的任意嵌套 {{{ let i = 1; {let i = 2};//不报错，不同的作用域中可以声明同一个变量 }}} 3、块级作用域域函数作用域在es5中函数只能在顶层作用域中以及函数作用域中声明，不能再块级作用域中声明，而es6中则可以在块级作用域中声明函数，在块级作用域中声明的函数只在当前作用域中生效，对其他作用域不会造成影响；另外，es6的块级作用域内声明函数必须使用大括号，如果没有会报错 // 不报错 if (true) { function f() {} } // 报错 if (true) function f() {} 三、变量的解构赋值1、数组的解构赋值在es6以前为变量赋值只能指定值 let a = 1; let b = 2; let c = 3; 上述代码在es6中可以住这样写 let [a, b, c] = [1, 2, 3];//a=1,b=2,c=3 //只要等号两边的模式相同，左边的变量就会被赋值对应的值 { let [x, y] = [1, 2, 3] //x=1,y=2 }; { let [x, ,y] = [1, 2, 3] //x=1,y=3 }; { let [x, [y], [z]] = [1, [2], [3]] //x=1,y=2,z=3 }; { let [x, ...y] = [1, 2, 3, 4] //x=1,y=[2,3,4] }; { let [x, y, ...z] = [1] //x=1,y=undefined,z=[] }; 如果结构不成功就会返回undefined { let x = []; //x = undefined; } { let [x, y] = [1] //y =undefined; } 如果等号左边的变量只能匹配等号右边变量的一部分值，这种情况就是不完全解构，但是解构依然会成功； { let [x, y] = [1, 2, 3] //x=1,y=2; } { let [x, [y], z] = [1, [2, 4], 3] //x=1,y=2,z=3; } 如果等号右边不是数组（不可遍历的结构）就会报错 { let [x] = 1; let [y] = false; let [z] = NaN; let [a] = undefined; let [b] = null; let [c] = {}; } 结构赋值允许指定默认值 { let [x = 1] = [];//x = 1 let [i, n = 2] = [1];//i=1,n=2 let [a = 1, b = 2] = [3]//a=3,b=2 } 在es6内部使用严格相等运算符（===），来判断一个位置是否有值，所以只有一个数组成员严格等于undefined默认值才会生效 { let [x = 1] = [undefined] //x=1 let [y = 2] = [null] //y=null,以为null===undefined不成立； } 如果默认是一个表达式，那么这个表达式只有在用到的时候才会求值 { function fn() { console.log(111); } let [x = f()] = [1];//fn不会执行,因为x能取到值1 } 默认值也可以使用解构赋值的其他变量，但是该变量必须先声明 { let [x = 1, y = x] = [] //x= 1;y =2 } { let [x = 1, y = x] = [2] //x=2,y=2 } { let [x = y, y = 1] = [] //报错 y is not defined，因为y还没有声明 } 2、对象的解构赋值对象的结构和数组类似，但是数组的解构按数组的顺序一次取值，而对象是没有顺序的，变量名必须与属性名一直才能取到正确的值； { let {bar, foo} = {foo: 1, bar: 2} //foo:1,bar:2; let {bar1} = {foo1: 1, bar2: 2} //bar1的值为undefined； } 如果变量名与属性名不一致，必须要写成如下形式 { let {foo: foo1} = {foo: 1} //foo1:1 let foo2 = {num1: 10, num2: 20 }; let {num1: f1, num2: f2} = foo2; //f1:10, f2:20; } 变量结构的机制是先找到同名的属性，然后在赋值给对应的变量，如下： { let {bar: foo1} = {bar: 10, bar1: 20} //foo1:10; bar: error: bar is not defined //bar 只是匹配的模式，foo1才是变量，真正被赋值的是变量foo1而不是模式bar } 与数组解构一样对象的解构也可以嵌套 { let foo = { index: [ 10, { y: 20 } ] } let {index:[x, {y}]} = foo;//x:10,y:20 } 对象结构中要注意赋值的是变量，而不是模式，模式只是用来匹配变量的 { let obj = { foo: { index: { num: 1, col: 2 } } } let {foo:{index: {num,col}}} = obj; //num:1, col:2 } 对象的解构也可以指定默认值 { let {x=1} = {} //x=3 } { let {x: y= 1} = {} // y = 3; } { let {x: y= 1} = {null} // y:null; } //和数组一样默认值生效的条件也是严格等于undefined 如果解构失败，变量的值是undefined { let {foo} = {bar: 1} //foo:undefined } 如果解构模式是嵌套的对象，如果子对象所在的父对象不存在，则会报错 { let {foo: {bar}} = {x: 1} //报错 } 解构赋值允许等号左边的模式中，不放置任何变量名，因此如下写法是可以执行的 { ({} = [1, 2]) ({} = &apos;abc) ({} = []) } 也可以对数组进行对象属性的解构 { let arr = [1, 2, 3]; let {0: f1, [arr.length-1]: f2} = arr //f1:1, f2:3 } 2、字符串的解构赋值字符串在解构的时候会被转换成一个类似数组的对象 { let [A, B, C, D] = &apos;abcd&apos;; //A:a,B:b,C:c,D:d; } 3、数值和布尔值的解构赋值数值和布尔值的解构赋值会先转成对象（隐式调用toString方法） { let {toString: s} = 123;//true s === Number.prototype.toString(隐式调用) } { let {toString: s} = true;//true s === Boolean.prototype.toString } { let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError //undefined,null无法转成对象 } 4、函数参数的解构赋值{ function fn([x, y]) { return x + y; } fn([1, 2]);//3 } 函数参数的结解构也可以指定默认值 { function fn({x=3, y=4} = {}) { return [x, y] } fn({x:10, y:20});// [10, 20] fn(); // [3, 4] } 四、圆括号的使用es6对于圆括号的规则是可能导致解构发生歧义，就不能使用圆括号 1、不能使用圆括号的场景(1). 变量的声明赋值 { let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; //上面6个语句都会报错，因为它们都是变量声明语句，模式中不能使用圆括号 } (2). 函数参数 { function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } // 报错 //函数参数也属于变量声明，因此不能带有圆括号。 } (3). 赋值语句的模式 { ({ p: a }) = { p: 42 }; //报错 ([a]) = [5];//报错 } 1、能使用圆括号的场景(1). 赋值语句的非模式部分，可以使用圆括号。 { [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 } 五、函数1、箭头函数的使用在es6中允许使用“箭头”（=&gt;）定义函数 { var f = fn =&gt; v //以上代码等同于 var f = function fn(v) { return v } } 基本语法 { 用法一：参数1（单一参数） =&gt; {函数声明} //一个参数，多个执行语句 用法二：（参数1）（单一参数） =&gt; 表达式（只有一条语句）//单个参数一条执行语句 用法三：(参数1，参数2，... , 参数n) =&gt; {函数声明} //多个参数，多个执行语句 用法四：(参数1，参数2，... , 参数n) =&gt; 表达式（只有一条语句）//相当于(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }//多个参数，一条语句 用法五： () =&gt; {函数声明} //没有参数时使用()代替 } 其他使用 { var f = bar =&gt; ({foo: bar}) console.log(f(1)); //{foo: 1} //箭头函数如果想直接返回一个对象必须在对象外面加()，不然会报错 } { (参数1, 参数2, ...rest) =&gt; {函数声明} (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明} //可以使用默认参数以及剩余参数 } { let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6 //也可以使用解构 } 如果箭头函数不需要参数或者需要多个参数，则使用一个()代表参数部分 { var f1 = () =&gt; x //等同于 var f1 = function() {return x} } { var f1 = (index1, index2) =&gt; index1 + index2; //等同于var f1 = function(index1, index2) {return index1+index2} } 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 { var f1 = (index1, index2) =&gt; { return index1 + index2; } } 2、箭头函数注意点（1）、箭头函数内部的this是固定的，就是定义时所在的对象，而不是使用时调用的对象；（2）、不能当做构造函数使用，如果和new一起使用会抛出错误；（3）、箭头函数内部不存在arguments对象，但是可以用rest参数代替arguments对象；（4）、call 或 apply 调用在箭头函数中不能修改this指针，他们的第一个参数会被忽略（5）、箭头函数没有prototype属性。（6）、箭头函数在参数和箭头之间不能换行。","tags":[{"name":"es6","slug":"es6","permalink":"https://www.23ybob.club/tags/es6/"}]},{"title":"drafting","date":"2018-07-21T06:46:21.000Z","path":"2018/07/21/cjsu6q1gk0000hgvb4f9r5m25/","text":"实现目标div在另一个div中的拖拽效果最近项目中遇到的一个小功能，总结了一下，感觉还不错.github地址： https://github.com/Abriams/js-drafting 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #draft_big &#123; border: 1px solid #FF3300; width: 300px; height: 300px; position: relative; margin-left: 400px; margin-top: 400px; &#125; #draft_small &#123; background: #99CC00; width: 50px; height: 50px; position: absolute; cursor: pointer; right: -80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"draft_big\"&gt; &lt;div id=\"draft_small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=\"javascript\"&gt; window.onload = function () &#123; var draftBig = document.getElementById(\"draft_big\"); var draftSmall = document.getElementById(\"draft_small\"); draftSmall.onmousedown = function (event) &#123; var e = e || window.event; //记录并保存可拖拽div（id为draftSmall的盒子）拖拽前的坐标 var startX = e.clientX - draftSmall.offsetLeft; var startY = e.clientY - draftSmall.offsetTop; // offsetHeight,包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话）; // offsetLeft,目标元素距离最近定位的父级元素左边的距离； // offsetTop,目标元素距离最近定位的父级元素上边的距离； // clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。 // clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的垂直坐标。 /*鼠标的移动事件*/ document.onmousemove = function(e) &#123; //判断被拖拽的盒子（id为draftSmall的盒子）必须拖拽到目标盒子（id为draftBig盒子中）才能移动； if(e.clientX - 400 &lt; draftBig.offsetHeight &amp;&amp; e.clientX &gt; 400) &#123; if(e.clientY -400 &lt; draftBig.offsetWidth &amp;&amp; e.clientY &gt; 400) &#123; var e = e || window.event; //计算当前拖拽的盒子（id为draftSmall的盒子）在目标盒子（id为draftBig盒子）中的坐标； draftSmall.style.left = e.clientX - startX + \"px\"; draftSmall.style.top = e.clientY - startY + \"px\"; /*判断拖拽边界（id为draftSmall的盒子四个边界的判断）*/ if (e.clientX - startX &lt;= 0) &#123; draftSmall.style.left = 0 + \"px\"; &#125; if (e.clientY - startX &lt;= 0) &#123; draftSmall.style.top = 0 + \"px\"; &#125; if (e.clientX - startX &gt;= 250) &#123; draftSmall.style.left = 250 + \"px\"; &#125; if (e.clientY - startX &gt;= 250) &#123; draftSmall.style.top = 250 + \"px\"; &#125; &#125; &#125; &#125;; /*鼠标的抬起事件,终止拖动*/ document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; &#125;; &#125;; &#125;; &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"js实现拖拽","slug":"js实现拖拽","permalink":"https://www.23ybob.club/tags/js实现拖拽/"}]},{"title":"vue slot使用小结","date":"2018-07-14T11:20:30.000Z","path":"2018/07/14/cjsu6q1gz0007hgvbwy5wettz/","text":"一、slot简介在vue实际项目开发当中，我们经常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在Vue中被称为内容分发。在Vue中，slot也分多种，从Vue的官网中可以获知，其主要分为：单个插槽、具名插槽和作用域插槽三种。下面就逐一介绍这三种插槽的用法： 二、slot插槽具体用法2.1单个插槽的使用从官网中（https://cn.vuejs.org/）我们知道，如果子组件template中没有包含任何一个时，就算父组件分发再多的内容也将会被丢弃。如下案例： 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; 父组件slotdemo组件 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图：上图所示在中添加内容并不会显示 只有子组件模板只中拥有一个没有属性的slot（可以有多个带属性的slot，后面的内容会介绍），父组件传入的整个内容片段才会被插入到slot所在的位置，并将替换掉slot本身，如果传入的内容为空则会显示slot的默认内容。如下案例： 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 当派发的内容为空时，会默认显示slot的内容 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.2具名插槽的使用可以用一个特殊的属性name来配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将根据name属性匹配内容片段中有对应slot属性的元素。 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div slot=&quot;header&quot;&gt;新的slotchildrenheader&lt;/div&gt; &lt;div slot=&quot;main&quot;&gt;新的内容&lt;/div&gt; &lt;div&gt;没有name&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt;//如果匹配不到内容显示在这 &lt;/header&gt; &lt;main&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.3作用域插槽的使用作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将prop传递给组件一样： &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;slot :text=&quot;msg&quot;&gt;&lt;/slot&gt;&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;&apos;, data() { return { msg: &quot;slot分发内容&quot;, } }, } &lt;/script&gt; 在父组件中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;template slot-scope=&quot;props&quot;&gt;//作用域模板插槽必须存在 &lt;div&gt;新的slotchildrenheader&lt;/div&gt; &lt;div&gt;新的内容&lt;div&gt;{{props.text}}&lt;/div&gt;&lt;/div&gt; &lt;/template&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图： 三、小结这篇文章主要介绍vue中的插槽的使用方法。只是一个空壳子，他的显示以及如何显示手父组件的控制，插槽显示的位置由子组件自身决定。父组件传过来的模板显示组件的template。使用slot可以帮助我们更容易，灵活的使用组件，同时也提高了组件的复用性。","tags":[{"name":"slot","slug":"slot","permalink":"https://www.23ybob.club/tags/slot/"},{"name":"vue","slug":"vue","permalink":"https://www.23ybob.club/tags/vue/"}]},{"title":"工作中遇到的问题总结","date":"2018-07-04T11:20:30.000Z","path":"2018/07/04/cjsu6q1h1000ahgvbll616yz7/","text":"一、element ui 的使用总结1.1. 自定义验证规则的使用在自定义验证规则的时候每一个判断里（if()else()或者if()else if() else()）都要有callback,否则表单在执行this.$refs[formName].validate((valid) =&gt; {}) 的时候，内部代码是不会执行的； &lt;el-form :model=&quot;ruleForm2&quot; status-icon :rules=&quot;rules2&quot; ref=&quot;ruleForm2&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt; &lt;el-input v-model.number=&quot;ruleForm2.age&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm2&apos;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;resetForm(&apos;ruleForm2&apos;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;script&gt; export default { data() { var checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&apos;年龄不能为空&apos;)); } setTimeout(() =&gt; { if (!Number.isInteger(value)) { callback(new Error(&apos;请输入数字值&apos;)); } else { if (value &lt; 18) { callback(new Error(&apos;必须年满18岁&apos;)); } else { callback();//不能省略，不然无法执行 } } }, 1000); }; var validatePass = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请输入密码&apos;)); } else { if (this.ruleForm2.checkPass !== &apos;&apos;) { this.$refs.ruleForm2.validateField(&apos;checkPass&apos;); } callback(); } }; var validatePass2 = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请再次输入密码&apos;)); } else if (value !== this.ruleForm2.pass) { callback(new Error(&apos;两次输入密码不一致!&apos;)); } else { callback(); } }; return { ruleForm2: { pass: &apos;&apos;, checkPass: &apos;&apos;, age: &apos;&apos; }, rules2: { pass: [ { validator: validatePass, trigger: &apos;blur&apos; } ], checkPass: [ { validator: validatePass2, trigger: &apos;blur&apos; } ], age: [ { validator: checkAge, trigger: &apos;blur&apos; } ] } }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { alert(&apos;submit!&apos;); } else { console.log(&apos;error submit!!&apos;); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); } } } &lt;/script&gt; 1.2移动端ios以及andriod兼容问题1.2.1 ios以及andriod使用overflow: scroll;遇到的问题；页面滚动时使用overflow：scroll;在ios端会出现滑动不流畅问题。 为了解决这个问题，首先我使用了-webkit-overflow-scrolling : touch;这个属性，发现使用这个属性以后，ios页面在滑动到底部或者顶部会出现页面卡死问题，在网上找了好多方法参考这篇文章https://hk.saowen.com/a/ba965995919b5f04ed8bcb7ccc5b4af1e95792e9769fd92a8d36881d1fad8683个人觉得这篇文章写得很好，试了一下这些方法，发现最后还是没有解决，最后发现不要用原生的滚动也就是overflow：scroll;并且阻止ios的默认滑动效果，改为使用better-scroll这个滚动插件完美解决了以上的问题；参考如下案例： &lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;contain-img wrapper&quot; ref=&quot;menuWrapper&quot; v-show=&quot;Show&quot; id=&quot;contain-img&quot;&gt; &lt;ul class=&quot;content&quot; id=&quot;content&quot; ref=&quot;content&quot;&gt; //合同图片显示 &lt;div class=&quot;img01&quot; id=&quot;img01&quot;&gt;&lt;img src=&quot;../../static/img/demo-detail01.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img02&quot;&gt; &lt;img id=&quot;img01&quot; src=&quot;../../static/img/demo-detail02.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;pact-sign&quot; v-show=&quot;isSubmit&quot; @click=&quot;sign()&quot;&gt;提交&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import BScroll from &apos;better-scroll&apos; export default { data() { return { contractImg: &apos;&apos;, isSubmit: true, Show: true } }, created() { this.$nextTick(()=&gt;{ //异步执行 setTimeout(() =&gt; { let containImg = document.getElementById(&quot;img01&quot;).offsetHeight; let bodyHeight = document.body.clientHeight; let distance = bodyHeight-containImg; let scrollHeight = containImg-distance; this.meunScroll=new BScroll(this.$refs.menuWrapper,{});//初始化better-scroll插件 this.meunScroll.scrollTo(0,-scrollHeight); //页面加载完滚动到某个位置 }, 100) }); this.$nextTick(function(){ document.getElementsByTagName(&quot;img&quot;)[0].onload =function() { document.body.addEventListener(&apos;touchmove&apos;, function (e) { e.preventDefault() // 阻止默认的处理方式(阻止下拉滑动的效果) }, {passive: false}) // passive 参数不能省略，用来兼容ios和android } }); }, beforeCreate() { document.title = &apos;签署确认&apos;; }, } &lt;/script&gt; &lt;style scoped&gt; *{ margin: 0; padding: 0; } body, html { height: 100%; width: 100%; background-color: #fff; } .container { width: 100%; height: 100%; } .contain-img { width: 100%; height: 100%; position: absolute; /* overflow: scroll; -webkit-overflow-scrolling : touch; */ } .container img { width: 100%; height: 100%; } .pact-sign { width: 40px; height: 40px; line-height: 40px; position: fixed; bottom: 40px; right: 20px; border-radius: 50%; background-color: #409EFF; text-align: center; color: #ffffff; z-index: 10; } .img01, .img02 { position: relative; overflow: hidden; } &lt;/style&gt; 1.3 prop以及attr的使用使用attr获取checked属性、disabled属性、select属性，如果这些属性默认选中可以取到值，如果未选中值返回undefined，使用prop则可以解决这些问题 官方文档建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()； 1.4 npm打包卡死问题修改为淘宝源：（npm config set registry http://registry.cnpmjs.org）；","tags":[]},{"title":"javascript权威指南理解片一","date":"2018-06-24T09:38:29.000Z","path":"2018/06/24/cjsu6q1gy0006hgvbqqu2pej5/","text":"eval函数eval函数执行另一段javascript代码; eval(&quot;function f() {return x + 1}&quot;); //eval函数只有一个参数，如果参数不是字符串则直接返回这个函数 console.log(eval(11)); //11 //如果参数是字符串则会将字符串当做javascript代码进行编译执行 //并且返回最后一个表达式或语句得值，如果最后一个表达式或语句没有值则返回undefined； //eval使用的作用域是调用他的作用域；如果eval调用了全局函数，则返回的是全局变量的值，如果eval调用了局部函数，他会返回局部变量的值； var geval = eval; var x = &quot;global&quot;, y = &quot;global&quot;; function f() { var x = &quot;local &quot;; eval(&quot;x += &apos;changed&apos;;&quot;) //改变局部变量x的值 return x; } function g() { var y = &quot;local&quot;; geval(&quot;y += &apos; changed&apos;;&quot;); //改变全局变量y的值 return y; } console.log(f(), x); //local changed global console.log(g(), y); //local global changed 三元运算符x &gt; 0 ? x : -x 条件运算符的操作数可以是任意类型，第一个操作符如果是真值，那么返回第二个操作符的结果，如果第一个操作符是假值，则返回第三个操作符的结果； typeof 运算符","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"vuex个人理解","date":"2018-06-14T11:20:30.000Z","path":"2018/06/14/cjsu6q1h2000bhgvbm2q81sd2/","text":"什么是vuex及其作用vuex是一个转为vue.js开发的状态管理模式（如同redux是为react提供的状态管理模式），采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 什么是”状态管理模式”在我看来就是在vue中把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中，以供其他任意组件使用； vuex核心vuex核心就是store仓库，也就是一个容器，在这个容器中存储着vuex应用的状态（state） vuex特点 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 在vuex中你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 vuex案例实现1、将state,mutations,actions写在一起 安装vuex，在命令行执行如下命令（注意点：要加上–save，因为这个包在生产环境中是要使用的） npm install vuex –save 新建store文件夹（名称不唯一），并在store文件夹中新家store.js文件，然后引入vue,以及vuex；代码实现如下 import Vue from ‘vue’; import Vuex from ‘vuex’; 使用vuex，代码如下 Vue.use(Vuex); 通过以上3步vuex就可以使用了，接下来就用一个小案例具体实现 在main.js中引入刚新建的store文件 import store from ‘./store/store’ 在实例化Vue对象中加入store对象 new Vue({ el: &apos;#app&apos;, router, store,//使用store template: &apos;&lt;App/&gt;&apos;, components: { App } }) demo介绍 在store.js定义要使用的对象 const state = { count:1 } 在store.js中加入改变state的方法 //提交state的唯一途径（mutations），state对应上边const state中存储的值； const mutations={ add(state){ state.count++; } } actions提交mutations（actions不能直接提交state，只能通过提交mutations改变state） //提交mutations const actions ={ //Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象 addCount(context){ context.commit(&apos;add&apos;) } } getter获取store中的 state 中派生出的一些状态 getters: { counts: state =&gt; { return state.count - 1 } } 在组建中使用 新建count.vue组建具体代码如下 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;addCount&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; //在组件中通过mapState对象赋值 //首先引入mapState对象&apos;; //然后在computed计算属性里获取值并操作： &lt;script&gt; import {mapState} from &apos;vuex&apos;; export default { computed:mapState({ //理解为传入state对象，修改state.count属性； count:state=&gt;state.count }) } &lt;/script&gt; 2、将state,mutations,actions分开管理1.建立相应目录 src文件夹下新建store文件夹 在store文件夹下新建cart文件夹，index.js文件 在cart文件夹下新建state.js, mutations.js, mutation_type, actions.js, getters.js, index.js 在store文件夹下的index.js问价下添加如下代码 import Vue from ‘vue’; import Vuex from ‘vuex’; Vue.use(Vuex); import cart from ‘./cart/‘; export default new Vuex.Store({ modules: { cart } }); 在cart文件夹下的state.js定义要使用的对象 export default { count: 1, isshow: false, params: &apos;hide&apos; } 在mutations.js问价中改变state.js中的状态 import * as types from ‘./mutations_types’ export default { [types.COUNT_LOCAL](state) { state.count += 1 } , [types.REDUCE_LOCAL](state) { state.count -= 1 } , [types.ISSHOW_LOCAl](state,params) { state.isshow = !state.isshow state.params = &apos;hide&apos; ? &apos;show&apos; : &apos;hide&apos; } } 在mutations_type.js中分离mutations.js，便于后期维护 export const COUNT_LOCAL = ‘COUNT_LOCAL’ export const ISSHOW_LOCAl = ‘ISSHOW_LOCAl’ export const REDUCE_LOCAL = ‘REDUCE_LOCAL’ 在action.js中提交mutations import * as types from ‘./mutations_types’ export default { change_count: ({ commit }) =&gt; { commit(types.COUNT_LOCAL); }, change_isshow: ({ commit },{params}) =&gt; { commit(types.ISSHOW_LOCAl,{params}); }, change_reduce: ({ commit }) =&gt; { commit(types.REDUCE_LOCAL) } } 7.在getters.js中获取state中的派生状态 export default { getCount(state) { return state.count; } }; 在caet文件夹下的index.js中导出数据 import state from ‘./state’; import mutations from ‘./mutations’; import getters from ‘./getters’; import actions from ‘./actions’; export default { state, mutations, getters, actions }; 在组件中使用（使用dispatch提交） &lt;div&gt; &lt;h3&gt;&lt;/h3&gt; &lt;button @click=&quot;change()&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&apos;change_reduce&apos;)&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;getmessage()&quot;&gt;get&lt;/button&gt; &lt;input type=&quot;text&quot; :value=&quot;$store.state.cart.count&quot;&gt; &lt;button @click=&quot;changeShow()&quot; ref=&quot;hide&quot;&gt;hide&lt;/button&gt; &lt;input type=&quot;text&quot; v-show=&quot;show&quot; value=&quot;11&quot;&gt; &lt;/div&gt; &lt;script&gt; import { mapState } from &apos;vuex&apos; export default { data () { return { msg: &apos;Hellow Vuex&apos;, show: false } }, methods: { getmessage() { console.log(this.$store.state.cart.count) }, change() { this.$store.dispatch(&apos;change_count&apos;); }, changeShow() { let ishide = this.$store.state.cart.params; if( ishide == &apos;hide&apos;) { ishide = &apos;show&apos; } else { ishide = &apos;hide&apos; } console.log(ishide); this.$store.dispatch(&apos;change_isshow&apos;,&apos;ishide&apos;) this.show = this.$store.state.cart.isshow this.$refs.hide.innerHTML = this.$store.state.cart.params // console.log(this.$store.state.cart.params) } }, computed: { ...mapState({ count: state =&gt; { console.log(state.count) } }) } } &lt;/script&gt; 小结假如你的项目需要数据 和 组件 分离，分别处理，使用 Vuex 是非常合适的，相反，如果不需要分离处理，那么不使用 Vuex 也没关系。","tags":[{"name":"vuex","slug":"vuex","permalink":"https://www.23ybob.club/tags/vuex/"}]},{"title":"从零开始使用github page + hexo搭建个人博客","date":"2018-05-15T11:20:30.000Z","path":"2018/05/15/cjsu6q1i5000shgvblnuzz4c8/","text":"首先附上我使用hexo搭建的博客：https://23ybob.club/github地址: https://github.com/Abriams/Abriams.github.io 简介：个人刚使用hexo+github page搭建完博客，感觉还是很有成就感，所以把自己的一些在搭建过程中遇到的问题总结了一下，并为大家介绍hexo的详细配置，如何将hexo布置到github上，以及最后绑定域名 写在前面：我是一名前端开发人员，经常都会浏览别人的博客，感觉很高大上，一直以后也希望有一个属于自己的博客，虽然以前也搭建过博客，但是做的不是很精细，博客也没有去维护，最近看了别人的文章感触挺深，所以参考一些资料自己完完全全搭建了一个博客，总体来说很简单，如果你是一名程序开发爱好者，刚好你也想搭建自己的博客，你可以认认真真阅读这篇文章，相信对你搭建博客会有很大帮助 废话不多说，直接开始搭建过程 一、安装搭建必须软件1. 安装node.js(直接去node官网下载自己需要的版本即可，这个应该不用多说了吧)2. 安装git（https://git-scm.com/download/win）2.1安装完成后再命令行输入git version查看是否安装成功如果安装成功鼠标右键就会出现Git GUI Here和Git Bash Here两个按钮，然后选择Git Bash Here即可打开git命令行 1. 安装教程：https://git-scm.com/download/win 2. Git入门教程：http://git.oschina.net/progit/ 3. git常用命令 - git clone仓库地址：将远程仓库clone到本地 - git init ：新建仓库 - git pull： 抓取远程仓库所有分支更新并合并到本地 - git add 文件名或者.：添加新文件 - git commit：提交你的修改 - git push：推送本地仓库更新到远程仓库 二、hexo介绍及安装Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.hexo安装在命令行输入 npm install -g hexo-cli 即可安装hexo安装完hexo还需安装将hexo部署到git page的deployer，在命令行输入 npm install hexo-deployer-git –save 2.使用hexo建立建立需要的文件选择自己要存放文件的目录，右键打开点击Git Bash Here，进入命令行执行 hexo init，安装完以后会在指定文件夹的中新建需要的文件，目录结构如下.git├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themeshexo配置参数可在https://hexo.io/zh-cn/docs/setup.html 中参看 3.执行hexohexo根目录中执行hexo generate 以及 hexo server，并且登录localhost:4000，即可看到本地的效果： 三、将博客布置到github Pages上经过以上步骤我们已经使用hexo搭建了一篇博客，但是我们只能通过本地查看，别人是不能看我们的博客的，所以现在我们需要将本地博客发布到服务器上，让别人也可以访问我们的博客，github Pages就可以帮我们实现这件事情，我们都知道github Pages的代码是保存在github上的所以现在我们需要在github上新建一个项目 1.注册github账号访问github官网： https://github.com/ 点击Sign Up注册自己的账号 2.创建项目代码库新用户点击New repository即可创建github Pages（如果已经创建过github Pages，点击github + 弹出新建github Pages主页，示例如下） 在弹出的github Pages主页中填写需要的内容 3.配置SSH密钥Github的SSH密钥可以使本地git项目与远程的github建立联系，这样我们就能将本地代码通过git操作实现与Github库的代码同步，具体操作如下： 1). 查看本机是否已经存在 SSH密钥（keys）打开git命令行（可在任一位置打开）运行 cd ~/. ssh 检查本机用户home目录下是否存在.ssh目录，如果，不存在此目录，则进行2).操作，否则，你本机已经存在ssh公钥和私钥，可以略过2).步，直接进入3).操作 2). 创建SSH密钥（keys）$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;（按照你提供的邮箱地址，创建一对密钥） 直接回车，会将密钥按默认文件进行存储当然了你也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 然后按照提示需要输入密码以及确认密码（一般其实也很安全，不需要密码，直接回车即可） 最后，输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 3). 在github中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。（运行完成后直接右键赋值即可 ） clip &lt; ~/.ssh/id_rsa.pub 3.1 登录github登录github进入Setting，如下图所示 3.2 选择SSH and GPG keys选择SSH and GPG keys，如下图所示 3.2 选择New SSH key点击右上角New SSH key即可添加 3.3 粘贴密钥将密钥粘贴在下方文本框中，如图 3.4 测试密钥输入下方命令，查看是否成功 ssh -T git@github.com 如果是如下所示，输入yes回车即可 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 3.5 设置用户信息现在已经通过SSH链接到了Github，但是git是根据用户的名字和邮箱来提交的，github也是用名字和邮箱处理权限的，为了方便可以使用如下命令设置自己的 邮箱和名字 git config --global user.name &quot;ryanlijianchang&quot;//用户名 git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 此时，SSH key已经配置成功，本机成功连接到github 四. 将hexo更新到github上4.1 打开github pages登录自己的github，选择刚才新建的github pages （Amriams/Amriams.github.io） 4.2 获取SSH类型地址进去页面选择clone or download， 再选择Use SSH，复制SSH密钥 4.3 配置hexo连接SSH打开新建的hexo根目录下的_config.yml文件 4.3 配置SSH在打开的文件里添加配置 deploy: type: git repository: git@github.com:Abriams/Abriams.github.io.git branch: master 如图： 4.4 将本地hexo代码布置到github上执行 hexo g -d 即可 执行时会让你输入github账号以及密码，输入完成后，回车即可在github pages服务器上访问我们的博客了，对应的地址就是username.github.io（我的博客是Abriams.github.io） 如果在上述执行过程中出现 ERROR Deployer not found: git，这个提示是你的deployer没有安装成功，所以需要安装 执行npm install hexo-deployer-git –save， 然后在执行hexo g -d就可将博客部署到github pages 上了 4.5 访问自己的博客访问https://Abriams.github.io就可看到自己的博客啦（https://您的用户名.github.io） 4.6 美化博客进入hexo官网https://hexo.io/themes/选择自己喜欢的主题即可 选择好主题后再打开Hexo文件夹下的themes目录（E:\\hexo\\BIOG\\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 等待下载完成后，打开Hexo文件夹下的配置文件_config.yml，修改参数为：theme: hexo-theme-next 然后依次执行 hexo g ， hexo s，打开浏览器，输入 http://localhost:4000/ 即可看见刚更新的主题啦。 更多hexo配置请在hexo官网https://hexo.io/zh-cn/docs/configuration.html查看详情 4.7部署新内容到github打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 执行完成后访问https://您的用户名.github.io即可 五. 使用hexo写博客首先新建文件 hexo n “文章标题” ，执行完成后会在项目E:\\hexo\\BIOG\\source_posts中生成 文章标题.md文件，当然，也可以直接在\\Hexo\\source_posts中新建一个md文件，然后使用markdown书写文章即可，文章完成后使用执行hexo g（生成）， hexo d（部署），就会将文章部署到github上 六.在hexo中华添加图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，（上传本地图片的插件） 3 等待一段时间后，再运行hexo n “xxxx”来生成md文件时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 七、将独立域名关联到github pages上1. 购买域名选择自己喜欢的域名购买即可，我是在腾讯云购买的一下一腾讯云为例https://cloud.tencent.com/?fromSource=gwzcw.234976.234976.234976 2. 配置域名域名买好后在https://console.qcloud.com/domain/mydomain 中管理自己的域名 进去我的域名页面点击解析，如下图 选择添加记录，添加即可，如下图 然后打开github pages你的项目，选择Settings 下拉到github pages设置添加域名 八.hexo中添加标签选项1 生成“标签页”并添加type属性打开命令行执行如下命令 hexo new page tags 成功后会提示INFO Created: ~/Documents/blog/source/tags/index.md 找到blog/source/tags/index.md的文件并添加type: “tags”如下所示： --- title: 文章分类 date: 2017-05-27 13:47:40 type: &quot;tags&quot; --- 2 给文章添加”tags”属性打开需要添加标签的文章，并添加tags属性，如下（tags后的- vuex就是标签内容） --- title: vuex个人理解 tags: - vuex --- 注意：只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 九.添加微博秀首先获取在微博上获取微博秀 &lt;iframe width=&quot;100%&quot; height=&quot;550&quot; class=&quot;share_self&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1&quot;&gt;&lt;/iframe&gt; 找到BIOG/themes/BlueLake/layout/_widget/weibo.jade文件将src=””里面的内容换成微博秀src=””里面的内容 然后找到跟目录下的_config.yml文件，将widgets:添加- weibo 如下： widgets: - recent_posts - category - tag - archive - weibo - links 注意：如果网站使用的是https协议，需要将微博秀中的http换成https即可； 10.设置百度分享（https）首先下载百度分享的文件 https://themebetter.com/uploads/2017/09/static.zip （解压码：themebetter）；将下载后的文件放到主题文件夹下的source文件夹下 修改百度分享代码：在主题文件夹下的layout/_partial/comment_js.jade 下全局搜索http://bgimg.share.baidu.com并去掉http://bgimg.share.baidu.com即可； window._bd_share_config={&quot;common&quot;:{&quot;bdSnsKey&quot;:{},&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;2&quot;,&quot;bdMiniList&quot;:[&quot;mshare&quot;,&quot;weixin&quot;,&quot;tsina&quot;,&quot;qzone&quot;,&quot;linkedin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;print&quot;,&quot;renren&quot;,&quot;sqq&quot;,&quot;evernotecn&quot;,&quot;bdysc&quot;,&quot;tqq&quot;,&quot;tqf&quot;,&quot;bdxc&quot;,&quot;kaixin001&quot;,&quot;tieba&quot;,&quot;douban&quot;,&quot;bdhome&quot;,&quot;thx&quot;,&quot;ibaidu&quot;,&quot;meilishuo&quot;,&quot;mogujie&quot;,&quot;diandian&quot;,&quot;huaban&quot;,&quot;duitang&quot;,&quot;hx&quot;,&quot;fx&quot;,&quot;youdao&quot;,&quot;sdo&quot;,&quot;qingbiji&quot;,&quot;people&quot;,&quot;xinhua&quot;,&quot;mail&quot;,&quot;isohu&quot;,&quot;yaolan&quot;,&quot;wealink&quot;,&quot;ty&quot;,&quot;iguba&quot;,&quot;h163&quot;,&quot;copy&quot;],&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;1&quot;,&quot;bdSize&quot;:&quot;16&quot;},&quot;share&quot;:{},&quot;image&quot;:{&quot;viewList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;],&quot;viewText&quot;:&quot;分享到：&quot;,&quot;viewSize&quot;:&quot;16&quot;},&quot;selectShare&quot;:{&quot;bdContainerClass&quot;:null,&quot;bdSelectMiniList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;]}};with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||head).appendChild(createElement(&apos;script&apos;)).src=&apos;http://bgimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)] //执行完上面几部发现请求的百度分享地址已经替换成了本地，但是在控制台会报错；这是hexo编译了static文件夹导致的； 最后修改根目录下的—_config.yml文件 找到skip_render并添加static/** ，如下所示 skip_render: static/** //防止hexo编译static文件导致报错； 小结：通过以上操作，一篇博客终于搭建成功了，虽然在搭建的过程中会遇到各种问题，这需要我们耐心解决，当所有问题都完成后，我个人收货到了很大成果，也希望各位小伙伴能有自己的收获，另外，既然博客搭建成功了，那么就一定要坚持下去，不需要每天都写，但是每个月写自己的总结心得，总是不过分的吧","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.23ybob.club/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://www.23ybob.club/tags/github-pages/"}]},{"title":"初识前端","date":"2018-05-06T11:20:30.000Z","path":"2018/05/06/cjsu6q1gs0002hgvbg25f6hvl/","text":"个人对前端的理解前端发展1.什么是前端虽然是做前端的，但是具体概念还真不知道，个人感觉就是写页面，渲染数据 2.前端演进史2.1.从静态走向动态大约1994就是前端发展的历史吧，前端都知道1943年10月13日网景公司推出了第一版Navigator；Tim Berners-Lee创建了W3C；Tim的基友发布了CSS。同样在这一年，为动态web网页设计的服务端脚本PHP诞生。 早期网页都是为了方便科学家看文章，传论文而制造的，这也就是为什么Web网页都基于Document，随着网页技术从学术机构走向社会，网页承载的功能已经不足以满足当前需求，因此早期网页的局限性也显示出来了 2.1.1 所有的网页都基于HTML页面，因为没有任何手段可以控制局部内容的显示和隐藏，因此任何局部的变化哪怕只多出一个标点符号，都只能重新下载一个新的页面。2.1.2 计算任务只能在服务端实现。由于网速限制，与服务器通信的过程是非常缓慢的，并且此过程是同步阻塞的，于是会出现这样的场景：用户提交一个表单，然后整个页面消失，浏览器呈现白屏，经过漫长的等待，浏览器渲染出一个和之前一模一样的页面，只不过输入框旁边多了一排红色小字：用户名错误。2.1.3 所有页面都是静态的，这意味着一个电商网站有一千种商品，哪怕页面布局一模一样，也必须写一千个单独的页面。1994年Rasmus Lerdorf为了维护个人网站而创建了PHP，PHP实现了与数据库的交互以及用于生产动态页面的模板引擎，是Web领域中最主流的服务端语言。 1995年网景推出了JavaScript，实现了客户端的计算任务（如表单验证）。 1996年微软推出了iframe标签，实现了异步的局部加载。 1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。 2006年，XMLHttpRequest被W3C正式纳入标准。 至此，早期的Document终于进化为了Web page，早期网页的三个局限都得到了妥善的解决。 2.2从后端走向前端早期网页都是有后端主导的，前端也就只是操作dom，2006年 John Resig发布了jQuery，主要用于操作DOM 起初制约Web开发从后到前的因素很简单，就是前端很多事干不了或干不好，当时的浏览器性能弱，标准化程度低，2008年问世的谷歌V8引擎改变了这一局面，现代浏览器的崛起终结了微软的垄断时代 ECMA也在2009年发布了第五代JavaScript 2009年AngularJS诞生，随后被谷歌收购。 2010年backbone.js诞生。 2011年React和Ember诞生。 2014年Vue.js诞生……前后端分离可谓大势所趋。 参考： Web开发的发展史http://blog.jobbole.com/45169/ https://www.cnblogs.com/leolovexx/p/7249314.html","tags":[{"name":"前端历史","slug":"前端历史","permalink":"https://www.23ybob.club/tags/前端历史/"}]}]