[{"title":"javascript设计模式与开发实践十三（职责链模式）","date":"2019-06-26T11:00:20.000Z","path":"2019/06/26/cjxe4h6ok001a6sup3emenbqo/","text":"职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点，如图 13-1所示。 一、 现实中的职责链模式职责链模式的例子在现实中并不难找到，以下就是两个常见的跟职责链模式有关的场景。 如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在 N 个人手上传递，才能最终到达售票员的手里。 中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他就会把这张小纸条继续递给他后面的人。 从这两个例子中，我们很容易找到职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。如果不使用职责链模式，那么在公交车上，我就得先搞清楚谁是售票员，才能把硬币递给他。同样，在期末考试中，也许我就要先了解同学中有哪些可以解答这道题。 二、 实际开发中的职责链模式假设我们负责一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预定后（订单已在此时生成），现在已经到了正式购买的阶段。 公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过 500 元定金的用户会收到 100 元的商城优惠券，200 元定金的用户可以收到 50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。 我们的订单页面是 PHP 吐出的模板，在页面加载之初，PHP 会传递给页面几个字段。 orderType：表示订单类型（定金用户或者普通购买用户），code 的值为 1 的时候是 500 元定金用户，为 2 的时候是 200 元定金用户，为 3 的时候是普通购买用户。 pay：表示用户是否已经支付定金，值为 true 或者 false, 虽然用户已经下过 500 元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。 stock：表示当前用于普通购买的手机库存数量，已经支付过 500 元或者 200 元定金的用户不受此限制。 下面我们把这个流程写成代码： 123456789101112131415161718192021222324252627282930var order = function (orderType, pay, stock) &#123; if (orderType === 1) &#123; // 500 元定金购买模式 if (pay === true) &#123; // 已支付定金 console.log('500 元定金预购, 得到 100 优惠券'); &#125; else &#123; // 未支付定金，降级到普通购买模式 if (stock &gt; 0) &#123; // 用于普通购买的手机还有库存 console.log('普通购买, 无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125; &#125; else if (orderType === 2) &#123; // 200 元定金购买模式 if (pay === true) &#123; console.log('200 元定金预购, 得到 50 优惠券'); &#125; else &#123; if (stock &gt; 0) &#123; console.log('普通购买, 无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125; &#125; else if (orderType === 3) &#123; if (stock &gt; 0) &#123; console.log('普通购买, 无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125;&#125;;order(1, true, 500); // 输出： 500 元定金预购, 得到 100 优惠券 虽然我们得到了意料中的运行结果，但这远远算不上一段值得夸奖的代码。order 函数不仅巨大到难以阅读，而且需要经常进行修改。虽然目前项目能正常运行，但接下来的维护工作无疑是个梦魇。恐怕只有最“新手”的程序员才会写出这样的代码。 三、 用职责链模式重构代码现在我们采用职责链模式重构这段代码，先把 500 元订单、200 元订单以及普通购买分成 3个函数。 接下来把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下： 123456789101112131415161718192021222324252627282930// 500 元订单var order500 = function (orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元定金预购, 得到 100 优惠券'); &#125; else &#123; order200(orderType, pay, stock); // 将请求传递给 200 元订单 &#125;&#125;;// 200 元订单var order200 = function (orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200 元定金预购, 得到 50 优惠券'); &#125; else &#123; orderNormal(orderType, pay, stock); // 将请求传递给普通订单 &#125;&#125;;// 普通购买订单var orderNormal = function (orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log('普通购买, 无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125;&#125;;// 测试结果：order500(1, true, 500); // 输出：500 元定金预购, 得到 100 优惠券order500(1, false, 500); // 输出：普通购买, 无优惠券order500(2, true, 500); // 输出：200 元定金预购, 得到 500 优惠券order500(3, false, 500); // 输出：普通购买, 无优惠券order500(3, false, 0); // 输出：手机库存不足 可以看到，执行结果和前面那个巨大的 order 函数完全一样，但是代码的结构已经清晰了很多，我们把一个大函数拆分了 3 个小函数，去掉了许多嵌套的条件分支语句。 目前已经有了不小的进步，但我们不会满足于此，虽然已经把大函数拆分成了互不影响的 3个小函数，但可以看到，请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函数之中： 12345678var order500 = function( orderType, pay, stock )&#123; if ( orderType === 1 &amp;&amp; pay === true )&#123; console.log( '500 元定金预购, 得到 100 优惠券' ); &#125;else&#123; order200( orderType, pay, stock ); // order200 和 order500 耦合在一起 &#125;&#125;; 这依然是违反开放封闭原则的，如果有天我们要增加 300 元预订或者去掉 200 元预订，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须得先砸烂这根链条。 四、 灵活可拆分的职责链节点本节我们采用一种更灵活的方式，来改进上面的职责链模式，目标是让链中的各个节点可以灵活拆分和重组。 首先需要改写一下分别表示 3 种购买模式的节点函数，我们约定，如果某个节点不能处理请求，则返回一个特定的字符串 ‘nextSuccessor’来表示该请求需要继续往后面传递： 123456789101112131415161718192021var order500 = function (orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元定金预购，得到 100 优惠券'); &#125; else &#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125;&#125;;var order200 = function (orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200 元定金预购，得到 50 优惠券'); &#125; else &#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125;&#125;;var orderNormal = function (orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log('普通购买，无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125;&#125;; 接下来需要把函数包装进职责链节点，我们定义一个构造函数 Chain，在 new Chain 的时候传递的参数即为需要被包装的函数，同时它还拥有一个实例属性 this.successor，表示在链中的下一个节点。 此外 Chain 的 prototype 中还有两个函数，它们的作用如下所示： 12345678910111213141516// Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点var Chain = function (fn) &#123; this.fn = fn; this.successor = null;&#125;;Chain.prototype.setNextSuccessor = function (successor) &#123; return this.successor = successor;&#125;;Chain.prototype.passRequest = function () &#123; var ret = this.fn.apply(this, arguments); if (ret === 'nextSuccessor') &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments); &#125; return ret;&#125;; 现在我们把 3 个订单函数分别包装成职责链的节点： 123var chainOrder500 = new Chain( order500 );var chainOrder200 = new Chain( order200 );var chainOrderNormal = new Chain( orderNormal ); 然后指定节点在职责链中的顺序： 12chainOrder500.setNextSuccessor( chainOrder200 );chainOrder200.setNextSuccessor( chainOrderNormal ); 最后把请求传递给第一个节点： 1234chainOrder500.passRequest( 1, true, 500 ); // 输出：500 元定金预购，得到 100 优惠券chainOrder500.passRequest( 2, true, 500 ); // 输出：200 元定金预购，得到 50 优惠券chainOrder500.passRequest( 3, true, 500 ); // 输出：普通购买，无优惠券chainOrder500.passRequest( 1, false, 0 ); // 输出：手机库存不足 通过改进，我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员又想出了支持 300 元定金购买，那我们就在该链中增加一个节点即可： 123456var order300 = function()&#123; // 具体实现略&#125;;chainOrder300= new Chain( order300 );chainOrder500.setNextSuccessor( chainOrder300);chainOrder300.setNextSuccessor( chainOrder200); 对于程序员来说，我们总是喜欢去改动那些相对容易改动的地方，就像改动框架的配置文件远比改动框架的源代码简单得多。在这里完全不用理会原来的订单函数代码，我们要做的只是增加一个节点，然后重新设置链中相关节点的顺序。 五、 异步的职责链在上一节的职责链模式中，我们让每个节点函数同步返回一个特定的值”nextSuccessor”，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个 ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中 passRequest。 这时候让节点函数同步返回”nextSuccessor”已经没有意义了，所以要给 Chain 类再增加一个原型方法 Chain.prototype.next，表示手动传递请求给职责链中的下一个节点： 123Chain.prototype.next= function()&#123; return this.successor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments );&#125;; 来看一个异步职责链的例子： 12345678910111213141516var fn1 = new Chain(function () &#123; console.log(1); return 'nextSuccessor';&#125;);var fn2 = new Chain(function () &#123; console.log(2); var self = this; setTimeout(function () &#123; self.next(); &#125;, 1000);&#125;);var fn3 = new Chain(function () &#123; console.log(3);&#125;);fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);fn1.passRequest(); 现在我们得到了一个特殊的链条，请求在链中的节点里传递，但节点有权利决定什么时候把请求交给下一个节点。可以想象，异步的职责链加上命令模式（把 ajax 请求封装成命令对象，详情请参考第 9 章），我们可以很方便地创建一个异步 ajax 队列库。 六、 职责链模式的优缺点前面已经说过，职责链模式的最大优点就是解耦了请求发送者和 N 个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可，如图 13-2 和图 13-3 所示。 用职责链模式改进后： 在手机商城的例子中，本来我们要被迫维护一个充斥着条件分支语句的巨大的函数，在例子里的购买过程中只打印了一条 log 语句。其实在现实开发中，这里要做更多事情，比如根据订单种类弹出不同的浮层提示、渲染不同的 UI 节点、组合不同的参数发送给不同的 cgi 等。 用了职责链模式之后，每种订单都有各自的处理函数而互不影响。 在手机商城的例子中，本来我们要被迫维护一个充斥着条件分支语句的巨大的函数，在例子里的购买过程中只打印了一条 log 语句。其实在现实开发中，这里要做更多事情，比如根据订单种类弹出不同的浮层提示、渲染不同的 UI 节点、组合不同的参数发送给不同的 cgi 等。 用了职责链模式之后，每种订单都有各自的处理函数而互不影响。 职责链模式还有一个优点，那就是可以手动指定起始节点，请求并不是非得从链中的第一个节点开始传递。比如在公交车的例子中，如果我明确在我前面的第一个人不是售票员，那我当然可以越过他把公交卡递给他前面的人，这样可以减少请求在链中的传递次数，更快地找到合适的请求接受者。这在普通的条件分支语句下是做不到的，我们没有办法让请求越过某一个 if 判断。 拿代码来证明这一点，假设某一天网站中支付过定金的订单已经全部结束购买流程，我们在接下来的时间里只需要处理普通购买订单，所以我们可以直接把请求交给普通购买订单节点： orderNormal.passRequest( 1, false, 500 ); // 普通购买, 无优惠券 如果运用得当，职责链模式可以很好地帮助我们组织代码，但这种模式也并非没有弊端，首先我们不能保证某个请求一定会被链中的节点处理。比如在期末考试的例子中，小纸条上的题目也许没有任何一个同学知道如何解答，此时的请求就得不到答复，而是径直从链尾离开，或者抛出一个错误异常。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。 另外，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链带来的性能损耗。 七、 用 AOP 实现职责链在之前的职责链实现中，我们利用了一个 Chain 类来把普通函数包装成职责链的节点。其实利用 JavaScript 的函数式特性，有一种更加方便的方法来创建职责链。 下面我们改写一下 前面节 Function.prototype.after 函数，使得第一个函数返回’nextSuccessor’时，将请求继续传递给下一个函数，无论是返回字符串’nextSuccessor’或者 false 都只是一个约定，当然在这里我们也可以让函数返回 false 表示传递请求，选择’nextSuccessor’字符串是因为它看起来更能表达我们的目的，代码如下： 1234567891011121314Function.prototype.after = function( fn )&#123; var self = this; return function()&#123; var ret = self.apply( this, arguments ); if ( ret === 'nextSuccessor' )&#123; return fn.apply( this, arguments ); &#125; return ret; &#125;&#125;;var order = order500yuan.after( order200yuan ).after( orderNormal );order( 1, true, 500 ); // 输出：500 元定金预购，得到 100 优惠券order( 2, true, 500 ); // 输出：200 元定金预购，得到 50 优惠券order( 1, false, 500 ); // 输出：普通购买，无优惠券 用 AOP 来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能有较大的影响。 八、 用职责链模式获取文件上传对象在第 7 节有一个用迭代器获取文件上传对象的例子：当时我们创建了一个迭代器来迭代获取合适的文件上传对象，其实用职责链模式可以更简单，我们完全不用创建这个多余的迭代器，完整代码如下： 12345678910111213141516171819var getActiveUploadObj = function () &#123; try &#123; return new ActiveXObject(\"TXFTNActiveX.FTNUpload\"); // IE 上传控件 &#125; catch (e) &#123; return 'nextSuccessor'; &#125;&#125;;var getFlashUploadObj = function () &#123; if (supportFlash()) &#123; var str = '&lt;object type=\"application/x-shockwave-flash\"&gt;&lt;/object&gt;'; return $(str).appendTo($('body')); &#125; return 'nextSuccessor';&#125;;var getFormUpladObj = function () &#123; return $('&lt;form&gt;&lt;input name=\"file\" type=\"file\"/&gt;&lt;/form&gt;').appendTo($('body'));&#125;;var getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUpladObj);console.log(getUploadObj()); 九、 小结在 JavaScript 开发中，职责链模式是最容易被忽视的模式之一。实际上只要运用得当，职责链模式可以很好地帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点。 无论是作用域链、原型链，还是 DOM 节点中的事件冒泡，我们都能从中找到职责链模式的影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率。学会使用职责链模式，相信在以后的代码编写中，将会对你大有裨益。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践十二（享元模式）","date":"2019-06-17T10:55:20.000Z","path":"2019/06/17/cjxe4h6pq001m6sup4x81u0p4/","text":"享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。 享元模式的概念初听起来并不太好理解，所以在深入讲解之前，我们先看一个例子。 一、 初识享元模式假设有个内衣工厂，目前的产品有 50 种男式内衣和 50 种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。 正常情况下需要 50 个男模特和 50 个女模特，然后让他们每人分别穿上一件内衣来拍照。不使用享元模式的情况下，在程序里也许会这样写： 123456789101112131415var Model = function (sex, underwear) &#123; this.sex = sex; this.underwear = underwear;&#125;;Model.prototype.takePhoto = function () &#123; console.log('sex= ' + this.sex + ' underwear=' + this.underwear);&#125;;for (var i = 1; i &lt;= 50; i++) &#123; var maleModel = new Model('male', 'underwear' + i); maleModel.takePhoto();&#125;;for (var j = 1; j &lt;= 50; j++) &#123; var femaleModel = new Model('female', 'underwear' + j); femaleModel.takePhoto();&#125;; 要得到一张照片，每次都需要传入 sex 和 underwear 参数，如上所述，现在一共有 50 种男内衣和 50 种女内衣，所以一共会产生 100 个对象。如果将来生产了 10000 种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。 下面我们来考虑一下如何优化这个场景。虽然有 100 种内衣，但很显然并不需要 50 个男模特和 50 个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照。 现在来改写一下代码，既然只需要区别男女模特，那我们先把 underwear 参数从构造函数中移除，构造函数只接收 sex 参数： 12345678910111213141516171819var Model = function (sex) &#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function () &#123; console.log('sex= ' + this.sex + ' underwear=' + this.underwear);&#125;;//分别创建一个男模特对象和一个女模特对象：var maleModel = new Model('male'), femaleModel = new Model('female');//给男模特依次穿上所有的男装，并进行拍照：for (var i = 1; i &lt;= 50; i++) &#123; maleModel.underwear = 'underwear' + i; maleModel.takePhoto();&#125;;//同样，给女模特依次穿上所有的女装，并进行拍照：for (var j = 1; j &lt;= 50; j++) &#123; femaleModel.underwear = 'underwear' + j; femaleModel.takePhoto();&#125;; 可以看到，改进之后的代码，只需要两个对象便完成了同样的功能。 二、 内部状态与外部状态12.1 节的这个例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。 内部状态存储于对象内部。 内部状态可以被一些对象共享。 内部状态独立于具体的场景，通常不会改变。 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并储存在外部。 剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。 在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要 2 个对象。 使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常被划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，模特的性别就可以作为内部状态储存在共享对象的内部。而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。 三、 享元模式的通用结构前面的示例初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中还存在以下两个问题。 我们通过构造函数显式 new 出了男女两个 model 对象，在其他系统中，也许并不是一开始就需要所有的共享对象。 给 model 对象手动设置了 underwear 外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。 我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。 四、 文件上传的例子在微云上传模块的开发中，我们曾经借助享元模式提升了程序的性能。下面我们就讲述这个例子。 4.1 对象爆炸在微云上传模块的开发中，存在对象爆炸的问题。微云的文件上传功能虽然可以选择依照队列，一个一个地排队上传，但也支持同时选择 2000 个文件。每一个文件都对应着一个JavaScript 上传对象的创建，在第一版开发中，的确往程序里同时 new 了 2000 个 upload 对象，结果可想而知，Chrome 中还勉强能够支撑，IE 下直接进入假死状态。 微云支持好几种上传方式，比如浏览器插件、Flash 和表单上传等，为了简化例子，我们先假设只有插件和 Flash 这两种。不论是插件上传，还是 Flash 上传，原理都是一样的，当用户选择了文件之后，插件和 Flash 都会通知调用 Window 下的一个全局 JavaScript 函数，它的名字是startUpload，用户选择的文件列表被组合成一个数组 files 塞进该函数的参数列表里，代码如下： 1234567var id = 0;window.startUpload = function (uploadType, files) &#123; // uploadType 区分是控件还是 flash for (var i = 0, file; file = files[i++];) &#123; var uploadObj = new Upload(uploadType, file.fileName, file.fileSize); uploadObj.init(id++); // 给 upload 对象设置一个唯一的 id &#125;&#125;; 当用户选择完文件之后，startUpload 函数会遍历 files 数组来创建对应的 upload 对象。接下来定义 Upload 构造函数，它接受 3 个参数，分别是插件类型、文件名和文件大小。这些信息都已经被插件组装在 files 数组里返回，代码如下： 123456789101112131415161718var Upload = function (uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null;&#125;;Upload.prototype.init = function (id) &#123; var that = this; this.id = id; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt;文件名称:' + this.fileName + ', 文件大小: ' + this.fileSize + '&lt;/span&gt;' + '&lt;button class=\"delFile\"&gt;删除&lt;/button&gt;'; this.dom.querySelector('.delFile').onclick = function () &#123; that.delFile(); &#125; document.body.appendChild(this.dom);&#125;; 同样为了简化示例，我们暂且去掉了 upload 对象的其他功能，只保留删除文件的功能，对应的方法是 Upload.prototype.delFile。该方法中有一个逻辑：当被删除的文小于 3000 KB 时，该文同样为了简化示例，我们暂且去掉了 upload 对象的其他功能，只留删除文件的功能，对应的方法是 Upload.prototype.delFile。该方法中有一逻辑：当被删除的文件小于 3000 KB 时，该文件将被直接删除。否则页面中会弹出一个提示框，提示用户是否确认要删除该文件，代码如下： 12345678Upload.prototype.delFile = function () &#123; if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm('确定要删除该文件吗? ' + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;; 接下来分别创建 3 个插件上传对象和 3 个 Flash 上传对象： 12345678910111213141516171819202122232425262728startUpload('plugin', [ &#123; fileName: '1.txt', fileSize: 1000 &#125;, &#123; fileName: '2.html', fileSize: 3000 &#125;, &#123; fileName: '3.txt', fileSize: 5000 &#125;]);startUpload('flash', [ &#123; fileName: '4.txt', fileSize: 1000 &#125;, &#123; fileName: '5.html', fileSize: 3000 &#125;, &#123; fileName: '6.txt', fileSize: 5000 &#125;]); 当点击删除最后一个文件时，可以看到弹出了是否确认删除的提示。 4.2 享元模式重构文件上传上一节的代码是第一版的文件上传，在这段代码里有多少个需要上传的文件，就一共创建了多少个 upload 对象，接下来我们用享元模式重构它。 首先，我们需要确认插件类型 uploadType 是内部状态，那为什么单单 uploadType 是内部状态呢？前面讲过，划分内部状态和外部状态的关键主要有以下几点。 内部状态储存于对象内部。 内部状态可以被一些对象共享。 内部状态独立于具体的场景，通常不会改变。 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 在文件上传的例子里，upload 对象必须依赖 uploadType 属性才能工作，这是因为插件上传、Flash 上传、表单上传的实际工作原理有很大的区别，它们各自调用的接口也是完全不一样的，必须在对象创建之初就明确它是什么类型的插件，才可以在程序的运行过程中，让它们分别调用各自的 start、pause、cancel、del 等方法。 实际上在微云的真实代码中，虽然插件和 Flash 上传对象最终创建自一个大的工厂类，但它们实际上根据 uploadType 值的不同，分别是来自于两个不同类的对象。（在目前的例子中，为了简化代码，我们把插件和 Flash 的构造函数合并成了一个。） 一旦明确了 uploadType，无论我们使用什么方式上传，这个上传对象都是可以被任何文件共用的。而 fileName 和 fileSize 是根据场景而变化的，每个文件的 fileName 和 fileSize 都不一样，fileName 和 fileSize 没有办法被共享，它们只能被划分为外部状态。 4.3 剥离外部状态明确了 uploadType 作为内部状态之后，我们再把其他的外部状态从构造函数中抽离出来，Upload 构造函数中只保留 uploadType 参数： 123 var Upload = function (uploadType) &#123; this.uploadType = uploadType;&#125;; Upload.prototype.init 函数也不再需要，因为 upload 对象初始化的工作被放在了 uploadManager.add函数里面，接下来只需要定义 Upload.prototype.del 函数即可： 123456789Upload.prototype.delFile = function (id) &#123; uploadManager.setExternalState(id, this); // (1) if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm('确定要删除该文件吗? ' + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;; 在开始删除文件之前，需要读取文件的实际大小，而文件的实际大小被储存在外部管理器uploadManager 中，所以在这里需要通过 uploadManager.setExternalState 方法给共享对象设置正确的 fileSize，上段代码中的(1)处表示把当前 id 对应的对象的外部状态都组装到共享对象中。 4.4 工厂进行对象实例化接下来定义一个工厂来创建 upload 对象，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象，否则创建一个新的对象： 1234567891011var UploadFactory = (function () &#123; var createdFlyWeightObjs = &#123;&#125;; return &#123; create: function (uploadType) &#123; if (createdFlyWeightObjs[uploadType]) &#123; return createdFlyWeightObjs[uploadType]; &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125;&#125;)(); 4.5 管理器封装外部状态现在我们来完善前面提到的 uploadManager 对象，它负责向 UploadFactory 提交创建对象的请求，并用一个 uploadDatabase 对象保存所有 upload 对象的外部状态，以便在程序运行过程中给upload 共享对象设置外部状态，代码如下： 12345678910111213141516171819202122232425262728var uploadManager = (function()&#123; var uploadDatabase = &#123;&#125;; return &#123; add: function( id, uploadType, fileName, fileSize )&#123; var flyWeightObj = UploadFactory.create( uploadType ); var dom = document.createElement( 'div' ); dom.innerHTML = '&lt;span&gt;文件名称:'+ fileName +', 文件大小: '+ fileSize +'&lt;/span&gt;' + '&lt;button class=\"delFile\"&gt;删除&lt;/button&gt;'; dom.querySelector( '.delFile' ).onclick = function()&#123; flyWeightObj.delFile( id ); &#125; document.body.appendChild( dom ); uploadDatabase[ id ] = &#123; fileName: fileName, fileSize: fileSize, dom: dom &#125;; return flyWeightObj ; &#125;, setExternalState: function( id, flyWeightObj )&#123; var uploadData = uploadDatabase[ id ]; for ( var i in uploadData )&#123; flyWeightObj[ i ] = uploadData[ i ]; &#125; &#125; &#125;&#125;)(); 然后是开始触发上传动作的 startUpload 函数： 123456var id = 0;window.startUpload = function( uploadType, files )&#123; for ( var i = 0, file; file = files[ i++ ]; )&#123; var uploadObj = uploadManager.add( ++id, uploadType, file.fileName, file.fileSize ); &#125;&#125;; 最后是测试时间，运行下面的代码后，可以发现运行结果跟用享元模式重构之前一致： 12345678910111213141516171819202122232425262728startUpload( 'plugin', [ &#123; fileName: '1.txt', fileSize: 1000 &#125;, &#123; fileName: '2.html', fileSize: 3000 &#125;, &#123; fileName: '3.txt', fileSize: 5000 &#125;]);startUpload( 'flash', [ &#123; fileName: '4.txt', fileSize: 1000 &#125;, &#123; fileName: '5.html', fileSize: 3000 &#125;, &#123; fileName: '6.txt', fileSize: 5000 &#125;]); 享元模式重构之前的代码里一共创建了 6个 upload 对象，而通过享元模式重构之后，对象的数量减少为 2，更幸运的是， 就算现在同时上传 2000个文件，需要创建的 upload 对象数量依然是 2。 五、 享元模式的适用性享元模式是一种很好的性能优化方案，但它也会带来一些复杂性的问题，从前面两组代码的比较可以看到，使用了享元模式之后，我们需要分别多维护一个 factory 对象和一个 manager 对象，在大部分不必要使用享元模式的环境下，这些开销是可以避免的。 享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时便可以使用享元模式。 一个程序中使用了大量的相似对象。 由于使用了大量对象，造成很大的内存开销。 对象的大多数状态都可以变为外部状态。 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。 可以看到，文件上传的例子完全符合这四点。 六、 再谈内部状态和外部状态如果顺利的话，通过前面的例子我们已经了解了内部状态和外部状态的概念以及享元模式的工作原理。我们知道，实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。现在来考虑两种极端的情况，即对象没有外部状态和没有内部状态的时候。 6.1 没有内部状态的享元在文件上传的例子中，我们分别进行过插件调用和 Flash 调用，即 startUpload( ‘plugin’, [] )和 startUpload( flash, [] )，导致程序中创建了内部状态不同的两个共享对象。也许你会奇怪，在文件上传程序里，一般都会提前通过特性检测来选择一种上传方式，如果浏览器支持插件就用插件上传，如果不支持插件，就用 Flash 上传。那么，什么情况下既需要插件上传又需要 Flash 上传呢？ 实际上这个需求是存在的，很多网盘都提供了极速上传（控件）与普通上传（Flash）两种模式，如果极速上传不好使（可能是没有安装控件或者控件损坏），用户还可以随时切换到普通上传模式，所以这里确实是需要同时存在两个不同的 upload 共享对象。 但不是每个网站都必须做得如此复杂，很多小一些的网站就只支持单一的上传方式。假设我们是这个网站的开发者，不需要考虑极速上传与普通上传之间的切换，这意味着在之前的代码中作为内部状态的 uploadType 属性是可以删除掉的。 在继续使用享元模式的前提下，构造函数 Upload 就变成了无参数的形式： 1var Upload = function()&#123;&#125;; 其他属性如 fileName、fileSize、dom 依然可以作为外部状态保存在共享对象外部。在uploadType 作为内部状态的时候，它可能为控件，也可能为 Flash，所以当时最多可以组合出两个共享对象。而现在已经没有了内部状态，这意味着只需要唯一的一个共享对象。现在我们要改写创建享元对象的工厂，代码如下： 1234567891011var UploadFactory = (function()&#123;var uploadObj;return &#123; create: function()&#123; if ( uploadObj )&#123; return uploadObj; &#125; return uploadObj = new Upload(); &#125;&#125;&#125;)(); 管理器部分的代码不需要改动，还是负责剥离和组装外部状态。可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂。虽然这时候的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，我们依然倾向于称之为享元模式。 6.2 没有外部状态的享元网上许多资料中，经常把 Java 或者 C#的字符串看成享元，这种说法是否正确呢？我们看看下面这段 Java 代码，来分析一下： 12345678// Java 代码public class Test &#123; public static void main( String args[] )&#123; String a1 = new String( \"a\" ).intern(); String a2 = new String( \"a\" ).intern(); System.out.println( a1 == a2 ); // true &#125;&#125; 在这段 Java 代码里，分别 new 了两个字符串对象 a1 和 a2。intern 是一种对象池技术， new String(“a”).intern()的含义如下。 如果值为 a 的字符串对象已经存在于对象池中，则返回这个对象的引用。 反之，将字符串 a 的对象添加进对象池，并返回这个对象的引用。 所以 a1 == a2 的结果是 true，但这并不是使用了享元模式的结果，享元模式的关键是区别内部状态和外部状态。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象。这里并没有剥离外部状态的过程，a1 和 a2 指向的完全就是同一个对象，所以如果没有外部状态的分离，即使这里使用了共享的技术，但并不是一个纯粹的享元模式。 七、 对象池我们在前面已经提到了 Java 中 String 的对象池，下面就来学习这种共享的技术。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。 对象池的原理很好理解，比如我们组人手一本《JavaScript 权威指南》，从节约的角度来讲，这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书还回图书馆。如果同时有三个人要看这本书，而现在图书馆里只有两本，那我们再马上去书店买一本放入图书馆。 对象池技术的应用非常广泛，HTTP 连接池和数据库连接池都是其代表应用。在 Web 前端开发中，对象池使用最多的场景大概就是跟 DOM 有关的操作。很多空间和时间都消耗在了 DOM节点上，如何避免频繁地创建和删除 DOM 节点就成了一个有意义的话题。 7.1 对象池实现假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它 toolTip。如图 12-2 所示。 在搜索我家附近地图的时候，页面里出现了 2 个小气泡。当我再搜索附近的兰州拉面馆时，页面中出现了 6 个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2 个小气泡删除掉，而是把它们放进对象池。这样在第二次的搜索结果页面里，我们只需要再创建 4 个小气泡而不是 6 个，如图 12-3 所示。 先定义一个获取小气泡节点的工厂，作为对象池的数组成为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create 表示获取一个 div 节点，recover 表示回收一个 div 节点： 1234567891011121314151617var toolTipFactory = (function()&#123; var toolTipPool = []; // toolTip 对象池 return &#123; create: function()&#123; if ( toolTipPool.length === 0 )&#123; // 如果对象池为空 var div = document.createElement( 'div' ); // 创建一个 dom document.body.appendChild( div ); return div; &#125;else&#123; // 如果对象池里不为空 return toolTipPool.shift(); // 则从对象池中取出一个 dom &#125; &#125;, recover: function( tooltipDom )&#123; return toolTipPool.push( tooltipDom ); // 对象池回收 dom &#125; &#125;&#125;)(); 现在把时钟拨回进行第一次搜索的时刻，目前需要创建 2 个小气泡节点，为了方便回收，用一个数组 ary 来记录它们： 123456var ary = [];for ( var i = 0, str; str = [ 'A', 'B' ][ i++ ]; )&#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str; ary.push( toolTip );&#125;; 如果你愿意稍稍测试一下，可以看到页面中出现了 innerHTML 分别为 A 和 B 的两个 div 节点。接下来假设地图需要开始重新绘制，在此之前要把这两个节点回收进对象池：123for ( var i = 0, toolTip; toolTip = ary[ i++ ]; )&#123; toolTipFactory.recover( toolTip );&#125;; 再创建 6 个小气泡： 1234for ( var i = 0, str; str = [ 'A', 'B', 'C', 'D', 'E', 'F' ][ i++ ]; )&#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str;&#125;; 现在再测试一番，页面中出现了内容分别为 A、B、C、D、E、F 的 6 个节点，上一次创建好的节点被共享给了下一次操作。对象池跟享元模式的思想有点相似，虽然 innerHTML 的值 A、B、C、D 等也可以看成节点的外部状态，但在这里我们并没有主动分离内部状态和外部状态的过程。 7.2 通用对象池实现我们还可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池： 12345678910111213var objectPoolFactory = function( createObjFn )&#123; var objectPool = []; return &#123; create: function()&#123; var obj = objectPool.length === 0 ? createObjFn.apply( this, arguments ) : objectPool.shift(); return obj; &#125;, recover: function( obj )&#123; objectPool.push( obj ); &#125; &#125;&#125;; 现在利用 objectPoolFactory 来创建一个装载一些 iframe 的对象池： 1234567891011121314151617var iframeFactory = objectPoolFactory( function()&#123; var iframe = document.createElement( 'iframe' ); document.body.appendChild( iframe ); iframe.onload = function()&#123; iframe.onload = null; // 防止 iframe 重复加载的 bug iframeFactory.recover( iframe ); // iframe 加载完成之后回收节点 &#125; return iframe;&#125;);var iframe1 = iframeFactory.create();iframe1.src = 'http:// baidu.com';var iframe2 = iframeFactory.create();iframe2.src = 'http:// QQ.com';setTimeout(function()&#123; var iframe3 = iframeFactory.create(); iframe3.src = 'http:// 163.com';&#125;, 3000 ); 对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。本章用享元模式完成了一个文件上传的程序，其实也可以用对象池+事件委托来代替实现。 八、 小结享元模式是为解决性能问题而生的模式，这跟大部分模式的诞生原因都不一样。在一个存在大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践十一（模板方法模式）","date":"2019-06-08T10:55:20.000Z","path":"2019/06/08/cjxe4h6pt001q6sup35ombyfl/","text":"在 JavaScript 开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这不代表继承在 JavaScript 里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型 prototype 来变相地实现继承。 不过本章并非要讨论继承，而是讨论一种基于继承的设计模式——模板方法（Template Method）模式。 一、 模板方法模式的定义和组成模板方法模式是一种只需使用继承就可以实现的非常简单的模式。 模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为解决这个问题而生的。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。 二、 第一个例子——Coffee or Tea咖啡与茶是一个经典的例子，经常用来讲解模板方法模式，这个例子的原型来自《Head First设计模式》。这一节我们就用 JavaScript 来实现这个例子。 2.1 先泡一杯咖啡首先，我们先来泡一杯咖啡，如果没有什么太个性化的需求，泡咖啡的步骤通常如下： (1) 把水煮沸(2) 用沸水冲泡咖啡(3) 把咖啡倒进杯子(4) 加糖和牛奶 通过下面这段代码，我们就能得到一杯香浓的咖啡： 123456789101112131415161718192021var Coffee = function () &#123; &#125;;Coffee.prototype.boilWater = function () &#123; console.log('把水煮沸');&#125;;Coffee.prototype.brewCoffeeGriends = function () &#123; console.log('用沸水冲泡咖啡');&#125;;Coffee.prototype.pourInCup = function () &#123; console.log('把咖啡倒进杯子');&#125;;Coffee.prototype.addSugarAndMilk = function () &#123; console.log('加糖和牛奶');&#125;;Coffee.prototype.init = function () &#123; this.boilWater(); this.brewCoffeeGriends(); this.pourInCup(); this.addSugarAndMilk();&#125;;var coffee = new Coffee();coffee.init(); 2.2 泡一壶茶接下来，开始准备我们的茶，泡茶的步骤跟泡咖啡的步骤相差并不大： (1) 把水煮沸(2) 用沸水浸泡茶叶(3) 把茶水倒进杯子(4) 加柠檬 同样用一段代码来实现泡茶的步骤： 123456789101112131415161718192021var Tea = function () &#123; &#125;;Tea.prototype.boilWater = function () &#123; console.log('把水煮沸');&#125;;Tea.prototype.steepTeaBag = function () &#123; console.log('用沸水浸泡茶叶');&#125;;Tea.prototype.pourInCup = function () &#123; console.log('把茶水倒进杯子');&#125;;Tea.prototype.addLemon = function () &#123; console.log('加柠檬');&#125;;Tea.prototype.init = function () &#123; this.boilWater(); this.steepTeaBag(); this.pourInCup(); this.addLemon();&#125;;var tea = new Tea();tea.init(); 2.3 分离出共同点现在我们分别泡好了一杯咖啡和一壶茶，经过思考和比较，我们发现咖啡和茶的冲泡过程是大同小异的，如下表所示。 煮咖啡 泡茶 把水煮沸 把水煮沸 用沸水冲泡咖啡 用沸水浸泡茶叶 把咖啡倒进杯子 把茶水倒进杯子 加糖和牛奶 加柠檬 我们找到泡咖啡和泡茶主要有以下不同点。 原料不同。一个是咖啡，一个是茶，但我们可以把它们都抽象为“饮料”。 泡的方式不同。咖啡是冲泡，而茶叶是浸泡，我们可以把它们都抽象为“泡”。 加入的调料不同。一个是糖和牛奶，一个是柠檬，但我们可以把它们都抽象为“调料”。 经过抽象之后，不管是泡咖啡还是泡茶，我们都能整理为下面四步： (1) 把水煮沸(2) 用沸水冲泡饮料(3) 把饮料倒进杯子(4) 加调料 所以，不管是冲泡还是浸泡，我们都能给它一个新的方法名称，比如说 brew()。同理，不管是加糖和牛奶，还是加柠檬，我们都可以称之为 addCondiments()。 让我们忘记最开始创建的 Coffee 类和 Tea 类。 现在可以创建一个抽象父类来表示泡一杯饮料的整个过程。不论是 Coffee，还是 Tea，都被我们用 Beverage 来表示，代码如下： 12345678910111213var Beverage = function () &#123; &#125;;Beverage.prototype.boilWater = function () &#123; console.log('把水煮沸');&#125;;Beverage.prototype.brew = function () &#123; &#125;; // 空方法，应该由子类重写Beverage.prototype.pourInCup = function () &#123; &#125;; // 空方法，应该由子类重写Beverage.prototype.addCondiments = function () &#123; &#125;; // 空方法，应该由子类重写Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;; 2.4 创建 Coffee 子类和 Tea 子类现在创建一个 Beverage 类的对象对我们来说没有意义，因为世界上能喝的东西没有一种真正叫“饮料”的，饮料在这里还只是一个抽象的存在。接下来我们要创建咖啡类和茶类，并让它们继承饮料类： 12var Coffee = function()&#123;&#125;;Coffee.prototype = new Beverage(); 接下来要重写抽象父类中的一些方法，只有“把水煮沸”这个行为可以直接使用父类 Beverage中的 boilWater 方法，其他方法都需要在 Coffee 子类中重写，代码如下： 1234567891011Coffee.prototype.brew = function () &#123; console.log('用沸水冲泡咖啡');&#125;;Coffee.prototype.pourInCup = function () &#123; console.log('把咖啡倒进杯子'); &#125;;Coffee.prototype.addCondiments = function () &#123; console.log('加糖和牛奶');&#125;;var Coffee = new Coffee();Coffee.init(); 至此我们的 Coffee 类已经完成了，当调用 coffee 对象的 init 方法时，由于 coffee 对象和Coffee 构造器的原型 prototype 上都没有对应的 init 方法，所以该请求会顺着原型链，被委托给Coffee 的“父类”Beverage 原型上的 init 方法。 而 Beverage.prototype.init 方法中已经规定好了泡饮料的顺序，所以我们能成功地泡出一杯咖啡，代码如下： 1234567891011121314151617181920Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;;//接下来照葫芦画瓢，来创建我们的 Tea 类：var Tea = function () &#123; &#125;;Tea.prototype = new Beverage();Tea.prototype.brew = function () &#123; console.log('用沸水浸泡茶叶');&#125;;Tea.prototype.pourInCup = function () &#123; console.log('把茶倒进杯子');&#125;;Tea.prototype.addCondiments = function () &#123; console.log('加柠檬');&#125;;var tea = new Tea();tea.init(); 本章一直讨论的是模板方法模式，那么在上面的例子中，到底谁才是所谓的模板方法呢？答案是 Beverage.prototype.init。 Beverage.prototype.init 被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在 Beverage.prototype.init 方法中，算法内的每一个步骤都清楚地展示在我们眼前。 三、 抽象类首先要说明的是，模板方法模式是一种严重依赖抽象类的设计模式。JavaScript 在语言层面并没有提供对抽象类的支持，我们也很难模拟抽象类的实现。这一节我们将着重讨论 Java 中抽象类的作用，以及 JavaScript 没有抽象类时所做出的让步和变通。 3.1 抽象类的作用在 Java 中，类分为两种，一种为具体类，另一种为抽象类。具体类可以被实例化，抽象类不能被实例化。要了解抽象类不能被实例化的原因，我们可以思考“饮料”这个抽象类。 想象这样一个场景：我们口渴了，去便利店想买一瓶饮料，我们不能直接跟店员说：“来一瓶饮料。”如果我们这样说了，那么店员接下来肯定会问：“要什么饮料？”饮料只是一个抽象名词，只有当我们真正明确了的饮料类型之后，才能得到一杯咖啡、茶、或者可乐。 由于抽象类不能被实例化，如果有人编写了一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。 抽象类和接口一样可以用于向上转型（可参考关于多态的内容），在静态类型语言中，编译器对类型的检查总是一个绕不过的话题与困扰。虽然类型检查可以提高程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们的 Java 程序尽量遵守依赖倒置原则。 除了用于向上转型，抽象类也可以表示一种契约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删掉了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的，比如我们本章讨论的模板方法模式，Beverage 类的 init 方法里规定了冲泡一杯饮料的顺序如下： 1234this.boilWater(); // 把水煮沸this.brew(); // 用水泡原料this.pourInCup(); // 把原料倒进杯子this.addCondiments(); // 添加调料 如果在 Coffee 子类中没有实现对应的 brew 方法，那么我们百分之百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类就应该拥有这些方法，并且提供正确的实现。 3.2 抽象方法和具体方法抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，是一些“哑”方法。比如Beverage 类中的 brew 方法、pourInCup 方法和 addCondiments 方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。 除了抽象方法之外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫作具体方法。当代码需要改变时，我们只需要改动抽象类里的具体方法就可以了。比如饮料中的 boilWater 方法，假设冲泡所有的饮料之前，都要先把水煮沸，那我们自然可以把 boilWater 方法放在抽象类 Beverage 中。 3.3 用 Java 实现 Coffee or Tea 的例子下面我们尝试着把 Coffee 和 Tea 的例子换成 Java 代码，这有助于我们理解抽象类的意义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Java 代码public abstract class Beverage &#123; // 饮料抽象类 final void init()&#123; // 模板方法 boilWater(); brew(); pourInCup(); addCondiments(); &#125; void boilWater()&#123; // 具体方法 boilWater System.out.println(\"把水煮沸\"); &#125; abstract void brew(); // 抽象方法 brew abstract void addCondiments(); // 抽象方法 addCondiments abstract void pourInCup(); // 抽象方法 pourInCup&#125;public class Coffee extends Beverage &#123; // Coffee 类 @Override void brew() &#123; // 子类中重写 brew 方法 System.out.println(\"用沸水冲泡咖啡\"); &#125; @Override void pourInCup() &#123; // 子类中重写 pourInCup 方法 System.out.println(\"把咖啡倒进杯子\"); &#125; @Override void addCondiments() &#123; // 子类中重写 addCondiments 方法 System.out.println(\"加糖和牛奶\"); &#125;&#125;public class Tea extends Beverage &#123; // Tea 类 @Override void brew() &#123; // 子类中重写 brew 方法 System.out.println(\"用沸水浸泡茶叶\"); &#125; @Override void pourInCup() &#123; // 子类中重写 pourInCup 方法 System.out.println(\"把茶倒进杯子\"); &#125; @Override void addCondiments() &#123; // 子类中重写 addCondiments 方法 System.out.println(\"加柠檬\"); &#125;&#125;public class Test &#123; private static void prepareRecipe(Beverage beverage) &#123; beverage.init(); &#125; public static void main(String args[]) &#123; Beverage coffee = new Coffee(); // 创建 coffee 对象 prepareRecipe(coffee); // 开始泡咖啡 // 把水煮沸 // 用沸水冲泡咖啡 // 把咖啡倒进杯子 // 加糖和牛奶 Beverage tea = new Tea(); // 创建 tea 对象 prepareRecipe(tea); // 开始泡茶 // 把水煮沸 // 用沸水浸泡茶叶 // 把茶倒进杯子 // 加柠檬 &#125;&#125; 3.4 JavaScript 没有抽象类的缺点和解决方案JavaScript 并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于 JavaScript 是一门“类型模糊”的语言，所以隐藏对象的类型在 JavaScript 中并不重要。 另一方面，当我们在 JavaScript 中使用原型继承来模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的“抽象方法”。 我们知道，Beverage.prototype.init 方法作为模板方法，已经规定了子类的算法框架，代码如下： 123456Beverage.prototype.init = function()&#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;; 如果我们的 Coffee 类或者 Tea 类忘记实现这 4 个方法中的一个呢？拿 brew 方法举例，如果我们忘记编写 Coffee.prototype.brew 方法，那么当请求 coffee 对象的 brew 时，请求会顺着原型链找到 Beverage“父类”对应的 Beverage.prototype.brew 方法，而 Beverage.prototype.brew 方法到目前为止是一个空方法，这显然是不能符合我们需要的。 在 Java 中编译器会保证子类会重写父类中的抽象方法，但在 JavaScript 中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。 下面提供两种变通的解决方案。 第 1 种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。 第 2 种方案是让 Beverage.prototype.brew 等方法直接抛出一个异常，如果因为粗心忘记编写 Coffee.prototype.brew 方法，那么至少我们会在程序运行时得到一个错误：123456789Beverage.prototype.brew = function()&#123; throw new Error( '子类必须重写 brew 方法' );&#125;;Beverage.prototype.pourInCup = function()&#123; throw new Error( '子类必须重写 pourInCup 方法' );&#125;;Beverage.prototype.addCondiments = function()&#123; throw new Error( '子类必须重写 addCondiments 方法' );&#125;; 第 2 种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后。 我们一共有 3 次机会得到这个错误信息，第 1 次是在编写代码的时候，通过编译器的检查来得到错误信息；第 2 次是在创建对象的时候用鸭子类型来进行“接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。 四、 模板方法模式的使用场景从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架，程序员继承框架的结构之后，负责往里面填空，比如 Java 程序员大多使用过 HttpServlet 技术来开发项目。 一个基于 HttpServlet 的程序包含 7 个生命周期，这 7 个生命周期分别对应一个 do 方法。 1234567doGet()doHead()doPost()doPut()doDelete()doOption()doTrace() HttpServlet 类还提供了一个 service 方法，它就是这里的模板方法，service 规定了这些 do方法的执行顺序，而这些 do 方法的具体实现则需要 HttpServlet 的子类来提供。 在 Web 开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的 UI 组件，这些组件的构建过程一般如下所示： (1) 初始化一个 div 容器；(2) 通过 ajax 请求拉取相应的数据；(3) 把数据渲染到 div 容器里面，完成组件的构造；(4) 通知用户组件渲染完毕。 我们看到，任何组件的构建都遵循上面的 4 步，其中第(1)步和第(4)步是相同的。第(2)步不同的地方只是请求 ajax 的远程地址，第(3)步不同的地方是渲染数据的方式。 于是我们可以把这 4 个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第(1)步和第(4)步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第(2)步和第(3)步。 五、 钩子方法通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于大多数子类的，但如果有一些特别“个性”的子类呢？比如我们在饮料类 Beverage 中封装了饮料的冲泡顺序： (1) 把水煮沸(2) 用沸水冲泡饮料(3) 把饮料倒进杯子(4) 加调料 这 4 个冲泡饮料的步骤适用于咖啡和茶，在我们的饮料店里，根据这 4 个步骤制作出来的咖啡和茶，一直顺利地提供给绝大部分客人享用。但有一些客人喝咖啡是不加调料（糖和牛奶）的。既然 Beverage 作为父类，已经规定好了冲泡饮料的 4 个步骤，那么有什么办法可以让子类不受这个约束呢？ 钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。 在这个例子里，我们把挂钩的名字定为 customerWantsCondiments，接下来将挂钩放入 Beverage类，看看我们如何得到一杯不需要糖和牛奶的咖啡，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940var Beverage = function () &#123; &#125;;Beverage.prototype.boilWater = function () &#123; console.log('把水煮沸');&#125;;Beverage.prototype.brew = function () &#123; throw new Error('子类必须重写 brew 方法');&#125;;Beverage.prototype.pourInCup = function () &#123; throw new Error('子类必须重写 pourInCup 方法');&#125;;Beverage.prototype.addCondiments = function () &#123; throw new Error('子类必须重写 addCondiments 方法');&#125;;Beverage.prototype.customerWantsCondiments = function () &#123; return true; // 默认需要调料&#125;;Beverage.prototype.init = function () &#123; this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) &#123; // 如果挂钩返回 true，则需要调料 this.addCondiments(); &#125;&#125;;var CoffeeWithHook = function () &#123; &#125;;CoffeeWithHook.prototype = new Beverage();CoffeeWithHook.prototype.brew = function () &#123; console.log('用沸水冲泡咖啡');&#125;;CoffeeWithHook.prototype.pourInCup = function () &#123; console.log('把咖啡倒进杯子');&#125;;CoffeeWithHook.prototype.addCondiments = function () &#123; console.log('加糖和牛奶');&#125;;CoffeeWithHook.prototype.customerWantsCondiments = function () &#123; return window.confirm('请问需要调料吗？');&#125;;var coffeeWithHook = new CoffeeWithHook();coffeeWithHook.init(); 六、 好莱坞原则学习完模板方法模式之后，我们要引入一个新的设计原则——著名的“好莱坞原则”。 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。” 在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。 模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。 除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。 发布—订阅模式 在发布—订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去 fetch 消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了每过 5 秒钟就问司机“是否到达目的地”之外，还可以在车上美美地睡上一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好莱坞原则中提到的“别调用我们，我们会调用你”。 回调函数 在 ajax 异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起 ajax 异步请求的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行的操作封装在回调函数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则是另外一个函数控制的。 七、 真的需要“继承”吗模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。 本章我们通过模板方法模式，编写了一个 Coffee or Tea 的例子。模板方法模式是为数不多的基于继承的设计模式，但 JavaScript 语言实际上没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但本章学习到的模板方法模式并不十分正宗。而且在 JavaScript 这般灵活的语言中，实现这样一个例子，是否真的需要继承这种重武器呢？ 在好莱坞原则的指导之下，下面这段代码可以达到和继承一样的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var Beverage = function (param) &#123; var boilWater = function () &#123; console.log('把水煮沸'); &#125;; var brew = param.brew || function () &#123; throw new Error('必须传递 brew 方法'); &#125;; var pourInCup = param.pourInCup || function () &#123; throw new Error('必须传递 pourInCup 方法'); &#125;; var addCondiments = param.addCondiments || function () &#123; throw new Error('必须传递 addCondiments 方法'); &#125;; var F = function () &#123; &#125;; F.prototype.init = function () &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125;; return F;&#125;;var Coffee = Beverage(&#123; brew: function () &#123; console.log('用沸水冲泡咖啡'); &#125;, pourInCup: function () &#123; console.log('把咖啡倒进杯子'); &#125;, addCondiments: function () &#123; console.log('加糖和牛奶'); &#125;&#125;); var Tea = Beverage(&#123; brew: function () &#123; console.log('用沸水浸泡茶叶'); &#125;, pourInCup: function () &#123; console.log('把茶倒进杯子'); &#125;, addCondiments: function () &#123; console.log('加柠檬'); &#125;&#125;);var coffee = new Coffee();coffee.init();var tea = new Tea();tea.init(); 在这段代码中，我们把 brew、pourInCup、addCondiments 这些方法依次传入 Beverage 函数，Beverage 函数被调用之后返回构造器 F。F 类中包含了“模板方法”F.prototype.init。跟继承得到的效果一样，该“模板方法”里依然封装了饮料子类的算法框架。 八、 小结模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放封闭原则的。 但在 JavaScript 中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数是更好的选择。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践十（组合模式）","date":"2019-06-01T10:40:20.000Z","path":"2019/06/01/cjxe4h6pn001i6supay96kr7r/","text":"我们知道地球和一些其他行星围绕着太阳旋转，也知道在一个原子中，有许多电子围绕着原子核旋转。把我们是否可以这样想象，我们的太阳系也许是一个更大世界里的一个原子，地球只是围绕着太阳原子的一个电子。而我身上的每个原子又是一个星系，原子核就是这个星系中的恒星，电子是围绕着恒星旋转的行星。一个电子中也许还包含了另一个宇宙，虽然这个宇宙还不能被显微镜看到，但我相信它的存在。 也许这个想法有些异想天开，但在程序设计中，也有一些和“事物是由相似的子事物构成”类似的思想。组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。 一、 回顾宏命令我们在命令模式中讲解过宏命令的结构和作用。宏命令对象包含了一组具体的子命令对象，不管是宏命令对象，还是子命令对象，都有一个 execute 方法负责执行命令。现在回顾一下这段安装在万能遥控器上的宏命令代码： 123456789101112131415161718192021222324252627282930313233var closeDoorCommand = &#123; execute: function()&#123; console.log( '关门' ); &#125;&#125;;var openPcCommand = &#123; execute: function()&#123; console.log( '开电脑' ); &#125;&#125;;var openQQCommand = &#123; execute: function()&#123; console.log( '登录 QQ' ); &#125;&#125;;var MacroCommand = function()&#123; return &#123; commandsList: [], add: function( command )&#123; this.commandsList.push( command ); &#125;, execute: function()&#123; for ( var i = 0, command; command = this.commandsList[ i++ ]; )&#123; command.execute(); &#125; &#125; &#125;&#125;;var macroCommand = MacroCommand();macroCommand.add( closeDoorCommand );macroCommand.add( openPcCommand );macroCommand.add( openQQCommand );macroCommand.execute(); 通过观察这段代码，我们很容易发现，宏命令中包含了一组子命令，它们组成了一个树形结构，这里是一棵结构非常简单的树，如图 10-1 所示。 其中，marcoCommand 被称为组合对象，closeDoorCommand、openPcCommand、openQQCommand 都是叶对象。在 macroCommand 的 execute 方法里，并不执行真正的操作，而是遍历它所包含的叶对象，把真正的 execute 请求委托给这些叶对象。 macroCommand 表现得像一个命令，但它实际上只是一组真正命令的“代理”。并非真正的代理，虽然结构上相似，但 macroCommand 只负责传递请求给叶对象，它的目的不在于控制对叶对象的访问。 二、 组合模式的用途组合模式将对象组合成树形结构，以表示“部分整体”的层次结构。 除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明。 表示树形结构。通过回顾上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象的 execute 方法，程序会递归调用组合对象下面的叶对象的 execute 方法，所以我们的万能遥控器只需要一次操作，便能依次完成关门、打开电脑、登录 QQ 这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。 利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。 这在实际开发中会给客户带来相当大的便利性，当我们往万能遥控器里面添加一个命令的时候，并不关心这个命令是宏命令还是普通子命令。这点对于我们不重要，我们只需要确定它是一个命令，并且这个命令拥有可执行的 execute 方法，那么这个命令就可以被添加进万能遥控器。 当宏命令和普通子命令接收到执行 execute 方法的请求时，宏命令和普通子命令都会做它们各自认为正确的事情。这些差异是隐藏在客户背后的，在客户看来，这种透明性可以让我们非常自由地扩展这个万能遥控器。 请求在树中传递的过程在组合模式中，请求在树中传递的过程总是遵循一种逻辑。 以宏命令为例，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象（普通子命令），叶对象自身会对请求作出相应的处理；如果当前处理请求的对象是组合对象（宏命令），组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。 总而言之，如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。叶对象下面不会再有其他子节点，一个叶对象就是树的这条枝叶的尽头，组合对象下面可能还会有子节点，如图 10-2 所示。 ; 请求从上到下沿着树进行传递，直到树的尽头。作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。 在刚刚的例子中，由于宏命令和子命令组成的树太过简单，我们还不能清楚地看到组合模式带来的好处，如果只是简单地遍历一组子节点，迭代器便能解决所有的问题。接下来我们将创造一个更强大的宏命令，这个宏命令中又包含了另外一些宏命令和普通子命令，看起来是一棵相对较复杂的树。 更强大的宏命令目前的万能遥控器，包含了关门、开电脑、登录 QQ 这 3 个命令。现在我们需要一个“超级万能遥控器”，可以控制家里所有的电器，这个遥控器拥有以下功能： 打开空调 打开电视和音响 关门、开电脑、登录 QQ 首先在节点中放置一个按钮 button 来表示这个超级万能遥控器，超级万能遥控器上安装了一个宏命令，当执行这个宏命令时，会依次遍历执行它所包含的子命令，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html&gt;&lt;body&gt; &lt;button id=\"button\"&gt;按我&lt;/button&gt; &lt;/body&gt;&lt;script&gt; var MacroCommand = function()&#123; return &#123; commandsList: [], add: function( command )&#123; this.commandsList.push( command ); &#125;, execute: function()&#123; for ( var i = 0, command; command = this.commandsList[ i++ ]; )&#123; command.execute(); &#125; &#125; &#125; &#125;; var openAcCommand = &#123; execute: function()&#123; console.log( '打开空调' ); &#125; &#125;; /**********家里的电视和音响是连接在一起的，所以可以用一个宏命令来组合打开电视和打开音响的命令*********/ var openTvCommand = &#123; execute: function()&#123; console.log( '打开电视' ); &#125; &#125;; var openSoundCommand = &#123; execute: function()&#123; console.log( '打开音响' ); &#125; &#125;; var macroCommand1 = MacroCommand(); macroCommand1.add( openTvCommand ); macroCommand1.add( openSoundCommand ); /*********关门、打开电脑和打登录 QQ 的命令****************/ var closeDoorCommand = &#123; execute: function()&#123; console.log( '关门' ); &#125; &#125;; var openPcCommand = &#123; execute: function()&#123; console.log( '开电脑' ); &#125; &#125;; var openQQCommand = &#123; execute: function()&#123; console.log( '登录 QQ' ); &#125; &#125;; var macroCommand2 = MacroCommand(); macroCommand2.add( closeDoorCommand ); macroCommand2.add( openPcCommand ); macroCommand2.add( openQQCommand ); /*********现在把所有的命令组合成一个“超级命令”**********/ var macroCommand = MacroCommand(); macroCommand.add( openAcCommand ); macroCommand.add( macroCommand1 ); macroCommand.add( macroCommand2 ); /*********最后给遥控器绑定“超级命令”**********/ var setCommand = (function( command )&#123; document.getElementById( 'button' ).onclick = function()&#123; command.execute(); &#125; &#125;)( macroCommand );&lt;/script&gt;&lt;/html&gt; 当按下遥控器的按钮时，所有命令都将被依次执行，执行结果如下所示。 打开空调打开电视打开音响关门开电脑登录 QQ 从这个例子中可以看到，基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。在树最终被构造完成之后，让整颗树最终运转起来的步骤非常简单，只需要调用最上层对象的 execute 方法。每当对最上层的对象进行一次请求时，实际上是在对整个树进行深度优先的搜索，而创建组合对象的程序员并不关心这些内在的细节，往这棵树里面添加一些新的节点对象是非常容易的事情。 五、 抽象类在组合模式中的作用前面说到，组合模式最大的优点在于可以一致地对待组合对象和基本对象。客户不需要知道当前处理的是宏命令还是普通命令，只要它是一个命令，并且有 execute 方法，这个命令就可以被添加到树中。 这种透明性带来的便利，在静态类型语言中体现得尤为明显。比如在 Java 中，实现组合模式的关键是 Composite 类和 Leaf 类都必须继承自一个 Compenent 抽象类。这个 Compenent 抽象类既代表组合对象，又代表叶对象，它也能够保证组合对象和叶对象拥有同样名字的方法，从而可以对同一消息都做出反馈。组合对象和叶对象的具体类型被隐藏在 Compenent 抽象类身后。 针对 Compenent 抽象类来编写程序，客户操作的始终是 Compenent 对象，而不用去区分到底是组合对象还是叶对象。所以我们往同一个对象里的 add 方法里，既可以添加组合对象，也可以添加叶对象，代码如下： 12345678910111213141516171819202122232425262728293031323334353637// Java 代码public abstract class Component&#123; //add 方法，参数为 Component 类型 public void add( Component child )&#123;&#125; //remove 方法，参数为 Component 类型 public void remove( Component child )&#123;&#125;&#125;public class Composite extends Component&#123; //add 方法，参数为 Component 类型 public void add( Component child )&#123;&#125; //remove 方法，参数为 Component 类型 public void remove( Component child )&#123;&#125;&#125;public class Leaf extends Component&#123; //add 方法，参数为 Component 类型 public void add( Component child )&#123; throw new UnsupportedOperationException() // 叶对象不能再添加子节点 &#125; //remove 方法，参数为 Component 类型 public void remove( Component child )&#123; &#125;&#125;public class client()&#123; public static void main( String args[] )&#123; Component root = new Composite(); Component c1 = new Composite(); Component c2 = new Composite(); Component leaf1 = new Leaf(); Component leaf2 = new Leaf(); root.add(c1); root.add(c2); c1.add(leaf1); c1.add(leaf2); root.remove(); &#125;&#125; 然而在 JavaScript 这种动态类型语言中，对象的多态性是与生俱来的，也没有编译器去检查变量的类型，所以我们通常不会去模拟一个“怪异”的抽象类，JavaScript 中实现组合模式的难点在于要保证组合对象和叶对象对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行接口检查。 在 JavaScript 中实现组合模式，看起来缺乏一些严谨性，我们的代码算不上安全，但能更快速和自由地开发，这既是 JavaScript 的缺点，也是它的优点。 六、 透明性带来的安全问题组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们在本质上有是区别的。 123456789101112131415161718192021222324var MacroCommand = function () &#123; return &#123; commandsList: [], add: function (command) &#123; this.commandsList.push(command); &#125;, execute: function () &#123; for (var i = 0, command; command = this.commandsList[i++];) &#123; command.execute(); &#125; &#125; &#125;&#125;;var openTvCommand = &#123; execute: function () &#123; console.log('打开电视'); &#125;, add: function () &#123; throw new Error('叶对象不能添加子节点'); &#125;&#125;;var macroCommand = MacroCommand();macroCommand.add(openTvCommand);openTvCommand.add(macroCommand) // Uncaught Error: 叶对象不能添加子节点 七、 组合模式的例子——扫描文件夹文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树，组合模式在文件夹的应用中有以下两层好处。 例如，我在同事的移动硬盘里找到了一些电子书，想把它们复制到 F 盘中的学习资料文件夹。在复制这些电子书的时候，我并不需要考虑这批文件的类型，不管它们是单独的电子书还是被放在了文件夹中。组合模式让 Ctrl+V、Ctrl+C 成为了一个统一的操作。当我用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。 现在我们来编写代码，首先分别定义好文件夹 Folder 和文件 File 这两个类。见如下代码： 123456789101112131415161718192021222324/******************************* Folder ******************************/var Folder = function (name) &#123; this.name = name; this.files = [];&#125;;Folder.prototype.add = function (file) &#123; this.files.push(file);&#125;;Folder.prototype.scan = function () &#123; console.log('开始扫描文件夹: ' + this.name); for (var i = 0, file, files = this.files; file = files[i++];) &#123; file.scan(); &#125;&#125;;/******************************* File ******************************/var File = function (name) &#123; this.name = name;&#125;;File.prototype.add = function () &#123; throw new Error('文件下面不能再添加文件');&#125;; File.prototype.scan = function () &#123; console.log('开始扫描文件: ' + this.name);&#125;; 接下来创建一些文件夹和文件对象， 并且让它们组合成一棵树，这棵树就是我们 F 盘里的现有文件目录结构： 1234567891011var folder = new Folder('学习资料');var folder1 = new Folder('JavaScript');var folder2 = new Folder('jQuery');var file1 = new File('JavaScript 设计模式与开发实践');var file2 = new File('精通 jQuery');var file3 = new File('重构与模式')folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3); 现在的需求是把移动硬盘里的文件和文件夹都复制到这棵树中，假设我们已经得到了这些文件对象： 1234var folder3 = new Folder( 'Nodejs' );var file4 = new File( '深入浅出 Node.js' );folder3.add( file4 );var file5 = new File( 'JavaScript 语言精髓与编程实践' ); 接下来就是把这些文件都添加到原有的树中： 12folder.add( folder3 );folder.add( file5 ); 通过这个例子，我们再次看到客户是如何同等对待组合对象和叶对象。在添加一批文件的操作过程中，客户不用分辨它们到底是文件还是文件夹。新增加的文件和文件夹能够很容易地添加到原来的树结构中，和树里已有的对象一起工作。 我们改变了树的结构，增加了新的数据，却不用修改任何一句原有的代码，这是符合开放封闭原则的。 运用了组合模式之后，扫描整个文件夹的操作也是轻而易举的，我们只需要操作树的最顶端对象： 1folder.scan(); 执行结果如图 10-4 所示。 八、 一些值得注意的地方在使用组合模式的时候，还有以下几个值得我们注意的地方。 8.1 组合模式不是父子关系组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。 组合模式是一种 HAS-A（聚合）的关系，而不是 IS-A。组合对象包含一组叶对象，但 Leaf并不是 Composite 的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。 为了方便描述，本章有时候把上下级对象称为父子节点，但大家要知道，它们并非真正意义上的父子关系。 8.2 对叶对象操作的一致性组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。 比如公司要给全体员工发放元旦的过节费 1000 块，这个场景可以运用组合模式，但如果公司给今天过生日的员工发送一封生日祝福的邮件，组合模式在这里就没有用武之地了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每个叶对象的时候，才适合使用组合模式。 8.3 双向映射关系发放过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但要考虑的一种情况是，也许某些员工属于多个组织架构。比如某位架构师既隶属于开发组，又隶属于架构组，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该架构师很可能会收到两份过节费。 这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。 8.4 用职责链模式提高组合模式性能在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。 九、 引用父对象在 11.7 节提到的例子中，组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时树结构是从上至下的。但有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件夹中删除该文件的。 现在来改写扫描文件夹的代码，使得在扫描整个文件夹之前，我们可以先移除某一个具体的文件。 首先改写 Folder 类和 File 类，在这两个类的构造函数中，增加 this.parent 属性，并且在调用 add 方法的时候，正确设置文件或者文件夹的父节点： 123456789101112131415var Folder = function (name) &#123; this.name = name; this.parent = null; //增加 this.parent 属性 this.files = [];&#125;;Folder.prototype.add = function (file) &#123; file.parent = this; //设置父对象 this.files.push(file);&#125;;Folder.prototype.scan = function () &#123; console.log('开始扫描文件夹: ' + this.name); for (var i = 0, file, files = this.files; file = files[i++];) &#123; file.scan(); &#125;&#125;; 接下来增加 Folder.prototype.remove 方法，表示移除该文件夹： 1234567891011Folder.prototype.remove = function () &#123; if (!this.parent) &#123; //根节点或者树外的游离节点 return; &#125; for (var files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) &#123; var file = files[l]; if (file === this) &#123; files.splice(l, 1); &#125; &#125;&#125;; 在 File.prototype.remove 方法里，首先会判断 this.parent，如果 this.parent 为 null，那么这个文件夹要么是树的根节点，要么是还没有添加到树的游离节点，这时候没有节点需要从树中移除，我们暂且让 remove 方法直接 return，表示不做任何操作。 如果 this.parent 不为 null，则说明该文件夹有父节点存在，此时遍历父节点中保存的子节点列表，删除想要删除的子节点。 File 类的实现基本一致： 123456789101112131415161718192021var File = function (name) &#123; this.name = name; this.parent = null;&#125;;File.prototype.add = function () &#123; throw new Error('不能添加在文件下面');&#125;;File.prototype.scan = function () &#123; console.log('开始扫描文件: ' + this.name);&#125;;File.prototype.remove = function () &#123; if (!this.parent) &#123; //根节点或者树外的游离节点 return; &#125; for (var files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) &#123; var file = files[l]; if (file === this) &#123; files.splice(l, 1); &#125; &#125;&#125;; 下面测试一下我们的移除文件功能： 12345678var folder = new Folder( '学习资料' );var folder1 = new Folder( 'JavaScript' );var file1 = new Folder ( '深入浅出 Node.js' ); folder1.add( new File( 'JavaScript 设计模式与开发实践' ) );folder.add( folder1 );folder.add( file1 );folder1.remove(); //移除文件夹folder.scan(); 执行结果如下： 开始扫描文件夹: 学习资料开始扫描文件夹: 深入浅出 Node.js 十、 何时使用组合模式组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种情况。 表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。 客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆 if、else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。 十一、 小结本章我们了解了组合模式在 JavaScript 开发中的应用。组合模式可以让我们使用树形方式创建对象的结构。我们可以把相同的操作应用在组合对象和单个对象上。在大多数情况下，我们都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方式来处理它们。 然而，组合模式并不是完美的，它可能会产生一个这样的系统：系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候才会显现出来，这会使代码难以理解。此外，如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践九（命令模式）","date":"2019-05-29T10:30:20.000Z","path":"2019/05/29/cjxe4h6po001k6supznqh2zf5/","text":"假设有一个快餐店，而我是该餐厅的点餐服务员，那么我一天的工作应该是这样的：当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人可能当前正在回家的路上，要求 1 个小时后才开始炒他的菜，只要订单还在，厨师就不会忘记。客人也可以很方便地打电话来撤销订单。另外如果有太多的客人点餐，厨房可以按照订单的顺序排队炒菜。 这些记录着订餐信息的清单，便是命令模式中的命令对象。 一、 命令模式的用途命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。 命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 拿订餐来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成 command 对象，也就是订餐中的订单对象。这个对象可以在程序中被四处传递，就像订单可以从服务员手中传到厨师的手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合关系。 另外，相对于过程化的请求调用，command 对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了 command 对象的方法中，成为了这个对象的行为。我们可以在程序运行的任意时刻去调用这个方法，就像厨师可以在客人预定 1 个小时之后才帮他炒菜，相当于程序在 1 个小时之后才开始执行 command 对象的方法。 除了这两点之外，命令模式还支持撤销、排队等操作，本节稍后将会详细讲解。 二、 命令模式的例子——菜单程序假设我们正在编写一个用户界面程序，该用户界面上至少有数十个 Button 按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。 在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定 onclick 事件呢？ 回想一下命令模式的应用场景： 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 我们很快可以找到在这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。 设计模式的主题总是把不变的事物和变化的事物分离开来，命令模式也不例外。按下按钮之后会发生一些事情是不变的，而具体会发生什么事情是可变的。通过 command 对象的帮助，将来我们可以轻易地改变这种关联，因此也可以在将来再次改变按钮的行为。 下面进入代码编写阶段，首先在页面中完成这些按钮的“绘制”： 12345678910&lt;body&gt; &lt;button id=\"button1\"&gt;点击按钮 1&lt;/button&gt; &lt;button id=\"button2\"&gt;点击按钮 2&lt;/button&gt; &lt;button id=\"button3\"&gt;点击按钮 3&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var button1 = document.getElementById( 'button1' ), var button2 = document.getElementById( 'button2' ), var button3 = document.getElementById( 'button3' );&lt;/script&gt; 接下来定义 setCommand 函数，setCommand 函数负责往按钮上面安装命令。可以肯定的是，点击按钮会执行某个 command 命令，执行命令的动作被约定为调用 command 对象的 execute()方法。虽然还不知道这些命令究竟代表什么操作，但负责绘制按钮的程序员不关心这些事情，他只需要预留好安装命令的接口，command 对象自然知道如何和正确的对象沟通： 12345var setCommand = function( button, command )&#123; button.onclick = function()&#123; command.execute(); &#125;&#125;; 最后，负责编写点击按钮之后的具体行为的程序员总算交上了他们的成果，他们完成了刷新菜单界面、增加子菜单和删除子菜单这几个功能，这几个功能被分布在 MenuBar 和 SubMenu 这两个对象中： 12345678910111213var MenuBar = &#123; refresh: function()&#123; console.log( '刷新菜单目录' ); &#125;&#125;;var SubMenu = &#123; add: function()&#123; console.log( '增加子菜单' ); &#125;, del: function()&#123; console.log( '删除子菜单' ); &#125;&#125;; 在让 button 变得有用起来之前，我们要先把这些行为都封装在命令类中： 123456789101112131415161718var RefreshMenuBarCommand = function( receiver )&#123; this.receiver = receiver;&#125;;RefreshMenuBarCommand.prototype.execute = function()&#123; this.receiver.refresh();&#125;;var AddSubMenuCommand = function( receiver )&#123; this.receiver = receiver;&#125;; AddSubMenuCommand.prototype.execute = function()&#123; this.receiver.add();&#125;;var DelSubMenuCommand = function( receiver )&#123; this.receiver = receiver;&#125;;DelSubMenuCommand.prototype.execute = function()&#123; console.log( '删除子菜单' );&#125;; 最后就是把命令接收者传入到 command 对象中，并且把 command 对象安装到 button 上面： 123456var refreshMenuBarCommand = new RefreshMenuBarCommand( MenuBar );var addSubMenuCommand = new AddSubMenuCommand( SubMenu );var delSubMenuCommand = new DelSubMenuCommand( SubMenu );setCommand( button1, refreshMenuBarCommand );setCommand( button2, addSubMenuCommand );setCommand( button3, delSubMenuCommand ); 以上只是一个很简单的命令模式示例，但从中可以看到我们是如何把请求发送者和请求接收者解耦开的。 三、 JavaScript 中的命令模式也许我们会感到很奇怪，所谓的命令模式，看起来就是给对象的某个方法取了 execute 的名字。引入 command 对象和 receiver 这两个无中生有的角色无非是把简单的事情复杂化了，即使不用什么模式，用下面寥寥几行代码就可以实现相同的功能： 12345678910111213141516171819var bindClick = function( button, func )&#123; button.onclick = func;&#125;;var MenuBar = &#123; refresh: function()&#123; console.log( '刷新菜单界面' ); &#125;&#125;;var SubMenu = &#123; add: function()&#123; console.log( '增加子菜单' ); &#125;, del: function()&#123; console.log( '删除子菜单' ); &#125;&#125;;bindClick( button1, MenuBar.refresh ); bindClick( button2, SubMenu.add );bindClick( button3, SubMenu.del ); 这种说法是正确的，上节中的示例代码是模拟传统面向对象语言的命令模式实现。命令模式将过程式的请求调用封装在 command 对象的 execute 方法里，通过封装方法调用，我们可以把运算块包装成形。command 对象可以被四处传递，所以在调用命令的时候，客户（Client）不需要关心事情是如何进行的。 命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。 JavaScript 作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了JavaScript 语言之中。运算块不一定要封装在 command.execute 方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。 在面向对象设计中，命令模式的接收者被当成 command 对象的属性保存起来，同时约定执行命令的操作调用 command.execute 方法。在使用闭包的命令模式实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。无论接收者被保存为对象的属性，还是被封闭在闭包产生的环境中，在将来执行命令的时候，接收者都能被顺利访问。用闭包实现的命令模式如下代码所示： 1234567891011121314151617var setCommand = function( button, func )&#123; button.onclick = function()&#123; func(); &#125;&#125;;var MenuBar = &#123; refresh: function()&#123; console.log( '刷新菜单界面' ); &#125;&#125;;var RefreshMenuBarCommand = function( receiver )&#123; return function()&#123; receiver.refresh(); &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar );setCommand( button1, refreshMenuBarCommand ); 当然，如果想更明确地表达当前正在使用命令模式，或者除了执行命令之外，将来有可能还要提供撤销命令等操作。那我们最好还是把执行函数改为调用 execute 方法： 1234567891011121314var RefreshMenuBarCommand = function( receiver )&#123; return &#123; execute: function()&#123; receiver.refresh(); &#125; &#125;&#125;;var setCommand = function( button, command )&#123; button.onclick = function()&#123; command.execute(); &#125;&#125;;var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar );setCommand( button1, refreshMenuBarCommand ); 四、 撤销命令命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。就像订餐时客人可以通过电话来取消订单一样。下面来看撤销命令的例子。 本节的目标是利用 前面提到的 Animate 类来编写一个动画，这个动画的表现是让页面上的小球移动到水平方向的某个位置。现在页面中有一个 input 文本框和一个 button 按钮，文本框中可以输入一些数字，表示小球移动后的水平位置，小球在用户点击按钮后立刻开始移动，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Animate 类tween = &#123; linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125;&#125;;var Animate = function (dom) &#123; this.dom = dom; // 进行运动的 dom 节点 this.startTime = 0; // 动画开始时间 this.startPos = 0; // 动画开始时，dom 节点的位置，即 dom 的初始位置 this.endPos = 0; // 动画结束时，dom 节点的位置，即 dom 的目标位置 this.propertyName = null; // dom 节点需要被改变的 css 属性名 this.easing = null; // 缓动算法 this.duration = null; // 动画持续时间&#125;;Animate.prototype.start = function (propertyName, endPos, duration, easing) &#123; this.startTime = +new Date; // 动画启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; // dom 节点初始位置 this.propertyName = propertyName; // dom 节点需要被改变的 CSS 属性名 this.endPos = endPos; // dom 节点目标位置 this.duration = duration; // 动画持续事件 this.easing = tween[easing]; // 缓动算法 var self = this; var timeId = setInterval(function () &#123; // 启动定时器，开始执行动画 if (self.step() === false) &#123; // 如果动画已结束，则清除定时器 clearInterval(timeId); &#125; &#125;, 19);&#125;;Animate.prototype.step = function () &#123; var t = +new Date; // 取得当前时间 if (t &gt;= this.startTime + this.duration) &#123; // (1) this.update(this.endPos); // 更新小球的 CSS 属性值 return false; &#125; var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration); // pos 为小球当前位置 this.update(pos); // 更新小球的 CSS 属性值&#125;;Animate.prototype.update = function (pos) &#123; this.dom.style[this.propertyName] = pos + 'px';&#125;;//点击盒子 var ball = document.getElementById('ball');var pos = document.getElementById('pos');var moveBtn = document.getElementById('moveBtn');moveBtn.onclick = function () &#123; var animate = new Animate(ball); animate.start('left', pos.value, 1000, 'strongEaseOut');&#125;; 如果文本框输入 200，然后点击 moveBtn 按钮，可以看到小球顺利地移动到水平方向 200px的位置。现在我们需要一个方法让小球还原到开始移动之前的位置。当然也可以在文本框中再次输入-200，并且点击 moveBtn 按钮，这也是一个办法，不过显得很笨拙。页面上最好有一个撤销按钮，点击撤销按钮之后，小球便能回到上一次的位置。 在给页面中增加撤销按钮之前，先把目前的代码改为用命令模式实现： 12345678910111213141516var ball = document.getElementById( 'ball' );var pos = document.getElementById( 'pos' );var moveBtn = document.getElementById( 'moveBtn' );var MoveCommand = function( receiver, pos )&#123; this.receiver = receiver; this.pos = pos;&#125;;MoveCommand.prototype.execute = function()&#123; this.receiver.start( 'left', this.pos, 1000, 'strongEaseOut' );&#125;;var moveCommand;moveBtn.onclick = function()&#123; var animate = new Animate( ball ); moveCommand = new MoveCommand( animate, pos.value ); moveCommand.execute();&#125;; 接下来增加撤销按钮： 123456 &lt;body&gt; &lt;div id=\"ball\" style=\"position:absolute;background:#000;width:50px;height:50px\"&gt;&lt;/div&gt; 输入小球移动后的位置：&lt;input id=\"pos\"/&gt; &lt;button id=\"moveBtn\"&gt;开始移动&lt;/button&gt; &lt;button id=\"cancelBtn\"&gt;cancel&lt;/cancel&gt; &lt;!--增加取消按钮--&gt;&lt;/body&gt; 撤销操作的实现一般是给命令对象增加一个名为 unexecude 或者 undo 的方法，在该方法里执行 execute 的反向操作。在 command.execute 方法让小球开始真正运动之前，我们需要先记录小球的当前位置，在 unexecude 或者 undo 操作中，再让小球回到刚刚记录下的位置，代码如下： 1234567891011121314151617181920212223242526272829 &lt;script&gt; var ball = document.getElementById( 'ball' ); var pos = document.getElementById( 'pos' ); var moveBtn = document.getElementById( 'moveBtn' ); var cancelBtn = document.getElementById( 'cancelBtn' ); var MoveCommand = function( receiver, pos )&#123; this.receiver = receiver; this.pos = pos; this.oldPos = null; &#125;; MoveCommand.prototype.execute = function()&#123; this.receiver.start( 'left', this.pos, 1000, 'strongEaseOut' ); this.oldPos = this.receiver.dom.getBoundingClientRect()[ this.receiver.propertyName ]; // 记录小球开始移动前的位置 &#125;; MoveCommand.prototype.undo = function()&#123; this.receiver.start( 'left', this.oldPos, 1000, 'strongEaseOut' ); // 回到小球移动前记录的位置 &#125;; var moveCommand; moveBtn.onclick = function()&#123; var animate = new Animate( ball ); moveCommand = new MoveCommand( animate, pos.value ); moveCommand.execute(); &#125;; cancelBtn.onclick = function()&#123; moveCommand.undo(); // 撤销命令 &#125;;&lt;/script&gt; 现在通过命令模式轻松地实现了撤销功能。如果用普通的方法调用来实现，也许需要每次都手工记录小球的运动轨迹，才能让它还原到之前的位置。而命令模式中小球的原始位置在小球开始移动前已经作为 command 对象的属性被保存起来，所以只需要再提供一个 undo 方法，并且在 undo方法中让小球回到刚刚记录的原始位置就可以了。 撤销是命令模式里一个非常有用的功能，试想一下开发一个围棋程序的时候，我们把每一步棋子的变化都封装成命令，则可以轻而易举地实现悔棋功能。同样，撤销命令还可以用于实现文本编辑器的 Ctrl+Z 功能。 五、 撤消和重做上一节我们讨论了如何撤销一个命令。很多时候，我们需要撤销一系列的命令。比如在一个围棋程序中，现在已经下了 10 步棋，我们需要一次性悔棋到第 5 步。在这之前，我们可以把所有执行过的下棋命令都储存在一个历史列表中，然后倒序循环来依次执行这些命令的 undo 操作，直到循环执行到第 5 个命令为止。 然而，在某些情况下无法顺利地利用 undo 操作让对象回到 execute 之前的状态。比如在一个Canvas 画图的程序中，画布上有一些点，我们在这些点之间画了 N 条曲线把这些点相互连接起来，当然这是用命令模式来实现的。但是我们却很难为这里的命令对象定义一个擦除某条曲线的undo 操作，因为在 Canvas 画图中，擦除一条线相对不容易实现。 这时候最好的办法是先清除画布，然后把刚才执行过的命令全部重新执行一遍，这一点同样可以利用一个历史列表堆栈办到。记录命令日志，然后重复执行它们，这是逆转不可逆命令的一个好办法。 在 HTML5 版《街头霸王》游戏中，命令模式可以用来实现播放录像功能。原理跟 Canvas 画图的例子一样，我们把用户在键盘的输入都封装成命令，执行过的命令将被存放到堆栈中。播放录像的时候只需要从头开始依次执行这些命令便可，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html&gt;&lt;body&gt; &lt;button id=\"replay\"&gt;播放录像&lt;/button&gt;&lt;/body&gt; &lt;script&gt; var Ryu = &#123; attack: function()&#123; console.log( '攻击' ); &#125;, defense: function()&#123; console.log( '防御' ); &#125;, jump: function()&#123; console.log( '跳跃' ); &#125;, crouch: function()&#123; console.log( '蹲下' ); &#125; &#125;; var makeCommand = function( receiver, state )&#123; // 创建命令 return function()&#123; receiver[ state ](); &#125; &#125;; var commands = &#123; \"119\": \"jump\", // W \"115\": \"crouch\", // S \"97\": \"defense\", // A \"100\": \"attack\" // D &#125;; var commandStack = []; // 保存命令的堆栈 document.onkeypress = function( ev )&#123; var keyCode = ev.keyCode, command = makeCommand( Ryu, commands[ keyCode ] ); if ( command )&#123; command(); // 执行命令 commandStack.push( command ); // 将刚刚执行过的命令保存进堆栈 &#125; &#125;; document.getElementById( 'replay' ).onclick = function()&#123; // 点击播放录像 var command; while( command = commandStack.shift() )&#123; // 从堆栈里依次取出命令并执行 command(); &#125; &#125;;&lt;/script&gt;&lt;/html&gt; 可以看到，当我们在键盘上敲下 W、A、S、D 这几个键来完成一些动作之后，再按下 Replay按钮，此时便会重复播放之前的动作。 六、 命令队列在订餐的故事中，如果订单的数量过多而厨师的人手不够，则可以让这些订单进行排队处理。第一个订单完成之后，再开始执行跟第二个订单有关的操作。 队列在动画中的运用场景也非常多，比如之前的小球运动程序有可能遇到另外一个问题：有些用户反馈，这个程序只适合于 APM 小于 20 的人群，大部分用户都有快速连续点击按钮的习惯，当用户第二次点击 button 的时候，此时小球的前一个动画可能尚未结束，于是前一个动画会骤然停止，小球转而开始第二个动画的运动过程。但这并不是用户的期望，用户希望这两个动画会排队进行。 把请求封装成命令对象的优点在这里再次体现了出来，对象的生命周期几乎是永久的，除非我们主动去回收它。也就是说，命令对象的生命周期跟初始请求发生的时间无关，command 对象的 execute 方法可以在程序运行的任何时刻执行，即使点击按钮的请求早已发生，但我们的命令对象仍然是有生命的。 所以我们可以把 div 的这些运动过程都封装成命令对象，再把它们压进一个队列堆栈，当动画执行完，也就是当前 command 对象的职责完成之后，会主动通知队列，此时取出正在队列中等待的第一个命令对象，并且执行它。 我们比较关注的问题是，一个动画结束后该如何通知队列。通常可以使用回调函数来通知队列，除了回调函数之外，还可以选择发布订阅模式。即在一个动画结束后发布一个消息，订阅者接收到这个消息之后，便开始执行队列里的下一个动画。读者可以尝试按照这个思路来自行实现一个队列动画。 七、 宏命令宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，它就会帮我们关上房间门，顺便打开电脑并登录 QQ。 下面我们看看如何逐步创建一个宏命令。首先，我们依然要创建好各种 Command： 123456789101112131415var closeDoorCommand = &#123; execute: function () &#123; console.log('关门'); &#125;&#125;;var openPcCommand = &#123; execute: function () &#123; console.log('开电脑'); &#125;&#125;; var openQQCommand = &#123; execute: function () &#123; console.log('登录 QQ'); &#125;&#125;; 接下来定义宏命令 MacroCommand，它的结构也很简单。macroCommand.add 方法表示把子命令添加进宏命令对象，当调用宏命令对象的 execute 方法时，会迭代这一组子命令对象，并且依次执行它们的 execute 方法： 123456789101112131415161718var MacroCommand = function () &#123; return &#123; commandsList: [], add: function (command) &#123; this.commandsList.push(command); &#125;, execute: function () &#123; for (var i = 0, command; command = this.commandsList[i++];) &#123; command.execute(); &#125; &#125; &#125;&#125;;var macroCommand = MacroCommand();macroCommand.add(closeDoorCommand);macroCommand.add(openPcCommand);macroCommand.add(openQQCommand);macroCommand.execute(); 当然我们还可以为宏命令添加撤销功能，跟 macroCommand.execute 类似，当调用macroCommand.undo 方法时，宏命令里包含的所有子命令对象要依次执行各自的 undo 操作。 宏命令是命令模式与组合模式的联用产物，关于组合模式的知识，我们将在接下来的章节介绍。 八、 智能命令与傻瓜命令再看一下我们在上一节创建的命令： 12345var closeDoorCommand = &#123; execute: function()&#123; console.log( '关门' ); &#125;&#125;; 很奇怪，closeDoorCommand 中没有包含任何 receiver 的信息，它本身就包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个 receiver 是矛盾的。 一般来说，命令模式都会在 command 对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。 但是我们也可以定义一些更“聪明”的命令对象，“聪明”的命令对象可以直接实现请求，这样一来就不再需要接收者的存在，这种“聪明”的命令对象也叫作智能命令。没有接收者的智能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图的不同。策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对“算法”而言的。而智能命令模式指向的问题域更广，command对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。 九、 小结本章我们学习了命令模式。跟许多其他语言不同，JavaScript 可以用高阶函数非常方便地实现命令模式。命令模式在 JavaScript 语言中是一种隐形的模式。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践八（发布—订阅模式）","date":"2019-05-28T11:00:20.000Z","path":"2019/05/28/cjxe4h6q8001y6sup332iemsd/","text":"发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。 一、 现实中的发布－订阅模式不论是在程序世界里还是现实生活中，发布—订阅模式的应用都非常之广泛。我们先看一个现实中的例子。 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼MM 告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。 于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼 MM 决定辞职，因为厌倦了每天回答 1000 个相同内容的电话。 当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼 MM 会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。 二、 发布－订阅模式的作用在刚刚的例子中，发送短信通知就是一个典型的发布—订阅模式，小明、小红等购买者都是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话号码，依次给购房者发布消息。 可以发现，在这个例子中使用发布—订阅模式有着显而易见的优点。 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，不管购房者是男是女还是一只猴子。 而售楼处的任何变动也不会影响购买者，比如售楼 MM 离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。 第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax 请求的 error、succ 等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 三、 DOM 事件实际上，只要我们曾经在 DOM 节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式，来看看下面这两句简单的代码发生了什么事情： 1234document.body.addEventListener( 'click', function()&#123; alert(2);&#125;, false );document.body.click(); // 模拟用户点击 在这里需要监控用户点击 document.body 的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时，body 节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。 当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写： 12345678910document.body.addEventListener( 'click', function()&#123; alert(2);&#125;, false );document.body.addEventListener( 'click', function()&#123; alert(3);&#125;, false );document.body.addEventListener( 'click', function()&#123; alert(4);&#125;, false );document.body.click(); // 模拟用户点击 注意，手动触发事件更好的做法是 IE 下用 fireEvent，标准浏览器下用 dispatchEvent 实现。 四、 自定义事件除了 DOM 事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布—订阅模式可以用于任何 JavaScript 代码中。 现在看看如何一步步实现发布—订阅模式。 首先要指定好谁充当发布者（比如售楼处）； 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）； 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。 另外，我们还可以往回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里加上房子的单价、面积、容积率等信息，订阅者接收到这些信息之后可以进行各自的处理： 123456789101112131415161718192021var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function (fn) &#123; // 增加订阅者 this.clientList.push(fn); // 订阅的消息添加进缓存列表&#125;;salesOffices.trigger = function () &#123; // 发布消息 for (var i = 0, fn; fn = this.clientList[i++];) &#123; fn.apply(this, arguments); // (2) // arguments 是发布消息时带上的参数 &#125;&#125;;//下面我们来进行一些简单的测试：salesOffices.listen(function (price, squareMeter) &#123; // 小明订阅消息 console.log('价格= ' + price); console.log('squareMeter= ' + squareMeter);&#125;);salesOffices.listen(function (price, squareMeter) &#123; // 小红订阅消息 console.log('价格= ' + price); console.log('squareMeter= ' + squareMeter);&#125;);salesOffices.trigger(2000000, 88); // 输出：200 万，88 平方米salesOffices.trigger(3000000, 110); // 输出：300 万，110 平方米 至此，我们已经实现了一个最简单的发布—订阅模式，但这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买 88 平方米的房子，但是发布者把 110 平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示 key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下： 1234567891011121314151617181920212223242526var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = &#123;&#125;; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function (key, fn) &#123; if (!this.clientList[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表&#125;;salesOffices.trigger = function () &#123; // 发布消息 var key = Array.prototype.shift.call(arguments), // 取出消息类型 fns = this.clientList[key]; // 取出该消息对应的回调函数集合 if (!fns || fns.length === 0) &#123; // 如果没有订阅该消息，则返回 return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); // (2) // arguments 是发布消息时附送的参数 &#125;&#125;;salesOffices.listen('squareMeter88', function (price) &#123; // 小明订阅 88 平方米房子的消息 console.log('价格= ' + price); // 输出： 2000000&#125;);salesOffices.listen('squareMeter110', function (price) &#123; // 小红订阅 110 平方米房子的消息 console.log('价格= ' + price); // 输出： 3000000&#125;);salesOffices.trigger('squareMeter88', 2000000); // 发布 88 平方米房子的价格salesOffices.trigger('squareMeter110', 3000000); // 发布 110 平方米房子的价格 很明显，现在订阅者可以只订阅自己感兴趣的事件了。 五、 发布－订阅模式的通用实现现在我们已经看到了如何让售楼处拥有接受订阅和发布事件的功能。假设现在小明又去另一个售楼处买房子，那么这段代码是否必须在另一个售楼处对象上重写一次呢，有没有办法可以让所有对象都拥有发布—订阅功能呢？ 答案显然是有的，JavaScript 作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。 所以我们把发布—订阅的功能提取出来，放在一个单独的对象内： 12345678910111213141516171819var event = &#123; clientList: [], listen: function (key, fn) &#123; if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进缓存列表 &#125;, trigger: function () &#123; var key = Array.prototype.shift.call(arguments), // (1); fns = this.clientList[key]; if (!fns || fns.length === 0) &#123; // 如果没有绑定对应的消息 return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); // (2) // arguments 是 trigger 时带上的参数 &#125; &#125;&#125;; 再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布—订阅功能： 12345var installEvent = function (obj) &#123; for (var i in event) &#123; obj[i] = event[i]; &#125;&#125;; 再来测试一番，我们给售楼处对象 salesOffices 动态增加发布—订阅功能： 12345678910var salesOffices = &#123;&#125;;installEvent(salesOffices);salesOffices.listen('squareMeter88', function (price) &#123; // 小明订阅消息 console.log('价格= ' + price);&#125;);salesOffices.listen('squareMeter100', function (price) &#123; // 小红订阅消息 console.log('价格= ' + price);&#125;);salesOffices.trigger('squareMeter88', 2000000); // 输出：2000000salesOffices.trigger('squareMeter100', 3000000); // 输出：3000000 六、 取消订阅的事件有时候，我们也许需要取消订阅事件的功能。比如小明突然不想买房子了，为了避免继续接收到售楼处推送过来的短信，小明需要取消之前订阅的事件。现在我们给 event 对象增加 remove方法： 12345678910111213141516171819202122232425262728293031event.remove = function (key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; // 如果 key 对应的消息没有被人订阅，则直接返回 return false; &#125; if (!fn) &#123; // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; // 反向遍历订阅的回调函数列表 var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); // 删除订阅者的回调函数 &#125; &#125; &#125;&#125;;var salesOffices = &#123;&#125;;var installEvent = function (obj) &#123; for (var i in event) &#123; obj[i] = event[i]; &#125;&#125;installEvent(salesOffices);salesOffices.listen('squareMeter88', fn1 = function (price) &#123; // 小明订阅消息 console.log('价格= ' + price);&#125;);salesOffices.listen('squareMeter88', fn2 = function (price) &#123; // 小红订阅消息 console.log('价格= ' + price);&#125;);salesOffices.remove('squareMeter88', fn1); // 删除小明的订阅salesOffices.trigger('squareMeter88', 2000000); // 输出：2000000 七、 真实的例子——网站登录通过售楼处的虚拟例子，我们对发布—订阅模式的概念和实现都已经熟悉了，那么现在就趁热打铁，看一个真实的项目。 假如我们正在开发一个商城网站，网站里有 header 头部、nav 导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用 ajax 异步请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在 header 模块里，而这两个字段都来自用户登录后返回的信息。 至于 ajax 请求什么时候能成功返回用户信息，这点我们没有办法确定。现在的情节看起来像极了售楼处的例子，小明不知道什么时候开发商的售楼手续能够成功办下来。 但现在还不足以说服我们在此使用发布—订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，我们不知道除了 header 头部、nav 导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式： 123456login.succ(function(data)&#123; header.setAvatar( data.avatar); // 设置 header 模块的头像 nav.setAvatar( data.avatar ); // 设置导航模块的头像 message.refresh(); // 刷新消息列表 cart.refresh(); // 刷新购物车列表&#125;); 现在登录模块是我们负责编写的，但我们还必须了解 header 模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫 refresh，这种耦合性会使程序变得僵硬，header 模块不能随意再改变 setAvatar 的方法名，它自身的名字也不能被改为 header1、header2。 这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。 等到有一天，项目中又新增了一个收货地址管理的模块，这个模块本来是另一个同事所写的，而此时你正在马来西亚度假，但是他却不得不给你打电话：“Hi，登录之后麻烦刷新一下收货地址列表。”于是你又翻开你 3 个月前写的登录模块，在最后部分加上这行代码： 1234567login.succ(function( data )&#123; header.setAvatar( data.avatar); nav.setAvatar( data.avatar ); message.refresh(); cart.refresh(); address.refresh(); // 增加这行代码&#125;); 我们就会越来越疲于应付这些突如其来的业务要求，要么跳槽了事，要么必须来重构这些代码。 用发布—订阅模式重写之后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码如下： 123$.ajax( 'http:// xxx.com?login', function(data)&#123; // 登录成功 login.trigger( 'loginSucc', data); // 发布登录成功的消息&#125;); 各模块监听登录成功的消息： 1234567891011121314151617181920var header = (function()&#123; // header 模块 login.listen( 'loginSucc', function( data)&#123; header.setAvatar( data.avatar ); &#125;); return &#123; setAvatar: function( data )&#123; console.log( '设置 header 模块的头像' ); &#125; &#125;&#125;)();var nav = (function()&#123; // nav 模块 login.listen( 'loginSucc', function( data )&#123; nav.setAvatar( data.avatar ); &#125;); return &#123; setAvatar: function( avatar )&#123; console.log( '设置 nav 模块的头像' ); &#125; &#125;&#125;)(); 如上所述，我们随时可以把 setAvatar 的方法名改成 setTouxiang。如果有一天在登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用再关心这些行为了。代码如下： 12345678910var address = (function()&#123; // nav 模块 login.listen( 'loginSucc', function( obj )&#123; address.refresh( obj ); &#125;); return &#123; refresh: function( avatar )&#123; console.log( '刷新收货地址列表' ); &#125; &#125;&#125;)(); 八、 全局的发布－订阅对象回想下刚刚实现的发布—订阅模式，我们给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题。 我们给每个发布者对象都添加了 listen 和 trigger 方法，以及一个缓存列表 clientList，这其实是一种资源浪费。 小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。见如下代码：123salesOffices.listen( 'squareMeter100', function( price )&#123; // 小明订阅消息 console.log( '价格= ' + price );&#125;); 如果小明还关心 300 平方米的房子，而这套房子的卖家是 salesOffices2，这意味着小明要开始订阅 salesOffices2 对象。见如下代码： 123salesOffices2.listen( 'squareMeter300', function( price )&#123; // 小明订阅消息 console.log( '价格= ' + price );&#125;); 其实在现实中，买房子未必要亲自去售楼处，我们只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，我们不用关心消息是来自哪个房产公司，我们在意的是能否顺利收到消息。当然，为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司。 同样在程序中，发布—订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来。见如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var Event = (function () &#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function (key, fn) &#123; if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function () &#123; var key = Array.prototype.shift.call(arguments), fns = clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();Event.listen('squareMeter88', function (price) &#123; // 小红订阅消息 console.log('价格= ' + price); // 输出：'价格=2000000'&#125;);Event.trigger('squareMeter88', 2000000); // 售楼处发布消息 九、 模块间通信上一节中实现的发布—订阅模式的实现，是基于一个全局的 Event 对象，我们利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在。就如同有了中介公司之后，我们不再需要知道房子开售的消息来自哪个售楼处。 比如现在有两个模块，a 模块里面有一个按钮，每次点击按钮之后，b 模块里的 div 中会显示按钮的总点击次数，我们用全局发布—订阅模式完成下面的代码，使得 a 模块和 b 模块可以在保持封装性的前提下进行通信。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button id=\"count\"&gt;点我&lt;/button&gt; &lt;div id=\"show\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/JavaScript\"&gt; var a = (function()&#123; var count = 0; var button = document.getElementById( 'count' ); button.onclick = function()&#123; Event.trigger( 'add', count++ ); &#125; &#125;)(); var b = (function()&#123; var div = document.getElementById( 'show' ); Event.listen( 'add', function( count )&#123; div.innerHTML = count; &#125;); &#125;)();&lt;/script&gt;&lt;/html&gt; 但在这里我们要留意另一个问题，模块之间如果用了太多的全局发布—订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给我们的维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用。 十、 必须先订阅再发布吗我们所了解到的发布—订阅模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的消息。如果把顺序反过来，发布者先发布一条消息，而在此之前并没有对象来订阅它，这条消息无疑将消失在宇宙中。 在某些情况下，我们需要先将这条消息保存下来，等到有对象来订阅它的时候，再重新把消息发布给订阅者。就如同 QQ 中的离线消息一样，离线消息被保存在服务器中，接收人下次登录上线之后，可以重新收到这条消息。 这种需求在实际项目中是存在的，比如在之前的商城网站中，获取到用户信息之后才能渲染用户导航模块，而获取用户信息的操作是一个 ajax 异步请求。当 ajax 请求成功返回之后会发布一个事件，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息。 但是这只是理想的状况，因为异步的原因，我们不能保证 ajax 请求返回的时间，有时候它返回得比较快，而此时用户导航模块的代码还没有加载好（还没有订阅相应事件），特别是在用了一些模块化惰性加载的技术后，这是很可能发生的事情。也许我们还需要一个方案，使得我们的发布—订阅对象拥有先发布后订阅的能力。 为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像 QQ 的未读消息只会被重新阅读一次，所以刚才的操作我们只能进行一次。 十一、 全局事件的命名冲突全局的发布—订阅对象里只有一个 clinetList 来存放消息名和回调函数，大家都通过它来订阅和发布各种消息，久而久之，难免会出现事件名冲突的情况，所以我们还可以给 Event 对象提供创建命名空间的功能。 在提供最终的代码之前，我们来感受一下怎么使用这两个新增的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/************** 先发布后订阅 ********************/Event.trigger('click', 1);Event.listen('click', function (a) &#123; console.log(a); // 输出：1&#125;);/************** 使用命名空间 ********************/Event.create('namespace1').listen('click', function (a) &#123; console.log(a); // 输出：1&#125;);Event.create('namespace1').trigger('click', 1);Event.create('namespace2').listen('click', function (a) &#123; console.log(a); // 输出：2&#125;);Event.create('namespace2').trigger('click', 2);//具体实现代码如下：var Event = (function () &#123; var global = this, Event, _default = 'default'; Event = function () &#123; var _listen, _trigger, _remove, _slice = Array.prototype.slice, _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, namespaceCache = &#123;&#125;, _create, find, each = function (ary, fn) &#123; var ret; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; var n = ary[i]; ret = fn.call(n, i, n); &#125; return ret; &#125;; _listen = function (key, fn, cache) &#123; if (!cache[key]) &#123; cache[key] = []; &#125; cache[key].push(fn); &#125;; _remove = function (key, cache, fn) &#123; if (cache[key]) &#123; if (fn) &#123; for (var i = cache[key].length; i &gt;= 0; i--) &#123; if (cache[key][i] === fn) &#123; cache[key].splice(i, 1); &#125; &#125; &#125; else &#123; cache[key] = []; &#125; &#125; &#125;; _trigger = function () &#123; var cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _self = this, ret, stack = cache[key]; if (!stack || !stack.length) &#123; return; &#125; return each(stack, function () &#123; return this.apply(_self, args); &#125;); &#125;; _create = function (namespace) &#123; var namespace = namespace || _default; var cache = &#123;&#125;, offlineStack = [], // 离线事件 ret = &#123; listen: function (key, fn, last) &#123; _listen(key, fn, cache); if (offlineStack === null) &#123; return; &#125; if (last === 'last') &#123; offlineStack.length &amp;&amp; offlineStack.pop()(); &#125; else &#123; each(offlineStack, function () &#123; this(); &#125;); &#125; offlineStack = null; &#125;, one: function (key, fn, last) &#123; _remove(key, cache); this.listen(key, fn, last); &#125;, remove: function (key, fn) &#123; _remove(key, cache, fn); &#125;, trigger: function () &#123; var fn, args, _self = this; _unshift.call(arguments, cache); args = arguments; fn = function () &#123; return _trigger.apply(_self, args); &#125;; if (offlineStack) &#123; return offlineStack.push(fn); &#125; return fn(); &#125; &#125;; return namespace ? (namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret) : ret; &#125;; return &#123; create: _create, one: function (key, fn, last) &#123; var event = this.create(); event.one(key, fn, last); &#125;, remove: function (key, fn) &#123; var event = this.create(); event.remove(key, fn); &#125;, listen: function (key, fn, last) &#123; var event = this.create(); event.listen(key, fn, last); &#125;, trigger: function () &#123; var event = this.create(); event.trigger.apply(this, arguments); &#125; &#125;; &#125;(); return Event;&#125;)(); 十二、 JavaScript 实现发布－订阅模式的便利性这里要提出的是，我们一直讨论的发布—订阅模式，跟一些别的语言（比如 Java）中的实现还是有区别的。在 Java 中实现一个自己的发布—订阅模式，通常会把订阅者对象自身当成引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如 update 的方法，供发布者对象在适合的时候调用。而在 JavaScript 中，我们用注册回调函数的形式来代替传统的发布—订阅模式，显得更加优雅和简单。 另外，在 JavaScript 中，我们无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的地方是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个“门户大开”的对象，同时增加了代码量和复杂度。 刚好在 JavaScript 中，arguments 可以很方便地表示参数列表，所以我们一般都会选择推模型，使用 Function.prototype.apply 方法把所有参数都推送给订阅者。 十三、 小结本章我们学习了发布—订阅模式，也就是常说的观察者模式。发布—订阅模式在实际开发中非常有用。 发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是 MVC 还是 MVVM，都少不了发布—订阅模式的参与，而且 JavaScript 本身也是一门基于事件驱动的语言。 当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践七（迭代器模式）","date":"2019-05-24T02:39:20.000Z","path":"2019/05/24/cjxe4h6jr000n6supbjgopyqk/","text":"迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 目前，恐怕只有在一些“古董级”的语言中才会为实现一个迭代器模式而烦恼，现在流行的大部分语言如 Java、Ruby 等都已经有了内置的迭代器实现，许多浏览器也支持 JavaScript 的Array.prototype.forEach。 一、 jQuery 中的迭代器迭代器模式无非就是循环访问聚合对象中的各个元素。比如 jQuery 中的$.each 函数，其中回调函数中的参数 i 为当前索引，n 为当前元素，代码如下： 1234$.each( [1, 2, 3], function( i, n )&#123; console.log( '当前下标为： '+ i ); console.log( '当前值为:' + n );&#125;); 二、 实现自己的迭代器现在我们来自己实现一个 each 函数，each 函数接受 2 个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数： 12345678var each = function (ary, callback) &#123; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; callback.call(ary[i], i, ary[i]); // 把下标和元素当作参数传给 callback 函数 &#125;&#125;;each([1, 2, 3], function (i, n) &#123; console.log([i, n]);&#125;); 三、 内部迭代器和外部迭代器迭代器可以分为内部迭代器和外部迭代器，它们有各自的适用场景。这一节我们将分别讨论这两种迭代器。 3.1 内部迭代器我们刚刚编写的 each 函数属于内部迭代器，each 函数的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。 内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的 each 函数就无法同时迭代 2 个数组了。 比如现在有个需求，要判断 2 个数组里元素的值是否完全相等， 如果不改写 each 函数本身的代码，我们能够入手的地方似乎只剩下 each 的回调函数了，代码如下： 123456789101112var compare = function (ary1, ary2) &#123; if (ary1.length !== ary2.length) &#123; throw new Error('ary1 和 ary2 不相等'); &#125; each(ary1, function (i, n) &#123; if (n !== ary2[i]) &#123; throw new Error('ary1 和 ary2 不相等'); &#125; &#125;); alert('ary1 和 ary2 相等');&#125;;compare([1, 2, 3], [1, 2, 4]); // throw new Error ( 'ary1 和 ary2 不相等' ); 说实话，这个 compare 函数一点都算不上好看，我们目前能够顺利完成需求，还要感谢在JavaScript 里可以把函数当作参数传递的特性，但在其他语言中未必就能如此幸运。 在一些没有闭包的语言中，内部迭代器本身的实现也相当复杂。比如 C 语言中的内部迭代器是用函数指针来实现的，循环处理所需要的数据都要以参数的形式明确地从外面传递进去。 3.2 外部迭代器外部迭代器必须显式地请求迭代下一个元素。 外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。 下面这个外部迭代器的实现来自《松本行弘的程序世界》第 4 章，原例用 Ruby 写成，这里我们翻译成 JavaScript： 1234567891011121314151617var Iterator = function (obj) &#123; var current = 0; var next = function () &#123; current += 1; &#125;; var isDone = function () &#123; return current &gt;= obj.length; &#125;; var getCurrItem = function () &#123; return obj[current]; &#125;; return &#123; next: next, isDone: isDone, getCurrItem: getCurrItem &#125;&#125;; 再看看如何改写 compare 函数： 12345678910111213var compare = function (iterator1, iterator2) &#123; while (!iterator1.isDone() &amp;&amp; !iterator2.isDone()) &#123; if (iterator1.getCurrItem() !== iterator2.getCurrItem()) &#123; throw new Error('iterator1 和 iterator2 不相等'); &#125; iterator1.next(); iterator2.next(); &#125; alert('iterator1 和 iterator2 相等');&#125;var iterator1 = Iterator([1, 2, 3]);var iterator2 = Iterator([1, 2, 3]);compare(iterator1, iterator2); // 输出：iterator1 和 iterator2 相等 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。内部迭代器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定。 四、 迭代类数组对象和字面量对象迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象。比如 arguments、{“0”:’a’,”1”:’b’}等。通过上面的代码可以观察到，无论是内部迭代器还是外部迭代器，只要被迭代的聚合对象拥有 length 属性而且可以用下标访问，那它就可以被迭代。 JavaScript 中，for in 语句可以用来迭代普通字面量对象的属性。jQuery 中提供了$.each`函数来封装各种迭代行为： 12345678910111213141516171819202122$.each = function (obj, callback) &#123; var value, i = 0, length = obj.length, isArray = isArraylike(obj); if (isArray) &#123; // 迭代类数组 for (; i &lt; length; i++) &#123; value = callback.call(obj[i], i, obj[i]); if (value === false) &#123; break; &#125; &#125; &#125; else &#123; for (i in obj) &#123; // 迭代 object 对象 value = callback.call(obj[i], i, obj[i]); if (value === false) &#123; break; &#125; &#125; &#125; return obj;&#125;; 五、 倒序迭代器由于 GoF 中对迭代器模式的定义非常松散，所以我们可以有多种多样的迭代器实现。总的来说， 迭代器模式提供了循环访问一个聚合对象中每个元素的方法，但它没有规定我们以顺序、倒序还是中序来循环遍历聚合对象。 下面我们分分钟实现一个倒序访问的迭代器： 12345678var reverseEach = function( ary, callback )&#123; for ( var l = ary.length - 1; l &gt;= 0; l-- )&#123; callback( l, ary[ l ] ); &#125; &#125;;reverseEach( [ 0, 1, 2 ], function( i, n )&#123; console.log( n ); // 分别输出：2, 1 ,0&#125;); 六、 中止迭代器迭代器可以像普通 for 循环中的 break 一样，提供一种跳出循环的方法。在前面 jQuery 的each 函数里有这样一句： 123if ( value === false ) &#123; break;&#125; 这句代码的意思是，约定如果回调函数的执行结果返回 false，则提前终止循环。下面我们把之前的 each 函数改写一下： 12345678910111213var each = function( ary, callback )&#123; for ( var i = 0, l = ary.length; i &lt; l; i++ )&#123; if ( callback( i, ary[ i ] ) === false )&#123; // callback 的执行结果返回 false，提前终止迭代 break; &#125; &#125;&#125;;each( [ 1, 2, 3, 4, 5 ], function( i, n )&#123; if ( n &gt; 3 )&#123; // n 大于 3 的时候终止循环 return false; &#125; console.log( n ); // 分别输出：1, 2, 3&#125;); 七、 迭代器模式的应用举例先看一下代码： 12345678910111213var getUploadObj = function()&#123; try&#123; return new ActiveXObject(\"TXFTNActiveX.FTNUpload\"); // IE 上传控件 &#125;catch(e)&#123; if ( supportFlash() )&#123; // supportFlash 函数未提供 var str = '&lt;object type=\"application/x-shockwave-flash\"&gt;&lt;/object&gt;'; return $( str ).appendTo( $('body') ); &#125;else&#123; var str = '&lt;input name=\"file\" type=\"file\"/&gt;'; // 表单上传 return $( str ).appendTo( $('body') ); &#125; &#125;&#125;; 在不同的浏览器环境下，选择的上传方式是不一样的。因为使用浏览器的上传控件进行上传速度快，可以暂停和续传，所以我们首先会优先使用控件上传。如果浏览器没有安装上传控件，则使用 Flash 上传， 如果连 Flash 也没安装，那就只好使用浏览器原生的表单上传了。 看看上面的代码，为了得到一个 upload 对象，这个 getUploadObj 函数里面充斥了 try，catch以及 if 条件分支。缺点是显而易见的。第一是很难阅读，第二是严重违反开闭原则。 在开发和调试过程中，我们需要来回切换不同的上传方式，每次改动都相当痛苦。后来我们还增加支持了一些另外的上传方式，比如，HTML5 上传，这时候唯一的办法是继续往 getUploadObj 函数里增加条件分支。 现在来梳理一下问题，目前一共有 3 种可能的上传方式，我们不知道目前正在使用的浏览器支持哪几种。就好比我们有一个钥匙串，其中共有 3 把钥匙，我们想打开一扇门但是不知道该使用哪把钥匙，于是从第一把钥匙开始，迭代钥匙串进行尝试，直到找到了正确的钥匙为止。 同样，我们把每种获取 upload 对象的方法都封装在各自的函数里，然后使用一个迭代器，迭代获取这些 upload 对象，直到获取到一个可用的为止： 123456789101112131415161718var getActiveUploadObj = function()&#123; try&#123; return new ActiveXObject( \"TXFTNActiveX.FTNUpload\" ); // IE 上传控件 &#125;catch(e)&#123; return false; &#125;&#125;;var getFlashUploadObj = function()&#123; if ( supportFlash() )&#123; // supportFlash 函数未提供 var str = '&lt;object type=\"application/x-shockwave-flash\"&gt;&lt;/object&gt;'; return $( str ).appendTo( $('body') ); &#125; return false;&#125;;var getFormUpladObj = function()&#123; var str = '&lt;input name=\"file\" type=\"file\" class=\"ui-file\"/&gt;'; // 表单上传 return $( str ).appendTo( $('body') );&#125;; 在 getActiveUploadObj、getFlashUploadObj、getFormUpladObj 这 3 个函数中都有同一个约定：如果该函数里面的 upload 对象是可用的，则让函数返回该对象，反之返回 false，提示迭代器继续往后面进行迭代。 所以我们的迭代器只需进行下面这几步工作。 提供一个可以被迭代的方法，使得 getActiveUploadObj，getFlashUploadObj 以及 getFlashUploadObj依照优先级被循环迭代。 如果正在被迭代的函数返回一个对象，则表示找到了正确的 upload 对象，反之如果该函数返回 false，则让迭代器继续工作。 迭代器代码如下： 123456789var iteratorUploadObj = function()&#123; for ( var i = 0, fn; fn = arguments[ i++ ]; )&#123; var uploadObj = fn(); if ( uploadObj !== false )&#123; return uploadObj; &#125; &#125;&#125;;var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpladObj ); 重构代码之后，我们可以看到，获取不同上传对象的方法被隔离在各自的函数里互不干扰，try、catch 和 if 分支不再纠缠在一起，使得我们可以很方便地的维护和扩展代码。比如，后来我们又给上传项目增加了 Webkit 控件上传和 HTML5 上传，我们要做的仅仅是下面一些工作。 增加分别获取 Webkit 控件上传对象和 HTML5 上传对象的函数： 123456var getWebkitUploadObj = function()&#123;// 具体代码略&#125;;var getHtml5UploadObj = function()&#123;// 具体代码略&#125;; 依照优先级把它们添加进迭代器： 1var uploadObj = iteratorUploadObj( getActiveUploadObj, getWebkitUploadObj, getFlashUploadObj, getHtml5UploadObj, getFormUpladObj );","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践六（代理模式）","date":"2019-05-23T03:30:20.000Z","path":"2019/05/23/cjxe4h6ps001o6sup1sxmit0e/","text":"代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 代理模式是一种非常有意义的模式，在生活中可以找到很多代理模式的场景。比如，明星都有经纪人作为代理。如果想请明星来办一场商业演出，只能联系他的经纪人。经纪人会把商业演出的细节和报酬都谈好之后，再把合同交给明星签。 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。如图 6-1 和图 6-2 所示。 下面我们通过几个例子来详细说明。 一、 代理模式第一个例子下面我们从一个小例子开始熟悉代理模式的结构。 在四月一个晴朗的早晨，小明遇见了他的百分百女孩，我们暂且称呼小明的女神为A。两天之后，小明决定给 A 送一束花来表白。刚好小明打听到 A 和他有一个共同的朋友 B，于是内向的小明决定让 B 来代替自己完成送花这件事情。 接下来先用代码来描述一下小明追女神的过程，先看看不用代理模式的情况： 1234567891011121314151617181920212223242526272829303132var Flower = function () &#123; &#125;;var xiaoming = &#123; sendFlower: function (target) &#123; var flower = new Flower(); target.receiveFlower(flower); &#125;&#125;;var A = &#123; receiveFlower: function (flower) &#123; console.log('收到花 ' + flower); &#125;&#125;;xiaoming.sendFlower(A);//接下来，我们引入代理 B，即小明通过 B 来给 A 送花：var Flower = function () &#123; &#125;;var xiaoming = &#123; sendFlower: function (target) &#123; var flower = new Flower(); target.receiveFlower(flower); &#125;&#125;;var B = &#123; receiveFlower: function (flower) &#123; A.receiveFlower(flower); &#125;&#125;;var A = &#123; receiveFlower: function (flower) &#123; console.log('收到花 ' + flower); &#125;&#125;;xiaoming.sendFlower(B); 很显然，执行结果跟第一段代码一致，至此我们就完成了一个最简单的代理模式的编写。 也许读者会疑惑，小明自己去送花和代理 B 帮小明送花，二者看起来并没有本质的区别，引入一个代理对象看起来只是把事情搞复杂了而已。 的确，此处的代理模式毫无用处，它所做的只是把请求简单地转交给本体。但不管怎样，我们开始引入了代理，这是一个不错的起点。 现在我们改变故事的背景设定，假设当 A 在心情好的时候收到花，小明表白成功的几率有60%，而当 A 在心情差的时候收到花，小明表白的成功率无限趋近于 0。 小明跟 A 刚刚认识两天，还无法辨别 A 什么时候心情好。如果不合时宜地把花送给 A，花被直接扔掉的可能性很大，这束花可是小明吃了 7 天泡面换来的。 但是 A 的朋友 B 却很了解 A，所以小明只管把花交给 B，B 会监听 A 的心情变化，然后选择 A 心情好的时候把花转交给 A，代码如下： 12345678910111213141516171819202122232425var Flower = function () &#123; &#125;;var xiaoming = &#123; sendFlower: function (target) &#123; var flower = new Flower(); target.receiveFlower(flower); &#125;&#125;;var B = &#123; receiveFlower: function (flower) &#123; A.listenGoodMood(function () &#123; // 监听 A 的好心情 A.receiveFlower(flower); &#125;); &#125;&#125;;var A = &#123; receiveFlower: function (flower) &#123; console.log('收到花 ' + flower); &#125;, listenGoodMood: function (fn) &#123; setTimeout(function () &#123; // 假设 10 秒之后 A 的心情变好 fn(); &#125;, 10000); &#125;&#125;;xiaoming.sendFlower(B); 二、 保护代理和虚拟代理虽然这只是个虚拟的例子，但我们可以从中找到两种代理模式的身影。代理 B 可以帮助 A过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理 B处被拒绝掉。这种代理叫作保护代理。A 和 B 一个充当白脸，一个充当黑脸。白脸 A 继续保持良好的女神形象，不希望直接拒绝任何人，于是找了黑脸 B 来控制对 A 的访问。 另外，假设现实中的花价格不菲，导致在程序世界里，new Flower 也是一个代价昂贵的操作，那么我们可以把 new Flower 的操作交给代理 B 去执行，代理 B 会选择在 A 心情好时再执行 newFlower，这是代理模式的另一种形式，叫作虚拟代理。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。代码如下： 12345678var B = &#123; receiveFlower: function( flower )&#123; A.listenGoodMood(function()&#123; // 监听 A 的好心情 var flower = new Flower(); // 延迟创建 flower 对象 A.receiveFlower( flower ); &#125;); &#125;&#125;; 保护代理用于控制不同权限的对象对目标对象的访问，但在 JavaScript 并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式，本章主要讨论的也是虚拟代理。 当然上面只是一个虚拟的例子，我们无需在此投入过多近精力，接下来我们看另外一个真实的示例。 三、 虚拟代理实现图片预加载在 Web 开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src 属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里，这种场景就很适合使用虚拟代理。 下面我们来实现这个虚拟代理，首先创建一个普通的本体对象，这个对象负责往页面中创建一个 img 标签，并且提供一个对外的 setSrc 接口，外界调用这个接口，便可以给该 img 标签设置src 属性： 12345678910var myImage = (function () &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function (src) &#123; imgNode.src = src; &#125; &#125;&#125;)();myImage.setSrc('http://pic35.nipic.com/20131115/13972544_160943053001_2.jpg'); 我们把网速调至 5KB/s，然后通过 MyImage.setSrc 给该 img 节点设置 src，可以看到，在图片被加载好之前，页面中有一段长长的空白时间。 现在开始引入代理对象 proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中将出现一张占位的菊花图 loading.gif, 来提示用户图片正在加载。代码如下： 1234567891011121314151617181920212223var myImage = (function () &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function (src) &#123; imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function () &#123; var img = new Image; img.onload = function () &#123; myImage.setSrc(this.src); &#125; return &#123; setSrc: function (src) &#123; myImage.setSrc('../images/loading.gif'); img.src = src; &#125; &#125;&#125;)();console.log(proxyImage.setSrc)proxyImage.setSrc('http://pic35.nipic.com/20131115/13972544_160943053001_2.jpg'); 现在我们通过 proxyImage 间接地访问 MyImage。proxyImage 控制了客户对 MyImage 的访问，并且在此过程中加入一些额外的操作，比如在真正的图片加载好之前，先把 img 节点的 src 设置为一张本地的 loading 图片。 四、 代理的意义也许读者会有疑问，不过是实现一个小小的图片预加载功能，即使不需要引入任何模式也能办到，那么引入代理模式的好处究竟在哪里呢？下面我们先抛开代理，编写一个更常见的图片预加载函数。 不用代理的预加载图片函数实现如下： 123456789101112131415var MyImage = (function () &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); var img = new Image; img.onload = function () &#123; imgNode.src = img.src; &#125;; return &#123; setSrc: function (src) &#123; imgNode.src = 'file:// /C:/Users/svenzeng/Desktop/loading.gif'; img.src = src; &#125; &#125;&#125;)();MyImage.setSrc('http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg'); 为了说明代理的意义，下面我们引入一个面向对象设计的原则——单一职责原则。 单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。 职责被定义为“引起变化的原因”。上段代码中的 MyImage 对象除了负责给 img 节点设置 src外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现。 另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放—封闭原则。如果我们只是从网络上获取一些体积很小的图片，或者 5 年后的网速快到根本不再需要预加载，我们可能希望把预加载图片的这段代码从 MyImage 对象里删掉。这时候就不得不改动MyImage 对象了。 实际上，我们需要的只是给 img 节点设置 src，预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就体现出来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体 MyImage。 纵观整个程序，我们并没有改变或者增加 MyImage 的接口，但是通过代理对象，实际上给系统添加了新的行为。这是符合开放—封闭原则的。给 img 节点设置 src 和图片预加载这两个功能，被隔离在两个对象里，它们可以各自变化而不影响对方。何况就算有一天我们不再需要预加载，那么只需要改成请求本体而不是请求代理对象即可。 五、 代理和本体接口的一致性上一节说到，如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 setSrc 方法，在客户看来，代理对象和本体是一致的， 代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这样做有两个好处。 用户可以放心地请求代理，他只关心是否能得到想要的结果。 在任何使用本体的地方都可以替换成使用代理。 在 Java 等语言中，代理和本体都需要显式地实现同一个接口，一方面接口保证了它们会拥有同样的方法，另一方面，面向接口编程迎合依赖倒置原则，通过接口进行向上转型，从而避开编译器的类型检查，代理和本体将来可以被替换使用。 在 JavaScript 这种动态类型语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了setSrc 方法，另外大多数时候甚至干脆不做检测，全部依赖程序员的自觉性，这对于程序的健壮性是有影响的。不过对于一门快速开发的脚本语言，这些影响还是在可以接受的范围内，而且我们也习惯了没有接口的世界。 另外值得一提的是，如果代理对象和本体对象都为一个函数（函数也是对象），函数必然都能被执行，则可以认为它们也具有一致的“接口”，代码如下： 123456789101112131415161718var myImage = (function () &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return function (src) &#123; imgNode.src = src; &#125;&#125;)();var proxyImage = (function () &#123; var img = new Image; img.onload = function () &#123; myImage(this.src); &#125; return function (src) &#123; myImage('file:// /C:/Users/svenzeng/Desktop/loading.gif'); img.src = src; &#125;&#125;)();proxyImage('http:// imgcache.qq.com/music// N/k/000GGDys0yA0Nk.jpg'); 六、 虚拟代理合并 HTTP 请求先想象这样一个场景：每周我们都要写一份工作周报，周报要交给总监批阅。总监手下管理着 150 个员工，如果我们每个人直接把周报发给总监，那总监可能要把一整周的时间都花在查看邮件上面。 现在我们把周报发给各自的组长，组长作为代理，把组内成员的周报合并提炼成一份后一次性地发给总监。这样一来，总监的邮箱便清净多了。 这个例子在程序世界里很容易引起共鸣，在 Web 开发中，也许最大的开销就是网络请求。假设我们在做一个文件同步的功能，当我们选中一个 checkbox 的时候，它对应的文件就会被同步到另外一台备用服务器上面，如图 6-3 所示。 我们先在页面中放置好这些 checkbox 节点： 1234567891011&lt;body&gt; &lt;input type=\"checkbox\" id=\"1\"&gt;&lt;/input&gt;1 &lt;input type=\"checkbox\" id=\"2\"&gt;&lt;/input&gt;2 &lt;input type=\"checkbox\" id=\"3\"&gt;&lt;/input&gt;3 &lt;input type=\"checkbox\" id=\"4\"&gt;&lt;/input&gt;4 &lt;input type=\"checkbox\" id=\"5\"&gt;&lt;/input&gt;5 &lt;input type=\"checkbox\" id=\"6\"&gt;&lt;/input&gt;6 &lt;input type=\"checkbox\" id=\"7\"&gt;&lt;/input&gt;7 &lt;input type=\"checkbox\" id=\"8\"&gt;&lt;/input&gt;8 &lt;input type=\"checkbox\" id=\"9\"&gt;&lt;/input&gt;9&lt;/body&gt; 接下来，给这些 checkbox 绑定点击事件，并且在点击的同时往另一台服务器同步文件： 1234567891011var synchronousFile = function( id )&#123; console.log( '开始同步文件，id 为: ' + id );&#125;;var checkbox = document.getElementsByTagName( 'input' );for ( var i = 0, c; c = checkbox[ i++ ]; )&#123; c.onclick = function()&#123; if ( this.checked === true )&#123; synchronousFile( this.id ); &#125; &#125;&#125;; 当我们选中 3 个 checkbox 的时候，依次往服务器发送了 3 次同步文件的请求。而点击一个checkbox 并不是很复杂的操作，可以预见，如此频繁的网络请求将会带来相当大的开销。 解决方案是，我们可以通过一个代理函数 proxySynchronousFile 来收集一段时间之内的请求，最后一次性发送给服务器。比如我们等待 2 秒之后才把这 2 秒之内需要同步的文件 ID 打包发给服务器，如果不是对实时性要求非常高的系统，2 秒的延迟不会带来太大副作用，却能大大减轻服务器的压力。代码如下： 123456789101112131415161718192021222324252627var synchronousFile = function (id) &#123; console.log('开始同步文件，id 为: ' + id);&#125;;var proxySynchronousFile = (function () &#123; var cache = [], // 保存一段时间内需要同步的 ID timer; // 定时器 return function (id) &#123; cache.push(id); if (timer) &#123; // 保证不会覆盖已经启动的定时器 return; &#125; timer = setTimeout(function () &#123; synchronousFile(cache.join(',')); // 2 秒后向本体发送需要同步的 ID 集合 clearTimeout(timer); // 清空定时器 timer = null; cache.length = 0; // 清空 ID 集合 &#125;, 2000); &#125;&#125;)();var checkbox = document.getElementsByTagName('input');for (var i = 0, c; c = checkbox[i++];) &#123; c.onclick = function () &#123; if (this.checked === true) &#123; proxySynchronousFile(this.id); &#125; &#125;&#125;; 七、 虚拟代理在惰性加载中的应用mini 控制台的开源项目 miniConsole.js可以帮助开发者在 IE 浏览器以及移动端浏览器上进行一些简单的调试工作。调用方式很简单： 1miniConsole.log(1); 这句话会在页面中创建一个 div，并且把 log 显示在 div 里面，如图 6-4 所示。 miniConsole.js的代码量大概有1000行左右，也许我们并不想一开始就加载这么大的JS文件，因为也许并不是每个用户都需要打印 log。我们希望在有必要的时候才开始加载它，比如当用户按下 F2 来主动唤出控制台的时候。 在 miniConsole.js 加载之前，为了能够让用户正常地使用里面的 API，通常我们的解决方案是用一个占位的 miniConsole 代理对象来给用户提前使用，这个代理对象提供给用户的接口，跟实际的 miniConsole 是一样的。 用户使用这个代理对象来打印 log 的时候，并不会真正在控制台内打印日志，更不会在页面中创建任何 DOM 节点。即使我们想这样做也无能为力，因为真正的 miniConsole.js 还没有被加载。 于是，我们可以把打印 log 的请求都包裹在一个函数里面，这个包装了请求的函数就相当于其他语言中命令模式中的 Command 对象。随后这些函数将全部被放到缓存队列中，这些逻辑都是在 miniConsole 代理对象中完成实现的。等用户按下 F2 唤出控制台的时候，才开始加载真正的miniConsole.js 的代码，加载完成之后将遍历 miniConsole 代理对象中的缓存函数队列，同时依次执行它们。 当然，请求的到底是什么对用户来说是不透明的，用户并不清楚它请求的是代理对象，所以他可以在任何时候放心地使用 miniConsole 对象。 未加载真正的 miniConsole.js 之前的代码如下： 12345678910111213141516171819202122232425262728293031var cache = [];var miniConsole = &#123; log: function () &#123; var args = arguments; cache.push(function () &#123; return miniConsole.log.apply(miniConsole, args); &#125;); &#125;&#125;;miniConsole.log(1);//当用户按下 F2 时，开始加载真正的 miniConsole.js，代码如下：var handler = function (ev) &#123; if (ev.keyCode === 113) &#123; var script = document.createElement('script'); script.onload = function () &#123; for (var i = 0, fn; fn = cache[i++];) &#123; fn(); &#125; &#125;; script.src = 'miniConsole.js'; document.getElementsByTagName('head')[0].appendChild(script); &#125;&#125;;document.body.addEventListener('keydown', handler, false);// miniConsole.js 代码：miniConsole = &#123; log: function () &#123; // 真正代码略 console.log(Array.prototype.join.call(arguments)); &#125;&#125;; 虽然我们没有给出 miniConsole.js 的真正代码，但这不影响我们理解其中的逻辑。当然这里还要注意一个问题，就是我们要保证在 F2 被重复按下的时候，miniConsole.js 只被加载一次。另外我们整理一下 miniConsole 代理对象的代码，使它成为一个标准的虚拟代理对象，代码如下： 123456789101112131415161718192021222324252627282930313233 var miniConsole = (function () &#123; var cache = []; var handler = function (ev) &#123; if (ev.keyCode === 113) &#123; var script = document.createElement('script'); script.onload = function () &#123; for (var i = 0, fn; fn = cache[i++];) &#123; fn(); &#125; &#125;; script.src = 'miniConsole.js'; document.getElementsByTagName('head')[0].appendChild(script); document.body.removeEventListener('keydown', handler);// 只加载一次 miniConsole.js &#125; &#125;; document.body.addEventListener('keydown', handler, false); return &#123; log: function () &#123; var args = arguments; cache.push(function () &#123; return miniConsole.log.apply(miniConsole, args); &#125;); &#125; &#125;&#125;)();miniConsole.log(11); // 开始打印 log// miniConsole.js 代码miniConsole = &#123; log: function () &#123; // 真正代码略 console.log(Array.prototype.join.call(arguments)); &#125;&#125;; 八、 缓存代理缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。 8.1 缓存代理的例子——计算乘积先创建一个用于求乘积的函数： 1234567891011121314151617181920212223 var mult = function () &#123; console.log('开始计算乘积'); var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a;&#125;;mult(2, 3); // 输出：6mult(2, 3, 4); // 输出：24//现在加入缓存代理函数：var proxyMult = (function () &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; return cache[args] = mult.apply(this, arguments); &#125;&#125;)();proxyMult(1, 2, 3, 4); // 输出：24proxyMult(1, 2, 3, 4); // 输出：24 当我们第二次调用 proxyMult( 1, 2, 3, 4 )的时候，本体 mult 函数并没有被计算，proxyMult直接返回了之前缓存好的计算结果。 通过增加缓存代理的方式，mult 函数可以继续专注于自身的职责——计算乘积，缓存的功能是由代理对象实现的。 8.2 缓存代理用于ajax异步请求数据我们在常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。 显然这里也可以引入缓存代理，实现方式跟计算乘积的例子差不多，唯一不同的是，请求数据是个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。具体代码不再赘述，读者可以自行实现。 九、 用高阶函数动态创建代理通过传入高阶函数这种更加灵活的方式，可以为各种计算方法创建缓存代理。现在这些计算方法被当作参数传入一个专门用于创建缓存代理的工厂中， 这样一来，我们就可以为乘法、加法、减法等创建缓存代理，代码如下： 123456789101112131415161718192021222324252627282930313233/**************** 计算乘积 *****************/var mult = function () &#123; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a;&#125;;/**************** 计算加和 *****************/var plus = function () &#123; var a = 0; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a + arguments[i]; &#125; return a;&#125;;/**************** 创建缓存代理的工厂 *****************/var createProxyFactory = function (fn) &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; return cache[args] = fn.apply(this, arguments); &#125;&#125;;var proxyMult = createProxyFactory(mult), proxyPlus = createProxyFactory(plus);alert(proxyMult(1, 2, 3, 4)); // 输出：24alert(proxyMult(1, 2, 3, 4)); // 输出：24alert(proxyPlus(1, 2, 3, 4)); // 输出：10alert(proxyPlus(1, 2, 3, 4)); // 输出：10 十、 其他代理模式代理模式的变体种类非常多，限于篇幅及其在 JavaScript 中的适用性，本章只简约介绍一下这些代理，就不一一详细展开说明了。 防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。 远程代理：为一个对象在不同的地址空间提供局部代表，在 Java 中，远程代理可以是另一个虚拟机中的对象。 保护代理：用于对象应该有不同访问权限的情况。 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。 十一、 小结代理模式包括许多小分类，在 JavaScript 开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践五（策略模式 ）","date":"2019-05-22T01:53:58.000Z","path":"2019/05/22/cjxe4h6qa00206supxae1b389/","text":"俗话说，条条大路通罗马。在美剧《越狱》中，主角 Michael Scofield 就设计了两条越狱的道路。这两条道路都可以到达靠近监狱外墙的医务室。 同样，在现实中，很多时候也有多种途径到达同一个目的地。比如我们要去某个地方旅游，可以根据具体的实际情况来选择出行的线路。 如果没有时间但是不在乎钱，可以选择坐飞机。 如果没有钱，可以选择坐大巴或者火车。 如果再穷一点，可以选择骑自行车。 一、 使用策略模式计算奖金在程序设计中，我们也常常遇到类似的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。 这些算法灵活多样，而且可以随意互相替换。这种解决方案就是本章将要介绍的策略模式。 策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 策略模式有着广泛的应用。本节我们就以年终奖的计算为例进行介绍。 很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，而绩效为 B 的人年终奖是 2 倍工资。假设财务部要求我们提供一段代码，来方便他们计算员工的年终奖。 1.1 最初的代码实现我们可以编写一个名为 calculateBonus 的函数来计算每个人的奖金数额。很显然，calculateBonus 函数要正确工作，就需要接收两个参数：员工的工资数额和他的绩效考核等级。代码如下： 12345678910111213var calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return salary * 4; &#125; if (performanceLevel === 'A') &#123; return salary * 3; &#125; if (performanceLevel === 'B') &#123; return salary * 2; &#125;&#125;;calculateBonus('B', 20000); // 输出：40000calculateBonus('S', 6000); // 输出：24000 可以发现，这段代码十分简单，但是存在着显而易见的缺点。 calculateBonus 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的逻辑分支。 calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级 C，或者想把绩效 S 的奖金系数改为 5，那我们必须深入 calculateBonus 函数的内部实现，这是违反开放封闭原则的。 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择只有复制和粘贴。 因此，我们需要重构这段代码。 1.2 使用组合函数重构代码一般最容易想到的办法就是使用组合函数来重构代码，我们把各种算法封装到一个个的小函数里面，这些小函数有着良好的命名，可以一目了然地知道它对应着哪种算法，它们也可以被复用在程序的其他地方。代码如下： 123456789101112131415161718192021var performanceS = function (salary) &#123; return salary * 4;&#125;;var performanceA = function (salary) &#123; return salary * 3;&#125;;var performanceB = function (salary) &#123; return salary * 2;&#125;;var calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return performanceS(salary); &#125; if (performanceLevel === 'A') &#123; return performanceA(salary); &#125; if (performanceLevel === 'B') &#123; return performanceB(salary); &#125;&#125;;calculateBonus('A', 10000); // 输出：30000 目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题：calculateBonus 函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。 1.3 使用策略模式重构代码经过思考，我们想到了更好的办法——使用策略模式来重构代码。策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。 在这个例子里，算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数额。而算法的实现是各异和变化的，每种绩效对应着不同的计算规则。 一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用。 现在用策略模式来重构上面的代码。第一个版本是模仿传统面向对象语言中的实现。我们先把每种绩效的计算规则都封装在对应的策略类里面： 1234567891011121314151617181920212223242526var performanceS = function() &#123;&#125;;performanceS.prototype.calculate = function(salary) &#123; return 4 * salary&#125;var performanceA = function ()&#123;&#125;;performanceA.prototype.calculate = function(salary) &#123; return 3 * salary&#125;var performanceB = function () &#123; &#125;;performanceB.prototype.calculate = function(salary) &#123; return 2 * salary&#125;//接下来定义奖金类 Bonus：var Bonus = function()&#123; this.salary = null; // 原始工资 this.strategy = null; // 绩效等级对应的策略对象&#125;;Bonus.prototype.setSalary = function( salary )&#123; this.salary = salary; // 设置员工的原始工资&#125;;Bonus.prototype.setStrategy = function( strategy )&#123; this.strategy = strategy; // 设置员工绩效等级对应的策略对象&#125;;Bonus.prototype.getBonus = function()&#123; // 取得奖金数额 return this.strategy.calculate( this.salary ); // 把计算奖金的操作委托给对应的策略对象&#125;; 在完成最终的代码之前，我们再来回顾一下策略模式的思想： 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换(“并且使它们可以相互替换”，这句话在很大程度上是相对于静态类型语言而言的。因为静态类型语言中有类型检查机制，所以各个策略类需要实现同样的接口。当它们的真正类型被隐藏在接口后面时，它们才能被相互替换。而在 JavaScript 这种“类型模糊”的语言中没有这种困扰，任何对象都可以被替换使用。因此，JavaScript 中的“可以相互替换使用”表现为它们具有相同的目标和意图。)。 这句话如果说得更详细一点，就是：定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对 Context 发起请求的时候，Context 总是把请求委托给这些策略对象中间的某一个进行计算。 现在我们来完成这个例子中剩下的代码。先创建一个 bonus 对象，并且给 bonus 对象设置一些原始的数据，比如员工的原始工资数额。接下来把某个计算奖金的策略对象也传入 bonus 对象内部保存起来。当调用 bonus.getBonus()来计算奖金的时候，bonus 对象本身并没有能力进行计算，而是把请求委托给了之前保存好的策略对象： 123456var bonus = new Bonus();bonus.setSalary(10000);bonus.setStrategy(new performanceS()); // 设置策略对象console.log(bonus.getBonus()); // 输出：40000bonus.setStrategy(new performanceA()); // 设置策略对象console.log(bonus.getBonus()); // 输出：30000 刚刚我们用策略模式重构了这段计算年终奖的代码，可以看到通过策略模式重构之后，代码变得更加清晰，各个类的职责更加鲜明。但这段代码是基于传统面向对象语言的模仿，下一节我们将了解用 JavaScript 实现的策略模式。 二、 JavaScript 版本的策略模式上一节中我们让 strategy 对象从各个策略类中创建而来，这是模拟一些传统面向对象语言的实现。实际上在 JavaScript 语言中，函数也是对象，所以更简单和直接的做法是把 strategy直接定义为函数： 1234567891011var strategies = &#123; \"S\": function( salary )&#123; return salary * 4; &#125;, \"A\": function( salary )&#123; return salary * 3; &#125;, \"B\": function( salary )&#123; return salary * 2; &#125;&#125;; 同样，Context 也没有必要必须用 Bonus 类来表示，我们依然用 calculateBonus 函数充当Context 来接受用户的请求。经过改造，代码的结构变得更加简洁： 12345678910111213141516var strategies = &#123; \"S\": function( salary )&#123; return salary * 4; &#125;, \"A\": function( salary )&#123; return salary * 3; &#125;, \"B\": function( salary )&#123; return salary * 2; &#125;&#125;;var calculateBonus = function( level, salary )&#123; return strategies[ level ]( salary );&#125;;console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000 在接下来的缓动动画和表单验证的例子中，我们用到的都是这种函数形式的策略对象。 三、 多态在策略模式中的体现通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算奖金有关的逻辑不再放在 Context 中，而是分布在各个策略对象中。Context 并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算奖金”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是“它们可以相互替换”的目的。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。 四、 使用策略模式实现缓动动画如果让一些不太了解前端开发的程序员来投票，选出他们眼中 JavaScript 语言在 Web 开发中的两大用途，我想结果很有可能是这样的： 编写一些让 div 飞来飞去的动画 验证表单 虽然这只是一句玩笑话，但从中可以看到动画在 Web 前端开发中的地位。一些别出心裁的动画效果可以让网站增色不少。 如果我们明白了怎样让一个小球运动起来，那么离编写一个完整的游戏就不遥远了，剩下的只是一些把逻辑组织起来的体力活。本节并不会从头到尾地编写一个完整的游戏，我们首先要做的是让一个小球按照不同的算法进行运动。 4.1 实现动画效果的原理用 JavaScript 实现动画效果的原理跟动画片的制作一样，较快的帧数播放，来达到视觉上的动画效果。在 JavaScript 中，可以通过连续改变元素的某个 CSS属性，比如 left、top、background-position 来实现动画效果。图 5-1 就是通过改变节点的background-position，让人物动起来的。 4.2 思路和一些准备工作我们目标是编写一个动画类和一些缓动算法，让小球以各种各样的缓动效果在页面中运动。 现在来分析实现这个程序的思路。在运动开始之前，需要提前记录一些有用的信息，至少包括以下信息： 动画开始时，小球所在的原始位置； 小球移动的目标位置； 动画开始时的准确时间点； 小球运动持续的时间。 随后，我们会用 setInterval 创建一个定时器，定时器每隔 19ms 循环一次。在定时器的每一帧里，我们会把动画已消耗的时间、小球原始位置、小球目标位置和动画持续的总时间等信息传入缓动算法。该算法会通过这几个参数，计算出小球当前应该所在的位置。最后再更新该 div 对应的 CSS 属性，小球就能够顺利地运动起来了。 4.3 让小球运动起来在实现完整的功能之前，我们先了解一些常见的缓动算法，这些算法最初来自 Flash，但可以非常方便地移植到其他语言中。 这些算法都接受 4 个参数，这 4 个参数的含义分别是动画已消耗的时间、小球原始位置、小球目标位置、动画持续的总时间，返回的值则是动画元素应该处在的当前位置。代码如下： 1234567891011121314151617181920var tween = &#123; linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125;&#125;; 现在我们开始编写完整的代码，下面代码的思想来自 jQuery 库，由于本节的目标是演示策略模式，而非编写一个完整的动画库，因此我们省去了动画的队列控制等更多完整功能。 现在进入代码实现阶段，首先在页面中放置一个 div： 123&lt;body&gt; &lt;div style=\"position:absolute;background:blue\" id=\"div\"&gt;我是 div&lt;/div&gt;&lt;/body&gt; 接下来定义 Animate 类，Animate 的构造函数接受一个参数：即将运动起来的 dom 节点。Animate类的代码如下： 123456789var Animate = function( dom )&#123; this.dom = dom; // 进行运动的 dom 节点 this.startTime = 0; // 动画开始时间 this.startPos = 0; // 动画开始时，dom 节点的位置，即 dom 的初始位置 this.endPos = 0; // 动画结束时，dom 节点的位置，即 dom 的目标位置 this.propertyName = null; // dom 节点需要被改变的 css 属性名 this.easing = null; // 缓动算法 this.duration = null; // 动画持续时间&#125;; 接下来 Animate.prototype.start 方法负责启动这个动画，在动画被启动的瞬间，要记录一些信息，供缓动算法在以后计算小球当前位置的时候使用。在记录完这些信息之后，此方法还要负责启动定时器。代码如下： 1234567891011121314Animate.prototype.start = function (propertyName, endPos, duration, easing) &#123; this.startTime = +new Date; // 动画启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; // dom 节点初始位置 this.propertyName = propertyName; // dom 节点需要被改变的 CSS 属性名 this.endPos = endPos; // dom 节点目标位置 this.duration = duration; // 动画持续事件 this.easing = tween[easing]; // 缓动算法 var self = this; var timeId = setInterval(function () &#123; // 启动定时器，开始执行动画 if (self.step() === false) &#123; // 如果动画已结束，则清除定时器 clearInterval(timeId); &#125; &#125;, 19);&#125;; Animate.prototype.start 方法接受以下 4 个参数。 propertyName：要改变的 CSS 属性名，比如’left’、’top’，分别表示左右移动和上下移动。 endPos： 小球运动的目标位置。 duration： 动画持续时间。 easing： 缓动算法。 再接下来是 Animate.prototype.step 方法，该方法代表小球运动的每一帧要做的事情。在此处，这个方法负责计算小球的当前位置和调用更新 CSS 属性值的方法 Animate.prototype.update。代码如下： 1234567891011Animate.prototype.step = function () &#123; var t = +new Date; // 取得当前时间 if (t &gt;= this.startTime + this.duration) &#123; // (1) this.update(this.endPos); // 更新小球的 CSS 属性值 return false; &#125; var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration); // pos 为小球当前位置 this.update(pos); // 更新小球的 CSS 属性值&#125;; 在这段代码中，(1)处的意思是，如果当前时间大于动画开始时间加上动画持续时间之和，说明动画已经结束，此时要修正小球的位置。因为在这一帧开始之后，小球的位置已经接近了目标位置，但很可能不完全等于目标位置。此时我们要主动修正小球的当前位置为最终的目标位置。此外让 Animate.prototype.step 方法返回 false，可以通知 Animate.prototype.start 方法清除定时器。 最后是负责更新小球 CSS 属性值的 Animate.prototype.update 方法： 123Animate.prototype.update = function( pos )&#123; this.dom.style[ this.propertyName ] = pos + 'px';&#125;; 如果不嫌麻烦，我们可以进行一些小小的测试： 1234var div = document.getElementById( 'div' );var animate = new Animate( div );animate.start( 'left', 500, 1000, 'strongEaseOut' );// animate.start( 'top', 1500, 500, 'strongEaseIn' ); 通过这段代码，可以看到小球按照我们的期望以各种各样的缓动算法在页面中运动。 本节我们学会了怎样编写一个动画类，利用这个动画类和一些缓动算法就可以让小球运动起来。我们使用策略模式把算法传入动画类中，来达到各种不同的缓动效果，这些算法都可以轻易地被替换为另外一个算法，这是策略模式的经典运用之一。策略模式的实现并不复杂，关键是如何从策略模式的实现背后，找到封装变化、委托和多态性这些思想的价值。 五、 更广义的“算法”策略模式指的是定义一系列的算法，并且把它们封装起来。本章我们介绍的计算奖金和缓动动画的例子都封装了一些算法。 从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。 GoF 在《设计模式》一书中提到了一个利用策略模式来校验用户是否输入了合法数据的例子，但 GoF 未给出具体的实现。刚好在 Web 开发中，表单校验是一个非常常见的话题。下面我们就看一个使用策略模式来完成表单校验的例子。 六、6 表单校验在一个 Web 项目中，注册、登录、修改用户信息等功能的实现都离不开提交表单。 在将用户输入的数据交给后台之前，常常要做一些客户端力所能及的校验工作，比如注册的时候需要校验是否填写了用户名，密码的长度是否符合规定，等等。这样可以避免因为提交不合法数据而带来的不必要网络开销。 假设我们正在编写一个注册的页面，在点击注册按钮之前，有如下几条校验逻辑。 用户名不能为空。 密码长度不能少于 6 位。 手机号码必须符合格式。 6.1 表单校验的第一个版本现在编写表单校验的第一个版本，可以提前透露的是，目前我们还没有引入策略模式。代码如下： 123456789101112131415161718192021222324252627&lt;html&gt;&lt;body&gt; &lt;form action=\"http:// xxx.com/register\" id=\"registerForm\" method=\"post\"&gt; 请输入用户名：&lt;input type=\"text\" name=\"userName\"/ &gt; 请输入密码：&lt;input type=\"text\" name=\"password\"/ &gt; 请输入手机号码：&lt;input type=\"text\" name=\"phoneNumber\"/ &gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; var registerForm = document.getElementById( 'registerForm' ); registerForm.onsubmit = function()&#123; if ( registerForm.userName.value === '' )&#123; alert ( '用户名不能为空' ); return false; &#125; if ( registerForm.password.value.length &lt; 6 )&#123; alert ( '密码长度不能少于 6 位' ); return false; &#125; if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( registerForm.phoneNumber.value ) )&#123; alert ( '手机号码格式不正确' ); return false; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是一种很常见的代码编写方式，它的缺点跟计算奖金的最初版本一模一样。 registerForm.onsubmit 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的校验规则。 registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的校验规则，或者想把密码的长度校验从 6 改成 8，我们都必须深入 registerForm.onsubmit 函数的内部实现，这是违反开放—封闭原则的。 算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制得漫天遍野。 6.2 用策略模式重构表单校验下面我们将用策略模式来重构表单校验的代码，很显然第一步我们要把这些校验逻辑都封装成策略对象： 1234567891011121314151617var strategies = &#123; isNonEmpty: function (value, errorMsg) &#123; // 不为空 if (value === '') &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; // 限制最小长度 if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function (value, errorMsg) &#123; // 手机号码格式 if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;; 接下来我们准备实现 Validator 类。Validator 类在这里作为 Context，负责接收用户的请求并委托给 strategy 对象。在给出 Validator 类的代码之前，有必要提前了解用户是如何向 Validator类发送请求的，这有助于我们知道如何去编写 Validator 类的代码。代码如下： 1234567891011121314151617181920var Validator = function () &#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function (dom, rule, errorMsg) &#123; var ary = rule.split(':'); // 把 strategy 和参数分开 this.cache.push(function () &#123; // 把校验的步骤用空函数包装起来，并且放入 cache var strategy = ary.shift(); // 用户挑选的 strategy ary.unshift(dom.value); // 把 input 的 value 添加进参数列表 ary.push(errorMsg); // 把 errorMsg 添加进参数列表 return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function () &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;; 从这段代码中可以看到，我们先创建了一个 validator 对象，然后通过 validator.add 方法，往 validator 对象中添加一些校验规则。validator.add 方法接受 3 个参数，以下面这句代码说明： 1validator.add( registerForm.password, 'minLength:6', '密码长度不能少于 6 位' ); registerForm.password 为参与校验的 input 输入框。 ‘minLength:6’是一个以冒号隔开的字符串。冒号前面的minLength代表客户挑选的strategy对象，冒号后面的数字 6 表示在校验过程中所必需的一些参数。’minLength:6’的意思就是校验 registerForm.password 这个文本输入框的 value 最小长度为 6。如果这个字符串中不包含冒号，说明校验过程中不需要额外的参数信息，比如’isNonEmpty’。 第 3 个参数是当校验未通过时返回的错误信息。 当我们往 validator 对象里添加完一系列的校验规则之后，会调用 validator.start()方法来启动校验。如果 validator.start()返回了一个确切的 errorMsg 字符串当作返回值，说明该次校验没有通过，此时需让 registerForm.onsubmit 方法返回 false 来阻止表单的提交。 最后是 Validator 类的实现： 1234567891011121314151617181920212223var Validator = function () &#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function (dom, rule, errorMsg) &#123; // console.log(dom) // console.log(rule) // console.log(errorMsg) var ary = rule.split(':'); // 把 strategy 和参数分开 this.cache.push(function () &#123; // 把校验的步骤用空函数包装起来，并且放入 cache var strategy = ary.shift(); // 用户挑选的 strategy ary.unshift(dom.value); // 把 input 的 value 添加进参数列表 ary.push(errorMsg); // 把 errorMsg 添加进参数列表 return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function () &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;; 使用策略模式重构代码之后，我们仅仅通过“配置”的方式就可以完成一个表单的校验，这些校验规则也可以复用在程序的任何地方，还能作为插件的形式，方便地被移植到其他项目中。 在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想将用户名输入框的校验规则改成用户名不能少于 4 个字符。可以看到，这时候的修改是毫不费力的。代码如下： 123validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空' );// 改成：validator.add( registerForm.userName, 'minLength:10', '用户名长度不能小于 10 位' ); 6.3 给某个文本输入框添加多种校验规则为了让读者把注意力放在策略模式的使用上，目前我们的表单校验实现留有一点小遗憾：一个文本输入框只能对应一种校验规则，比如，用户名输入框只能校验输入是否为空： validator.add( registerForm.userName, ‘isNonEmpty’, ‘用户名不能为空’ ); 如果我们既想校验它是否为空，又想校验它输入文本的长度不小于 10 呢？我们期望以这样的形式进行校验： 12345678910validator.add(registerForm.userName, [ &#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于 10 位' &#125;]); 下面提供的代码可用于一个文本输入框对应多种校验规则： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var strategies = &#123; isNonEmpty: function (value, errorMsg) &#123; if (value === '') &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function (value, errorMsg) &#123; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;;/***********************Validator 类**************************/var Validator = function () &#123; this.cache = [];&#125;;Validator.prototype.add = function (dom, rules) &#123; var self = this; for (var i = 0, rule; rule = rules[i++];) &#123; (function (rule) &#123; var strategyAry = rule.strategy.split(':'); var errorMsg = rule.errorMsg; self.cache.push(function () &#123; var strategy = strategyAry.shift(); strategyAry.unshift(dom.value); strategyAry.push(errorMsg); return strategies[strategy].apply(dom, strategyAry); &#125;); &#125;)(rule) &#125;&#125;;Validator.prototype.start = function () &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var errorMsg = validatorFunc(); if (errorMsg) &#123; return errorMsg; &#125; &#125;&#125;;/***********************客户调用代码**************************/var registerForm = document.getElementById('registerForm');var validataFunc = function () &#123; var validator = new Validator(); validator.add(registerForm.userName, [ &#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于 10 位' &#125; ]); validator.add(registerForm.password, [ &#123; strategy: 'minLength:6', errorMsg: '密码长度不能小于 6 位' &#125; ]); validator.add(registerForm.phoneNumber, [ &#123; strategy: 'isMobile', errorMsg: '手机号码格式不正确' &#125; ]); var errorMsg = validator.start(); return errorMsg;&#125;registerForm.onsubmit = function () &#123; var errorMsg = validataFunc(); if (errorMsg) &#123; alert(errorMsg); return false; &#125; &#125;; 七、 策略模式的优缺点策略模式是一种常用且有效的设计模式，本章提供了计算奖金、缓动动画、表单校验这三个例子来加深大家对策略模式的理解。从这三个例子中，我们可以总结出策略模式的一些优点。 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 当然，策略模式也有一些缺点，但这些缺点并不严重。 首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在 Context 中要好。 其次，要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选择飞机、火车、自行车等方案的细节。此时 strategy 要向客户暴露它的所有实现，这是违反最少知识原则的。 八、 一等函数对象与策略模式本章提供的几个策略模式示例，既有模拟传统面向对象语言的版本，也有针对 JavaScript 语言的特有实现。在以类为中心的传统面向对象语言中，不同的算法或者行为被封装在各个策略类中，Context 将请求委托给这些策略对象，这些策略对象会根据请求返回不同的执行结果，这样便能表现出对象的多态性。 Peter Norvig 在他的演讲中曾说过：“在函数作为一等对象的语言中，策略模式是隐形的。strategy 就是值为函数的变量。”在 JavaScript 中，除了使用类来封装算法和行为之外，使用函数当然也是一种选择。这些“算法”可以被封装到函数中并且四处传递，也就是我们常说的“高阶函数”。实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出“调用”的消息时，不同的函数会返回不同的执行结果。在 JavaScript 中，“函数对象的多态性”来得更加简单。 在前面的学习中，为了清楚地表示这是一个策略模式，我们特意使用了 strategies 这个名字。如果去掉 strategies，我们还能认出这是一个策略模式的实现吗？代码如下： 12345678910111213var S = function( salary )&#123; return salary * 4;&#125;;var A = function( salary )&#123; return salary * 3;&#125;;var B = function( salary )&#123; return salary * 2;&#125;;var calculateBonus = function( func, salary )&#123; return func( salary );&#125;;calculateBonus( S, 10000 ); // 输出：40000 九、 小结本章我们既提供了接近传统面向对象语言的策略模式实现，也提供了更适合 JavaScript 语言的策略模式版本。在 JavaScript 语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式。尽管这样，从头到尾地了解策略模式，不仅可以让我们对该模式有更加透彻的了解，也可以使我们明白使用函数的好处。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践四（单例模式）","date":"2019-05-21T08:53:58.000Z","path":"2019/05/21/cjxe4h6oi00166supv7shju7q/","text":"单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的 window 对象等。在 JavaScript 开发中，单例模式的用途同样非常广泛。试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。 一、 实现单例模式要实现一个标准的单例模式并不复杂，无非是用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。代码如下： 1234567891011121314151617181920212223242526272829303132333435var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;;Singleton.prototype.getName = function () &#123; alert(this.name);&#125;;Singleton.getInstance = function (name) &#123; console.log(name) if (!this.instance) &#123; this.instance = new Singleton(name); &#125; console.log(this.instance) return this.instance;&#125;;var a = Singleton.getInstance('sven1');var b = Singleton.getInstance('sven2');console.log(a === b); // true //或者var Singleton = function( name )&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; alert ( this.name );&#125;;Singleton.getInstance = (function()&#123; var instance = null; return function( name )&#123; if ( !instance )&#123; instance = new Singleton( name ); &#125; return instance; &#125;&#125;)(); 我们通过 Singleton.getInstance 来获取 Singleton 类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的“不透明性”，Singleton 类的使用者必须知道这是一个单例类，跟以往通过 new XXX 的方式来获取对象不同，这里偏要使用 Singleton.getInstance 来获取对象。 接下来顺便进行一些小测试，来证明这个单例类是可以信赖的： 123var a = Singleton.getInstance( 'sven1' );var b = Singleton.getInstance( 'sven2' );alert ( a === b ); // true 虽然现在已经完成了一个单例模式的编写，但这段单例模式代码的意义并不大。从下一节开始，我们将一步步编写出更好的单例模式。 二、透明的单例模式我们现在的目标是实现一个“透明”的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。在下面的例子中，我们将使用 CreateDiv 单例类，它的作用是负责在页面中创建唯一的 div 节点，代码如下： 虽然现在完成了一个透明的单例类的编写，但它同样有一些缺点 为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的 Singleton 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。 观察现在的 Singleton 构造函数： 12345678var CreateDiv = function( html )&#123; if ( instance )&#123; return instance; &#125; this.html = html; this.init(); return instance = this;&#125;; 在这段代码中，CreateDiv 的构造函数实际上负责了两件事情。第一是创建对象和执行初始化 init 方法，第二是保证只有一个对象。虽然我们目前还没有接触过“单一职责原则”的概念，但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。 假设我们某天需要利用这个类，在页面中创建千千万万的 div，即要让这个类从单例类变成一个普通的可产生多个实例的类，那我们必须得改写 CreateDiv 构造函数，把控制创建唯一对象的那一段去掉，这种修改会给我们带来不必要的烦恼。 三、 用代理实现单例模式现在我们通过引入代理类的方式，来解决上面提到的问题。 我们依然使用 4.2 节中的代码，首先在 CreateDiv 构造函数中，把负责管理单例的代码移除出去，使它成为一个普通的创建 div 的类： 12345678910111213141516171819202122var CreateDiv = function (html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div);&#125;;//接下来引入代理类 proxySingletonCreateDiv：var ProxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)();var a = new ProxySingletonCreateDiv('sven1');var b = new ProxySingletonCreateDiv('sven2');alert(a === b); 通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。这样一来，CreateDiv就变成了一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果。 本例是缓存代理的应用之一，在接下来的学习中，我们将继续了解代理带来的好处。 四、 JavaScript 中的单例模式前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来。在以类为中心的语言中，这是很自然的做法。比如在 Java 中，如果需要某个对象，就必须先定义一个类，对象总是从类中创建而来的。 但 JavaScript 其实是一门无类（class-free）语言，也正因为如此，生搬单例模式的概念并无意义。在 JavaScript 中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢？这无异于穿棉衣洗澡，传统的单例模式实现在 JavaScript 中并不适用。 单例模式的核心是确保只有一个实例，并提供全局访问。 全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当成单例来使用。例如： var a = {}; 当用这种方式创建对象 a 时，对象 a 确实是独一无二的。如果 a 变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样就满足了单例模式的两个条件。 但是全局变量存在很多问题，它很容易造成命名空间污染。在大中型项目中，如果不加以限制和管理，程序中可能存在很多这样的变量。JavaScript 中的变量也很容易被不小心覆盖，相信每个 JavaScript 程序员都曾经历过变量冲突的痛苦，就像上面的对象 var a = {};，随时有可能被别人覆盖。 Douglas Crockford 多次把全局变量称为 JavaScript 中最糟糕的特性。在对 JavaScript 的创造者Brendan Eich 的访谈中， Brendan Eich 本人也承认全局变量是设计上的失误，是在没有足够的时间思考一些东西的情况下导致的结果。 作为普通的开发者，我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染。 4.1 使用命名空间适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量 最简单的方法依然是用对象字面量的方式： 12345678var namespace1 = &#123; a: function()&#123; alert (1); &#125;, b: function()&#123; alert (2); &#125;&#125;; 把 a 和 b 都定义为 namespace1 的属性，这样可以减少变量和全局作用域打交道的机会。另外我们还可以动态地创建命名空间，代码如下（引自 Object-Oriented JavaScrtipt 一书）： 123456789101112131415161718192021var MyApp = &#123;&#125;;MyApp.namespace = function (name) &#123; var parts = name.split('.'); var current = MyApp; for (var i in parts) &#123; if (!current[parts[i]]) &#123; current[parts[i]] = &#123;&#125;; &#125; current = current[parts[i]]; &#125;&#125;;MyApp.namespace('event');MyApp.namespace('dom.style');console.dir(MyApp);// 上述代码等价于：var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;&#125;; 4.2 使用闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信： 123456789var user = (function()&#123; var __name = 'sven', __age = 29; return &#123; getUserInfo: function()&#123; return __name + '-' + __age; &#125; &#125;&#125;)(); 我们用下划线来约定私有变量name 和age，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。 五、 惰性单例前面我们了解了单例模式的一些实现办法，本节我们来了解惰性单例。 惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用，有用的程度可能超出了我们的想象，实际上在本章开头就使用过这种技术，instance 实例对象总是在我们调用 Singleton.getInstance 的时候才被创建，而不是在页面加载好的时候就创建，代码如下： 123456789Singleton.getInstance = (function()&#123; var instance = null; return function( name )&#123; if ( !instance )&#123; instance = new Singleton( name ); &#125; return instance; &#125;&#125;)(); 不过这是基于“类”的单例模式，前面说过，基于“类”的单例模式在 JavaScript 中并不适用，下面我们将以 WebQQ 的登录浮窗为例，介绍与全局变量结合实现惰性的单例。 假设我们是 WebQQ 的开发人员（网址是web.qq.com），当点击左边导航里 QQ 头像时，会弹出一个登录浮窗（如图 4-1 所示），很明显这个浮窗在页面里总是唯一的，不可能出现同时存在两个登录窗口的情况。 第一种解决方案是在页面加载完成的时候便创建好这个 div 浮窗，这个浮窗一开始肯定是隐藏状态的，当用户点击登录按钮的时候，它才开始显示： 1234567891011121314151617&lt;html&gt; &lt;body&gt; &lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt; &lt;/body&gt; &lt;script&gt; var loginLayer = (function()&#123; var div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); return div; &#125;)(); document.getElementById( 'loginBtn' ).onclick = function()&#123; loginLayer.style.display = 'block'; &#125;; &lt;/script&gt;&lt;/html&gt; 这种方式有一个问题，也许我们进入 WebQQ 只是玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录浮窗总是一开始就被创建好，那么很有可能将白白浪费一些 DOM 节点。 现在改写一下代码，使用户点击登录按钮的时候才开始创建该浮窗： 123456789101112131415161718&lt;html&gt;&lt;body&gt; &lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var createLoginLayer = function()&#123; var div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); return div; &#125;; document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block'; &#125;;&lt;/script&gt;&lt;/html&gt; 虽然现在达到了惰性的目的，但失去了单例的效果。当我们每次点击登录按钮的时候，都会创建一个新的登录浮窗 div。虽然我们可以在点击浮窗上的关闭按钮时（此处未实现）把这个浮窗从页面中删除掉，但这样频繁地创建和删除节点明显是不合理的，也是不必要的。 也许读者已经想到了，我们可以用一个变量来判断是否已经创建过登录浮窗，这也是本节第一段代码中的做法： 12345678910111213141516var createLoginLayer = (function()&#123; var div; return function()&#123; if ( !div )&#123; div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); &#125; return div; &#125;&#125;)(); document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;; 六、 通用的惰性单例上一节我们完成了一个可用的惰性单例，但是我们发现它还有如下一些问题。 这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer对象内部。如果我们下次需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就必须得如法炮制，把 createLoginLayer 函数几乎照抄一遍： 1234567891011var createIframe= (function()&#123; var iframe; return function()&#123; if ( !iframe)&#123; iframe= document.createElement( 'iframe' ); iframe.style.display = 'none'; document.body.appendChild( iframe); &#125; return iframe; &#125;&#125;)(); 我们需要把不变的部分隔离出来，先不考虑创建一个 div 和创建一个 iframe 有多少差异，管理单例的逻辑其实是完全可以抽象出来的，这个逻辑始终是一样的：用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象： 1234var obj;if ( !obj )&#123; obj = xxx;&#125; 现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle函数内部，创建对象的方法 fn 被当成参数动态传入 getSingle 函数： 123456var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;; 接下来将用于创建登录浮窗的方法用参数 fn 的形式传入 getSingle，我们不仅可以传入createLoginLayer，还能传入 createScript、createIframe、createXhr 等。之后再让 getSingle 返回一个新的函数，并且用一个变量 result 来保存 fn 的计算结果。result 变量因为身在闭包中，它永远不会被销毁。在将来的请求中，如果 result 已经被赋值，那么它将返回这个值。代码如下： 123456789101112var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').onclick = function () &#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;; 下面我们再试试创建唯一的 iframe 用于动态加载第三方页面： 123456789var createSingleIframe = getSingle(function () &#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe;&#125;);document.getElementById('loginBtn').onclick = function () &#123; var loginLayer = createSingleIframe(); loginLayer.src = 'http://baidu.com';&#125;; 在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能，看起来是一件挺奇妙的事情。 这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里追加数据，在使用事件代理的前提下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，如果借助于 jQuery，我们通常选择给节点绑定 one 事件： 123456789101112var bindEvent = function () &#123; $('div').one('click', function () &#123; alert('click'); &#125;);&#125;;var render = function () &#123; console.log('开始渲染列表'); bindEvent();&#125;;render(); render();render(); 如果利用 getSingle 函数，也能达到一样的效果。代码如下： 12345678910111213var bindEvent = getSingle(function () &#123; document.getElementById('div1').onclick = function () &#123; alert('click'); &#125; return true;&#125;);var render = function () &#123; console.log('开始渲染列表'); bindEvent();&#125;;render();render();render(); 可以看到，render 函数和 bindEvent 函数都分别执行了 3 次，但 div 实际上只被绑定了一个事件。 七、 小结单例模式是我们学习的第一个模式，我们先学习了传统的单例模式实现，也了解到因为语言的差异性，有更适合的方法在 JavaScript 中创建单例。这一章还提到了代理模式和单一职责原则，后面的章节会对它们进行更详细的讲解。 在 getSinge 函数中，实际上也提到了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践三（闭包和高阶函数）","date":"2019-05-07T01:53:58.000Z","path":"2019/05/07/cjxe4h6qn00236supah5ugp39/","text":"虽然 JavaScript 是一门完整的面向对象的编程语言，但这门语言同时也拥有许多函数式语言的特性。 函数式语言的鼻祖是 LISP，JavaScript 在设计之初参考了 LISP 两大方言之一的 Scheme，引入了 Lambda 表达式、闭包、高阶函数等特性。使用这些特性，我们经常可以用一些灵活而巧妙的方式来编写 JavaScript 代码。 本章主要挑选了闭包和高阶函数进行讲解。在 JavaScript 版本的设计模式中，许多模式都可以用闭包和高阶函数来实现。 一、 闭包对于 JavaScript 程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点。 1.1 变量的作用域变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。 另外一种情况是用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。代码如下： 123456var func = function () &#123; var a = 1; alert(a); // 输出: 1&#125;; func();alert(a); // 输出：Uncaught ReferenceError: a is not defined 在 JavaScript 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的。 下面这段包含了嵌套函数的代码，也许能帮助我们加深对变量搜索过程的理解： 123456789101112var a = 1;var func1 = function () &#123; var b = 2; var func2 = function () &#123; var c = 3; alert(b); // 输出：2 alert(a); // 输出：1 &#125; func2(); alert(c); // 输出：Uncaught ReferenceError: c is not defined&#125;;func1(); 1.2 变量的生存周期除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁： 12345var func = function () &#123; var a = 1; // 退出函数后局部变量 a 将被销毁 alert(a);&#125;;func(); 现在来看看下面这段代码： 123456789101112var func = function () &#123; var a = 1; return function () &#123; a++; alert(a); &#125;&#125;;var f = func();f(); // 输出：2f(); // 输出：3f(); // 输出：4f(); // 输出：5 跟我们之前的推论相反，当退出函数后，局部变量 a 并没有消失，而是似乎一直在某个地方存活着。这是因为当执行 var f = func();时，f 返回了一个匿名函数的引用，它可以访问到 func()被调用时产生的环境，而局部变量 a 一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。 利用闭包我们可以完成许多奇妙的工作，下面介绍一个闭包的经典应用。假设页面上有 5 个div 节点，我们通过循环来给每个 div 绑定 onclick 事件，按照索引顺序，点击第 1 个 div 时弹出0，点击第 2 个 div 时弹出 1，以此类推。代码如下： 1234567891011121314151617&lt;html&gt; &lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; var nodes = document.getElementsByTagName( 'div' ); for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; nodes[ i ].onclick = function()&#123; alert ( i ); &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。 解决方法是在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i，如果有 5 个 div，这里的 i就分别是 0,1,2,3,4： 1234567for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)( i )&#125;; 根据同样的道理，我们还可以编写如下一段代码： 12345678910var Type = &#123;&#125;;for (var i = 0, type; type = ['String', 'Array', 'Number'][i++];) &#123; (function (type) &#123; Type['is' + type] = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125; &#125;)(type)&#125;;Type.isArray([]); // 输出：trueType.isString(\"str\"); // 输出：true 1.3 闭包的更多作用这一小节我们将通过几个例子，进一步讲解闭包的作用。因为篇幅所限，这里仅例举少量示例。在实际开发中，闭包的运用非常广泛。 1.3.1 封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的简单函数： 1234567var mult = function()&#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ )&#123; a = a * arguments[i]; &#125; return a;&#125;; mult 函数接受一些 number 类型的参数，并返回这些参数的乘积。现在我们觉得对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能： 1234567891011121314var cache = &#123;&#125;;var mult = function () &#123; var args = Array.prototype.join.call(arguments, ','); if (cache[args]) &#123; return cache[args]; &#125; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return cache[args] = a;&#125;;alert(mult(1, 2, 3)); // 输出：6alert(mult(1, 2, 3)); // 输出：6 我们看到 cache 这个变量仅仅在 mult 函数中被使用，与其让 cache 变量跟 mult 函数一起平行地暴露在全局作用域下，不如把它封闭在 mult 函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。代码如下： 1234567891011121314var mult = (function () &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return cache[args] = a; &#125;&#125;)(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。代码如下： 1234567891011121314151617var mult = (function () &#123; var cache = &#123;&#125;; var calculate = function () &#123; // 封闭 calculate 函数 var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a; &#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; return cache[args] = calculate.apply(null, arguments); &#125;&#125;)(); 1.3.2 延续局部变量的寿命img 对象经常用于进行数据上报，如下所示： 12345var report = function (src) &#123; var img = new Image(); img.src = src;&#125;;report('http://xxx.com/getUserInfo'); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说，report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后，img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题： 12345678var report = (function () &#123; var imgs = []; return function (src) &#123; var img = new Image(); imgs.push(img); img.src = src; &#125;&#125;)(); 1.4 闭包和面向对象设计过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。在 JavaScript 语言的祖先 Scheme 语言中，甚至都没有提供面向对象的原生设计，但可以使用闭包来实现一个完整的面向对象系统。 下面来看看这段跟闭包相关的代码： 123456789101112131415161718192021222324252627282930313233343536var extent = function () &#123; var value = 0; return &#123; call: function () &#123; value++; console.log(value); &#125; &#125;&#125;;var extent = extent();extent.call(); // 输出：1extent.call(); // 输出：2extent.call(); // 输出：3//如果换成面向对象的写法，就是：var extent = &#123; value: 0, call: function () &#123; this.value++; console.log(this.value); &#125;&#125;;extent.call(); // 输出：1extent.call(); // 输出：2extent.call(); // 输出：3//或者：var Extent = function () &#123; this.value = 0;&#125;;Extent.prototype.call = function () &#123; this.value++; console.log(this.value);&#125;;var extent = new Extent();extent.call();extent.call();extent.call(); 1.5 用闭包实现命令模式在 JavaScript 版本的各种设计模式实现中，闭包的运用非常广泛，在后续的学习过程中，我们将体会到这一点。 在 JavaScript 版本的各种设计模式实现中，闭包的运用非常广泛，在后续的学习过程中，我们将体会到这一点。 在完成闭包实现的命令模式之前，我们先用面向对象的方式来编写一段命令模式的代码。虽然还没有进入设计模式的学习，但这个作为演示作用的命令模式结构非常简单，不会对我们的理解造成困难，代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;body&gt; &lt;button id=\"execute\"&gt;点击我执行命令&lt;/button&gt; &lt;button id=\"undo\"&gt;点击我执行命令&lt;/button&gt; &lt;script&gt; var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var OpenTvCommand = function( receiver )&#123; this.receiver = receiver; &#125;; OpenTvCommand.prototype.execute = function()&#123; this.receiver.open(); // 执行命令，打开电视机 &#125;; OpenTvCommand.prototype.undo = function()&#123; this.receiver.close(); // 撤销命令，关闭电视机 &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( new OpenTvCommand( Tv ) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 但在 JavaScript 中，函数作为一等对象，本身就可以四处传递，用函数对象而不是普通对象来封装请求显得更加简单和自然。如果需要往函数对象中预先植入命令的接收者，那么闭包可以完成这个工作。在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来；而在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中，代码如下： 1234567891011121314151617181920212223242526272829var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125;&#125;;var createCommand = function( receiver )&#123; var execute = function()&#123; return receiver.open(); // 执行命令，打开电视机 &#125; var undo = function()&#123; return receiver.close(); // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125;&#125;;var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125;&#125;;setCommand( createCommand( Tv ) ); 1.6 闭包与内存管理闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 二、 高级函数高阶函数是指至少满足下列条件之一的函数： 函数可以作为参数被传递；函数可以作为返回值输出。 JavaScript 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当作参数传递，还是让函数的执行结果返回另外一个函数，这两种情形都有很多应用场景，下面就列举一些高阶函数的应用场景。 2.1 函数作为参数传递把函数当作参数传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。 2.1.1 回调函数在 ajax 异步请求的应用中，回调函数的使用非常频繁。当我们想在 ajax 请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把 callback 函数当作参数传入发起 ajax 请求的方法中，待请求完成之后执行 callback 函数： 12345678910var getUserInfo = function( userId, callback )&#123; $.ajax( 'http://xxx.com/getUserInfo?' + userId, function( data )&#123; if ( typeof callback === 'function' )&#123; callback( data ); &#125; &#125;);&#125;getUserInfo( 13157, function( data )&#123; alert ( data.userName );&#125;); 回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行。 比如，我们想在页面中创建 100 个 div 节点，然后把这些 div 节点都设置为隐藏。下面是一种编写代码的方式： 123456789var appendDiv = function () &#123; for (var i = 0; i &lt; 100; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); div.style.display = 'none'; &#125;&#125;;appendDiv(); 把 div.style.display = ‘none’的逻辑硬编码在 appendDiv 里显然是不合理的，appendDiv 未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。 于是我们把 div.style.display = ‘none’这行代码抽出来，用回调函数的形式传入 appendDiv方法： 12345678910111213var appendDiv = function (callback) &#123; for (var i = 0; i &lt; 100; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); if (typeof callback === 'function') &#123; callback(div); &#125; &#125;&#125;;appendDiv(function (node) &#123; node.style.display = 'none';&#125;); 可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在回调函数中，“委托”给 appendDiv 方法。appendDiv 方法当然知道节点什么时候创建好，所以在节点创建好的时候，appendDiv 会执行之前客户传入的回调函数。 2.1.2 Array.prototype.sortArray.prototype.sort 接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。从Array.prototype.sort 的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入Array.prototype.sort，使 Array.prototype.sort 方法成为了一个非常灵活的方法，代码如下： 12345678910//从小到大排列[1, 4, 3].sort(function (a, b) &#123; return a - b; &#125;);// 输出: [ 1, 3, 4 ]//从大到小排列[1, 4, 3].sort(function (a, b) &#123; return b - a;&#125;);// 输出: [ 4, 3, 1 ] 2.2 函数作为返回值输出相比把函数当作参数传递，函数当作返回值输出的应用场景也许更多，也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。 2.2.1 判断数据的类型我们来看看这个例子，判断一个数据是否是数组，在以往的实现中，可以基于鸭子类型的概念来判断，比如判断这个数据有没有 length 属性，有没有 sort 方法或者 slice 方法等。但更好的方式是用 Object.prototype.toString 来计算。Object.prototype.toString.call( obj )返回一个字符串，比如 Object.prototype.toString.call( [1,2,3] ) 总是返回 “[object Array]” ， 而Object.prototype.toString.call( “str”)总是返回”[object String]”。所以我们可以编写一系列的isType 函数。代码如下： 123456789 var isString = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object String]';&#125;;var isArray = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]';&#125;;var isNumber = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object Number]';&#125;; 我们发现，这些函数的大部分实现都是相同的，不同的只是 Object.prototype.toString.call( obj )返回的字符串。为了避免多余的代码，我们尝试把这些字符串作为参数提前值入 isType函数。代码如下： 1234567891011121314151617181920var isType = function (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125;&#125;; var isString = isType('String');var isArray = isType('Array');var isNumber = isType('Number');console.log(isArray([1, 2, 3])); // 输出：true//我们还可以用循环语句，来批量注册这些 isType 函数：var Type = &#123;&#125;;for (var i = 0, type; type = ['String', 'Array', 'Number'][i++];) &#123; (function (type) &#123; Type['is' + type] = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125; &#125;)(type)&#125;;Type.isArray([]); // 输出：trueType.isString(\"str\"); // 输出：true 2.2.2 getSingle下面是一个单例模式的例子，在第三部分设计模式的学习中，我们将进行更深入的讲解，这里暂且只了解其代码实现： 123456var getSingle = function ( fn ) &#123; var ret; return function () &#123; return ret || ( ret = fn.apply( this, arguments ) ); &#125;;&#125;; 这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数。我们可以看看 getSingle 函数的效果： 12345678910111213var getSingle = function (fn) &#123; var ret; return function () &#123; return ret || (ret = fn.apply(this, arguments)); &#125;;&#125;; var getScript = getSingle(function () &#123; return document.createElement('script');&#125;);var script1 = getScript();var script2 = getScript();alert(script1 === script2); // 输出：true 2.3 高阶函数实现AOPAOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 在 Java 语言中，可以通过反射和动态代理机制来实现 AOP 技术。而在 JavaScript 这种动态语言中，AOP 的实现更加简单，这是 JavaScript 与生俱来的能力。 通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，本节我们通过扩展 Function.prototype 来做到这一点。代码如下： 123456789101112131415161718192021222324Function.prototype.before = function (beforefn) &#123; var __self = this; // 保存原函数的引用 return function () &#123; // 返回包含了原函数和新函数的\"代理\"函数 beforefn.apply(this, arguments); // 执行新函数，修正 this return __self.apply(this, arguments); // 执行原函数 &#125;&#125;;Function.prototype.after = function (afterfn) &#123; var __self = this; return function () &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;;var func = function () &#123; console.log(2);&#125;;func = func.before(function () &#123; console.log(1);&#125;).after(function () &#123; console.log(3);&#125;);func(); //1, 2, 3 我们把负责打印数字 1 和打印数字 3 的两个函数通过 AOP 的方式动态植入 func 函数。通过执行上面的代码，我们看到控制台顺利地返回了执行结果 1、2、3。 这种使用 AOP 的方式来给函数添加职责，也是 JavaScript 语言中一种非常特别和巧妙的装饰者模式实现。这种装饰者模式在实际开发中非常有用。 2.4 高阶函数的其他应用前面我们已经学习过高阶函数，本节我们再挑选一些常见的高阶函数应用进行介绍。 2.4.1 currying首先我们讨论的是函数柯里化（function currying）。currying 的概念最早由俄国数学家 MosesSchönfinkel 发明，而后由著名的数理逻辑学家 Haskell Curry 将其丰富和发展，currying 由此得名。 currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。 从字面上理解 currying 并不太容易，我们来看下面的例子。 假设我们要编写一个计算每月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱。代码如下： 123456789var monthlyCost = 0;var cost = function( money )&#123; monthlyCost += money;&#125;;cost( 100 ); // 第 1 天开销cost( 200 ); // 第 2 天开销cost( 300 ); // 第 3 天开销//cost( 700 ); // 第 30 天开销alert ( monthlyCost ); // 输出：600 通过这段代码可以看到，每天结束后我们都会记录并计算到今天为止花掉的钱。但我们其实并不太关心每天花掉了多少钱，而只想知道到月底的时候会花掉多少钱。也就是说，实际上只需要在月底计算一次。 如果在每个月的前 29 天，我们都只是保存好当天的开销，直到第 30 天才进行求值计算，这样就达到了我们的要求。虽然下面的 cost 函数还不是一个 currying 函数的完整实现，但有助于我们了解其思想： 123456789101112131415161718var cost = (function () &#123;var args = [];return function () &#123; if (arguments.length === 0) &#123; var money = 0; for (var i = 0, l = args.length; i &lt; l; i++) &#123; money += args[i]; &#125; return money; &#125; else &#123; [].push.apply(args, arguments); &#125; &#125;&#125;)();cost(100); // 未真正求值cost(200); // 未真正求值cost(300); // 未真正求值console.log(cost()); // 求值并输出：600 接下来我们编写一个通用的 function currying(){}，function currying(){}接受一个参数，即将要被 currying 的函数。在这个例子里，这个函数的作用遍历本月每天的开销并求出它们的总和。代码如下： 12345678910111213141516171819202122232425var currying = function (fn) &#123; var args = []; return function () &#123; if (arguments.length === 0) &#123; return fn.apply(this, args); &#125; else &#123; [].push.apply(args, arguments); return arguments.callee; &#125; &#125;&#125;;var cost = (function () &#123; var money = 0; return function () &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; money += arguments[i]; &#125; return money; &#125;&#125;)();var cost = currying(cost); // 转化成 currying 函数cost(100); // 未真正求值cost(200); // 未真正求值cost(300); // 未真正求值alert(cost()); // 求值并输出：600 至此，我们完成了一个 currying 函数的编写。当调用 cost()时，如果明确地带上了一些参数，表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让 cost 函数返回另外一个函数。只有当我们以不带参数的形式执行 cost()时，才利用前面保存的所有参数，真正开始进行求值计算。 2.4.2 uncurrying在 JavaScript 中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。 同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？ 答案对于我们来说很简单，call 和 apply 都可以完成这个需求： 123456789var obj1 = &#123; name: 'sven'&#125;;var obj2 = &#123; getName: function()&#123; return this.name; &#125;&#125;;console.log( obj2.getName.call( obj1 ) ); // 输出：sven 我们常常让类数组对象去借用 Array.prototype 的方法，这是 call 和 apply 最常见的应用场景之一： 1234(function()&#123; Array.prototype.push.call( arguments, 4 ); // arguments 借用 Array.prototype.push 方法 console.log( arguments ); // 输出：[1, 2, 3, 4]&#125;)( 1, 2, 3 ); 在我们的预期中，Array.prototype 上的方法原本只能用来操作 array 对象。但用 call 和 apply可以把任意对象当作 this 传入某个方法，这样一来，方法中用到 this 的地方就不再局限于原来规定的对象，而是加以泛化并得到更广的适用性。 那么有没有办法把泛化 this 的过程提取出来呢？本小节讲述的 uncurrying 就是用来解决这个问题的。uncurrying 的话题来自 JavaScript 之父 Brendan Eich 在 2011 年发表的一篇 Twitter。以下代码是 uncurrying 的实现方式之一： 1234567Function.prototype.uncurrying = function () &#123; var self = this; return function () &#123; var obj = Array.prototype.shift.call(arguments); return self.apply(obj, arguments); &#125;;&#125;; 在讲解这段代码的实现原理之前，我们先来瞧瞧它有什么作用。 在类数组对象 arguments 借用 Array.prototype 的方法之前，先把 Array.prototype.push.call这句代码转换为一个通用的 push 函数： 12345var push = Array.prototype.push.uncurrying();(function()&#123; push( arguments, 4 ); console.log( arguments ); // 输出：[1, 2, 3, 4]&#125;)( 1, 2, 3 ); 通过 uncurrying 的方式，Array.prototype.push.call 变成了一个通用的 push 函数。这样一来，push 函数的作用就跟 Array.prototype.push 一样了，同样不仅仅局限于只能操作 array 对象。而对于使用者而言，调用 push 函数的方式也显得更加简洁和意图明了。 我们还可以一次性地把 Array.prototype 上的方法“复制”到 array 对象上，同样这些方法可操作的对象也不仅仅只是 array 对象： 1234567891011121314151617for (var i = 0, fn, ary = ['push', 'shift', 'forEach']; fn = ary[i++];) &#123; Array[fn] = Array.prototype[fn].uncurrying();&#125;;var obj = &#123; \"length\": 3, \"0\": 1, \"1\": 2, \"2\": 3&#125;;Array.push(obj, 4); // 向对象中添加一个元素console.log(obj.length); // 输出：4var first = Array.shift(obj); // 截取第一个元素console.log(first); // 输出：1console.log(obj); // 输出：&#123;0: 2, 1: 3, 2: 4, length: 3&#125;Array.forEach(obj, function (i, n) &#123; console.log(n); // 分别输出：0, 1, 2&#125;); 甚至 Function.prototype.call 和 Function.prototype.apply 本身也可以被 uncurrying，不过这没有实用价值，只是使得对函数的调用看起来更像 JavaScript 语言的前身 Scheme： 12345678910111213141516171819202122232425262728293031323334353637383940var call = Function.prototype.call.uncurrying();var fn = function (name) &#123; console.log(name); &#125;;call(fn, window, 'sven'); // 输出：svenvar apply = Function.prototype.apply.uncurrying();var fn = function (name) &#123; console.log(this.name); // 输出：\"sven\" console.log(arguments); // 输出: [1, 2, 3]&#125;;apply(fn, &#123; name: 'sven' &#125;, [1, 2, 3]);//目前我们已经给出了 Function.prototype.uncurrying 的一种实现。现在来分析调用Array.prototype.push.uncurrying()//这句代码时发生了什么事情：Function.prototype.uncurrying = function () &#123; var self = this; // self 此时是 Array.prototype.push return function () &#123; var obj = Array.prototype.shift.call(arguments); // obj 是&#123; // \"length\": 1, // \"0\": 1 // &#125; // arguments 对象的第一个元素被截去，剩下[2] return self.apply(obj, arguments); // 相当于 Array.prototype.push.apply( obj, 2 ) &#125;;&#125;;var push = Array.prototype.push.uncurrying();var obj = &#123; \"length\": 1, \"0\": 1&#125;;push(obj, 2);console.log(obj); // 输出：&#123;0: 1, 1: 2, length: 2&#125;//除了刚刚提供的代码实现，下面的代码是 uncurrying 的另外一种实现方式：Function.prototype.uncurrying = function () &#123; var self = this; return function () &#123; return Function.prototype.call.apply(self, arguments); &#125;&#125;; 2.4.3 函数节流JavaScript 中的函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则我们一般不会遇到跟性能相关的问题。但在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。下面将列举一些这样的场景。 (1) 函数被频繁调用的场景 window.onresize 事件。我们给 window 对象绑定了 resize 事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在 window.onresize 事件函数里有一些跟 DOM 节点相关的操作，而跟 DOM 节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。mousemove 事件。同样，如果我们给一个 div 节点绑定了拖曳事件（主要是 mousemove），当div 节点被拖动的时候，也会频繁地触发该拖曳事件函数。上传进度。微云的上传功能使用了公司提供的一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知 JavaScript 函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约一秒钟 10 次，很显然我们在页面中不需要如此频繁地去提示用户。 (2) 函数节流的原理 我们整理上面提到的三个场景，发现它们面临的共同问题是函数被触发的频率太高。 比如我们在 window.onresize 事件中要打印当前的浏览器窗口大小，在我们通过拖曳来改变窗口大小的时候，打印窗口大小的工作 1 秒钟进行了 10 次。而我们实际上只需要 2 次或者 3 次。这就需要我们按时间段来忽略掉一些事件请求，比如确保在 500ms 内只打印一次。很显然，我们可以借助 setTimeout 来完成这件事情。 (3) 函数节流的代码实现 关于函数节流的代码实现有许多种，下面的 throttle 函数的原理是，将即将被执行的函数用setTimeout 延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。throttle 函数接受 2 个参数，第一个参数为需要被延迟执行的函数，第二个参数为延迟执行的时间。具体实现代码如下： 1234567891011121314151617181920212223242526var throttle = function (fn, interval) &#123; var __self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true; // 是否是第一次调用 return function () &#123; var args = arguments, __me = this; console.log(args); if (firstTime) &#123; // 如果是第一次调用，不需延迟执行 __self.apply(__me, args); return firstTime = false; &#125; if (timer) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return false; &#125; timer = setTimeout(function () &#123; // 延迟一段时间执行 clearTimeout(timer); timer = null; __self.apply(__me, args); &#125;, interval || 500); &#125;;&#125;;window.onresize = throttle(function () &#123; console.log(arguments) console.log(1);&#125;, 500); 2.4.4 分时函数在前面关于函数节流的讨论中，我们提供了一种限制函数被频繁调用的解决方案。下面我们将遇到另外一个问题，某些函数确实是用户主动调用的，但因为一些客观的原因，这些函数会严重地影响页面性能。 一个例子是创建 WebQQ 的 QQ 好友列表。列表中通常会有成百上千个好友，如果一个好友用一个节点来表示，当我们在页面中渲染这个列表的时候，可能要一次性往页面中创建成百上千个节点。 在短时间内往页面中大量添加 DOM 节点显然也会让浏览器吃不消，我们看到的结果往往就是浏览器的卡顿甚至假死。代码如下： 123456789101112var ary = [];for (var i = 1; i &lt;= 1000; i++) &#123; ary.push(i); // 假设 ary 装载了 1000 个好友的数据&#125;;var renderFriendList = function (data) &#123; for (var i = 0, l = data.length; i &lt; l; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); &#125;&#125;;renderFriendList(ary); 这个问题的解决方案之一是下面的 timeChunk 函数，timeChunk 函数让创建节点的工作分批进行，比如把 1 秒钟创建 1000 个节点，改为每隔 200 毫秒创建 8 个节点。timeChunk 函数接受 3 个参数，第 1 个参数是创建节点时需要用到的数据，第 2 个参数是封装了创建节点逻辑的函数，第 3 个参数表示每一批创建的节点数量。代码如下： 12345678910111213141516171819202122232425262728293031var timeChunk = function (ary, fn, count) &#123; //ary创建节点时需要用到的数据，fn 封装创建节点逻辑的函数，count每一批创建的节点数量 var obj, t; var len = ary.length; var start = function () &#123; for (var i = 0; i &lt; Math.min(count || 1, ary.length); i++) &#123; var obj = ary.shift(); console.log(obj) fn(obj); &#125; &#125;; return function () &#123; t = setInterval(function () &#123; if (ary.length === 0) &#123; // 如果全部节点都已经被创建好 return clearInterval(t); &#125; start(); &#125;, 200); // 分批执行的时间间隔，也可以用参数的形式传入 &#125;;&#125;; var ary = [];for (var i = 1; i &lt;= 1000; i++) &#123; ary.push(i);&#125;;var renderFriendList = timeChunk(ary, function (n) &#123; var div = document.createElement('div'); div.innerHTML = n; document.body.appendChild(div);&#125;, 8);renderFriendList(); 2.4.5 惰性加载函数Web 开发中，因为浏览器之间的实现差异，一些嗅探工作总是不可避免。比如我们需要一个在各个浏览器中能够通用的事件绑定函数 addEvent，常见的写法如下： 12345678var addEvent = function (elem, type, handler) &#123; if (window.addEventListener) &#123; return elem.addEventListener(type, handler, false); &#125; if (window.attachEvent) &#123; return elem.attachEvent('on' + type, handler); &#125;&#125;; 这个函数的缺点是，当它每次被调用的时候都会执行里面的 if 条件分支，虽然执行这些 if分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行过程。 第二种方案是这样，我们把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，以便让 addEvent 返回一个包裹了正确逻辑的函数。代码如下： 123456789101112var addEvent = (function () &#123; if (window.addEventListener) &#123; return function (elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; if (window.attachEvent) &#123; return function (elem, type, handler) &#123; elem.attachEvent('on' + type, handler); &#125; &#125;&#125;)(); 目前的 addEvent 函数依然有个缺点，也许我们从头到尾都没有使用过 addEvent 函数，这样看来，前一次的浏览器嗅探就是完全多余的操作，而且这也会稍稍延长页面 ready 的时间。 第三种方案即是我们将要讨论的惰性载入函数方案。此时 addEvent 依然被声明为一个普通函数，在函数里依然有一些分支判断。但是在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是我们期望的 addEvent 函数，在下一次进入 addEvent 函数的时候，addEvent函数里不再存在条件分支语句： 1234567891011121314151617181920212223242526&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;点我绑定事件&lt;/div&gt; &lt;script&gt; var addEvent = function( elem, type, handler )&#123; if ( window.addEventListener )&#123; addEvent = function( elem, type, handler )&#123; elem.addEventListener( type, handler, false ); &#125; &#125;else if ( window.attachEvent )&#123; addEvent = function( elem, type, handler )&#123; elem.attachEvent( 'on' + type, handler ); &#125; &#125; addEvent( elem, type, handler ); &#125;; var div = document.getElementById( 'div1' ); addEvent( div, 'click', function()&#123; alert (1); &#125;); addEvent( div, 'click', function()&#123; alert (2); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 三、 小结在进入设计模式的学习之前，本章挑选了闭包和高阶函数来进行讲解。这是因为在 JavaScript开发中，闭包和高阶函数的应用极多。就设计模式而言，因为 JavaScript 这门语言的自身特点，许多设计模式在 JavaScript 之中的实现跟在一些传统面向对象语言中的实现相差很大。在JavaScript 中，很多设计模式都是通过闭包和高阶函数实现的。这并不奇怪，相对于模式的实现过程，我们更关注的是模式可以帮助我们完成什么。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践二（this、call 和 apply）","date":"2019-04-29T03:18:40.000Z","path":"2019/04/29/cjxe4h6og00146sup89ilct3o/","text":"在 JavaScript 编程中，this 关键字总是让初学者感到迷惑，Function.prototype.call 和Function.prototype.apply 这两个方法也有着广泛的运用。我们有必要在学习设计模式之前先理解这几个概念。 一、 this跟别的语言大相径庭的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 1.1 this的指向除去不常用的 with 和 eval 的情况，具体到实际应用中，this 的指向大致可以分为以下 4 种。 作为对象的方法调用。作为普通函数调用。构造器调用。Function.prototype.call 或 Function.prototype.apply 调用。 下面我们分别进行介绍。 1.1.1 作为对象的方法调用当函数作为对象的方法被调用时，this 指向该对象： 12345678var obj = &#123; a: 1, getA: function () &#123; alert(this === obj); // 输出：true alert(this.a); // 输出: 1 &#125;&#125;;obj.getA(); 1.1.2 作为普通函数调用当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。 12345window.name = 'globalName';var getName = function () &#123; return this.name;&#125;;console.log(getName()); // 输出：globalName 或者： 123456789window.name = 'globalName';var myObject = &#123; name: 'sven', getName: function () &#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log(getName()); // globalName 有时候我们会遇到一些困扰，比如在 div 节点的事件函数内部，有一个局部的 callback 方法，callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向该 div 节点，见如下代码： 123456789101112131415&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;我是一个 div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.id = 'window'; document.getElementById( 'div1' ).onclick = function()&#123; alert ( this.id ); // 输出：'div1' var callback = function()&#123; alert ( this.id ); // 输出：'window' &#125; callback(); &#125;; &lt;/script&gt;&lt;/html&gt; 此时有一种简单的解决方案，可以用一个变量保存 div 节点的引用： 1234567document.getElementById( 'div1' ).onclick = function()&#123; var that = this; // 保存 div 的引用 var callback = function()&#123; alert ( that.id ); // 输出：'div1' &#125; callback();&#125;; 在 ECMAScript 5 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined： 12345function func()&#123; \"use strict\" alert ( this ); // 输出：undefined&#125;func(); 1.1.3 构造器调用JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。 除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码： 12345var MyClass = function()&#123; this.name = 'sven';&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：sven 但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this： 12345678var MyClass = function()&#123; this.name = 'sven'; return &#123; // 显式地返回一个对象 name: 'anne' &#125;&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：anne 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题 123456var MyClass = function()&#123; this.name = 'sven' return 'anne'; // 返回 string 类型&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：sven 1.1.4 Function.prototype.call 或 Function.prototype.apply 调用跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this： 1234567891011var obj1 = &#123; name: 'sven', getName: function()&#123; return this.name; &#125;&#125;;var obj2 = &#123; name: 'anne'&#125;;console.log( obj1.getName() ); // 输出: svenconsole.log( obj1.getName.call( obj2 ) ); // 输出：anne call 和 apply 方法能很好地体现 JavaScript 的函数式语言特性，在 JavaScript 中，几乎每一次编写函数式语言风格的代码，都离不开 call 和 apply。在 JavaScript 诸多版本的设计模式中，也用到了 call 和 apply。在下一节会详细介绍它们。 1.2 丢失的this这是一个经常遇到的问题，我们先看下面的代码： 123456789var obj = &#123; myName: 'sven', getName: function () &#123; return this.myName; &#125;&#125;;console.log(obj.getName()); // 输出：'sven'var getName2 = obj.getName;console.log(getName2()); // 输出：undefined 当调用 obj.getName 时，getName 方法是作为 obj 对象的属性被调用的，根据前面提到的规律，此时的 this 指向 obj 对象，所以 obj.getName()输出’sven’。 当用另外一个变量 getName2 来引用 obj.getName，并且调用 getName2 时，根据前面提到的规律，此时是普通函数调用方式，this 是指向全局 window 的，所以程序的执行结果是undefined。 再看另一个例子，document.getElementById 这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它，如同 prototype.js 等一些框架所做过的事情： 1234var getId = function( id )&#123; return document.getElementById( id );&#125;; getId( 'div1' ); 我们也许思考过为什么不能用下面这种更简单的方式： 12var getId = document.getElementById;getId( 'div1' ); 在浏览器中运行以上代码： 123456789&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;我是一个 div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var getId = document.getElementById; getId( 'div1' ); &lt;/script&gt;&lt;/html&gt; 在 Chrome、Firefox、IE10 中执行过后就会发现，这段代码抛出了一个异常。这是因为许多引擎的 document.getElementById 方法的内部实现中需要用到 this。这个 this 本来被期望指向document，当 getElementById 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指向 document 的。 但当用 getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用，函数内部的 this 指向了 window，而不是原来的 document。 我们可以尝试利用 apply 把 document 当作 this 传入 getId 函数，帮助“修正”this： 12345678document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document, arguments); &#125;&#125;)(document.getElementById);var getId = document.getElementById;var div = getId('div1');alert(div.id); // 输出： div1 二、 call 和 applyECAMScript 3给Function的原型定义了两个方法，它们是Function.prototype.call和Function.prototype.apply。在实际开发中，特别是在一些函数式风格的代码编写中，call和 apply 方法尤为有用。在 JavaScript 版本的设计模式中，这两个方法的应用也非常广泛，能熟练运用这两个方法，是我们真正成为一名 JavaScript 程序员的重要一步。 2.1 call和apply的区别Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。 apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数： 1234var func = function( a, b, c )&#123; alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]&#125;;func.apply( null, [ 1, 2, 3 ] ); 在这段代码中，参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列表中的 a、b、c。 call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数： 1234var func = function (a, b, c) &#123; alert([a, b, c]); // 输出 [ 1, 2, 3 ]&#125;;func.call(null, 1, 2, 3); 当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript 的参数在内部就是用一个数组来表示的。从这个意义上说，apply 比call 的使用率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了。 call 是包装在 apply 上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call 来传送参数。 当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window： 1234var func = function( a, b, c )&#123; alert ( this === window ); // 输出 true &#125;;func.apply( null, [ 1, 2, 3 ] ); 但如果是在严格模式下，函数体内的 this 还是为 null： 12345var func = function( a, b, c )&#123;\"use strict\"; alert ( this === null ); // 输出 true&#125;func.apply( null, [ 1, 2, 3 ] ); 有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象： 1Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输出：5 2.2 call和apply的用途前面说过，能够熟练使用 call 和 apply，是我们真正成为一名 JavaScript 程序员的重要一步，本节我们将详细介绍 call 和 apply 在实际开发中的用途。 2.2.1 改变 this 指向call 和 apply 最常见的用途是改变函数内部的 this 指向，我们来看个例子： 12345678910111213var obj1 = &#123; name: 'sven'&#125;;var obj2 = &#123; name: 'anne'&#125;;window.name = 'window';var getName = function () &#123; alert(this.name);&#125;;getName(); // 输出: windowgetName.call(obj1); // 输出: svengetName.call(obj2); // 输出: anne 当执行 getName.call( obj1 )这句代码时，getName 函数体内的 this 就指向 obj1 对象，所以此处的 123var getName = function()&#123; alert ( this.name );&#125;; 实际上相当于： 123var getName = function()&#123; alert ( obj1.name ); // 输出: sven&#125;; 在实际开发中，经常会遇到 this 指向被不经意改变的场景，比如有一个 div 节点，div 节点的 onclick 事件中的 this 本来是指向这个 div 的： 123document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1&#125;; 假如该事件函数中有一个内部函数 func，在事件内部调用 func 函数时，func 函数体内的 this就指向了 window，而不是我们预期的 div，见如下代码： 1234567document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1 var func = function()&#123; alert ( this.id ); // 输出：undefined &#125; func();&#125;; 这时候我们用 call 来修正 func 函数内的 this，使其依然指向 div： 1234567document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1 var func = function()&#123; alert ( this.id ); // 输出：输出：div1 &#125; func.call(this);&#125;; 使用 call 来修正 this 的场景，我们并非第一次遇到，在前面关于 this 的学习中，我们就曾经修正过 document.getElementById 函数内部“丢失”的 this，代码如下： 12345678document.getElementById = (function( func )&#123; return function()&#123; return func.apply( document, arguments ); &#125;&#125;)( document.getElementById );var getId = document.getElementById;var div = getId( 'div1' );alert ( div.id ); // 输出： div1 2.2.2 Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this指向，即使没有原生的 Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下： 1234567891011121314Function.prototype.bind = function (context) &#123; var self = this; // 保存原函数 return function () &#123; // 返回一个新的函数 return self.apply(context, arguments); // 执行新的函数的时候，会把之前传入的 context // 当作新函数体内的 this &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function () &#123; alert(this.name); // 输出：sven&#125;.bind(obj);func(); 我们通过 Function.prototype.bind 来“包装”func 函数，并且传入一个对象 context 当作参数，这个 context 对象就是我们想修正的 this 对象。 在 Function.prototype.bind 的内部实现中，我们先把 func 函数的引用保存起来，然后返回一个新的函数。当我们在将来执行 func 函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply( context, arguments )这句代码才是执行原来的 func 函数，并且指定 context对象为 func 函数体内的 this。 这是一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一点，使得可以往 func 函数中预先填入一些参数： 123456789101112131415161718Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的 this 上下文 args = [].slice.call(arguments); // 剩余的参数转成数组 return function () &#123; // 返回一个新的函数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this // 并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function (a, b, c, d) &#123; alert(this.name); // 输出：sven alert([a, b, c, d]) // 输出：[ 1, 2, 3, 4 ]&#125;.bind(obj, 1, 2);func(3, 4); 2.2.3 借用其他对象的方法我们知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让它们代为孵化和养育。同样，在 JavaScript 中也存在类似的借用现象。 借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果： 1234567891011var A = function (name) &#123; this.name = name;&#125;;var B = function () &#123; A.apply(this, arguments);&#125;;B.prototype.getName = function () &#123; return this.name;&#125;;var b = new B('sven');console.log(b.getName()); // 输出： 'sven' 借用方法的第二种运用场景跟我们的关系更加密切。 函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用Array.prototype.push： 1234(function () &#123; Array.prototype.push.call(arguments, 3); console.log(arguments); // 输出[1,2,3]&#125;)(1, 2); 在操作 arguments 的时候，我们经常非常频繁地找 Array.prototype 对象借用方法。 想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内部实现原理是什么呢？我们不妨翻开 V8 的引擎源码，以 Array.prototype.push 为例，看看 V8 引擎中的具体实现： 123456789function ArrayPush() &#123; var n = TO_UINT32(this.length); // 被 push 的对象的 length var m = % _ArgumentsLength(); // push 的参数个数 for (var i = 0; i &lt; m; i++) &#123; this[i + n] = % _Arguments(i); // 复制元素 (1) &#125; this.length = n + m; // 修正 length 属性的值 (2) return this.length;&#125;; 通过这段代码可以看到，Array.prototype.push 实际上是一个属性复制的过程，把参数按照下标依次添加到被 push 的对象上面，顺便修改了这个对象的 length 属性。至于被修改的对象是谁，到底是数组还是类数组对象，这一点并不重要。 由此可以推断，我们可以把“任意”对象传入 Array.prototype.push 1234var a = &#123;&#125;;Array.prototype.push.call(a, 'first');alert(a.length); // 输出：1alert(a[0]); // first 这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版本的 IE 浏览器中执行，必须显式地给对象 a 设置 length 属性： 123var a = &#123; length: 0&#125;; 前面我们之所以把“任意”两字加了双引号，是因为可以借用 Array.prototype.push 方法的对象还要满足以下两个条件，从 ArrayPush 函数的(1)处和(2)处也可以猜到，这个对象至少还要满足： 对象本身要可以存取属性；对象的 length 属性可读写。 对于第一个条件，对象本身存取属性并没有问题，但如果借用 Array.prototype.push 方法的不是一个 object 类型的数据，而是一个 number 类型的数据呢? 我们无法在 number 身上存取其他数据，那么从下面的测试代码可以发现，一个 number 类型的数据不可能借用到 Array.prototype.push 方法： 1234var a = 1;Array.prototype.push.call(a, 'first');alert(a.length); // 输出：undefinedalert(a[0]); // 输出：undefined 对于第二个条件，函数的 length 属性就是一个只读的属性，表示形参的个数，我们尝试把一个函数当作 this 传入 Array.prototype.push： 1234var func = function () &#123; &#125;;Array.prototype.push.call(func, 'first');alert(func.length);// 报错：cannot assign to read only property ‘length’ of function()&#123;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践一（面向对象的JavaScript ）","date":"2019-04-18T07:36:40.000Z","path":"2019/04/18/cjxe4h6r400256supa3ebbsjo/","text":"JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript 也没有在语言层面提供对抽象类和接口的支持。正因为存在这些跟传统面向对象语言不一致的地方，我们在用设计模式编写代码的时候，更要跟传统面向对象语言加以区别。所以在正式学习设计模式之前，我们有必要先了解一些 JavaScript 在面向对象方面的知识。 一、 动态类型语言和鸭子类型编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。 静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。 静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。 静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。 动态类型语言的优点是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。 动态类型语言的缺点是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。这好像在商店买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味。 JavaScript 中，当我们对一个变量赋值时，显然不需要考虑它的类型，因此，JavaScript是一门典型的动态类型语言。 动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。 这一切都建立在鸭子类型（duck typing）的概念上，鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。” 我们可以通过一个小故事来更深刻地了解鸭子类型。 从前在 JavaScript 王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个 1000 只鸭子组成的合唱团。大臣们找遍了全国，终于找到 999 只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为了合唱团的最后一员。 这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注 HAS-A, 而不是 IS-A。 下面我们用代码来模拟这个故事。 1234567891011121314151617181920var duck = &#123; duckSinging: function () &#123; console.log('嘎嘎嘎'); &#125;&#125;;var chicken = &#123; duckSinging: function () &#123; console.log('嘎嘎嘎'); &#125;&#125;;var choir = []; // 合唱团var joinChoir = function (animal) &#123; if (animal &amp;&amp; typeof animal.duckSinging === 'function') &#123; choir.push(animal); console.log('恭喜加入合唱团'); console.log('合唱团已有成员数量:' + choir.length); &#125;&#125;;joinChoir(duck); // 恭喜加入合唱团joinChoir(chicken); // 恭喜加入合唱团 我们看到，对于加入合唱团的动物，大臣们根本无需检查它们的类型，而是只需要保证它们拥有 duckSinging 方法。如果下次期望加入合唱团的是一只小狗，而这只小狗刚好也会鸭子叫，我相信这只小狗也能顺利加入。 在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥有 slice 和 splice 等方法），这个对象就可以被当作数组来使用。 在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行向上转型。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类型检查系统的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。 “面向接口编程”是设计模式中最重要的思想，但在 JavaScript 语言中，“面向接口编程”的过程跟主流的静态类型语言不一样，因此，在 JavaScript 中实现设计模式的过程与在一些我们熟悉的语言中实现的过程会大相径庭。 二、 多肽“多态”一词源于希腊文 polymorphism，拆开来看是 poly（复数）+ morph（形态）+ ism，从字面上我们可以理解为复数形态。 多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 从字面上来理解多态不太容易，下面我们来举例说明一下。 主人家里养了两只动物，分别是一只鸭和一只鸡，当主人向它们发出“叫”的命令时，鸭会“嘎嘎嘎”地叫，而鸡会“咯咯咯”地叫。这两只动物都会以自己的方式来发出叫声。它们同样“都是动物，并且可以发出叫声”，但根据主人的指令，它们会各自发出不同的叫声。 其实，其中就蕴含了多态的思想。下面我们通过代码进行具体的介绍。 2.1 一段“多态”的JavaScript代码我们把上面的故事用 JavaScript 代码实现如下： 1234567891011var makeSound = function (animal) &#123; if (animal instanceof Duck) &#123; console.log('嘎嘎嘎'); &#125; else if (animal instanceof Chicken) &#123; console.log('咯咯咯'); &#125;&#125;;var Duck = function () &#123; &#125;;var Chicken = function () &#123; &#125;;makeSound(new Duck()); // 嘎嘎嘎makeSound(new Chicken()); // 咯咯咯 这段代码确实体现了“多态性”，当我们分别向鸭和鸡发出“叫唤”的消息时，它们根据此消息作出了各自不同的反应。但这样的“多态性”是无法令人满意的，如果后来又增加了一只动物，比如狗，显然狗的叫声是“汪汪汪”，此时我们必须得改动 makeSound 函数，才能让狗也发出叫声。修改代码总是危险的，修改的地方越多，程序出错的可能性就越大，而且当动物的种类越来越多时，makeSound 有可能变成一个巨大的函数。 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来是可生长的，也是符合开放—封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。 2.2 对象的多态性下面是改写后的代码，首先我们把不变的部分隔离出来，那就是所有的动物都会发出叫声： 123var makeSound = function( animal )&#123; animal.sound();&#125;; 然后把可变的部分各自封装起来，我们刚才谈到的多态性实际上指的是对象的多态性： 12345678910var Duck = function()&#123;&#125;Duck.prototype.sound = function()&#123; console.log( '嘎嘎嘎' );&#125;;var Chicken = function()&#123;&#125;Chicken.prototype.sound = function()&#123; console.log( '咯咯咯' );&#125;;makeSound( new Duck() ); // 嘎嘎嘎makeSound( new Chicken() ); // 咯咯咯 现在我们向鸭和鸡都发出“叫唤”的消息，它们接到消息后分别作出了不同的反应。如果有一天动物世界里又增加了一只狗，这时候只要简单地追加一些代码就可以了，而不用改动以前的makeSound 函数，如下所示： 12345var Dog = function()&#123;&#125;Dog.prototype.sound = function()&#123; console.log( '汪汪汪' );&#125;;makeSound( new Dog() ); // 汪汪汪 2.3 类型检查和多态类型检查是在表现出对象多态性之前的一个绕不开的话题，但 JavaScript 是一门不必进行类型检查的动态类型语言，为了真正了解多态的目的，我们需要转一个弯，从一门静态类型语言说起。 我们在前面已经说明过静态类型语言在编译时会进行类型匹配检查。以 Java 为例，由于在代码编译时要进行严格的类型检查，所以不能给变量赋予不同类型的值，这种类型检查有时候会让代码显得僵硬，代码如下： 123String str;str = \"abc\"; // 没有问题str = 2; // 报错 现在我们尝试把上面让鸭子和鸡叫唤的例子换成 Java 代码： 12345678910111213141516171819202122public class Duck &#123; // 鸭子类 public void makeSound()&#123; System.out.println( \"嘎嘎嘎\" ); &#125;&#125; public class Chicken &#123; // 鸡类 public void makeSound()&#123; System.out.println( \"咯咯咯\" ); &#125;&#125;public class AnimalSound &#123; public void makeSound( Duck duck )&#123; // (1) duck.makeSound(); &#125;&#125;public class Test &#123; public static void main( String args[] )&#123; AnimalSound animalSound = new AnimalSound(); Duck duck = new Duck(); animalSound.makeSound( duck ); // 输出：嘎嘎嘎 &#125;&#125; 我们已经顺利地让鸭子可以发出叫声，但如果现在想让鸡也叫唤起来，我们发现这是一件不可能实现的事情。因为(1)处 AnimalSound 类的 makeSound 方法，被我们规定为只能接受Duck 类型的参数： 1234567public class Test &#123; public static void main( String args[] )&#123; AnimalSound animalSound = new AnimalSound(); Chicken chicken = new Chicken(); animalSound.makeSound( chicken ); // 报错，只能接受 Duck 类型的参数 &#125;&#125; 某些时候，在享受静态语言类型检查带来的安全性的同时，我们亦会感觉被束缚住了手脚。 为了解决这一问题，静态类型的面向对象语言通常被设计为可以向上转型：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。这就像我们在描述天上的一只麻雀或者一只喜鹊时，通常说“一只麻雀在飞”或者“一只喜鹊在飞”。但如果想忽略它们的具体类型，那么也可以说“一只鸟在飞”。 同理，当 Duck 对象和 Chicken 对象的类型都被隐藏在超类型 Animal 身后，Duck 对象和 Chicken对象就能被交换使用，这是让对象表现出多态性的必经之路，而多态性的表现正是实现众多设计模式的目标。 2.4 使用继承得到多态效果使用继承来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括实现继承和接口继承。接下来我们先讨论实现继承。 我们先创建一个 Animal 抽象类，再分别让 Duck 和 Chicken 都继承自 Animal 抽象类，下述代码中(1)处和(2)处的赋值语句显然是成立的，因为鸭子和鸡也是动物： 123456789101112131415public abstract class Animal &#123; abstract void makeSound(); // 抽象方法&#125;public class Chicken extends Animal&#123; public void makeSound()&#123; System.out.println( \"咯咯咯\" ); &#125;&#125;public class Duck extends Animal&#123; public void makeSound()&#123; System.out.println( \"嘎嘎嘎\" ); &#125;&#125;Animal duck = new Duck(); // (1)Animal chicken = new Chicken(); // (2) 现在剩下的就是让 AnimalSound 类的 makeSound 方法接受 Animal 类型的参数，而不是具体的Duck 类型或者 Chicken 类型： 1234567891011121314public class AnimalSound&#123; public void makeSound( Animal animal )&#123; // 接受 Animal 类型的参数 animal.makeSound(); &#125;&#125;public class Test &#123; public static void main( String args[] )&#123; AnimalSound animalSound= new AnimalSound (); Animal duck = new Duck(); Animal chicken = new Chicken(); animalSound.makeSound( duck ); // 输出嘎嘎嘎 animalSound.makeSound( chicken ); // 输出咯咯咯 &#125;&#125; 2.5 JavaScript的多态从前面的讲解我们得知，多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系。如果类型之间的耦合关系没有被消除，那么我们在 makeSound 方法中指定了发出叫声的对象是某个类型，它就不可能再被替换为另外一个类型。在 Java 中，可以通过向上转型来实现多态。 而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript 对象的多态性是与生俱来的。 这种与生俱来的多态性并不难解释。JavaScript 作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。在前面的代码示例中，我们既可以往 makeSound 函数里传递 duck 对象当作参数，也可以传递 chicken 对象当作参数。 由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是否是某种类型的对象，这里不存在任何程度上的“类型耦合”。这正是我们从上一节的鸭子类型中领悟的道理。在 JavaScript 中，并不需要诸如向上转型之类的技术来取得多态的效果。 2.6 多态在面向对象程序设计中的作用有许多人认为，多态是面向对象编程语言中最重要的技术。但我们目前还很难看出这一点，毕竟大部分人都不关心鸡是怎么叫的，也不想知道鸭是怎么叫的。让鸡和鸭在同一个消息之下发出不同的叫声，这跟程序员有什么关系呢？ Martin Fowler 在《重构：改善既有代码的设计》里写到： 多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。 换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 Martin Fowler 的话可以用下面这个例子很好地诠释： 在电影的拍摄现场，当导演喊出“action”时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前，确认它们的职业分工（类型），然后告诉他们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。 利用对象的多态性，导演在发布消息时，就不必考虑各个对象接到消息后应该做什么。对象应该做什么并不是临时决定的，而是已经事先约定和排练完毕的。每个对象应该做什么，已经成为了该对象的一个方法，被安装在对象的内部，每个对象负责它们自己的行为。所以这些对象可以根据同一个消息，有条不紊地分别进行各自的工作。 将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。 再看一个现实开发中遇到的例子，这个例子的思想和动物叫声的故事非常相似。 假设我们要编写一个地图应用，现在有两家可选的地图 API 提供商供我们接入自己的应用。目前我们选择的是谷歌地图，谷歌地图的 API 中提供了 show 方法，负责在页面上展示整个地图。示例代码如下： 123456789var googleMap = &#123; show: function()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;;var renderMap = function()&#123; googleMap.show();&#125;;renderMap(); // 输出：开始渲染谷歌地图 后来因为某些原因，要把谷歌地图换成百度地图，为了让 renderMap 函数保持一定的弹性，我们用一些条件分支来让 renderMap 函数同时支持谷歌地图和百度地图： 12345678910111213141516171819var googleMap = &#123; show: function()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;;var baiduMap = &#123; show: function()&#123; console.log( '开始渲染百度地图' ); &#125;&#125;;var renderMap = function( type )&#123; if ( type === 'google' )&#123; googleMap.show(); &#125;else if ( type === 'baidu' )&#123; baiduMap.show(); &#125;&#125;;renderMap( 'google' ); // 输出：开始渲染谷歌地图renderMap( 'baidu' ); // 输出：开始渲染百度地图 可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成搜搜地图，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。 我们还是先把程序中相同的部分抽象出来，那就是显示某个地图： 1234567var renderMap = function( map )&#123; if ( map.show instanceof Function )&#123; map.show(); &#125;&#125;;renderMap( googleMap ); // 输出：开始渲染谷歌地图renderMap( baiduMap ); // 输出：开始渲染百度地图 现在来找找这段代码中的多态性。当我们向谷歌地图对象和百度地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。对象的多态性提示我们，“做什么”和“怎么去做”是可以分开的，即使以后增加了搜搜地图，renderMap 函数仍然不需要做任何改变，如下所示： 123456var sosoMap = &#123; show: function()&#123; console.log( '开始渲染搜搜地图' ); &#125;&#125;;renderMap( sosoMap ); // 输出：开始渲染搜搜地图 在这个例子中，我们假设每个地图 API 提供展示地图的方法名都是 show，在实际开发中也许不会如此顺利，这时候可以借助适配器模式来解决问题。 2.7 设计模式与多态GoF 所著的《设计模式》一书的副书名是“可复用面向对象软件的基础”。该书完全是从面向对象设计的角度出发的，通过对封装、继承、多态、组合等技术的反复使用，提炼出一些可重复使用的面向对象设计技巧。而多态在其中又是重中之重，绝大部分设计模式的实现都离不开多态性的思想。 拿命令模式①来说，请求被封装在一些命令对象中，这使得命令的调用者和命令的接收者可以完全解耦开来，当调用命令的 execute 方法时，不同的命令会做不同的事情，从而会产生不同的执行结果。而做这些事情的过程是早已被封装在命令对象内部的，作为调用命令的客户，根本不必去关心命令执行的具体过程。 在组合模式②中，多态性使得客户可以完全忽略组合对象和叶节点对象之前的区别，这正是组合模式最大的作用所在。对组合对象和叶节点对象发出同一个消息的时候，它们会各自做自己应该做的事情，组合对象把消息继续转发给下面的叶节点对象，叶节点对象则会对这些消息作出真实的反馈。 在策略模式③中，Context 并没有执行算法的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算”的消息时，它们会返回各自不同的计算结果。 在 JavaScript 这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在 JavaScript 中可以用高阶函数来代替实现的原因。 三、 封装封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。 3.1 封装数据在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private、public、protected 等关键字来提供不同的访问权限。 但 JavaScript 并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，而且只能模拟出 public 和 private 这两种封装性。 除了 ECMAScript 6 中提供的 let 之外，一般我们通过函数来创建作用域： 12345678910var myObject = (function () &#123; var __name = 'sven'; // 私有（private）变量 return &#123; getName: function () &#123; // 公开（public）方法 return __name; &#125; &#125;&#125;)(); console.log(myObject.getName()); // 输出：svenconsole.log(myObject.__name) // 输出：undefined 另外值得一提的是，在 ECAMScript 6 中，还可以通过 Symbol 创建私有属性。详情可参阅 https://github.com/lukehoban/es6features，二维码如下。 3.2 封装实现上一节描述的封装，指的是数据层面的封装。有时候我们喜欢把封装等同于封装数据，但这是一种比较狭义的定义。 封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是1隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。 从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。 封装实现细节的例子非常之多。拿迭代器来说明，迭代器的作用是在不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。我们编写了一个 each 函数，它的作用就是遍历一个聚合对象，使用这个 each 函数的人不用关心它的内部是怎样实现的，只要它提供的功能正确便可以。即使 each 函数修改了内部源代码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变。 3.3 封装类型封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的①。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。 当然在 JavaScript 中，并没有对抽象类和接口的支持。JavaScript 本身也是一门类型模糊的语言。在封装类型方面，JavaScript 没有能力，也没有必要做得更多。对于 JavaScript 的设计模式实现来说，不区分类型是一种失色，也可以说是一种解脱。在后面的学习中，我们可以慢慢了解这一点。 3.4 封装变化从设计模式的角度出发，封装在更重要的层面体现为封装变化。 《设计模式》一书曾提到如下文字：“考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念，这是许多设计模式的主题。” 这段文字即是《设计模式》提到的“找到变化并封装之”。《设计模式》一书中共归纳总结了 23种设计模式。从意图上区分，这 23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。 拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。 从《设计模式》副标题“可复用面向对象软件的基础”可以知道，这本书理应教我们如何编写可复用的面向对象程序。这本书把大多数笔墨都放在如何封装变化上面，这跟编写可复用的面向对象程序是不矛盾的。当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。 四、 原型模式和基于原型继承的 JavaScript 对象系统在 Brendan Eich 为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。之所以选择基于原型的面向对象系统，并不是因为时间匆忙，它设计起来相对简单，而是因为从一开始 Brendan Eich 就没有打算在 JavaScript 中加入类的概念。 在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。就像电影《第六日》一样，通过克隆可以创造另外一个一模一样的人，而且本体和克隆体看不出任何区别。 原型模式不单是一种设计模式，也被称为一种编程泛型。 本节我们将首先学习第一个设计模式——原型模式。随后会了解基于原型的 Io 语言，借助对 Io 语言的了解，我们对 JavaScript 的面向对象系统也将有更深的认识。在本节的最后，我们将详细了解 JavaScript 语言如何通过原型来构建一个面向对象系统。 4.1 使用克隆的原型模式从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。 既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一模一样的对象，就可以使用原型模式。 假设我们在编写一个飞机大战的网页游戏。某种飞机拥有分身技能，当它使用分身技能的时候，要在页面中创建一些跟它一模一样的飞机。如果不使用原型模式，那么在创建分身之前，无疑必须先保存该飞机的当前血量、炮弹等级、防御等级等信息，随后将这些信息设置到新创建的飞机上面，这样才能得到一架一模一样的新飞机。 如果使用原型模式，我们只需要调用负责克隆的方法，便能完成同样的功能。 原型模式的实现关键，是语言本身是否提供了clone方法。ECMAScript 5提供了Object.create方法，可以用来克隆对象。代码如下： 1234567891011121314151617var Plane = function()&#123; this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1;&#125;;var plane = new Plane();plane.blood = 500;plane.attackLevel = 10;plane.defenseLevel = 7;var clonePlane = Object.create( plane );console.log( clonePlane ); // 输出：Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125;//在不支持 Object.create 方法的浏览器中，则可以使用以下代码：Object.create = Object.create || function( obj )&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125; 4.2 克隆是创建对象的手段通过上一节的代码，我们看到了如何通过原型模式来克隆出一个一模一样的对象。但原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。 在用 Java 等静态类型语言编写程序的时候，类型之间的解耦非常重要。依赖倒置原则提醒我们创建对象的时候要避免依赖具体类型，而用 new XXX 创建对象的方式显得很僵硬。工厂方法模式和抽象工厂模式可以帮助我们解决这个问题，但这两个模式会带来许多跟产品类平行的工厂类层次，也会增加很多额外的代码。 原型模式提供了另外一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类型名字。这就像一个仙女要送给三岁小女孩生日礼物，虽然小女孩可能还不知道飞机或者船怎么说，但她可以指着商店橱柜里的飞机模型说“我要这个”。 当然在 JavaScript 这种类型模糊的语言中，创建对象非常容易，也不存在类型耦合的问题。从设计模式的角度来讲，原型模式的意义并不算大 。但 JavaScript 本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型也许更合适。 4.3 体验Io语言前面说过，原型模式不仅仅是一种设计模式，也是一种编程范型。JavaScript 就是使用原型模式来搭建整个面向对象系统的。在 JavaScript 语言中不存在类的概念，对象也并非从类中创建出来的，所有的 JavaScript 对象都是从某个对象上克隆而来的。 对于习惯了以类为中心语言的人来说，也许一时不容易理解这种基于原型的语言。即使是对于 JavaScript 语言的熟练使用者而言，也可能会有一种“不识庐山真面目，只缘身在此山中”的感觉。事实上，使用原型模式来构造面向对象系统的语言远非仅有 JavaScript 一家。 JavaScript 基于原型的面向对象系统参考了 Self 语言和 Smalltalk 语言，为了搞清 JavaScript中的原型，我们本该寻根溯源去瞧瞧这两门语言。但由于这两门语言距离现在实在太遥远，我们不妨转而了解一下另外一种轻巧又基于原型的语言——Io 语言。 Io 语言在 2002 年由 Steve Dekorte 发明。可以从http://iolanguage.com 下载到 Io 语言的解释器，安装好之后打开 Io 解释器，输入经典的“Hello World”程序。解释器打印出了 Hello World 的字符串，这说明我们已经可以使用 Io 语言来编写一些小程序了，如图 1-1 所示。 作为一门基于原型的语言，Io 中同样没有类的概念，每一个对象都是基于另外一个对象的克隆。 就像吸血鬼的故事里必然有一个吸血鬼祖先一样，既然每个对象都是由其他对象克隆而来的，那么我们猜测 Io 语言本身至少要提供一个根对象，其他对象都发源于这个根对象。这个猜测是正确的，在 Io 中，根对象名为 Object。 这一节我们依然拿动物世界的例子来讲解 Io 语言。在下面的代码中，通过克隆根对象 Object，就可以得到另外一个对象 Animal。虽然 Animal 是以大写开头的，但是记住 Io 中没有类，Animal跟所有的数据一样都是对象。 Animal := Object clone // 克隆动物对象 现在通过克隆根对象 Object 得到了一个新的 Animal 对象，所以 Object 就被称为 Animal 的原型。目前 Animal 对象和它的原型 Object 对象一模一样，还没有任何属于它自己的方法和能力。我们假设在 Io 的世界里，所有的动物都会发出叫声，那么现在就给 Animal 对象添加 makeSound 方法吧。代码如下： Animal makeSound := method( “animal makeSound “ print ); 好了，现在所有的动物都能够发出叫声了，那么再来继续创建一个 Dog 对象。显而易见，Animal对象可以作为 Dog 对象的原型，Dog 对象从 Animal 对象克隆而来： Dog := Animal clone 可以确定，Dog 一定懂得怎么吃食物，所以接下来给 Dog 对象添加 eat 方法： Dog eat := method( “dog eat “ print ); 现在已经完成了整个动物世界的构建，通过一次次克隆，Io 的对象世界里不再只有形单影只的根对象 Object，而是多了两个新的对象：Animal 对象和 Dog 对象。其中 Dog 的原型是Animal，Animal 对象的原型是 Object。最后我们来测试 Animal 对象和 Dog 对象的功能。 先尝试调用 Animal 的 makeSound 方法，可以看到，动物顺利发出了叫声： Animal makeSound // 输出：animal makeSound 然后再调用 Dog 的 eat 方法，同样我们也看到了预期的结果： Dog eat // 输出：dog eat 4.4 原型编程范型的一些规则从上一节的讲解中，我们看到了如何在 Io 语言中从无到有地创建一些对象。跟使用“类”的语言不一样的地方是，Io 语言中最初只有一个根对象 Object，其他所有的对象都克隆自另外一个对象。如果 A 对象是从 B 对象克隆而来的，那么 B 对象就是 A 对象的原型。 在上一小节的例子中，Object 是 Animal 的原型，而 Animal 是 Dog 的原型，它们之间形成了一条原型链。这个原型链是很有用处的，当我们尝试调用 Dog 对象的某个方法时，而它本身却没有这个方法，那么 Dog 对象会把这个请求委托给它的原型 Animal 对象，如果 Animal 对象也没有这个属性，那么请求会顺着原型链继续被委托给 Animal 对象的原型Object 对象，这样一来便能得到继承的效果，看起来就像 Animal 是 Dog 的“父类”，Object 是 Animal 的“父类”。 这个机制并不复杂，却非常强大，Io 和 JavaScript 一样，基于原型链的委托机制就是原型继承的本质。 我们来进行一些测试。在 Io 的解释器中执行 Dog makeSound 时，Dog 对象并没有 makeSound 方法，于是把请求委托给了它的原型 Animal 对象 ，而 Animal 对象是有makeSound 方法的，所以该条语句可以顺利得到输出，如图 1-2 所示。 现在我们明白了原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委托给它自己的原型。 最后整理一下本节的描述，我们可以发现原型编程范型至少包括以下基本规则。 所有的数据都是对象。要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。对象会记住它的原型。如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 4.5 JavaScript中的原型继承刚刚我们已经体验过同样是基于原型编程的 Io 语言，也已经了解了在 Io 语言中如何通过原型链来实现对象之间的继承关系。在原型继承方面，JavaScript 的实现原理和 Io 语言非常相似，JavaScript 也同样遵守这些原型编程的基本规则。 所有的数据都是对象。要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。对象会记住它的原型。如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 下面我们来分别讨论 JavaScript 是如何在这些规则的基础上来构建它的对象系统的。 4.5.1 所有的数据都是对象JavaScript 在设计的时候，模仿 Java 引入了两套类型机制：基本类型和对象类型。基本类型包括 undefined、number、boolean、string、function、object。从现在看来，这并不是一个好的想法。 按照 JavaScript 设计者的本意，除了 undefined 之外，一切都应是对象。为了实现这一目标，number、boolean、string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。 我们不能说在 JavaScript 中所有的数据都是对象，但可以说绝大部分数据都是对象。那么相信在 JavaScript 中也一定会有一个根对象存在，这些对象追根溯源都来源于这个根对象。 事实上，JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的原型。比如下面的 obj1 对象和 obj2 对象： 12var obj1 = new Object();var obj2 = &#123;&#125;; 可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型： 12console.log( Object.getPrototypeOf( obj1 ) === Object.prototype ); // 输出：trueconsole.log( Object.getPrototypeOf( obj2 ) === Object.prototype ); // 输出：true 4.5.2 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它在Io 语言中，克隆一个对象的动作非常明显，我们可以在代码中清晰地看到 clone 的过程。 比如以下代码： Dog := Animal clone 但在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。我们所需要做的只是显式地调用 var obj1 = new Object()或者 var obj2 = {}。此时，引擎内部会从Object.prototype 上面克隆一个对象出来，我们最终得到的就是这个对象。 再来看看如何用 new 运算符从构造器中得到一个对象，下面的代码我们再熟悉不过了： 12345678910function Person( name )&#123; this.name = name;&#125;;Person.prototype.getName = function()&#123; return this.name;&#125;;var a = new Person( 'sven' )console.log( a.name ); // 输出：svenconsole.log( a.getName() ); // 输出：svenconsole.log( Object.getPrototypeOf( a ) === Person.prototype ); // 输出：true 在 JavaScript 中没有类的概念，这句话我们已经重复过很多次了。但刚才不是明明调用了 newPerson()吗？ 在这里 Person 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。 在 Chrome 和 Firefox 等向外暴露了对象proto属性的浏览器下，我们可以通过下面这段代码来理解 new 运算的过程： 1234567891011121314151617function Person( name )&#123; this.name = name;&#125;;Person.prototype.getName = function()&#123; return this.name;&#125;;var objectFactory = function()&#123; var obj = new Object(), // 从 Object.prototype 上克隆一个空的对象 Constructor = [].shift.call( arguments ); // 取得外部传入的构造器，此例是 Person obj.__proto__ = Constructor.prototype; // 指向正确的原型 var ret = Constructor.apply( obj, arguments ); // 借用外部传入的构造器给 obj 设置属性 return typeof ret === 'object' ? ret : obj; // 确保构造器总是会返回一个对象&#125;;var a = objectFactory( Person, 'sven' );console.log( a.name ); // 输出：svenconsole.log( a.getName() ); // 输出：svenconsole.log( Object.getPrototypeOf( a ) === Person.prototype ); // 输出：true 我们看到，分别调用下面两句代码产生了一样的结果： 12var a = objectFactory( A, 'sven' );var a = new A( 'sven' ); 4.5.3 对象会记住它的原型如果请求可以在一个链条中依次往后传递，那么每个节点都必须知道它的下一个节点。同理，要完成 Io语言或者 JavaScript语言中的原型链查找机制，每个对象至少应该先记住它自己的原型。 目前我们一直在讨论“对象的原型”，就 JavaScript 的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型。那么对象如何把请求顺利地转交给它的构造器的原型呢？ JavaScript 给对象提供了一个名为proto的隐藏属性，某个对象的proto属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。在一些浏览器中，proto被公开出来，我们可以在 Chrome 或者 Firefox 上用这段代码来验证： 12var a = new Object();console.log ( a.__proto__=== Object.prototype ); // 输出：true 实际上，proto就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过proto属性来记住它的构造器的原型，所以我们用上一节的 objectFactory 函数来模拟用 new创建对象时， 需要手动给 obj 对象设置正确的proto指向。 1obj.__proto__ = Constructor.prototype; 通过这句代码，我们让 obj.proto 指向 Person.prototype，而不是原来的 Object.prototype。 4.5.4 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型这条规则即是原型继承的精髓所在。从对 Io 语言的学习中，我们已经了解到，当一个对象无法响应某个请求的时候，它会顺着原型链把请求传递下去，直到遇到一个可以处理该请求的对象为止。 JavaScript 的克隆跟 Io 语言还有点不一样，Io 中每个对象都可以作为原型被克隆，当 Animal对象克隆自 Object 对象，Dog 对象又克隆自 Animal 对象时，便形成了一条天然的原型链，如图1-3 所示。 而在 JavaScript 中，每个对象都是从 Object.prototype 对象克隆而来的，如果是这样的话，我们只能得到单一的继承关系，即每个对象都继承自 Object.prototype 对象，这样的对象系统显然是非常受限的。 实际上，虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的效果。下面的代码是我们最常用的原型继承方式： 12345var obj = &#123; name: 'sven' &#125;;var A = function()&#123;&#125;;A.prototype = obj;var a = new A();console.log( a.name ); // 输出：sven 我们来看看执行这段代码的时候，引擎做了哪些事情。 首先，尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.proto 记录着并且指向 A.prototype，而 A.prototype 被设置为对象 obj。在对象 obj 中找到了 name 属性，并返回它的值。 当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现： 123456var A = function()&#123;&#125;;A.prototype = &#123; name: 'sven' &#125;;var B = function()&#123;&#125;;B.prototype = new A();var b = new B();console.log( b.name ); // 输出：sven 再看这段代码执行的时候，引擎做了什么事情。 首先，尝试遍历对象 b 中的所有属性，但没有找到 name 这个属性。查找 name 属性的请求被委托给对象 b 的构造器的原型，它被 b.proto 记录着并且指向B.prototype，而 B.prototype 被设置为一个通过 new A()创建出来的对象。在该对象中依然没有找到 name 属性，于是请求被继续委托给这个对象构造器的原型A.prototype。在 A.prototype 中找到了 name 属性，并返回它的值。 和把 B.prototype 直接指向一个字面量对象相比，通过 B.prototype = new A()形成的原型链比之前多了一层。但二者之间没有本质上的区别，都是将对象构造器的原型指向另外一个对象，继承总是发生在对象和对象之间。 最后还要留意一点，原型链并不是无限长的。现在我们尝试访问对象 a 的 address 属性。而对象 b 和它构造器的原型上都没有 address 属性，那么这个请求会被最终传递到哪里呢？ 实际上，当请求达到 A.prototype，并且在 A.prototype 中也没有找到 address 属性的时候，请求会被传递给 A.prototype 的构造器原型 Object.prototype，显然Object.prototype 中也没有address 属性，但 Object.prototype 的原型是 null，说明这时候原型链的后面已经没有别的节点了。所以该次请求就到此打住，a.address 返回 undefined。 a.address // 输出：undefined 4.5.5 原型继承的未来设计模式在很多时候其实都体现了语言的不足之处。Peter Norvig 曾说，设计模式是对语言不足的补充，如果要使用设计模式，不如去找一门更好的语言。这句话非常正确。不过，作为Web 前端开发者，相信 JavaScript 在未来很长一段时间内都是唯一的选择。虽然我们没有办法换一门语言，但语言本身也在发展，说不定哪天某个模式在 JavaScript 中就已经是天然的存在，不再需要拐弯抹角来实现。比如 Object.create 就是原型模式的天然实现。使用 Object.create 来完成原型继承看起来更能体现原型模式的精髓。目前大多数主流浏览器都供了 Object.create 方法。 但美中不足是在当前的 JavaScript 引擎下，通过 Object.create 来创建对象的效率并不高，通常比通过构造函数创建对象要慢。此外还有一些值得注意的地方，比如通过设置构造器的prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个原型。而通过 Object.create( null )可以创建出没有原型的对象。 另外，ECMAScript 6 带来了新的 Class 语法。这让 JavaScript 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。通过 Class 创建对象的一段简单示例代码①如下所示 ： 123456789101112131415161718class Animal &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name); &#125; speak() &#123; return \"woof\"; &#125;&#125;var dog = new Dog(\"Scamp\");console.log(dog.getName() + ' says ' + dog.speak());","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法十二（算法复杂度）","date":"2019-04-12T01:53:40.000Z","path":"2019/04/12/cjxe4h6ju000q6supwz0di3ga/","text":"一、 大 O 表示法大O表示法用于描述算法的性能和复杂程度 分析算法时，时常遇到以下几类函数： 符 号 名 称 O(1) 常数的 O(log(n)) 对数的 O((log(n))c) 对数多项式的 O(n) 线性的 O(n^2) 二次的 O(n^c) 多项式的 O(c^n) 指数的 1.1 理解大 O 表示法如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。 让我们试着用一些例子来理解大O表示法的规则。 1.1.1 O(1)考虑以下函数： 123function increment(num)&#123; return ++num;&#125; 假设运行increment(1)函数，执行时间等于X。如果再用不同的参数（例如2）运行一次increment函数，执行时间依然是X。和参数无关，increment函数的性能都一样。因此，我们说上述函数的复杂度是O(1)（常数）。 1.1.2 O(n)现在以前面实现的顺序搜索算法为例： 12345678function sequentialSearch(array, item)&#123; for (var i=0; i&lt;array.length; i++)&#123; if (item === array[i])&#123; //&#123;1&#125; return i; &#125; &#125; return -1;&#125; 如果将含10个元素的数组（[1, …, 10]）传递给该函数，假如搜索1这个元素，那么，第一次判断时就能找到想要搜索的元素。在这里我们假设每执行一次行{1} ，开销是 1。 现在，假如要搜索元素11。行{1}会执行10次（遍历数组中所有的值，并且找不到要搜索的元素，因而结果返回 -1）。如果行{1}的开销是1，那么它执行10次的开销就是10，10倍于第一种假设。 现在，假如该数组有1000个元素（[1, …, 1000]）。搜索1001的结果是行{1}执行了1000次（然后返回-1）。 注意，sequentialSearch函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，行{1}会执行几次呢？如果查找的是数组中不存在的值，那么行{1}就会执行和数组大小一样多次，这就是通常所说的最坏情况。 最坏情况下，如果数组大小是10，开销就是10；如果数组大小是1000，开销就是1000。可以得出sequentialSearch函数的时间复杂度是O(n)，n是（输入）数组的大小。 回到之前的例子，修改一下算法的实现，使之计算开销： 123456789101112function sequentialSearch(array, item) &#123; var cost = 0; for (var i = 0; i &lt; array.length; i++) &#123; cost++; if (item === array[i]) &#123; //&#123;1&#125; return i; &#125; &#125; console.log('cost for sequentialSearch with input size ' + array.length + ' is ' + cost); return -1;&#125; sequentialSearch([1,2,3,4,5,6,7,8,9], 19) // cost for sequentialSearch with input size 9 is 9 1.1.3 O(n^2)用冒泡排序做O(n^2)的例子： 123456789101112131415function swap(array, index1, index2) &#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;&#125;function bubbleSort(array) &#123; var length = array.length; for (var i = 0; i &lt; length; i++) &#123; //&#123;1&#125; for (var j = 0; j &lt; length - 1; j++) &#123; //&#123;2&#125; if (array[j] &gt; array[j + 1]) &#123; swap(array, j, j + 1); &#125; &#125; &#125;&#125; 假设行{1}和行{2}的开销分别是1。修改算法的实现使之计算开销： 1234567891011121314function bubbleSort(array) &#123; var length = array.length; var cost = 0; for (var i = 0; i &lt; length; i++) &#123; //&#123;1&#125; cost++; for (var j = 0; j &lt; length - 1; j++) &#123; //&#123;2&#125; cost++; if (array[j] &gt; array[j + 1]) &#123; swap(array, j, j + 1); &#125; &#125; &#125; console.log('cost for bubbleSort with input size ' + length + 'is ' + cost);&#125; 如果用大小为10的数组执行bubbleSort，开销是 100（102）。如果用大小为100的数组执行bubbleSort，开销就是 10 000（1002）。需要注意，我们每次增加输入的大小，执行都会越来越久。 时间复杂度O(n)的代码只有一层循环，而O(n2)的代码有双层嵌套循环。如果算法有三层遍历数组的嵌套循环，它的时间复杂度很可能就是O(n3)。 1.2 时间复杂度比较 下图比较了前述各个大O符号表示的时间复杂度： 这个图表是用JavaScript绘制的哦！在本书示例代码中，你可以到Chapter12下的bigOChart目录中找到绘制本图表的源代码。 在接下来的部分，你可以找到本书实现的所有算法的时间复杂度的速查表。 1.2.1 数据结构下表是常用数据结构的时间复杂度： 数据结构一般情况最差情况插入删除搜索插入删除搜索数组/栈/队列O(1)O(1)O(n)O(1)O(1)O(n)链表O(1)O(1)O(n)O(1)O(1)O(n)双向链表O(1)O(1)O(n)O(1)O(1)O(n)散列表O(1)O(1)O(1)O(n)O(n)O(n)二分搜索树O(log(n))O(log(n))O(log(n))O(n)O(n)O(n)AVL树O(log(n))O(log(n))O(log(n))O(log(n))O(log(n))O(log(n)) 1.2.2 图下表是图的时间复杂度： 节点/边的管理方式存储空间增加顶点增加边删除顶点删除边轮 询邻接表O(|V|+|E|) O(1) O(1)O(|V|+|E|)O(|E|)O(|V|)邻接矩阵O(|V|^2)O(|V|^2)O(1)O(|V|^2O(1)O(1) 1.2.3 排序算法下表是排序算法的时间复杂度： 数据结构时间复杂度最好情况一般情况 最差情况冒泡排序O(n)O(n^2)O(n^2)选择排序O(n^2)O(n^2)O(n^2)插入排序O(n)O(n^2)O(n^2)归并排序O(nlog(n))O(nlog(n))O(nlog(n))快速排序O(nlog(n))O(log(n)) O(n^2)堆排序O(nlog(n))O(nlog(n))O(nlog(n))桶排序O(n+k)O(n+k)O(n^2)基数排序O(nk)O(nk)O(nk) 1.2.4 搜索算法下表是搜索算法的时间复杂度： 算 法数据结构最差情况顺序搜索数组O(n)二分搜索已排序的数组O(log(n))深度优先搜索（DPS）顶点数为|V|，边数为|E|的图O(|V|+|E|)广度优先搜索（BFS）顶点数为|V|，边数为|E|的图 O(|V|+|E|) 1.3 NP 完全理论概述一般来说，如果一个算法的复杂度为O(nk)，其中k是常数，我们就认为这个算法是高效的，这就是多项式算法。 对于给定的问题，如果存在多项式算法，则计为P（polynomial，多项式）。 还有一类NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为NP。 如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的P都是NP。然而，P = NP是否成立，仍然不得而知。 NP问题中最难的是NP完全问题，它满足以下两个条件： (1) 是NP问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；(2) 所有的NP问题都能在多项式时间内归约为它。 为了理解问题的归约，考虑两个决策问题L和M。假设算法A可以解决问题L，算法B可以验证输入y是否为M的解。目标是找到一个把L转化为M的方法，使得算法B可以用于构造算法A。 还有一类问题，只需满足NP完全问题的第二个条件，称为NP困难问题。因此，NP完全问题也是NP困难问题的子集。 P = NP是否成立，是计算机科学中最重要的难题之一。如果能找到答案，对密码学、算法研究、人工智能等诸多领域都会产生重大影响。 下面是满足P &lt; &gt; NP时，P、NP、NP完全和NP困难问题的欧拉图： 非NP完全的NP困难问题的例子有停机问题和布尔可满足性问题（SAT） NP完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。 不可解问题与启发式算法 我们提到的有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。 启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。详情请查阅http://goo.gl/gxIu9w。 二、 用算法娱乐身心我们学习算法并不单单是因为它是大学必修课，也不单单是因为我们想成为开发者。通过用在本书中学到的算法来解决问题，我们可以提高解决问题的能力，进而成为更棒的专业人士。 增长（解题）知识的最好方式是练习，而练习不一定是枯燥的。本节将展示一些网站，你可以访问它们并尝试从算法中获到快乐（甚至小赚一笔）。 这里列出一些有用的网站（有些不支持用JavaScript提交解答，但是我们依然可以将从本书中所学到的逻辑应用到其他语言上）。 UVa Online Judge（http://uva.onlinejudge.org/）：这个网站包含了世界各大赛事的题目，包括 由IBM赞助的ACM国际大学生程序竞赛（ICPC。若你依然在校，应尽量参与这项赛事，如果团队获胜，则有可能免费享受一次国际旅行）。这个网站包括了成百上千的题目，可以应用本书所学的算法。Sphere Online Judge（http://www.spoj.com/）： 这个网站和UVa Online Judge差不多，但支持用更多语言解题（包括JavaScript）。Coder Byte（http://coderbyte.com/）：这个网站包含了74个可以用JavaScript解答的题目（简单、中等难度和非常困难）。Project Euler（https://projecteuler.net/）：这个网站包含了一系列数学/计算机的编程题目。你所要做的就是输入那些题目的答案，不过我们可以用算法来找到正确的解答。Hacker Rank（https://www.hackerrank.com）：这个网站包含了263个挑战，分为16个类别（可以应用本书中的算法和更多其他算法）。它也支持JavaScript和其他语言。Code Chef（http://www.codechef.com/）：这个网站包含一些题目，并会举办在线比赛。Top Coder（http://www.topcoder.com/）：此网站会举办算法联赛，这些联赛通常由NASA、Google、Yahoo!、Amazon和Facebook这样的公司赞助。参加其中一些赛事，你可以获得到赞助公司工作的机会，而参与另一些赛事会赢得奖金。这个网站也提供很棒的解题和算法教程。 以上网站的另一个好处是，它们通常给出的是真实世界中的问题，而我们需要鉴别用哪一个算法解决它。通过这样的方式也能让我们明白本书中的算法并非局限于学术，而是能应用到现实问题上。 如果你想从事技术工作，强烈推荐你创建一个免费的GitHub（https://github.com） 账号，你可以将上述网站的解答代码提交上去。如果你没有任何专业经验，GitHub可以帮助你建立一个作品集，还会对你找到第一份工作有帮助！ 三、延 展 阅 读","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法十一（算法模式）","date":"2019-03-30T07:49:40.000Z","path":"2019/03/30/cjxe4h6q6001w6supm4iwaj47/","text":"一、递归递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。 递归函数是像下面这样能够直接调用自身的方法或函数： 123function recursiveFunction(someParam)&#123; recursiveFunction(someParam);&#125;; 能够像下面这样间接调用自身的函数，也是递归函数： 123456function recursiveFunction1(someParam)&#123; recursiveFunction2(someParam);&#125;;function recursiveFunction2(someParam)&#123; recursiveFunction1(someParam);&#125;; 假设现在必须要执行recursiveFunction，结果是什么？单单就上述情况而言，它会一直执行下去。因此，每个递归函数都必须要有边界条件，即一个不再递归调用的条件（停止点），以防止无限递归。 1.1 JavaScript 调用栈大小的限制如果忘记加上用以停止函数递归调用的边界条件，会发生什么呢？递归并不会无限地执行下去；浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）。 每个浏览器都有自己的上限，可用以下代码测试： 12345678910var i = 0;function recursiveFn () &#123; i++; recursiveFn(); //&#123;1&#125;&#125;try &#123; recursiveFn();&#125; catch (ex) &#123; alert('i = ' + i + ' error: ' + ex);&#125; 在Chrome v37中，这个函数执行了20 955次，而后浏览器抛出错误RangeError: Maximumcall stack size exceeded（超限错误：超过最大调用栈大小）。在Firefox v27中，函数执行了343 429次，然后浏览器抛出错误 InternalError: too much recursion（内部错误：递归次数过多）。 ECMAScript 6有尾调用优化（tail call optimization）。如果函数内最后一个操作是调用函数（就像示例中{1}的那行），会通过“跳转指令”（jump） 而不是“子程序调用”（subroutine call）来控制。也就是说，在ECMAScript 6中，这里的代码可以一直执行下去。所以，具有停止递归的边界条件非常重要。 1.2 斐波那契数列斐波那契数列的定义如下： 1和2的斐波那契数是 1；n（n&gt;2）的斐波那契数是(n-1)的斐波那契数加上(n-2)的斐波那契数。 那么，让我们开始实现斐波那契函数： 12345function fibonacci(num)&#123; if (num === 1 || num === 2)&#123; //&#123;1&#125; return 1; &#125;&#125; 边界条件是已知的，1和2的斐波那契数（行{1}）是1。现在，让我们完成斐波那契函数的实现： 123456function fibonacci(num)&#123; if (num === 1 || num === 2)&#123; return 1; &#125; return fibonacci(num - 1) + fibonacci(num - 2);&#125; 我们已经知道，当n大于2时，Fibonacci(n)等于Fibonacci(n-1)+Fibonacci(n-2)。 现在，斐波那契函数实现完毕。让我们试着找出6的斐波那契数，其会产生如下函数调用 我们也可以用非递归的方式实现斐波那契函数： 1234567891011function fib(num)&#123; var n1 = 1, n2 = 1, n = 1; for (var i = 3; i&lt;=num; i++)&#123; n = n1 + n2; n1 = n2; n2 = n; &#125; return n;&#125; 为何用递归呢？更快吗？递归并不比普通版本更快，反倒更慢。但要知道，递归更容易理解，并且它所需的代码量更少。 在ECMAScript 6中，因为尾调用优化的缘故，递归并不会更慢。但是在其他语言中，递归通常更慢。 所以，我们用递归，通常是因为它更容易解决问题。 二、动态规划动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。 之前提到过几次动态规划技术。用动态规划解决的一个问题就是深度优先搜索。 要注意动态规划和分而治之（归并排序和快速排序算法中用到的那种）是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。 另一个例子是上一节解决的斐波那契问题。我们将斐波那契问题分解成如该节图示的小问题。 用动态规划解决问题时，要遵循三个重要步骤： (1) 定义子问题；(2) 实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；(3) 识别并求解出边界条件。 能用动态规划解决的一些著名的问题如下。 背包问题：给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。硬币找零：给出面额为d1…dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。图的全源最短路径：对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。我们在前面已经学习过这个问题的Floyd-Warshall算法。 2.1 最少硬币找零问题最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找到所需的最少的硬币个数。 例如，美国有以下面额（硬币）：d1=1，d2=5，d3=10，d4=25。 如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（1美分）。 如何将这个解答转化成算法？ 最少硬币找零的解决方案是找到n所需的最小硬币数。但要做到这一点，首先得找到对每个x&lt;n的解。然后，我们将解建立在更小的值的解的基础上。 来看看算法： 123456789101112131415161718192021222324252627282930function MinCoinChange(coins) &#123; var coins = coins; //&#123;1&#125; var cache = &#123;&#125;; //&#123;2&#125; this.makeChange = function (amount) &#123; var me = this; if (!amount) &#123; //&#123;3&#125; return []; &#125; if (cache[amount]) &#123; //&#123;4&#125; return cache[amount]; &#125; var min = [], newMin, newAmount; for (var i = 0; i &lt; coins.length; i++) &#123; //&#123;5&#125; var coin = coins[i]; newAmount = amount - coin; //&#123;6&#125; if (newAmount &gt;= 0) &#123; newMin = me.makeChange(newAmount); //&#123;7&#125; &#125; if ( newAmount &gt;= 0 &amp;&amp; //&#123;8&#125; (newMin.length &lt; min.length - 1 || !min.length)//&#123;9&#125; &amp;&amp; (newMin.length || !newAmount)) //&#123;10&#125;) &#123; min = [coin].concat(newMin); //&#123;11&#125; console.log('new Min ' + min + ' for ' + amount); &#125; &#125; return (cache[amount] = min); //&#123;12&#125; &#125;;&#125; 为了更有条理，我们创建了一个类，解决给定面额的最少硬币找零问题。让我们一步步解读这个算法。 MinCoinChange类接收coins参数（行{1}），该参数代表问题中的面额。对美国的硬币系统而言，它是[1, 5, 10, 25]。我们可以随心所欲传递任何面额。此外，为了更加高效且不重复计算值，我们使用了cache（行{2}）。 接下来是makeChange方法，它也是一个递归函数，找零问题由它解决。首先，若amount不为正（&lt; 0），就返回空数组（行{3}）；方法执行结束后，会返回一个数组，包含用来找零的各个面额的硬币数量（最少硬币数）。接着，检查cache缓存。若结果已缓存（行{4}），则直接返回结果；否则，执行算法。 我们基于coins参数（面额）解决问题。因此，对每个面额（行{5}），我们都计算newAmount（行{6}）的值，它的值会一直减小，直到能找零的最小钱数（别忘了本算法对所有的x &lt; amount都会计算makeChange结果）。若newAmount是合理的值（正值），我们也会计算它的找零结果（行{7}）。 最后，我们判断newAmount是否有效，minValue（最少硬币数）是否是最优解，与此同时minValue和newAmount是否是合理的值（{行10}）。若以上判断都成立，意味着有一个比之前更优的答案（行{11}。以5美分为例，可以给5便士或者1个5美分镍币，1个5美分镍币是最优解）。最后，返回最终结果（行{12}）。 测试一下这个算法： 12var minCoinChange = new MinCoinChange([1, 5, 10, 25]);console.log(minCoinChange.makeChange(36)); 要知道，如果我们检查cache变量，会发现它存储了从1到36美分的所有结果。以上代码的结果是[1, 10, 25]。 本节的源码中会有几行多余的代码，输出算法的步骤。例如，使用面额[1, 3, 4]，并对钱数6执行算法，会产生以下输出： 12345678910new Min 1 for 1new Min 1,1 for 2new Min 1,1,1 for 3new Min 3 for 3new Min 1,3 for 4new Min 4 for 4 new Min 1,4 for 5new Min 1,1,4 for 6new Min 3,3 for 6[3, 3] 所以，找零钱数为6时，最佳答案是两枚价值为3的硬币。 2.2 背包问题背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重W的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大。 下面是一个例子： 物 品# 重 量 价 值 1 2 3 2 3 4 3 4 5 考虑背包能够携带的重量只有5。对于这个例子，我们可以说最佳解决方案是往背包里装入物品1和物品2，这样，总重量为5，总价值为7。 这个问题有两个版本。0-1版本只能往背包里装完整的物品，而分数背包问题则允许装入分数物品。在这个例子里，我们将处理该问题的0-1版本。动态规划对分数版本无能为力，但稍后要学习的贪心算法可以解决它。 我们来看看下面这个背包算法： 1234567891011121314151617181920function knapSack(capacity, weights, values, n) &#123; var i, w, a, b, kS = []; for (i = 0; i &lt;= n; i++) &#123; //&#123;1&#125; kS[i] = []; &#125; for (i = 0; i &lt;= n; i++) &#123; for (w = 0; w &lt;= capacity; w++) &#123; if (i == 0 || w == 0) &#123; //&#123;2&#125; kS[i][w] = 0; &#125; else if (weights[i - 1] &lt;= w) &#123; //&#123;3&#125; a = values[i - 1] + kS[i - 1][w - weights[i - 1]]; b = kS[i - 1][w]; kS[i][w] = (a &gt; b) ? a : b; //&#123;4&#125; max(a,b) &#125; else &#123; kS[i][w] = kS[i - 1][w]; //&#123;5&#125; &#125; &#125; &#125; return kS[n][capacity]; //&#123;6&#125;&#125; 我们来看看这个算法是如何工作的。 行{1}：首先，初始化将用于寻找解决方案的矩阵ks[n+1][capacity+1]。 行{2}：忽略矩阵的第一列和第一行，只处理索引不为0的列和行。 行{3}：物品i的重量必须小于约束（capacity）才有可能成为解决方案的一部分；否则，总重量就会超出背包能够携带的重量，这是不可能发生的。发生这种情况时，只要忽略它，用之前的值就可以了（行{5}）。 行{4}：当找到可以构成解决方案的物品时，选择价值最大的那个。 行{6}：最后，问题的解决方案就在这个二维表格右下角的最后一个格子里。 我们可以用开头的例子来测试这个算法： 下图举例说明了例子中kS矩阵的构造： 请注意，这个算法只输出背包携带物品价值的最大值，而不列出实际的物品。我们可以增加下面的附加函数来找出构成解决方案的物品： 12345678910111213function findValues(n, capacity, kS, weights, values) &#123; var i = n, k = capacity; console.log('解决方案包含以下物品：'); while (i &gt; 0 &amp;&amp; k &gt; 0) &#123; if (kS[i][k] !== kS[i - 1][k]) &#123; console.log('物品' + i + '，重量：' + weights[i - 1] + '，价值：' + values[i - 1]); i--; k = k - kS[i][k]; &#125; else &#123; i--; &#125; &#125;&#125; 我们可以在knapsack函数的行{6}之前调用这个函数。执行完整的算法，会得到如下输出： 1234解决方案包含以下物品：88 物品2，重量：3，价值：488 物品1，重量：2，价值：37 2.3 最长公共子序列另一个经常被当作编程挑战问题的动态规划问题是最长公共子序列（LCS）：找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。 考虑如下例子： 再看看下面这个算法： 12345678910111213141516171819202122232425262728293031function lcs(wordX, wordY) &#123; var m = wordX.length, n = wordY.length, l = [], i, j, a, b; for (i = 0; i &lt;= m; ++i) &#123; l[i] = []; //&#123;1&#125; for (j = 0; j &lt;= n; ++j) &#123; l[i][j] = 0; //&#123;2&#125; &#125; &#125; for (i = 0; i &lt;= m; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) &#123; l[i][j] = 0; &#125; else if (wordX[i - 1] == wordY[j - 1]) &#123; l[i][j] = l[i - 1][j - 1] + 1; //&#123;3&#125; &#125; else &#123; a = l[i - 1][j]; b = l[i][j - 1]; l[i][j] = (a &gt; b) ? a : b; //max(a, b) //&#123;4&#125; &#125; &#125; &#125; //&#123;5&#125; return l[m][n];&#125; 比较背包问题和LCS算法，我们会发现两者非常相似。这项从顶部开始构建解决方案的技术被称为记忆，而解决方案就在表格或矩阵的右下角。 像背包问题算法一样，这种方法只输出LCS的长度，而不包含LCS的实际结果。要提取这个信息，需要对算法稍作修改，声明一个新的solution矩阵。如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function lcs(wordX, wordY) &#123; var m = wordX.length, n = wordY.length, l = [], i, j, a, b; for (i = 0; i &lt;= m; ++i) &#123; l[i] = []; solution[i] = [];//&#123;1&#125; for (j = 0; j &lt;= n; ++j) &#123; l[i][j] = 0; solution[i][j] = '0';//&#123;2&#125; &#125; &#125; for (i = 0; i &lt;= m; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) &#123; l[i][j] = 0; &#125; else if (wordX[i - 1] == wordY[j - 1]) &#123; l[i][j] = l[i - 1][j - 1] + 1; solution[i][j] = 'diagonal';//&#123;3&#125; &#125; else &#123; a = l[i - 1][j]; b = l[i][j - 1]; l[i][j] = (a &gt; b) ? a : b; //max(a, b) solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';//&#123;4&#125; &#125; &#125; &#125; printSolution(solution, l, wordX, wordY, m, n);//&#123;5&#125; return l[m][n];&#125; //printSolution函数如下：function printSolution(solution, l, wordX, wordY, m, n) &#123; var a = m, b = n, i, j, x = solution[a][b], answer = ''; while (x !== '0') &#123; if (solution[a][b] === 'diagonal') &#123; answer = wordX[a - 1] + answer; a--; b--; &#125; else if (solution[a][b] === 'left') &#123; b--; &#125; else if (solution[a][b] === 'top') &#123; a--; &#125; x = solution[a][b]; &#125; console.log('lcs: ' + answer);&#125; 当解矩阵的方向为对角线时，我们可以将字符添加到答案中。 如果用’acbaed’和’abcadf’两个字符串执行上面的算法，我们将得到输出4。用于构建结果的矩阵l看起来像下面这样。我们也可以用附加的算法来跟踪LCS的值（如下图高亮所示）。 通过上面的矩阵，我们知道LCS算法的结果是长度为4的acad。 2.4 矩阵链相乘矩阵链相乘是另一个可以用动态规划解决的著名问题。这个问题是要找出一组矩阵相乘的最佳方式（顺序）。 让我们试着更好地理解这个问题。n行m列的矩阵A和m行p列的矩阵B相乘，结果是n行p列的矩阵C。 考虑我们想做ABC*D的乘法。因为乘法满足结合律，所以我们可以让这些矩阵以任意顺序相乘。因此，考虑如下情况： A是一个10行100列的矩阵B是一个100行5列的矩阵C是一个5行50列的矩阵D是一个50行1列的矩阵 ABC*D的结果是一个10行1列的矩阵 在这个例子里，相乘的方式有五种。 (1) (A(B(CD)))：乘法运算的次数是1750次。(2) ((AB)(CD))：乘法运算的次数是5300次。(3) (((AB)C)D)：乘法运算的次数是8000次。(4) ((A(BC))D)：乘法运算的次数是75 500次。(5) (A((BC)D))：乘法运算的次数是31 000次。 相乘的顺序不一样，要进行的乘法运算总数也有很大差异。那么，要如何构建一个算法，求出最少的乘法运算操作次数？矩阵链相乘的算法如下： 12345678910111213141516171819202122function matrixChainOrder(p, n) &#123; var i, j, k, l, q, m = []; for (i = 1; i &lt;= n; i++) &#123; m[i] = []; m[i][i] = 0; &#125; for (l = 2; l &lt; n; l++) &#123; for (i = 1; i &lt;= n - l + 1; i++) &#123; j = i + l - 1; m[i][j] = Number.MAX_SAFE_INTEGER; for (k = i; k &lt;= j - 1; k++) &#123; q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; //&#123;1&#125; if (q &lt; m[i][j]) &#123; m[i][j] = q; //&#123;2&#125; &#125; &#125; &#125; &#125; //&#123;3&#125; return m[1][n - 1];&#125; 整个算法中最重要的是行{1}，神奇之处全都在这一行。它计算了给定括号顺序的乘法运算次数，并将值保存在辅助矩阵m中。 对开头的例子执行上面的算法，会得到结果7500；正如我们前面提到的，这是最少的操作次数。看看这个： 123var p = [10, 100, 5, 50, 1],n = p.length;console.log(matrixChainOrder(p, n)); //1750 然而，这个算法也不会给出最优解的括号顺序。为了得到这些信息，我们可以对代码做一些改动。 123456789101112131415161718192021222324252627282930313233343536373839404142function matrixChainOrder(p, n) &#123; var i, j, k, l, q, m = []; var s = []; for (i = 0; i &lt;= n; i++) &#123; s[i] = []; for (j = 0; j &lt;= n; j++) &#123; s[i][j] = 0; &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; m[i] = []; m[i][i] = 0; &#125; for (l = 2; l &lt; n; l++) &#123; for (i = 1; i &lt;= n - l + 1; i++) &#123; j = i + l - 1; m[i][j] = Number.MAX_SAFE_INTEGER; for (k = i; k &lt;= j - 1; k++) &#123; q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; //&#123;1&#125; if (q &lt; m[i][j]) &#123; m[i][j] = q; s[i][j] = k; //&#123;2&#125; &#125; &#125; &#125; &#125; printOptimalParenthesis(s, 1, n - 1); //&#123;3&#125; return m[1][n - 1];&#125; function printOptimalParenthesis(s, i, j) &#123; if (i == j) &#123; console.log(\"A[\" + i + \"]\"); &#125; else &#123; console.log(\"(\"); printOptimalParenthesis(s, i, s[i][j]); printOptimalParenthesis(s, s[i][j] + 1, j); console.log(\")\"); &#125;&#125; var p = [10, 100, 5, 50, 1],n = p.length;console.log(matrixChainOrder(p, n)); 执行修改后的算法，也能得到括号的最佳顺序(A1))，并可以转化为(A(B(CD)))。 三、 贪心算法贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。 我们来看看如何用贪心算法解决前面的最少硬币找零问题和背包问题。（我们已经介绍了一些其他的贪心算法，比如Dijkstra算法、Prim算法和Kruskal算法。） 3.1 最少硬币找零问题最少硬币找零问题也能用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。 来看看算法： 123456789101112131415function MinCoinChange(coins) &#123; var coins = coins; //&#123;1&#125; this.makeChange = function (amount) &#123; var change = [], total = 0; for (var i = coins.length; i &gt;= 0; i--) &#123; //&#123;2&#125; var coin = coins[i]; while (total + coin &lt;= amount) &#123; //&#123;3&#125; change.push(coin); //&#123;4&#125; total += coin; //&#123;5&#125; &#125; &#125; return change; &#125;;&#125; 不得不说贪心版本的MinCoinChange比动态规划版本的简单多了。和动态规划方法相似，我们传递面额参数，实例化MinCoinChange（行{1}）。 对每个面额（行{2}——从大到小），把它的值和total相加后，total需要小于amount（行{3}）。我们会将当前面额coin添加到结果中（行{4}），也会将它和total相加（行{5}）。 如你所见，这个解法很简单。从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。 用和DP方法同样的测试代码测试： 12var minCoinChange = new MinCoinChange([1, 5, 10, 25]);console.log(minCoinChange.makeChange(36)); 结果依然是[25, 10, 1]，和用DP得到的一样。下图阐释了算法的执行过程： 然而，如果用[1, 3, 4]面额执行贪心算法，会得到结果[4, 1, 1]。如果用动态规划的解法，会得到最优的结果[3, 3]。 比起动态规划算法而言，贪心算法更简单、更快。然而，如我们所见，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。 3.2 分数背包问题求解分数背包问题的算法与动态规划版本稍有不同。在0-1背包问题中，只能向背包里装入完整的物品，而在分数背包问题中，我们可以装入分数的物品。我们用前面用过的例子来比较两者的差异，如下所示： 物 品# 重 量 价 值 1 2 3 2 3 4 3 4 5 在动态规划的例子里，我们考虑背包能够携带的重量只有5。而在这个例子里，我们可以说最佳解决方案是往背包里装入物品1和物品2，总重量为5，总价值为7。 如果在分数背包问题中考虑相同的容量，得到的结果是一样的。因此，我们考虑容量为6的情况。 在这种情况下，解决方案是装入物品1和物品2，还有25%的物品3。这样，重量为6的物品总价值为8.25。 我们来看看下面这个算法： 123456789101112131415function knapSack(capacity, values, weights) &#123; var n = values.length, load = 0, i = 0, val = 0; for (i = 0; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123; //&#123;1&#125; if (weights[i] &lt;= (capacity - load)) &#123; //&#123;2&#125; val += values[i]; load += weights[i]; &#125; else &#123; var r = (capacity - load) / weights[i]; //&#123;3&#125; val += r * values[i]; load += weights[i]; &#125; &#125; return val;&#125; 下面是对算法的解释。 行{1}：总重量少于背包容量，继续迭代，装入物品。行{2}：如果物品可以完整地装入背包，就将其价值和重量分别计入背包已装入物品的总价值（val）和总重量（load）。行{3}：如果物品不能完整地装入背包，计算能够装入部分的比例（r）。 如果在0-1背包问题中考虑同样的容量6，我们就会看到，物品1和物品3组成了解决方案。在这种情况下，对同一个问题应用不同的解决方法，会得到两种不同的结果。 测试以上代码： 12345var values = [3, 4, 5], weights = [2, 3, 4], capacity = 5, n = values.length;console.log(knapSack(capacity, values, weights)) //7 四、 函数式编程简介到目前为止，我们在本书中所用的编程范式都是命令式编程。在命令式编程中，我们按部就班地编写程序代码，详细描述要完成的事情以及完成的顺序。 在本节中，我们会介绍一种新的范式，叫作函数式编程。函数式编程是一种曾经主要用于学术领域的范式，多亏了Python和Ruby等现代语言，它才开始在行业开发者中流行起来。值得欣慰的是，借助ES6的能力，JavaScript也能够进行函数式编程。 4.1 函数式编程与命令式编程以函数式范式进行开发并不简单；关键在于习惯这种范式的机制。我们编写一个例子来说明差异。 假设我们想打印一个数组中所有的元素。我们可以用命令式编程，声明的函数如下： 123456var printArray = function (array) &#123; for (var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]); &#125;&#125;;printArray([1, 2, 3, 4, 5]); 在上面的代码中，我们迭代数组，打印每一项。 现在，我们试着把这个例子转换成函数式编程。在函数式编程中，函数就是摇滚明星。我们关注的重点是需要描述什么，而不是如何描述。回到这一句：“我们迭代数组，打印每一项”。那么，我们首先要关注的是迭代数据，然后进行操作，即打印数组项。下面的函数负责迭代数组： 12345var forEach = function (array, action) &#123; for (var i = 0; i &lt; array.length; i++) &#123; action(array[i]); &#125;&#125;; 接下来，我们要创建另一个负责把数组元素打印到控制台的函数（考虑为回调函数），如下： 123var logItem = function (item) &#123; console.log(item);&#125;; 最后，像下面这样使用声明的函数： 1forEach([1, 2, 3, 4, 5], logItem); 只需要上面这一行代码，我们就能描述我们要把数组的每一项打印到控制台。这是我们的第一个函数式编程的例子！ 有几点要注意： 主要目标是描述数据，以及要对数据应用的转换；程序执行顺序的重要性很低，而在命令式编程中，步骤和顺序是非常重要的；函数和数据集合是函数式编程的核心；在函数式编程中，我们可以使用和滥用函数和递归，而在命令式编程中，则使用循环、赋值、条件和函数。 4.2 ES2015 和函数式编程有了ES2015的新功能，用JavaScript进行函数式编程变得更加容易了。我们来看一个例子。 考虑我们要找出数组中最小的值。要用命令式编程完成这个任务，只要迭代数组，检查当前的最小值是否大于数组元素；如果是，就更新最小值，代码如下： 12345678910var findMinArray = function (array) &#123; var minValue = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; if (minValue &gt; array[i]) &#123; minValue = array[i]; &#125; &#125; return minValue;&#125;;console.log(findMinArray([8, 6, 4, 5, 9])); //输出4 用函数式编程完成相同的任务，可以使用Math.min函数，传入所有要比较的数组元素。我们可以像下面的例子里这样，使用ES2015的解构操作符（…），把数组转换成单个的元素： 1234const min_ = function (array) &#123; return Math.min(...array)&#125;;console.log(min_([8, 6, 4, 5, 9])); //输出4 使用ES2015的箭头函数，我们可以进一步简化上面的代码： 12const min = arr =&gt; Math.min(...arr);console.log(min([8, 6, 4, 5, 9])); 4.3 JavaScript 函数式工具箱—— map、filter 和 reducemap、filter和reduce函数是函数式编程的基础。 我们可以使用map函数，把一个数据集合转换或映射成另一个数据集合。先看一个命令式编程的例子： 123456789var daysOfWeek = [ &#123;name: 'Monday', value: 1&#125;, &#123;name: 'Tuesday', value: 2&#125;, &#123;name: 'Wednesday', value: 7&#125;];var daysOfWeekValues_ = [];for (var i = 0; i &lt; daysOfWeek.length; i++) &#123; daysOfWeekValues_.push(daysOfWeek[i].value);&#125; 再以函数式编程来考虑同样的例子，代码如下： 1234var daysOfWeekValues = daysOfWeek.map(function(day) &#123; return day.value;&#125;);console.log(daysOfWeekValues); 我们可以使用filter函数过滤一个集合的值。来看一个例子： 12345678910var positiveNumbers_ = function (array) &#123; var positive = []; for (var i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt;= 0) &#123; positive.push(array[i]); &#125; &#125; return positive;&#125;console.log(positiveNumbers_([-1, 1, 2, -2])); 我们可以把同样的代码写成函数式的，如下： 123456var positiveNumbers = function(array) &#123; return array.filter(function(num) &#123; return num &gt;= 0; &#125;)&#125;;console.log(positiveNumbers([-1, 1, 2, -2])); 我们也可以使用reduce函数，把一个集合归约成一个特定的值。比如，对一个数组中的值求和： 12345678var sumValues = function (array) &#123; var total = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; total += array[i]; &#125; return total;&#125;;console.log(sumValues([1, 2, 3, 4, 5])); 上面的代码也可以写成这样： 123456var sum_ = function (array) &#123; return array.reduce(function (a, b) &#123; return a + b; &#125;)&#125;;console.log(sum_([1, 2, 3, 4, 5])); 我们还可以把这些函数与ES2015的功能结合起来，比如解构操作符和箭头函数，代码如下： 12const sum = arr =&gt; arr.reduce((a, b) =&gt; a + b);console.log(sum([1, 2, 3, 4, 5])); 我们再看另一个例子。考虑我们需要写一个函数，把几个数组连接起来。为此，可以创建另一个数组，用于存放其他数组的元素。我们可以执行以下命令式的代码： 123456789101112 var mergeArrays_ = function (arrays) &#123; var count = arrays.length, newArray = [], k = 0; for (var i = 0; i &lt; count; i++) &#123; for (var j = 0; j &lt; arrays[i].length; j++) &#123; newArray[k++] = arrays[i][j]; &#125; &#125; return newArray;&#125;;console.log(mergeArrays_([[1, 2, 3], [4, 5], [6]])); 注意，在这个例子中，我们声明了变量，还使用了循环。现在，我们用JavaScript函数式编程把上面的代码重写如下： 123456var mergeArraysConcat = function (arrays) &#123; return arrays.reduce(function (p, n) &#123; return p.concat(n); &#125;);&#125;;console.log(mergeArraysConcat([[1, 2, 3], [4, 5], [6]])); 上面的代码完成了同样的任务，但它是面向函数的。我们也可以用ES2015使代码更加精简，如下所示： 123 const mergeArrays = (...arrays) =&gt; [].concat(...arrays); console.log(mergeArrays([1, 2, 3], [4, 5], [6])); ` 4.4 JavaScript 函数式类库和数据结构有一些很棒的JavaScript类库借助工具函数和函数式数据结构，对函数式编程提供支持。通过下面的列表，你可以找到一些最有名的JavaScript函数式类库。 Underscode.js：http://underscorejs.org/Bilby.js：http://bilby.brianmckenna.org/Lazy.js：http://danieltao.com/lazy.js/Bacon.js：https://baconjs.github.io/Fn.js：http://eliperelman.com/fn.js/Functional.js：http://functionaljs.com/Ramda.js：http://ramdajs.com/0.20.1/index.htmlMori：http://swannodette.github.io/mori/","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法十（排序和搜索算法）","date":"2019-03-18T02:51:50.000Z","path":"2019/03/18/cjxe4h6pl001g6sup41xq1hjw/","text":"一、排序算法在开始排序算法之前，我们先创建一个数组（列表）来表示待排序和搜索的数据结构。 123456789function ArrayList() &#123; var array = []; //&#123;1&#125; this.insert = function (item) &#123; //&#123;2&#125; array.push(item); &#125;; this.toString = function () &#123; //&#123;3&#125; return array.join(); &#125;;&#125; 如你所见，ArrayList是一个简单的数据结构，它将项存储在数组中（行{1}）。我们只需要一个插入方法来向数据结构中添加元素（行{2}），用JavaScript Array类原生的push方法即可。最后，为了帮助我们验证结果，toString方法使用JavaScript原生Array类的join方法，来拼接数组中的所有元素至一个单一的字符串，这样我们就可以轻松地在浏览器的控制台输出结果了。 注意ArrayList类并没有任何方法来移除数据或插入数据到特定位置。我们刻意保持简单是为了能够专注于排序和搜索算法。所有的排序和搜索算法会添加至这个类中。 1.1 冒泡排序在开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 让我们来实现一下冒泡排序： 12345678910this.bubbleSort = function () &#123; var length = array.length; //&#123;1&#125; for (var i = 0; i &lt; length; i++) &#123; //&#123;2&#125; for (var j = 0; j &lt; length - 1; j++) &#123; //&#123;3&#125; if (array[j] &gt; array[j + 1]) &#123; //&#123;4&#125; swap(array, j, j + 1); //&#123;5&#125; &#125; &#125; &#125;&#125;; 首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。 现在我们得声明swap函数（一个私有函数，只能用在ArrayList类的内部代码中）： 12345var swap = function (array, index1, index2) &#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;&#125;; 交换时，我们用一个中间值来存储某一交换项的值。其他排序法也会用到这个方法，因此我们声明一个方法放置这段交换代码以便重用。 如果使用在第1章学过的ES6（ECMAScript 2015）增强的对象属性，这个函数可以写成下面这样： 1[array[index1], array[index2]] = [array[index2], array[index1]]; 下面这个示意图展示了冒泡排序的工作过程： 该示意图中每一小段表示外循环的一轮（行{2}），而相邻两项的比较则是在内循环中进行的（行{3}）。 我们将使用下面这段代码来测试冒泡排序算法，看结果是否和示意图所示一致： 1234567891011function createNonSortedArray(size) &#123; //&#123;6&#125; var array = new ArrayList(); for (var i = size; i &gt; 0; i--) &#123; array.insert(i); &#125; return array;&#125;var array = createNonSortedArray(5); //&#123;7&#125;console.log(array.toString()); //&#123;8&#125;array.bubbleSort(); //&#123;9&#125;console.log(array.toString()); //&#123;10&#125; 为了辅助测试本章将要学习的排序算法，我们将创建一个函数来自动地创建一个未排序的数组，数组的长度由函数参数指定（行{6}）。如果传递5作为参数，该函数会创建如下数组：[5, 4 ,3, 2, 1]。调用这个函数并将返回值存储在一个变量中，该变量将包含这个以某些数字来初始化的ArrayList类实例（行{7}）。我们在控制台上输出这个数组内容，确保这是一个未排序数组（行{8}），接着我们调用冒泡排序方法（行{9}）并再次在控制台上输出数组内容以验证数组已被排序了（行{10}）。 注意当算法执行外循环的第二轮的时候，数字4和5已经是正确排序的了。尽管如此，在后续比较中，它们还一直在进行着比较，即使这是不必要的。因此，我们可以稍稍改进一下冒泡排序算法。 改进后的冒泡排序 如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较（行{1}）。 12345678910this.modifiedBubbleSort = function()&#123; var length = array.length; for (var i=0; i&lt;length; i++)&#123; for (var j=0; j&lt;length-1-i; j++ )&#123; //&#123;1&#125; if (array[j] &gt; array[j+1])&#123; swap(j, j+1); &#125; &#125; &#125;&#125;; 下面这个示意图展示了改进后的冒泡排序算法是如何执行的： 1.2 选择排序选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。 下面是选择排序算法的源代码： 123456789101112131415this.selectionSort = function () &#123; var length = array.length, //&#123;1&#125; indexMin; for (var i = 0; i &lt; length - 1; i++) &#123; //&#123;2&#125; indexMin = i; //&#123;3&#125; for (var j = i; j &lt; length; j++) &#123; //&#123;4&#125; if (array[indexMin] &gt; array[j]) &#123; //&#123;5&#125; indexMin = j; //&#123;6&#125; &#125; &#125; if (i !== indexMin) &#123; //&#123;7&#125; swap(array, i, indexMin); &#125; &#125;&#125;; 首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。 用以下代码段来测试选择排序算法： 1234array = createNonSortedArray(5);console.log(array.toString()); //[5, 4, 3, 2, 1]array.selectionSort(); console.log(array.toString()); //[1, 2, 3, 4, 5] 下面的示意图展示了选择排序算法，此例基于之前代码中所用的数组。 数组底部的箭头指示出当前迭代轮寻找最小值的数组范围（内循环{4}），示意图中的每一步则表示外循环。 选择排序同样也是一个复杂度为O(n2)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。然而，接下来要学的插入排序比选择排序性能要好。 1.3 插入排序插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。 下面这段代码表示插入排序算法： 照例，算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。 下面的示意图展示了一个插入排序的实例： 举个例子，假定待排序数组是[3, 5, 1, 4, 2]。这些值将被插入排序算法按照下面形容的步骤进行排序。 (1) 3已被排序，所以我们从数组第二个值5开始。3比5小，所以5待在原位（数组的第二位）。3和5排序完毕。(2) 下一个待排序和插到正确位置上去的值是1（目前在数组的第三位）。5比1大，所以5被移至第三位去了。我们得分析1是否应该被插入到第二位——1比3大吗？不，所以3被移到第二位去了。接着，我们得证明1应该插入到数组的第一位上。因为0是第一个位置且没有负数位，所以1必须被插入到第一位。1、3、5三个数字已经排序。(3) 4应该在当前位置（索引3）还是要移动到索引较低的位置上呢？4比5小，所以5移动到索引3位置上去。那么应该把4插到索引2的位置上去吗？4要比3大，所以4插入到数组的位置3上。 下一个待插入的数字是2（数组的位置4）。5比2大，所以5移动至索引4。4比2大，所以4也得移动（位置3）。3也比2大，所以3还得移动。1比2小，所以2插入到数组的第二位置上。至此，数组已排序完成。 排序小型数组时，此算法比选择排序和冒泡排序性能要好。 1.4 归并排序归并排序是第一个可以被实际使用的排序算法。前面学到的三个排序算法性能不好，但归并排序性能不错，其复杂度为O(nlogn)。 JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。 归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 由于是分治法，归并排序也是递归的： 123this.mergeSort = function()&#123; array = mergeSortRec(array);&#125;; 像之前的章节一样，每当要实现一个递归函数，我们都会实现一个实际被执行的辅助函数。对归并排序我们也会这么做。我们将声明mergeSort方法以供随后使用，而mergeSort方法将会调用mergeSortRec，该函数是一个递归函数： 12345678910var mergeSortRec = function(array)&#123; var length = array.length; if(length === 1) &#123; //&#123;1&#125; return array; //&#123;2&#125; &#125; var mid = Math.floor(length / 2), //&#123;3&#125; left = array.slice(0, mid), //&#123;4&#125; right = array.slice(mid, length); //&#123;5&#125; return merge(mergeSortRec(left), mergeSortRec(right)); //&#123;6&#125;&#125;; 归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。 如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。 下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。 12345678910111213141516171819var merge = function (left, right) &#123; var result = [], // &#123;7&#125; il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; // &#123;8&#125; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); // &#123;9&#125; &#125; else &#123; result.push(right[ir++]); // &#123;10&#125; &#125; &#125; while (il &lt; left.length) &#123; // &#123;11&#125; result.push(left[il++]); &#125; while (ir &lt; right.length) &#123; // &#123;12&#125; result.push(right[ir++]); &#125; return result; // &#123;13&#125;&#125;; merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。 接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。 如果执行mergeSort函数，下图是具体的执行过程： 可以看到，算法首先将原始数组分割直至只有一个元素的子数组，然后开始归并。归并过程也会完成排序，直至原始数组完全合并并完成排序。 1.5 快速排序快速排序也许是最常用的排序算法了。它的复杂度为O(nlogn)，且它的性能通常比其他的复杂度为O(nlogn)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。 快速排序比到目前为止你学过的其他排序算法要复杂一些。让我们一步步地来学习。 (1) 首先，从数组中选择中间一项作为主元。(2) 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。 让我们开始快速排序的实现吧： 123this.quickSort = function()&#123; quick(array, 0, array.length - 1);&#125;; 就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数。 123456789101112var quick = function (array, left, right) &#123; var index; //&#123;1&#125; if (array.length &gt; 1) &#123; //&#123;2&#125; index = partition(array, left, right); //&#123;3&#125; if (left &lt; index - 1) &#123; //&#123;4&#125; quick(array, left, index - 1); //&#123;5&#125; &#125; if (index &lt; right) &#123; //&#123;6&#125; quick(array, index, right); //&#123;7&#125; &#125; &#125;&#125;; 首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。 如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。 1.5.1 划分过程第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。 现在，让我们看看划分过程： 12345678910111213141516171819var partition = function (array, left, right) &#123; var pivot = array[Math.floor((right + left) / 2)], //&#123;8&#125; i = left, //&#123;9&#125; j = right; //&#123;10&#125; while (i &lt;= j) &#123; //&#123;11&#125; while (array[i] &lt; pivot) &#123; //&#123;12&#125; i++; &#125; while (array[j] &gt; pivot) &#123; //&#123;13&#125; j--; &#125; if (i &lt;= j) &#123; //&#123;14&#125; swap(array, i, j); //&#123;15&#125; i++; j--; &#125; &#125; return i; //&#123;16&#125;&#125;; 在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。 只要left和right指针没有相互交错（行{11}），就执行划分操作。首先，移动left指针直到找到一个元素比主元大（行{12}）。对right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。 在划分操作结束后，返回左指针的索引，用来在行{3}处创建子数组。 swap函数和我们在本章开始为冒泡排序算法实现的相同。我们也可以将此函数替换为以下ES6代码。 1[array[index1], array[index2]] = [array[index2], array[index1]]; 1.5.2 快速排序实战让我们来一步步地看一个快速排序的实际例子： 给定数组[3, 5, 1, 6, 4, 7, 2]，前面的示意图展示了划分操作的第一次执行。 下面的示意图展示了对有较小值的子数组执行的划分操作（注意7和6不包含在子数组之内）： 接着，我们继续创建子数组，请看下图，但是这次操作是针对上图中有较大值的子数组（有1的那个较小子数组不用再划分了，因为它仅含有一个项）。 子数组（[2, 3, 5, 4]）中的较小子数组（[2, 3]）继续进行划分（算法代码中的行{5}）： 然后子数组（[2, 3, 5, 4]）中的较大子数组（[5, 4]）也继续进行划分（算法中的行{7}），示意图如下： 最终，较大子数组[6, 7]也会进行划分（partition）操作，快速排序算法的操作执行完成。 1.6 堆排序堆排序也是一种很高效的算法，因其把数组当作二叉树来排序而得名。这个算法会根据以下信息，把数组当作二叉树来管理。 索引0是树的根节点；除根节点外，任意节点N的父节点是N/2；节点L的左子节点是2L；节点R的右子节点是2R+1。 举例来说，可以将数组[3, 5, 1, 6, 4, 7, 2]想象成下面的树： 堆排序算法实现如下： 123456789this.heapSort = function () &#123; var heapSize = array.length; buildHeap(array); //&#123;1&#125; while (heapSize &gt; 1) &#123; heapSize--; swap(array, 0, heapSize); //&#123;2&#125; heapify(array, heapSize, 0); //&#123;3&#125; &#125;&#125;; 第一步，构造一个满足array[parent(i)] ≥ array[i]的堆结构（行{1}）。 第二步，交换堆里第一个元素（数组中较大的值）和最后一个元素的位置（行{2}）。这样，最大的值就会出现在它已排序的位置。 第二步可能会丢掉堆的属性。因此，我们还需要执行一个heapify函数，再次将数组转换成堆，也就是说，它会找到当前堆的根节点（较小的值），重新放到树的底部。 buildHeap函数实现如下： 123456var buildHeap = function(array)&#123; var heapSize = array.length; for (var i = Math.floor(array.length / 2); i &gt;= 0; i--) &#123; heapify(array, heapSize, i); &#125;&#125;; 如果对数组[3, 5, 1, 6, 4, 7, 2]调用buildHeap函数，堆的构建过程如下： 最后，heapify函数实现如下： 123456789101112131415var heapify = function (array, heapSize, i) &#123; var left = i * 2 + 1, right = i * 2 + 2, largest = i; if (left &lt; heapSize &amp;&amp; array[left] &gt; array[largest]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123; largest = right; &#125; if (largest !== i) &#123; swap(array, i, largest); heapify(array, heapSize, largest); &#125;&#125;; 堆构造好之后，就可以应用堆排序的算法了，也就是行{2}和行{3} 二、搜索算法现在，让我们来谈谈搜索算法。回顾一下之前章节所实现的算法，我们会发现BinarySearchTree类的search方法（第8章），以及LinkedList类的indexOf方法（第5章）等，都是搜索算法，当然，它们每一个都是根据其各自的数据结构来实现的。所以，我们已经熟悉两个搜索算法了，只是还不知道它们“正式”的名称而已。 2.1 顺序搜索顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。 以下是其实现： 1234567this.sequentialSearch = function (item) &#123; for (var i = 0; i &lt; array.length; i++) &#123; //&#123;1&#125; if (item === array[i]) //&#123;2&#125; return i; //&#123;3&#125; &#125; return -1; //&#123;4&#125;&#125;; 顺序搜索迭代整个数组（行{1}），并将每个数组元素和搜索项作比较（行{2}）。如果搜索到了，算法将用返回值来标示搜索成功。返回值可以是该搜索项本身，或是true，又或是搜索项的索引（行{3}）。如果没有找到该项，则返回-1（行{4}），表示该索引不存在；也可以考虑返回false或者null。 假定有数组[5, 4, 3, 2, 1]和待搜索值3，下图展示了顺序搜索的示意图： 2.2 二分搜索二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。 这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。 (1) 选择数组的中间值。 (2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。 (3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。 (4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。 以下是其实现： 123456789101112131415161718this.binarySearch = function (item) &#123; this.quickSort(); //&#123;1&#125; var low = 0, //&#123;2&#125; high = array.length - 1, //&#123;3&#125; mid, element; while (low &lt;= high) &#123; //&#123;4&#125; mid = Math.floor((low + high) / 2); //&#123;5&#125; element = array[mid]; //&#123;6&#125; if (element &lt; item) &#123; //&#123;7&#125; low = mid + 1; //&#123;8&#125; &#125; else if (element &gt; item) &#123; //&#123;9&#125; high = mid - 1; //&#123;10&#125; &#125; else &#123; return mid; //&#123;11&#125; &#125; &#125; return -1; //&#123;12&#125;&#125; 开始前需要先将数组排序，我们可以选择任何一个在10.1节中实现的排序算法。这里我们选择了快速排序。在数组排序之后，我们设置low（行{2}）和high（行{3}）指针（它们是边界）。 当low比high小时（行{4}），我们计算得到中间项索引并取得中间项的值，此处如果low比high大，则意思是该待搜索值不存在并返回-1（行{12}）。接着，我们比较选中项的值和搜索值（行{7}）。如果小了，则选择数组低半边并重新开始。如果选中项的值比搜索值大了，则选择数组高半边并重新开始。若两者都是不是，则意味着选中项的值和搜索值相等，因此，直接返回该索引（行{11}）。 给定下图所示数组，让我们试试看搜索2。这些是算法将会执行的步骤：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法九（图）","date":"2019-03-08T01:45:50.000Z","path":"2019/03/08/cjxe4h6q3001u6suppmgo34x7/","text":"一、图的相关术语图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。 任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。 我们还可以使用图来表示道路、航班以及通信状态，如下图所示： 让我们来学习一下图在数学及技术上的概念。 一个图G = (V, E)由以下元素组成。 V：一组顶点E：一组边，连接V中的顶点 下图表示一个图： 在着手实现算法之前，让我们先了解一下图的一些术语。 由一条边连接在一起的顶点称为相邻顶点。比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。 一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3；E和其他两个顶点相连，因此，E的度为2。 路径是顶点v1, v2,…,vk的一个连续序列，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。 简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如A D C A（最后一个顶点重新回到A）。 如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。 1.1 有向图和无向图图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向： 如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的，而A和B不是强连通的。 图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值： 我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。 二、 图的表示从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。 2.1 邻接矩阵图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0，如下图所示： 不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而2维数组不太灵活。 2.2 邻接表我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。 尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质（例如，要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。在本书的示例中，我们将会使用邻接表表示法。 2.3 关联矩阵我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。 关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。 三、创建Graph类照例，我们声明类的骨架： 1234function Graph() &#123; var vertices = []; //&#123;1&#125; var adjList = new Dictionary(); //&#123;2&#125;&#125; 我们使用一个数组来存储图中所有顶点的名字（行{1}），以及一个字典（在第7章中已经实现）来存储邻接表（行{2}）。字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和adjList字典两者都是我们Graph类的私有属性。 接着，我们将实现两个方法：一个用来向图中添加一个新的顶点（因为图实例化后是空的），另外一个方法用来添加顶点之间的边。我们先实现addVertex方法： 1234this.addVertex = function(v)&#123; vertices.push(v); //&#123;3&#125; adjList.set(v, []); //&#123;4&#125;&#125;; 这个方法接受顶点v作为参数。我们将该顶点添加到顶点列表中（行{3}），并且在邻接表中，设置顶点v作为键对应的字典值为一个空数组（行{4}）。 现在，我们来实现addEdge方法： 1234this.addEdge = function(v, w)&#123; adjList.get(v).push(w); //&#123;5&#125; adjList.get(w).push(v); //&#123;6&#125;&#125;; 这个方法接受两个顶点作为参数。首先，通过将w加入到v的邻接表中，我们添加了一条自顶点v到顶点w的边。如果你想实现一个有向图，则行{5}就足够了。由于本章中大多数的例子都是基于无向图的，我们需要添加一条自w向v的边（行{6}）。 为了更方便一些，让我们来实现一下Graph类的toString方法，以便于在控制台输出图。 123456789101112this.toString = function()&#123; var s = ''; for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;10&#125; s += vertices[i] + ' -&gt; '; var neighbors = adjList.get(vertices[i]); //&#123;11&#125; for (var j=0; j&lt;neighbors.length; j++)&#123; //&#123;12&#125; s += neighbors[j] + ' '; &#125; s += '\\n'; //&#123;13&#125; &#125; return s;&#125;; 我们为邻接表表示法构建了一个字符串。首先，迭代vertices数组列表（行{10}），将顶点的名字加入字符串中。接着，取得该顶点的邻接表（行{11}），同样也迭代该邻接表（行{12}），将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符（行{13}），这样就可以在控制台看到一个漂亮的输出了。运行如下代码： 测试以上代码： 12345678910111213141516var graph = new Graph();var myVertices = ['A','B','C','D','E','F','G','H','I']; //&#123;7&#125;for (var i=0; i&lt;myVertices.length; i++)&#123; //&#123;8&#125; graph.addVertex(myVertices[i]);&#125;graph.addEdge('A', 'B'); //&#123;9&#125;graph.addEdge('A', 'C');graph.addEdge('A', 'D');graph.addEdge('C', 'D');graph.addEdge('C', 'G');graph.addEdge('D', 'G');graph.addEdge('D', 'H');graph.addEdge('B', 'E');graph.addEdge('B', 'F');graph.addEdge('E', 'I');console.log(graph.toString()); 为方便起见，我们创建了一个数组，包含所有我们想添加到图中的顶点（行{7}）。接下来，我们只要遍历vertices数组并将其中的值逐一添加到我们的图中（行{8}）。最后，我们添加想要的边（行{9}）。这段代码将会创建一个图，也就是到目前为止本章的示意图所使用的。 输出如下： 123456789A -&gt; B C DB -&gt; A E FC -&gt; A D GD -&gt; A C G HE -&gt; B IF -&gt; BG -&gt; C DH -&gt; DI -&gt; E 一个漂亮的邻接表！从该输出中，我们知道顶点A有这几个相邻顶点：B、C和D。 四、图的遍历和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。 在实现算法之前，让我们来更好地理解一下图遍历的思想方法。 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。 完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。 为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。 广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。 算 法 数据结构 描述 深度优先搜索 栈 通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 广度优先搜索 队列 通过将顶点存入队列中，最先入队列的顶点先被探索 当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。 白色：表示该顶点还没有被访问。灰色：表示该顶点被访问过，但并未被探索过。黑色：表示该顶点被访问过且被完全探索过。 这就是之前提到的务必访问每个顶点最多两次的原因。 4.1 广度优先搜索广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示： 以下是从顶点v开始的广度优先搜索算法所遵循的步骤。 (1) 创建一个队列Q。(2) 将v标注为被发现的（灰色），并将v入队列Q。(3) 如果Q非空，则运行以下步骤： (a) 将u从Q中出队列； (b) 将标注u为被发现的（灰色）； (c) 将u所有未被访问过的邻点（白色）入队列； (d) 将u标注为已被探索的（黑色）。 让我们来实现广度优先搜索算法： 12345678910111213141516171819202122232425262728var initializeColor = function () &#123; var color = []; for (var i = 0; i &lt; vertices.length; i++) &#123; color[vertices[i]] = 'white'; //&#123;1&#125; &#125; return color;&#125;; this.bfs = function (v, callback) &#123; var color = initializeColor(), //&#123;2&#125; queue = new Queue(); //&#123;3&#125; queue.enqueue(v); //&#123;4&#125; while (!queue.isEmpty()) &#123; //&#123;5&#125; var u = queue.dequeue(), //&#123;6&#125; neighbors = adjList.get(u); //&#123;7&#125; color[u] = 'grey'; // &#123;8&#125; for (var i = 0; i &lt; neighbors.length; i++) &#123; // &#123;9&#125; var w = neighbors[i]; // &#123;10&#125; if (color[w] === 'white') &#123; // &#123;11&#125; color[w] = 'grey'; // &#123;12&#125; queue.enqueue(w); // &#123;13&#125; &#125; &#125; color[u] = 'black'; // &#123;14&#125; if (callback) &#123; // &#123;15&#125; callback(u); &#125; &#125;&#125;; 广度优先搜索和深度优先搜索都需要标注被访问过的顶点。为此，我们将使用一个辅助数组color。由于当算法开始执行时，所有的顶点颜色都是白色（行{1}），所以我们可以创建一个辅助函数initializeColor，为这两个算法执行此初始化操作。 让我们深入学习广度优先搜索方法的实现。我们要做的第一件事情是用initializeColor函数来将color数组初始化为white（行{2}）。我们还需要声明和创建一个Queue实例（行{3}），它将会存储待访问和待探索的顶点。 照着本章开头解释过的步骤，bfs方法接受一个顶点作为算法的起始点。起始顶点是必要的，我们将此顶点入队列（行{4}）。 如果队列非空（行{5}），我们将通过出队列（行{6}）操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表（行{7}）。该顶点将被标注为grey（行{8}），表示我们发现了它（但还未完成对其的探索）。 对于u（行{9}）的每个邻点，我们取得其值（该顶点的名字——行{10}），如果它还未被访问过（颜色为white——行{11}），则将其标注为我们已经发现了它（颜色设置为grey——行{12}），并将这个顶点加入队列中（行{13}），这样当其从队列中出列的时候，我们可以完成对其的探索。 当完成探索该顶点和其相邻顶点后，我们将该顶点标注为已探索过的（颜色设置为black——行{14}）。 我们实现的这个bfs方法也接受一个回调（我们在第8章中遍历树时使用了一个相似的方法）。这个参数是可选的，如果我们传递了回调函数（行{15}），会用到它。 让我们执行下面这段代码来测试一下这个算法： 1234function printNode(value)&#123; //&#123;16&#125; console.log('Visited vertex: ' + value); //&#123;17&#125;&#125;graph.bfs(myVertices[0], printNode); //&#123;18&#125; 首先，我们声明了一个回调函数（行{16}），它仅仅在浏览器控制台上输出已经被完全探索过的顶点的名字。接着，我们会调用bfs方法，给它传递第一个顶点（A——从本章开头声明的myVertices数组）和回调函数。当我们执行这段代码时，该算法会在浏览器控制台输出下示的结果： Visited vertex: AVisited vertex: BVisited vertex: CVisited vertex: DVisited vertex: EVisited vertex: FVisited vertex: GVisited vertex: HVisited vertex: I 顶点被访问的顺序和本节开头的示意图中所展示的一致。 4.1.1 使用BFS寻找最短路径到目前为止，我们只展示了BFS算法的工作原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面这个问题。 给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。 对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改bfs方法以返回给我们一些信息： 从v到u的距离d[u]； 前溯点pred[u]，用来推导出从v到其他每个顶点u的最短路径。 123456789101112131415161718192021222324252627282930this.BFS = function (v) &#123; var color = initializeColor(), queue = new Queue(), d = [], //&#123;1&#125; pred = []; //&#123;2&#125; queue.enqueue(v); for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;3&#125; d[vertices[i]] = 0; //&#123;4&#125; pred[vertices[i]] = null; //&#123;5&#125; &#125; while (!queue.isEmpty()) &#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; color[w] = 'grey'; d[w] = d[u] + 1; //&#123;6&#125; pred[w] = u; //&#123;7&#125; queue.enqueue(w); &#125; &#125; color[u] = 'black'; &#125; return &#123; //&#123;8&#125; distances: d, predecessors: pred &#125;;&#125;; 让我们来看看改进过的广度优先方法的实现： 我们还需要声明数组d（行{1}）来表示距离，以及pred数组来表示前溯点。下一步则是对图中的每一个顶点，用0来初始化数组d（行{4}），用null来初始化数组pred。 当我们发现顶点u的邻点w时，则设置w的前溯点值为u（行{7}）。我们还通过给d[u]加1来设置v和w之间的距离（u是w的前溯点，d[u]的值已经有了）。 方法最后返回了一个包含d和pred的对象（行{8}）。 现在，我们可以再次执行BFS方法，并将其返回值存在一个变量中： 12var shortestPathA = graph.BFS(myVertices[0]);console.log(shortestPathA); 对顶点A执行BFS方法，以下将会是输出： 12distances: [A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3],predecessors: [A: null, B: \"A\", C: \"A\", D: \"A\", E: \"B\", F: \"B\", G: \"C\", H: \"D\", I: \"E\"] 这意味着顶点A与顶点B、C和D的距离为1；与顶点E、F、G和H的距离为2；与顶点I的距离为3。 通过前溯点数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径： 1234567891011121314var fromVertex = myVertices[0]; //&#123;9&#125;for (var i = 1; i &lt; myVertices.length; i++) &#123; //&#123;10&#125; var toVertex = myVertices[i], //&#123;11&#125; path = new Stack(); //&#123;12&#125; for (var v = toVertex; v !== fromVertex;v = shortestPathA.predecessors[v]) &#123; //&#123;13&#125; path.push(v); //&#123;14&#125; &#125; path.push(fromVertex); //&#123;15&#125; var s = path.pop(); //&#123;16&#125; while (!path.isEmpty()) &#123; //&#123;17&#125; s += ' - ' + path.pop(); //&#123;18&#125; &#125; console.log(s); //&#123;19&#125;&#125; 我们用顶点A作为源顶点（行{9}）。对于每个其他顶点（除了顶点A——行{10}），我们会计算顶点A到它的路径。我们从顶点数组得到toVertex（行{11}），然后会创建一个栈来存储路径值（行{12}）。 接着，我们追溯toVertex到fromVertex的路径（行{13}）。变量v被赋值为其前溯点的值，这样我们能够反向追溯这条路径。将变量v添加到栈中（行{14}）。最后，源顶点也会被添加到栈中，以得到完整路径。 这之后，我们创建了一个s字符串，并将源顶点赋值给它（它是最后一个加入栈中的，所以它是第一个被弹出的项 ——行{16}）。当栈是非空的，我们就从栈中移出一个项并将其拼接到字符串s的后面（行{18}）。最后（行{19}）在控制台上输出路径。 执行该代码段，我们会得到如下输出： A - BA - CA - DA - B - EA - B - FA - C - GA - D - HA - B - E - I 这里，我们得到了从顶点A到图中其他顶点的最短路径（衡量标准是边的数量）。 4.1.2 深入学习最短路径算法本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法），广度优先搜索未必合适。 举些例子，Dijkstra算法解决了单源最短路径问题。Bellman-Ford算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。Floyd-Warshall算法解决了求所有顶点对间的最短路径这一问题。 如文章开头提到的，图是一个广泛的主题，对最短路径问题及其变种问题，我们有很多的解决方案。但在开始学习这些其他解决方案前，我们需要掌握好图的基本概念，这是本章涵盖的内容。而这些其他解决方案则不会在本章讲述，但你可以自行探索图的奇妙世界 4.2深度优先搜索深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示： 深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。 要访问顶点v，照如下步骤做。 (1) 标注v为被发现的（灰色）。(2) 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。 如你所见，深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。 让我们来实现一下深度优先算法 12345678910111213141516171819202122this.dfs = function (callback) &#123; var color = initializeColor(); //&#123;1&#125; for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;2&#125; if (color[vertices[i]] === 'white') &#123; //&#123;3&#125; dfsVisit(vertices[i], color, callback); //&#123;4&#125; &#125; &#125;&#125;;var dfsVisit = function (u, color, callback) &#123; color[u] = 'grey'; //&#123;5&#125; if (callback) &#123; //&#123;6&#125; callback(u); &#125; var neighbors = adjList.get(u); //&#123;7&#125; for (var i = 0; i &lt; neighbors.length; i++) &#123; //&#123;8&#125; var w = neighbors[i]; //&#123;9&#125; if (color[w] === 'white') &#123; //&#123;10&#125; dfsVisit(w, color, callback); //&#123;11&#125; &#125; &#125; color[u] = 'black'; //&#123;12&#125;&#125;; 首先，我们创建颜色数组（行{1}），并用值white为图中的每个顶点对其做初始化，广度优先搜索也这么做的。接着，对于图实例中每一个未被访问过的顶点（行{2}和{3}），我们调用私有的递归函数dfsVisit，传递的参数为顶点、颜色数组以及回调函数（行{4}）。 当访问u顶点时，我们标注其为被发现的（grey——行{5}）。如果有callback函数的话（行{6}），则执行该函数输出已访问过的顶点。接下来一步是取得包含顶点u所有邻点的列表（行{7}）。对于顶点u的每一个未被访问过（颜色为white——行{10}和行{8}）的邻点w（行{9}），我们将调用dfsVisit函数，传递w和其他参数（行{11}——添加顶点w入栈，这样接下来就能访问它）。最后，在该顶点和邻点按深度访问之后，我们回退，意思是该顶点已被完全探索，并将其标注为black（行{12}）。 让我们执行下面的代码段来测试一下dfs方法： 输出如下： Visited vertex: AVisited vertex: BVisited vertex: EVisited vertex: IVisited vertex: FVisited vertex: CVisited vertex: DVisited vertex: GVisited vertex: H 这个顺序和本节开头处示意图所展示的一致。下面这个示意图展示了该算法每一步的执行过程： 在我们示例所用的图中，行{4}只会被执行一次，因为所有其他的顶点都有路径到第一个调用dfsVisit函数的顶点（顶点A）。如果顶点B第一个调用函数，则行{4}将会为其他顶点再执行一次（比如顶点A）。 4.2.1 深度优先搜索到目前为止，我们只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事情，而不只是输出被访问顶点的顺序。 对于给定的图G，我们希望深度优先搜索算法遍历图G的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。我们可以修改dfs方法来返回给我们一些信息： 顶点u的发现时间d[u]；当顶点u被标注为黑色时，u的完成探索时间f[u]；顶点u的前溯点p[u]。 让我们来看看改进了的DFS方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839var time = 0; //&#123;1&#125;this.DFS = function () &#123; var color = initializeColor(), //&#123;2&#125; d = [], f = [], p = []; time = 0; for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;3&#125; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for (i = 0; i &lt; vertices.length; i++) &#123; if (color[vertices[i]] === 'white') &#123; DFSVisit(vertices[i], color, d, f, p); &#125; &#125; return &#123; //&#123;4&#125; discovery: d, finished: f, predecessors: p &#125;;&#125;;var DFSVisit = function (u, color, d, f, p) &#123; console.log('discovered ' + u); color[u] = 'grey'; d[u] = ++time; //&#123;5&#125; var neighbors = adjList.get(u); for (var i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; p[w] = u; // &#123;6&#125; DFSVisit(w, color, d, f, p); &#125; &#125; color[u] = 'black'; f[u] = ++time; //&#123;7&#125; console.log('explored ' + u);&#125;; 我们需要一个变量来要追踪发现时间和完成探索时间（行{1}）。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他JavaScript方法（将变量作为引用传递的意思是如果该变量在其他方法内部被修改，新值会在原始变量中反映出来）。接下来，我们声明数组d、f和p（行{2}）。我们需要为图的每一个顶点来初始化这些数组（行{3}）。在这个方法结尾处返回这些值（行{4}），之后我们要用到它们。 当一个顶点第一次被发现时，我们追踪其发现时间（行{5}）。当它是由引自顶点u的边而被发现的，我们追踪它的前溯点（行{6}）。最后，当这个顶点被完全探索后，我们追踪其完成时间（行{7}）。 深度优先算法背后的思想是什么？边是从最近发现的顶点u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法回退到u被发现的地方去探索其他的边。这个过程持续到我们发现了所有从原始顶点能够触及的顶点。如果还留有任何其他未被发现的顶点，我们对新源顶点重复这个过程。重复该算法，直到图中所有的顶点都被探索了。 对于改进过的深度优先搜索，有两点需要我们注意： 时间（time）变量值的范围只可能在图顶点数量的一倍到两倍之间；对于所有的顶点u，d[u]&lt;f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）。 在这两个假设下，我们有如下的规则： 1 ≤ d [u] &lt; f [u] ≤ 2|V| 如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间： 4.2.2 拓扑排序——使用深度优先搜索给定下图，假定每个顶点都是一个我们需要去执行的任务： 这是一个有向图，意味着任务的执行是有顺序的。例如，任务F不能在任务A之前执行。注意这个图没有环，意味着这是一个无环图。所以，我们可以说该图是一个有向无环图（DAG）。 当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting，英文亦写作topsort或是toposort）。在日常生活中，这个问题在不同情形下都会出现。例如，当我们开始学习一门计算机科学课程，在学习某些知识之前得按顺序完成一些知识储备（你不可以在上算法I前先上算法II）。当我们在开发一个项目时，需要按顺序执行一些步骤，例如，首先我们得从客户那里得到需求，接着开发客户要求的东西，最后交付项目。你不能先交付项目再去收集需求。 拓扑排序只能应用于DAG。那么，如何使用深度优先搜索来实现拓扑排序呢？让我们在本节开头的示意图上执行一下深度优先搜索。 123456789101112graph = new Graph();myVertices = ['A','B','C','D','E','F'];for (i=0; i&lt;myVertices.length; i++)&#123;graph.addVertex(myVertices[i]);&#125;graph.addEdge('A', 'C');graph.addEdge('A', 'D');graph.addEdge('B', 'D');graph.addEdge('B', 'E');graph.addEdge('C', 'F');graph.addEdge('F', 'E');var result = graph.DFS(); 这段代码将创建图，添加边，执行改进版本的深度优先搜索算法，并将结果保存到result变量。下图展示了深度优先搜索算法执行后，该图的发现和完成时间 现在要做的仅仅是以倒序来排序完成时间数组，这便得出了该图的拓扑排序： B - A - D - C - F - E 注意之前的拓扑排序结果仅是多种可能性之一。如果我们稍微修改一下算法，就会有不同的结果，比如下面这个结果也是众多其他可能性中的一个： A - B - C - D - F - E 五、 最短路径算法设想你要从街道地图上的A点，通过可能的最短路径到达B点。举例来说，从洛杉矶的圣莫尼卡大道到好莱坞大道，如下图所示： 这种问题在生活中非常常见，我们（特别是生活在大城市的人们）会求助于苹果地图、谷歌地图、Waze等应用程序。当然，我们也有其他的考虑，如时间或路况，但根本的问题仍然是：从A到B的最短路径是什么？ 我们可以用图来解决这个问题，相应的算法被称为最短路径。本节我们将介绍两种非常著名的算法，即Dijkstra算法和Floyd-Warshall算法。 5.1 Dijkstra 算法Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。 考虑下图： 我们来看看如何找到顶点A和其余顶点之间的最短路径。但首先，我们需要声明表示上图的邻接矩阵，如下所示： 123456var graph = [[0, 2, 4, 0, 0, 0], [0, 0, 1, 4, 2, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 2], [0, 0, 0, 3, 0, 2], [0, 0, 0, 0, 0, 0]]; 现在，通过下面的代码来看看Dijkstra算法是如何工作的： 1234567891011121314151617181920this.dijkstra = function (src) &#123; var dist = [], visited = [], length = this.graph.length; for (var i = 0; i &lt; length; i++) &#123; //&#123;1&#125; dist[i] = Number.MAX_SAFE_INTEGER; visited[i] = false; &#125; dist[src] = 0; //&#123;2&#125; for (var i = 0; i &lt; length - 1; i++) &#123; //&#123;3&#125; var u = minDistance(dist, visited); //&#123;4&#125; visited[u] = true; //&#123;5&#125; for (var v = 0; v &lt; length; v++) &#123; if (!visited[v] &amp;&amp; this.graph[u][v] != 0 &amp;&amp; dist[u] != Number.MAX_SAFE_INTEGER &amp;&amp; dist[u] + this.graph[u][v] &lt; dist[v]) &#123; //&#123;6&#125; dist[v] = dist[u] + this.graph[u][v]; //&#123;7&#125; &#125; &#125; &#125; return dist; //&#123;8&#125;&#125;; 下面是对算法过程的描述。 行{1}：首先，把所有的距离（dist）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），将visited[]初始化为false。行{2}：然后，把源顶点到自己的距离设为0。行{3}：接下来，要找出到其余顶点的最短路径。行{4}：为此，我们需要从尚未处理的顶点中选出距离最近的顶点。行{5}：把选出的顶点标为visited，以免重复计算。行{6}：如果找到更短的路径，则更新最短路径的值（行{7}）。行{8}：处理完所有顶点后，返回从源顶点（src）到图中其他顶点最短路径的结果。 要计算顶点间的minDistance，就要搜索dist数组中的最小值，返回它在数组中的索引： 12345678910var minDistance = function(dist, visited) &#123; var min = INF, minIndex = -1; for (var v = 0; v &lt; dist.length; v++) &#123; if (visited[v] == false &amp;&amp; dist[v] &lt;= min) &#123; min = dist[v]; minIndex = v; &#125; &#125; return minIndex;&#125;; 对本节开始的图执行以上算法，会得到如下输出： 1234560 01 22 33 64 45 6 5.2 Floyd-Warshall 算法Floyd-Warshall算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。 Floyd-Warshall算法实现如下： 1234567891011121314151617181920212223242526272829303132333435363738 this.floydWarshall = function() &#123; var dist = [], length = this.graph.length, i, j, k; for (i = 0; i &lt; length; i++) &#123; //&#123;1&#125; dist[i] = []; for (j = 0; j &lt; length; j++) &#123; dist[i][j] = this.graph[i][j]; &#125; &#125; for (k = 0; k &lt; length; k++) &#123; //&#123;2&#125; for (i = 0; i &lt; length; i++) &#123; for (j = 0; j &lt; length; j++) &#123; if (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; //&#123;3&#125; dist[i][j] = dist[i][k] + dist[k][j]; //&#123;4&#125; &#125; &#125; &#125; &#125; return dist; &#125;; 下面是对算法过程的描述:&gt; 行&#123;1&#125;：首先，把dist数组初始化为每个顶点之间的权值，因为i到j可能的最短距离就是这些顶点间的权值。&gt; 行&#123;2&#125;：通过k，得到i途径顶点0至k，到达j的最短路径。&gt; 行&#123;3&#125;：判断i经过顶点k到达j的路径是否比已有的最短路径更短。&gt; 行&#123;4&#125;：如果是更短的路径，则更新最短路径的值。行&#123;3&#125;是Floyd-Warshall算法的核心。对本节开始的图执行以上算法，会得到如下输出：```javascript 0 2 3 6 4 6 INF 0 1 4 2 4 INF INF 0 6 3 5 INF INF INF 0 INF 2 INF INF INF 3 0 2 INF INF INF INF INF 0 其中，INF代表顶点i到j的最短路径不存在。 对图中每一个顶点执行Dijkstra算法，也可以得到相同的结果。 六、 最小生成树最小生成树（MST）问题是网络设计中常见的问题。想象一下，你的公司有几间办公室，要以最低的成本实现办公室电话线路相互连通，以节省资金，最好的办法是什么？ 这也可以应用于岛桥问题。设想你要在n个岛屿之间建造桥梁，想用最低的成本实现所有岛屿相互连通。 这两个问题都可以用MST算法来解决，其中的办公室或者岛屿可以表示为图中的一个顶点，边代表成本。这里我们有一个图的例子，其中较粗的边是一个MST的解决方案。 6.1 Prim 算法Prim算法是一种求解加权无向连通图的MST问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。 现在，通过下面的代码来看看Prim算法是如何工作的： 123456789101112131415161718192021222324this.prim = function() &#123; var parent = [], key = [], visited = []; length = this.graph.length, i; for (i = 0; i &lt; length; i++) &#123; //&#123;1&#125; key[i] = INF; visited[i] = false; &#125; key[0] = 0; //&#123;2&#125; parent[0] = -1; for (i = 0; i &lt; length-1; i++) &#123; //&#123;3&#125; var u = minKey(key, visited); //&#123;4&#125; visited[u] = true; //&#123;5&#125; for (var v = 0; v &lt; length; v++) &#123; if (this.graph[u][v] &amp;&amp; visited[v] == false &amp;&amp; this.graph[u][v] &lt; key[v]) &#123; //&#123;6&#125; parent[v] = u; //&#123;7&#125; key[v] = this.graph[u][v]; //&#123;8&#125; &#125; &#125; &#125; return parent; //&#123;9&#125;&#125;; 下面是对算法过程的描述。 行{1}：首先，把所有顶点（key）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），visited[]初始化为false。行{2}：其次，选择第一个key作为第一个顶点，同时，因为第一个顶点总是MST的根节点，所以parent[0] = -1。行{3}：然后，对所有顶点求MST。行{4}：从未处理的顶点集合中选出key值最小的顶点（与Dijkstra算法中使用的函数一样，只是名字不同）。行{5}：把选出的顶点标为visited，以免重复计算。行{6}：如果得到更小的权值，则保存MST路径（parent，行{7}）并更新其权值（行{8}）。行{9}：处理完所有顶点后，返回包含MST的结果。 比较Prim算法和Dijkstra算法，我们会发现除了行{7}和行{8}之外，两者非常相似。行{7}用parent数组保存MST的结果。行{8}用key数组保存权值最小的边，而在Dijkstra算法中，用dist数组保存距离。我们可以修改Dijkstra算法，加入parent数组。这样，就可以在求出距离的同时得到路径。 对如下的图执行以上算法： 123456var graph = [[0, 2, 4, 0, 0, 0], [2, 0, 2, 4, 2, 0], [4, 2, 0, 0, 3, 0], [0, 4, 0, 0, 3, 2], [0, 2, 3, 3, 0, 2], [0, 0, 0, 2, 2, 0]]; 我们会得到如下输出： 123456Edge Weight0 - 1 21 - 2 25 - 3 21 - 4 24 - 5 2 6.1 Kruskal 算法和Prim算法类似，Kruskal算法也是一种求加权无向连通图的MST的贪心算法。 现在，通过下面的代码来看看Kruskal算法是如何工作的： 123456789101112131415161718192021222324this.kruskal = function() &#123; var length = this.graph.length, parent = [], cost, ne = 0, a, b, u, v, i, j, min; cost = initializeCost(); //&#123;1&#125; while (ne &lt; length-1) &#123; //&#123;2&#125; for (i = 0, min = INF; i &lt; length; i++) &#123; //&#123;3&#125; for (j = 0; j &lt; length; j++) &#123; if (cost[i][j] &lt; min) &#123; min = cost[i][j]; u = i; v = j; &#125; &#125; &#125; u = find(u, parent); //&#123;4&#125; v = find(v, parent); //&#123;5&#125; if (union(u, v, parent)) &#123; //&#123;6&#125; ne++; &#125; cost[u][v] = cost[v][u] = INF; //&#123;7&#125; &#125; return parent;&#125; 下面是对算法过程的描述。 行{1}：首先，把邻接矩阵的值复制到cost数组，以方便修改且可以保留原始值行{7}。行{2}：当MST的边数小于顶点总数减1时。行{3}：找出权值最小的边。行{4}和行{5}：检查MST中是否已存在这条边，以避免环路。行{6}：如果u和v是不同的边，则将其加入MST。行{7}：从列表中移除这些边，以免重复计算。行{8}：返回MST。 下面是find函数的定义。它能防止MST出现环路： 123456var find = function(i, parent) &#123; while (parent[i]) &#123; i = parent[i]; &#125; return i;&#125;; union函数的定义如下: 1234567var union = function(i, j, parent) &#123; if (i != j) &#123; parent[j] = i; return true; &#125; return false;&#125;; 这个算法有几种变体。这取决于对边的权值排序时所使用的数据结构（如优先队列），以及图是如何表示的。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法八（树）","date":"2019-02-28T08:08:07.000Z","path":"2019/02/28/cjxe4h6q2001t6supt0c1hj7n/","text":"到目前为止，我们学习了一些顺序数据结构，学习的第一个非顺序数据结构是散列表。在节章，我们将要学习另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用。 一、 树数据结构树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图，如下图所示： 二、 树的相关术语一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点： 位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。 一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）。 三、 二叉树和二叉搜索树二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。 二叉搜索树将是我们在本章中要研究的数据结构。 3.1 创建 BinarySearchTree 类让我们开始创建自己的BinarySearchTree类。首先，声明它的结构： 12345678function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125;&#125; 下图展现了二叉搜索树数据结构的组织方式： 和链表一样，将通过指针来表示节点之间的关系（术语称其为边）。在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树，使用同样的方式（也使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。因此，将声明一个Node类来表示树中的每个节点（行{1}）。值得注意的一个小细节是，不同于在之前的章节中将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼。 我们将会遵循和LinkedList类中相同的模式，这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是根元素（行{2}） 然后，我们需要实现一些方法。下面是将要在树类中实现的方法。 insert(key)：向树中插入一个新的键。 search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。 inOrderTraverse：通过中序遍历方式遍历所有节点。 preOrderTraverse：通过先序遍历方式遍历所有节点。 postOrderTraverse：通过后序遍历方式遍历所有节点。 min：返回树中最小的值/键。 max：返回树中最大的值/键。 remove(key)：从树中移除某个键。 3.1.1 向树中插入一个键下面的代码是用来向树插入一个新键的算法的第一部分： 12345678this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125;&#125;; 要向树中插入一个新的节点（或项），要经历三个步骤。 第一步是创建用来表示新节点的Node类实例（行{1}）。只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针的值会由构造函数自动设置为null。 第二步要验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点（行{2}）。如果是，就将根节点指向新节点 第三步是将节点加在非根节点的其他位置。这种情况下，需要一个私有的辅助函数（行{3}），函数定义如下： 123456789101112131415var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125;&#125;; 如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入树的根节点和要插入的节点。 如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}），那么需要检查当前节点的左侧子节点。如果它没有左侧子节点（行{5}），就在那里插入新的节点。 如果有左侧子节点，需要通过递归调用insertNode方法（行{7}）继续找到树的下一层。在这里，下次将要比较的节点将会是当前节点的左侧子节点。 如果节点的键比当前节点的键大，同时当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。如果有右侧子节点，同样需要递归调用insertNode方法，但是要用来和新节点比较的节点将会是右侧子节点。 让我们通过一个例子来更好地理解这个过程。 考虑下面的情景：我们有一个新的树，并且想要向它插入第一个值。 12var tree = new BinarySearchTree();tree.insert(11); 这种情况下，树中有一个单独的节点，根指针将会指向它。源代码的行{2}将会执行。 现在，来考虑下图所示树结构的情况： 创建上图所示的树的代码如下，它们接着上面一段代码（插入了键为11的节点）之后输入执行： 12345678910111213tree.insert(7);tree.insert(15);tree.insert(5);tree.insert(3);tree.insert(9);tree.insert(8);tree.insert(10);tree.insert(13);tree.insert(12);tree.insert(14);tree.insert(20);tree.insert(18);tree.insert(25); 同时我们想要插入一个值为6的键，执行下面的代码： tree.insert(6); 下面的步骤将会被执行。 树不是空的，行{3}的代码将会执行。insertNode方法将会被调用（root, key[6]）。 算法将会检测行{4}（key[6] &lt; root[11]为真），并继续检测行{5}（node.left[7]不是null），然后将到达行{7}并调用insertNode（node.left[7], key[6]）。 将再次进入insertNode方法内部，但是使用了不同的参数。它会再次检测行{4}（key[6]&lt; node[7]为真），然后再检测行{5}（node.left[5]不是null），接着到达行{7}，调用insertNode（node.left[5], key[6]）。 将再一次进入insertNode方法内部。它会再次检测行{4}（key[6] &lt; node[5]为假），然后到达行{8}（node.right是null 然后，方法调用会依次出栈，代码执行过程结束 这是插入键6后的结果： 四、树的遍历遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做呢？应该从树的顶端还是底端开始呢？从左开始还是从右开始呢？访问树的所有节点有三种方式：中序、先序和后序。 4.1 中序遍历中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。我们来看它的实现： 123this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback); //&#123;1&#125;&#125;; inOrderTraverse方法接收一个回调函数作为参数。回调函数用来定义我们对遍历到的每个节点进行的操作（这也叫作访问者模式，要了解更多关于访问者模式的信息，请参考http://en.wikipedia.org/wiki/Visitor_pattern）。由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）。 1234567var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125;&#125;; 要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为null（这就是停止递归继续执行的判断条件——行{2}——递归算法的基本条件）。 然后，递归调用相同的函数来访问左侧子节点（行{3}）。接着对这个节点进行一些操作（callback），然后再访问右侧子节点（行{5}）。 我们试着在之前展示的树上执行下面的方法： 1234function printNode(value)&#123; //&#123;6&#125; console.log(value);&#125;tree.inOrderTraverse(printNode); //&#123;7&#125; 但首先，需要创建一个回调函数（行{6}）。我们要做的，是在浏览器的控制台上输出节点的值。然后，调用inOrderTraverse方法并将回调函数作为参数传入（行{7}）。当执行上面的代码后，下面的结果将会在控制台上输出（每个数字将会输出在不同的行）： 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25 完整案例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//创建 BinarySearchTree 类function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125; //私有的辅助函数 var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125; &#125;; //insert向树中插入一个键 this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125; &#125;; //inOrderTraverse中序遍历 this.inOrderTraverse = function (callback) &#123; // console.log(callback) inOrderTraverseNode(root, callback); //&#123;1&#125; &#125;; var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125; &#125;; // tree.inOrderTraverse(printNode); //&#123;7&#125; &#125; let binarySearchTree = new BinarySearchTree();function printNode(value) &#123; //&#123;6&#125; console.log(value);&#125;binarySearchTree.insert(7);binarySearchTree.insert(15);binarySearchTree.insert(5);binarySearchTree.insert(3);binarySearchTree.insert(9);binarySearchTree.insert(8);binarySearchTree.insert(10);binarySearchTree.insert(13);binarySearchTree.insert(12);binarySearchTree.insert(14);binarySearchTree.insert(20);binarySearchTree.insert(18);binarySearchTree.insert(25); binarySearchTree.insert(6); binarySearchTree.inOrderTraverse(printNode) 下面的图描绘了inOrderTraverse方法的访问路径： 4.2 先序遍历先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。 我们来看实现: 1234567891011this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback);&#125;; //preOrderTraverseNode方法的实现如下：var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key); //&#123;1&#125; preOrderTraverseNode(node.left, callback); //&#123;2&#125; preOrderTraverseNode(node.right, callback); //&#123;3&#125; &#125;&#125;; 先序遍历和中序遍历的不同点是，先序遍历会先访问节点本身（行{1}），然后再访问它的左侧子节点（行{2}），最后是右侧子节点（行{3}），而中序遍历的执行顺序是：{2}、{1}和{3}。 下面是控制台上的输出结果（每个数字将会输出在不同的行）： 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25 下面的图描绘了preOrderTraverse方法的访问路径： 4.3 后序遍历后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。 我们来看它的实现： 1234567891011this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback);&#125;;//postOrderTraverseNode方法的实现如下：var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); //&#123;1&#125; postOrderTraverseNode(node.right, callback); //&#123;2&#125; callback(node.key); //&#123;3&#125; &#125;&#125;; 这个例子中，后序遍历会先访问左侧子节点（行{1}），然后是右侧子节点（行{2}），最后是父节点本身（行{3}）。 你会发现，中序、先序和后序遍历的实现方式是很相似的，唯一不同的是行{1}、{2}和{3}的执行顺序。 下面是控制台的输出结果（每个数字将会输出在不同行）： 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11 下面的图描绘了postOrderTraverse方法的访问路径： 五、搜索树中的值在树中，有三种经常执行的搜索类型： 搜索最小值搜索最大值搜索特定的值 5.1 搜索最小值和最大值我们使用下面的树作为示例： 只用眼睛看这张图，你能一下找到树中的最小值和最大值吗？ 如果你看一眼树最后一层最左侧的节点，会发现它的值为3，这是这棵树中最小的键。如果你再看一眼树最右端的节点（同样是树的最后一层），会发现它的值为25，这是这棵树中最大的键。这条信息在我们实现搜索树节点的最小值和最大值的方法时能给予我们很大的帮助。 首先，我们来看寻找树的最小键的方法： 123this.min = function() &#123; return minNode(root);&#125; min方法将会暴露给用户。这个方法调用了minNode方法（行{1}）： 123456789var minNode = function(node) &#123; if(node) &#123; while(node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node.key; &#125; return null;&#125; minNode方法允许我们从树中任意一个节点开始寻找最小的键。我们可以使用它来找到一棵树或它的子树中最小的键。因此，我们在调用minNode方法的时候传入树的根节点（行{1}），因为我们想要找到整棵树的最小键。 在minNode内部，我们会遍历树的左边（行{2}和行{3}）直到找到树的最下层（最左端）。 以相似的方式，可以实现max方法： 1234567891011121314this.max = function() &#123; return maxNode(root);&#125;//maxNode方法实现var maxNode = function(node) &#123; if(node) &#123; while(node &amp;&amp; node.right !== null) &#123; node = node.right; &#125; return node.key; &#125; return null;&#125; 要找到最大的键，我们要沿着树的右边进行遍历（行{5}）直到找到最右端的节点。 因此，对于寻找最小值，总是沿着树的左边；而对于寻找最大值，总是沿着树的右边。 5.2 搜索一个特定的值在之前的学习中，我们同样实现了find、search或get方法来查找数据结构中的一个特定的值（和之前实现的has方法相似）。我们将同样在BST中实现搜索的方法，来看它的实现： 123456789101112131415this.search = function (key) &#123; return searchNode(root, key); //&#123;1&#125;&#125;;var searchNode = function (node, key) &#123; if (node === null) &#123; //&#123;2&#125; return false; &#125; if (key &lt; node.key) &#123; //&#123;3&#125; return searchNode(node.left, key); //&#123;4&#125; &#125; else if (key &gt; node.key) &#123; //&#123;5&#125; return searchNode(node.right, key); //&#123;6&#125; &#125; else &#123; return true; //&#123;7&#125; &#125;&#125;; 我们要做的第一件事，是声明search方法。和BST中声明的其他方法的模式相同，我们将会使用一个辅助函数（行{1}）。 searchNode方法可以用来寻找一棵树或它的任意子树中的一个特定的值。这也是为什么在行{1}中调用它的时候传入树的根节点作为参数。 在开始算法之前，先要验证作为参数传入的node是否合法（不是null）。如果是null的话，说明要找的键没有找到，返回false。 如果传入的节点不是null，需要继续验证。如果要找的键比当前的节点小（行{3}），那么继续在左侧的子树上搜索（行{4}）。如果要找的键比当前的节点大，那么就从右侧子节点开始继续搜索（行{6}），否则就说明要找的键和当前节点的键相等，就返回true来表示找到了这个键（行{7}）。 可以通过下面的代码来测试这个方法： console.log(binarySearchTree.search(1) ? ‘Key 1 found.’ : ‘Key 1 not found.’);console.log(binarySearchTree.search(8) ? ‘Key 8 found.’ : ‘Key 8 not found.’); 输出结果如下： Value 1 not found.Value 8 found. 让我们详细展示查找1这个键的时候方法是如何执行的。 (1) 调用searchNode方法，传入根节点作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们执行到行{3}。(2) （key[1] &lt; node[11]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[7], key[1]）作为参数。(3) （node[7]）不是null（{2}），因此继续执行行{3}。(4) （key[1] &lt; node[7]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[5], key[1]）作为参数。(5) （node[5]）不是null（行{2}），因此继续执行行{3}。(6) （key[1] &lt; node[5]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[3], key[1]）作为参数。(7) （node[3]）不是null（行{2}），因此来到行{3}。(8) （key[1] &lt; node[3]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（null, key[1]）作为参数。null被作为参数传入是因为node[3]是一个叶节点（它没有子节点，所以它的左侧子节点的值为null）。(9) 节点（null）的值为null（行{2}，这时要搜索的节点为null），因此返回false。(10) 然后，方法调用会依次出栈，代码执行过程结束。 让我们再来查找值为8的节点。 (1) 调用searchNode方法，传入root作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们来到行{3}。(2) （key[8] &lt; node[11]）为真（行{3}），因此执行到行{4}并再次调用searchNode方法，传入（node[7], key[8]）作为参数。(3) （node[7]）不是null，因此来到行{3}。(4) （key[8] &lt; node[7]）为假（行{3}），因此来到行{5}。(5) （key[8] &gt; node[7]）为真（行{5}），因此来到行{6}并再次调用searchNode方法，传入（node[9], key[8]）作为参数。(6) （node[9]）不是null（行{2}），因此来到行{3}。(7) （key[8] &lt; node[9]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[8], key[8]）作为参数。(8) （node[8]）不是null（行{2}），因此来到行{3}。(9) （key[8] &lt; node[8]）为假（行{3}），因此来到行{5}。(10)（key[8] &gt; node[8]）为假（行{5}），因此来到行{7}并返回true，因为node[8]就是要找的键。(11) 然后，方法调用会依次出栈，代码执行过程结束。 5.3 移除一个节点我们要为BST实现的下一个、也是最后一个方法是remove方法。这是我们在本书中要实现的最复杂的方法。我们先创建这个方法，使它能够在树的实例上被调用： 123this.remove = function(key)&#123; root = removeNode(root, key); //&#123;1&#125; &#125;; 这个方法接收要移除的键并且它调用了removeNode方法，传入root和要移除的键作为参数（行{1}）。我要提醒大家的一件非常重要的事情是，root被赋值为removeNode方法的返回值。我们稍后会明白其中的原因。 removeNode方法的复杂之处在于我们要处理不同的运行场景，当然也包括它同样是通过递归来实现的。 我们来看removeNode方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940this.remove = function (key) &#123; root = removeNode(root, key); //&#123;1&#125; &#125;; var removeNode = function (node, key) &#123; if (node === null) &#123; //&#123;2&#125; return null; &#125; if (key &lt; node.key) &#123; //&#123;3&#125; node.left = removeNode(node.left, key); //&#123;4&#125; return node; //&#123;5&#125; &#125; else if (key &gt; node.key) &#123; //&#123;6&#125; node.right = removeNode(node.right, key); //&#123;7&#125; return node; //&#123;8&#125; &#125; else &#123; //键等于node.key //第一种情况——一个叶节点 if (node.left === null &amp;&amp; node.right === null) &#123; //&#123;9&#125; node = null; //&#123;10&#125; return node; //&#123;11&#125; &#125; //第二种情况——一个只有一个子节点的节点 if (node.left === null) &#123; //&#123;12&#125; node = node.right; //&#123;13&#125; return node; //&#123;14&#125; &#125; else if (node.right === null) &#123; //&#123;15&#125; node = node.left; //&#123;16&#125; return node; //&#123;17&#125; &#125; //第三种情况——一个有两个子节点的节点 var aux = findMinNode(node.right); //&#123;18&#125; node.key = aux.key; //&#123;19&#125; node.right = removeNode(node.right, aux.key); //&#123;20&#125; return node; //&#123;21&#125; &#125; var findMinNode = function (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node; &#125;; &#125;; 我们来看行{2}，如果正在检测的节点是null，那么说明键不存在于树中，所以返回null。 然后，我们要做的第一件事，就是在树中找到要移除的节点。因此，如果要找的键比当前节点的值小（行{3}），就沿着树的左边找到下一个节点（行{4}）。如果要找的键比当前节点的值大（行{6}），那么就沿着树的右边找到下一个节点（行{7}）。 如果我们找到了要找的键（键和node.key相等），就需要处理三种不同的情况。 5.3.1第一种情况是该节点是一个没有左侧或右侧子节点的叶节点——行{9}。在这种情况下，我们要做的就是给这个节点赋予null值来移除它（行{9}）。但是当学习了链表的实现之后，我们知道仅仅赋一个null值是不够的，还需要处理指针。在这里，这个节点没有任何子节点，但是它有一个父节点，需要通过返回null来将对应的父节点指针赋予null值（行{11}）。 现在节点的值已经是null了，父节点指向它的指针也会接收到这个值，这也是我们要在函数中返回节点的值的原因。父节点总是会接收到函数的返回值。另一种可行的办法是将父节点和节点本身都作为参数传入方法内部。 如果回头来看方法的第一行代码，会发现我们在行{4}和行{7}更新了节点左右指针的值，同样也在行{5}和行{8}返回了更新后的节点。 下图展现了移除一个叶节点的过程： 5.3.2 移除有一个左侧或右侧子节点的节点现在我们来看第二种情况，移除有一个左侧子节点或右侧子节点的节点。这种情况下，需要跳过这个节点，直接将父节点指向它的指针指向子节点。如果这个节点没有左侧子节点（行{12}），也就是说它有一个右侧子节点。因此我们把对它的引用改为对它右侧子节点的引用（行{13}）并返回更新后的节点（行{14}）。如果这个节点没有右侧子节点，也是一样——把对它的引用改为对它左侧子节点的引用（行{16}）并返回更新后的值（行{17}）。 下图展现了移除只有一个左侧子节点或右侧子节点的节点的过程： 5.3.3 移除有两个子节点的节点现在是第三种情况，也是最复杂的情况，那就是要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。 (1) 当找到了需要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们改变了这个节点的键，也就是说它被移除了。(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。 findMinNode方法的实现和min方法的实现方式是一样的。唯一不同之处在于，在min方法中只返回键，而在findMinNode中返回了节点。 下图展现了移除有两个子节点的节点的过程： 六、 自平衡树BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层，如下图所示： 这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作Adelson-Velskii-Landi树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树。 6.1 Adelson-Velskii-Landi 树（AVL 树）AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1。添加或移除节点时，AVL树会尽可能尝试转换为完全树。 6.1.1 在AVL树中插入节点在AVL树中插入或移除节点和BST完全相同。然而，AVL树的不同之处在于我们需要检验它的平衡因子，如果有需要，则将其逻辑应用于树的自平衡。 下面的代码是向AVL树插入新节点的例子： 12345678910111213141516var insertNode = function(node, element) &#123; if (node === null) &#123; node = new Node(element); &#125; else if (element &lt; node.key) &#123; node.left = insertNode(node.left, element); if (node.left !== null) &#123; // 确认是否需要平衡 &#123;1&#125; &#125; &#125; else if (element &gt; node.key) &#123; node.right = insertNode(node.right, element); if (node.right !== null) &#123; // 确认是否需要平衡 &#123;2&#125; &#125; &#125; return node;&#125;; 然而，插入新节点时，还要检查是否需要平衡树（行{1}和行{2}） 计算平衡因子 在AVL树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）的差值，该值（hr－hl）应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。这就是平衡因子的概念。 下图举例说明了一些树的平衡因子（所有的树都是平衡的）： 计算节点高度的代码如下： 1234567var heightNode = function(node) &#123; if (node === null) &#123; return -1; &#125; else &#123; return Math.max(heightNode(node.left),heightNode(node.right)) + 1; &#125;&#125;; 因此，向左子树插入新节点时，需要计算其高度；如果高度大于1（即不为-1、0和1之一），就需要平衡左子树。代码如下： 12345678910// 替换insertNode方法的行&#123;1&#125;if ((heightNode(node.left) - heightNode(node.right)) &gt; 1) &#123; // 旋转 &#123;3&#125;&#125;//向右子树插入新节点时，应用同样的逻辑，代码如下：// 替换insertNode方法的行&#123;2&#125;if ((heightNode(node.right) - heightNode(node.left)) &gt; 1) &#123; // 旋转 &#123;4&#125;&#125; AVL旋转 向AVL树插入节点时，可以执行单旋转或双旋转两种平衡操作，分别对应四种场景。 右-右（RR）：向左的单旋转左-左（LL）：向右的单旋转左-右（LR）：向右的双旋转右-左（RL）：向左的双旋转 我们依次看看它们是如何工作的。 右-右（RR）：向左的单旋转 如下图所示： 假设向AVL树插入节点90，这会造成树失衡（节点50-Y高度为-2），因此需要恢复树的平衡。下面是我们执行的操作： 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为-2）所在的位置（行{1}）；节点X的右子树保持不变；将节点Y的右子节点置为节点X的左子节点Z（行{2}）；将节点X的左子节点置为节点Y（行{3}）。 下面的代码举例说明了整个过程： 123456var rotationRR = function(node) &#123; var tmp = node.right; // &#123;1&#125; node.right = tmp.left; // &#123;2&#125; tmp.left = node; // &#123;3&#125; return tmp;&#125;; 左-左（LL）：向右的单旋转 如下图所示： 假设向AVL树插入节点5，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作： 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为+2）所在的位置（行{1}）；节点X的左子树保持不变；将节点Y的左子节点置为节点X的右子节点Z（行{2}）；将节点X的右子节点置为节点Y（行{3}）。 下面的代码举例说明了整个过程： 123456var rotationLL = function(node) &#123; var tmp = node.left; // &#123;1&#125; node.left = tmp.right; // &#123;2&#125; tmp.right = node; // &#123;3&#125; return tmp;&#125;; 左-右（LR）：向右的双旋转 如下图所示： 假设向AVL树插入节点35，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作： 将节点X置于节点Y（平衡因子为+2）所在的位置；将节点Y的左子节点置为节点X的右子节点；将节点Z的右子节点置为节点X的左子节点；将节点X的右子节点置为节点Y；将节点X的左子节点置为节点Z。 基本上，就是先做一次RR旋转，再做一次LL旋转 下面的代码举例说明了整个过程： 1234var rotationLR = function(node) &#123; node.left = rotationRR(node.left); return rotationLL(node);&#125;; 右-左（RL）：向左的双旋转 如下图所示： 假设向AVL树插入节点75，这会造成树失衡（节点70-Y高度为-2），需要恢复树的平衡。下面是我们执行的操作： 将节点X置于节点Y（平衡因子为-2）所在的位置；将节点Z的左子节点置为节点X的右子节点；将节点Y的右子节点置为节点X的左子节点；将节点X的左子节点置为节点Y；将节点X的右子节点置为节点Z。 基本上，就是先做一次LL旋转，再做一次RR旋转 下面的代码举例说明了整个过程： 1234var rotationRL = function(node) &#123; node.right = rotationLL(node.right); return rotationRR(node);&#125;; 完成insertNode方法 确认树需要平衡后，就需要对每种情况分别应用正确的旋转。 向左子树插入新节点，且节点的值小于其左子节点时，应进行LL旋转。否则，进行LR旋转。该过程的代码如下： 123456789// 替换insertNode方法的行&#123;1&#125;if ((heightNode(node.left) - heightNode(node.right)) &gt; 1)&#123; // 旋转 &#123;3&#125; if (element &lt; node.left.key)&#123; node = rotationLL(node); &#125; else &#123; node = rotationLR(node); &#125;&#125; 向右子树插入新节点，且节点的值大于其右子节点时，应进行RR旋转。否则，进行RL旋转。该过程的代码如下： 123456789// 替换insertNode方法的行&#123;2&#125;if ((heightNode(node.right) - heightNode(node.left)) &gt; 1)&#123; // 旋转 &#123;4&#125; if (element &gt; node.right.key)&#123; node = rotationRR(node); &#125; else &#123; node = rotationRL(node); &#125;&#125; 七、 小结在本节中，我们学习了在计算机科学中被广泛使用的基本树数据结构——二叉搜索树中添加、搜索和移除项的算法。我们同样介绍了访问树中每个节点的三种遍历方式。此外还学习了如何开发名叫AVL的自平衡树。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法七（字典和散列表）","date":"2019-01-18T11:40:59.000Z","path":"2019/01/18/cjxe4h6pi001d6supkdj324f5/","text":"字典和散也是用来存储唯一值（不重复的值）的数据结构。 集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。 一、 字典前面已经学习过，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。 1.1 创建字典首先创建Dictionary类的骨架： 123function Dictionary() &#123; var items = &#123;&#125;;&#125; 与Set类类似，我们将在一个Object的实例而不是数组中存储元素。然后，我们需要声明一些映射/字典所能使用的方法。 set(key,value)：向字典中添加新元素。delete(key)：通过使用键值来从字典中移除键值对应的数据值。has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。get(key)：通过键值查找特定的数值并返回。clear()：将这个字典中的所有元素全部删除。size()：返回字典所包含元素的数量。与数组的length属性类似。keys()：将字典所包含的所有键名以数组形式返回。values()：将字典所包含的所有数值以数组形式返回。 1.1.1 has 和 set 方法我们首先来实现has(key)方法。之所以要先实现这个方法，是因为它会被set和remove等其他方法调用。我们可以通过如下代码来实现： 123this.has = function(key) &#123; return key in items;&#125;; 这个方法的实现和我们之前在Set类中的实现是一样的。我们使用JavaScript中的in操作符来验证一个key是否是items对象的一个属性。 然后是set方法的实现： 123this.set = function(key, value) &#123; items[key] = value; //&#123;1&#125;&#125;; 该方法接受一个key和一个value作为参数。我们直接将value设为items对象的key属性的值。它可以用来给字典添加一个新的值，或者用来更新一个已有的值。 1.1.2 delete方法接下来，我们实现delete方法。它和Set类中的delete方法很相似，唯一的不同点在于我们将先搜索key（而不是value）： 1234567this.delete= function(key) &#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false;&#125;; 然后我们可以使用JavaScript的delete操作符来从items对象中移除key属性。 1.1.3 get和values方法如果我们想在字典中查找一个特定的项，并检索它的值，可以使用下面的方法： 123this.get = function(key) &#123; return this.has(key) ? items[key] : undefined;&#125;; get方法首先会验证我们想要检索的值是否存在（通过查找key值），如果存在，将返回该值，反之将返回一个undefined值（请记住undefined值和null值是不一样的 下一个是values方法。这个方法以数组的形式返回字典中所有values实例的值： 123456789this.values = function() &#123; let values = []; for(var key in items) &#123; //&#123;1&#125; if(this.has(key)) &#123; values.push(items[key]) //&#123;2&#125; &#125; &#125; return values&#125; 首先，我们遍历items对象的所有属性值（行{1}）。为了确定值存在，我们使用has函数来验证key确实存在，然后将它的值加入values数组（行{2}）。最后，我们就能返回所有找到的值。 我们不能仅仅使用for-in语句来遍历items对象的所有属性，还需要使用hasOwnProperty方法（验证items对象是否包含某个属性），因为对象的原型也会包含对象的其他属性（JavaScript基本的Object类中的属性将会被继承，并存在于当前对象中，而对于这个数据结构来说，我们并不需要它们）。 1.1.4 clear、size、keys和getItems方法clear和size 方法与前面介绍的Set类中对应的方法是完全一样的。 keys方法返回在Dictionary类中所有用于标识值的键名。要取出一个JavaScript对象中所有的键名，可以把这个对象作为参数传入Object类的keys方法（到目前为止，书中创建的类，包括Dictionary在内，都是JavaScript对象），如下： 123this.keys = function() &#123; return object.keys(items)&#125; 最后，我们来验证items属性的输出值。我们可以实现一个返回items变量的方法，叫作getItems： 123this.getItems = function() &#123; return items;&#125; 1.1.5 使用Dictionary首先，我们来创建一个Dictionary类的实例，然后给它添加三条电子邮件地址。我们将会使用这个dictionary实例来实现一个电子邮件地址簿。 使用我们创建的类来执行如下代码： 1234var dictionary = new Dictionary();dictionary.set('Gandalf', 'gandalf@email.com');dictionary.set('John', 'johnsnow@email.com');dictionary.set('Tyrion', 'tyrion@email.com'); 如果执行了如下代码，输出结果将会是true： console.log(dictionary.has(‘Gandalf’)); 下面的代码将会输出3，因为我们向字典实例中添加了三个元素： console.log(dictionary.size()); 现在，执行下面的几行代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.get(‘Tyrion’)); 输出结果分别如下所示： [“Gandalf”, “John”, “Tyrion”][“gandalf@email.com“, “johnsnow@email.com“, “tyrion@email.com“]tyrion@email.com 最后，再执行几行代码： dictionary.delete(‘John’); 再执行下面的代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.getItems()); 输出结果如下所示： [“Gandalf”, “Tyrion”][“gandalf@email.com“, “tyrion@email.com“]Object {Gandalf: “gandalf@email.com“, Tyrion:”tyrion@email.com“} 移除了一个元素后，现在的dictionary实例中只包含两个元素了。 二、 散列表接下来我们会学到HashTable类，也叫HashMap类，它是Dictionary类的一种散列表实现方式。 散列算法的作用是尽可能快地在数据结构中找到一个值。在前面我们已经知道如果要在数据结构中获得一个值（使用get方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址 举个例子，我们继续使用字典中的案例使用电子邮件地址簿。我们将要使用最常见的散列函数——“lose lose”散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。 2.1 创建散列表我们将使用数组来表示我们的数据结构，该数据结构的图表（“lose lose”）所用的非常相似。 和之前一样，我们从搭建类的骨架开始： 123function HashTable() &#123; var table = [];&#125; 然后，给类添加一些方法。我们给每个类实现三个基本方法 put(key,value)：向散列表增加一个新的项（也能更新散列表）。remove(key)：根据键值从散列表中移除值。get(key)：返回根据键值检索到的特定的值。 在实现这三个方法之前，要实现的第一个方法是散列函数，它是HashTable类中的一个私有方法： 1234567var loseloseHashCode = function (key) &#123; var hash = 0; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash += key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 37; //&#123;4&#125;&#125;; 给定一个key参数，我们就能根据组成key的每个字符的ASCII码值的和得到一个数字。所以，首先需要一个变量来存储这个总和（行{1}）。然后，遍历key（行{2}）并将从ASCII表中查到的每个字符对应的ASCII值加到hash变量中（可以使用JavaScript的String类中的charCodeAt方法——行{3}）。最后，返回hash值。为了得到比较小的数值，我们会使用hash值和一个任意数做除法的余数（mod）。 现在，有了散列函数，我们就可以实现put方法了： 12345this.put = function (key, value) &#123; var position = loseloseHashCode(key); //&#123;5&#125; console.log(position + ' - ' + key); //&#123;6&#125; table[position] = value; //&#123;7&#125;&#125;; 首先，根据给定的key，我们需要根据所创建的散列函数计算出它在表中的位置（行{5}）。为了便于展示信息，我们将计算出的位置输出至控制台（行{6}）。由于它不是必需的，我们也可以将这行代码移除。然后要做的，是将value参数添加到用散列函数计算出的对应的位置上。（行{7}）。 从HashTable实例中查找一个值也很简单。为此，我们将会实现一个get方法： 123this.get = function (key) &#123; return table[loseloseHashCode(key)];&#125;; 首先，我们会使用所创建的散列函数来求出给定key所对应的位置。这个函数会返回值的位置，因此我们所要做的就是根据这个位置从数组table中获得这个值。 我们要实现的最后一个方法是remove方法： 123this.remove = function(key) &#123; table[loseloseHashCode(key)] = undefined;&#125;; 要从HashTable实例中移除一个元素，只需要求出元素的位置（可以使用散列函数来获取）并赋值为undefined。 对于HashTable类来说，我们不需要像ArrayList类一样从table数组中将位置也移除。由于元素分布于整个数组范围内，一些位置会没有任何元素占据，并默认为undefined值。我们也不能将位置本身从数组中移除（这会改变其他元素的位置），否则，当下次需要获得或移除一个元素的时候，这个元素会不在我们用散列函数求出的位置上。 2.2 使用 HashTable 类让我们执行一些代码来测试HashTable类: var hash = new HashTable();hash.put(‘Gandalf’, &#39;gandalf@email.com‘);hash.put(‘John’, &#39;johnsnow@email.com‘);hash.put(‘Tyrion’, &#39;tyrion@email.com‘); 执行上述代码，会在控制台中获得如下输出： 19 - Gandalf29 - John16 - Tyrion 下面的图表展现了包含这三个元素的HashTable数据结构： 现在来测试get方法： console.log(hash.get(‘Gandalf’));console.log(hash.get(‘Loiane’)); 获得如下的输出： gandalf@email.comundefined 由于Gandalf是一个在散列表中存在的键，get方法将会返回它的值。而由于Loiane是一个不存在的键，当我们试图在数组中根据位置获取值的时候（一个由散列函数生成的位置），返回值将会是undefined（即不存在）。 然后，我们试试从散列表中移除Gandalf： hash.remove(‘Gandalf’);console.log(hash.get(‘Gandalf’)); 由于Gandalf不再存在于表中，hash.get(‘Gandalf’)方法将会在控制台上给出undefined的输出结果。 2.3 散列表和散列集合散列表和散列映射是一样的，我们学习过这种数据结构了。 在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是散列函数。我们可以重用本章实现HashTable的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。 2.4 处理散列表中的冲突有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。例如，我们看看下面的代码会得到怎样的输出结果： 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 注意，Tyrion和Aaron有相同的散列值（16）。Donnie和Ana有相同的散列值（13），Jonathan、Jamie和Sue有相同的散列值（5），Mindy和Paul也有相同的散列值（32）。 那HashTable实例会怎样呢？执行之前的代码后散列表中会有哪些值呢？ 为了获得结果，我们来实现一个叫作print的辅助方法，它会在控制台上输出HashTable中的值： 1234567this.print = function () &#123; for (var i = 0; i &lt; table.length; ++i) &#123; //&#123;1&#125; if (table[i] !== undefined) &#123; //&#123;2&#125; console.log(i + \": \" + table[i]);//&#123;3&#125; &#125; &#125;&#125;; 现在来使用这个方法： hash.print(); 在控制台上得到如下的输出结果： 12345675: sue @email.com10: nathan@email.com13: ana@email.com16: aaron@email.com19: gandalf@email.com29: johnsnow@email.com32: paul@email.com Jonathan、Jamie和Sue有相同的散列值，也就是5。由于Sue是最后一个被添加的，Sue将是在HashTable实例中占据位置5的元素。首先，Jonathan会占据这个位置，然后Jamie会覆盖它，然后Sue会再次覆盖。这对于其他发生冲突的元素来说也是一样的。 使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接、线性探查和双散列法。在本节中，我们会介绍前两种方法。 2.4.1 分离链接分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。 例如，我们在之前的测试代码中使用分离链接的话，输出结果将会是这样： 在位置5上，将会有包含三个元素的LinkedList实例；在位置13、16和32上，将会有包含两个元素的LinkedList实例；在位置10、19和29上，将会有包含单个元素的LinkedList实例。 对于分离链接和线性探查来说，只需要重写三个方法：put、get和remove。这三个方法在每种技术实现中都是不同的。 为了实现一个使用了分离链接的HashTable实例，我们需要一个新的辅助类来表示将要加入LinkedList实例的元素。我们管它叫ValuePair类（在HashTable类内部定义）： 1234567var ValuePair = function (key, value) &#123; this.key = key; this.value = value; this.toString = function () &#123; return '[' + this.key + ' - ' + this.value + ']'; &#125;&#125;; 这个类只会将key和value存储在一个Object实例中。我们也重写了toString方法，以便之后在浏览器控制台中输出结果。 put方法 我们来实现第一个方法，put方法，代码如下： 1234567this.put = function (key, value) &#123; var position = loseloseHashCode(key); if (table[position] == undefined) &#123; //&#123;1&#125; table[position] = new LinkedList(); &#125; table[position].append(new ValuePair(key, value)); //&#123;2&#125;&#125;; 在这个方法中，将验证要加入新元素的位置是否已经被占据（行{1}）。如果这个位置是第一次被加入元素，我们会在这个位置上初始化一个LinkedList类的实例（你已经在第5章中学习过）。然后，使用第5章中实现的append方法向LinkedList实例中添加一个ValuePair实例（键和值）（行{2}）。 (2) get方法 然后，我们实现用来获取特定值的get方法： 123456789101112131415161718this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;3&#125; //遍历链表来寻找键/值 var current = table[position].getHead(); //&#123;4&#125; while (current.next) &#123; //&#123;5&#125; if (current.element.key === key) &#123; //&#123;6&#125; return current.element.value; //&#123;7&#125; &#125; current = current.next; //&#123;8&#125; &#125; //检查元素在链表第一个或最后一个节点的情况 if (current.element.key === key) &#123; //&#123;9&#125; return current.element.value; &#125; &#125; return undefined; //&#123;10&#125;&#125;; 我们要做的第一个验证，是确定在特定的位置上是否有元素存在（行{3}）。如果没有，则返回一个undefined表示在HashTable实例中没有找到这个值（行{10}）。如果在这个位置上有值存在，我们知道这是一个LinkedList实例。现在要做的是遍历这个链表来寻找我们需要的元素。在遍历之前先要获取链表表头的引用（行{4}），然后就可以从链表的头部遍历到尾部（行{5}，current.next将会是null）。 Node链表包含next指针和element属性。而element属性又是ValuePair的实例，所以它又有value和key属性。可以通过current.element.key来获得Node链表的key属性，并通过比较它来确定它是否就是我们要找的键（行{6}）。（这就是要使用ValuePair这个辅助类来存储元素的原因。我们不能简单地存储值本身，这样就不能确定哪个值对应着特定的键。）如果key值相同，就返回Node的值（行{7}）；如果不相同，就继续遍历链表，访问下一个节点（行{8}）。 如果要找的元素是链表的第一个或最后一个节点，那么就不会进入while循环的内部。因此，需要在行{9}处理这种特殊的情况 remove方法 使用分离链接法从HashTable实例中移除一个元素和之前在本章实现的remove方法有一些不同。现在使用的是链表，我们需要从链表中移除一个元素。来看看remove方法的实现： 12345678910111213141516171819202122232425this.remove = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; var current = table[position].getHead(); while (current.next) &#123; if (current.element.key === key) &#123; //&#123;11&#125; table[position].remove(current.element); //&#123;12&#125; if (table[position].isEmpty()) &#123; //&#123;13&#125; table[position] = undefined; //&#123;14&#125; &#125; return true; //&#123;15&#125; &#125; current = current.next; &#125; // 检查是否为第一个或最后一个元素 if (current.element.key === key) &#123; //&#123;16&#125; table[position].remove(current.element); if (table[position].isEmpty()) &#123; table[position] = undefined; &#125; return true; &#125; &#125; return false; //&#123;17&#125;&#125;; 在remove方法中，我们使用和get方法一样的步骤找到要找的元素。遍历LinkedList实例时，如果链表中的current元素就是要找的元素（行{11}），使用remove方法将其从链表中移除。然后进行一步额外的验证：如果链表为空了（行{13}——链表中不再有任何元素了），就将散列表这个位置的值设为undefined（行{14}），这样搜索一个元素或打印它的内容的时候，就可以跳过这个位置了。最后，返回true表示这个元素已经被移除（行{15}）或者在最后返回false表示这个元素在散列表中不存在（行{17}）。同样，需要和get方法一样，处理元素在第一个或最后一个的情况（行{16}）。 重写了这三个方法后，我们就拥有了一个使用了分离链接法来处理冲突的HashMap实例。 2.4.1 线性探查另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推 然后重写put、get、remove方法 put方法 123456789101112this.put = function (key, value) &#123; var position = loseloseHashCode(key); // &#123;1&#125; if (table[position] == undefined) &#123; // &#123;2&#125; table[position] = new ValuePair(key, value); // &#123;3&#125; &#125; else &#123; var index = ++position; // &#123;4&#125; while (table[index] != undefined) &#123; // &#123;5&#125; index++; // &#123;6&#125; &#125; table[index] = new ValuePair(key, value); // &#123;7&#125; &#125;&#125;; 和之前一样，先获得由散列函数生成的位置（行{1}），然后验证这个位置是否有元素存在（如果这个位置被占据了，将会通过行{2}的验证）。如果没有元素存在，就在这个位置加入新元素（行{3}——一个ValuePair的实例）。 如果这个位置已经被占据了，需要找到下一个没有被占据的位置（position的值是undefined），因此我们声明一个index变量并赋值为position+1（行{4}——在变量名前使用自增运算符++会先递增变量值然后再将其赋值给index）。然后验证这个位置是否被占据（行{5}），如果被占据了，继续将index递增（行{6}），直到找到一个没有被占据的位置。然后要做的，就是将值分配到这个位置（行{7}）。 如果再次执行插入数据的代码: 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 下图展示使用了线性探查的散列表的最终结果： 让我们来模拟一下散列表中的插入操作。 (1) 试着插入Gandalf。它的散列值是19，由于散列表刚刚被创建，位置19还是空的——可以在这里插入数据。(2) 试着在位置29插入John。它也是空的，所以可以插入这个姓名。(3) 试着在位置16插入Tyrion。它是空的，所以可以插入这个姓名。(4) 试着插入Aaron，它的散列值也是16。位置16已经被Tyrion占据了，所以需要检查索引值为position+1的位置（16+1）。位置17是空的，所以可以在位置17插入Aaron。(5) 接着，试着在位置13插入Donnie。它是空的，所以可以插入这个姓名。(6) 想在位置13插入Ana，但是这个位置被占据了。因此在位置14进行尝试，它是空的，所以可以在这里插入姓名。(7) 然后，在位置5插入Jonathan，这个位置是空的，所以可以插入这个姓名。(8) 试着在位置5插入Jamie，但是这个位置被占了。所以跳至位置6，这个位置是空的，因此可以在这个位置插入姓名。(9) 试着在位置5插入Sue，但是位置被占据了。所以跳至位置6，但也被占了。接着跳至位置7，这里是空的，所以可以在这里插入姓名。以此类推。 get方法 现在插入了所有的元素，让我们实现get方法来获取它们的值吧： 1234567891011121314151617this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;8&#125; if (table[position].key === key) &#123; //&#123;9&#125; return table[position].value; //&#123;10&#125; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key) &#123; //&#123;11&#125; index++; &#125; if (table[index].key === key) &#123; //&#123;12&#125; return table[index].value; //&#123;13&#125; &#125; &#125; &#125; return undefined; //&#123;14&#125; &#125;; 要获得一个键对应的值，先要确定这个键存在（行{8}）。如果这个键不存在，说明要查找的值不在散列表中，因此可以返回undefined（行{14}）。如果这个键存在，需要检查我们要找的值是否就是这个位置上的值（行{9}）。如果是，就返回这个值（行{10}）。 如果不是，就在散列表中的下一个位置继续查找，直到找到一个键值与我们要找的键值相同的元素（行{11}）。然后，验证一下当前项就是我们要找的项（行{12}——只是为了确认一下）并且将它的值返回（行{13}）。 我们无法确定要找的元素实际上在哪个位置，这就是使用ValuePair来表示HashTable元素的原因。 remove方法 remove方法和get方法基本相同，不同之处在于行{10}和{13}，它们将会由下面的代码代替： table[index] = undefined; 要移除一个元素，只需要给其赋值为undefined，来表示这个位置不再被占据并且可以在必要时接受一个新元素。 2.5 创建更好的散列函数我们实现的“lose lose”散列函数并不是一个表现良好的散列函数，因为它会产生太多的冲突。如果我们使用这个函数的话，会产生各种各样的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。我们可以在网上找到一些不同的实现方法，或者也可以实现自己的散列函数。 另一个可以实现的比“lose lose”更好的散列函数是djb2： 1234567var djb2HashCode = function (key) &#123; var hash = 5381; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 1013; //&#123;4&#125;&#125;; 它包括初始化一个hash变量并赋值为一个质数（行{1}——大多数实现都使用5381），然后迭代参数key（行{2}），将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加（行{3}）。 最后，我们将使用相加的和与另一个随机质数（比我们认为的散列表的大小要大——在本例中，我们认为散列表的大小为1000）相除的余数。 如果再次执行插入数据的代码，这将是使用djb2HashCode代替loseloseHashCode的最终结果： 123456789101112798 - Gandalf838 - John624 - Tyrion215 - Aaron278 - Donnie925 - Ana288 - Jonathan962 - Jamie502 - Sue804 - Mindy54 - Paul223 - Nathan 这并不是最好的散列函数，但这是最受社区推崇的散列函数之一。 三、es6——Map类我们看看原生的Map类怎么用。 还是用我们原来测试Dictionary类的例子： 123456789var map = new Map();map.set('Gandalf', 'gandalf@email.com');map.set('John', 'johnsnow@email.com');map.set('Tyrion', 'tyrion@email.com');console.log(map.has('Gandalf')); //输出trueconsole.log(map.size); //输出3console.log(map.keys()); //输出[\"Gandalf\", \"John\", \"Tyrion\"]console.log(map.values()); //输出[\"gandalf@email.com\", s\"johnsnow@email.com\", \"tyrion@email.com\"]console.log(map.get('Tyrion')); //输出tyrion@email.com 和我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator（第2章提到过），而不是值或键构成的数组。另一个区别是，我们实现的size方法返回字典中存储的值的个数，而ES6的Map类则有一个size属性。 删除map中的元素可以用delete方法： map.delete(‘John’); clear方法会重置map数据结构，这跟我们在Dictionary类里实现的一样。 四、ES6——WeakMap 类和 WeakSet 类除了Set和Map这两种新的数据结构，ES6还增加了它们的弱化版本，WeakSet和WeakMap。 基本上，Map和Set与其弱化版本之间仅有的区别是： WeakSet或WeakMap类没有entries、keys和values等方法； 只能用对象作为键。 创建和使用这两个类主要是为了性能。WeakSet和WeakMap是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。 另一个优点是，必须用键才可以取出值。这些类没有entries、keys和values等迭代器方法，因此，除非你知道键，否则没有办法取出值。这印证了我们在前面的做法，即使用WeakMap类封装ES6类的私有属性。 使用WeakMap类的例子如下： 12345678910var map = new WeakMap();var ob1 = &#123;name:'Gandalf'&#125;, //&#123;1&#125;ob2 = &#123;name:'John'&#125;,ob3 = &#123;name:'Tyrion'&#125;;map.set(ob1, 'gandalf@email.com'); //&#123;2&#125;map.set(ob2, 'johnsnow@email.com');map.set(ob3, 'tyrion@email.com');console.log(map.has(ob1)); //&#123;3&#125; 输出trueconsole.log(map.get(ob3)); //&#123;4&#125; 输出tyrion@email.commap.delete(ob2); //&#123;5&#125; WeakMap类也可以用set方法，但不能使用数字、字符串、布尔值等基本数据类型，需要将名字转换为对象（行{1}和行{2}）。搜索（行{3}）、读取（行{4}）和删除值（行{5}），也要传入作为键的对象。同样的逻辑也适用于WeakSet类。 五、小结在本节中，我们学习了字典的相关知识，了解了如何添加、移除和获取元素以及其他的一些方法。我们还了解了字典和集合的不同之处。 我们也学习了散列运算，怎样创建一个散列表（或者说散列映射）数据结构，如何添加、移除和获取元素，以及如何创建散列函数。我们学习了怎样使用两种不同的方法解决散列表中的冲突问题。 我们还介绍了如何使用ES6的Map、WeakMap和WeakSet类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法六（集合）","date":"2018-12-28T08:10:32.000Z","path":"2018/12/28/cjxe4h6oj00186supg0r4wgjc/","text":"一、构建数据集合集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。 在深入学习集合的计算机科学实现之前，我们先看看它的数学概念。在数学中，集合是一组不同的对象（的集）。 比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6, …}。集合中的对象列表用“{}”（大括号）包围。 还有一个概念叫空集。空集就是不包含任何元素的集合。比如24和29之间的素数集合。由于24和29之间没有素数（除了1和自身，没有其他正因数的大于1的自然数），这个集合就是空集。空集用“{ }”表示。 你也可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。 在数学中，集合也有并集、交集、差集等基本操作。在本片文章中我们也会介绍这些操作 二、创建集合首先创建set类，Set类的骨架如下： 123function Set() &#123; let items = &#123;&#125;;&#125; 有一个非常重要的细节，我们使用对象而不是数组来表示集合（items）。但也可以用数组实现。在这里我们用对象来实现，稍微有点儿不一样，也学习一下实现相似数据结构的新方法。同时，JavaScript的对象不允许一个键指向两个不同的属性，也保证了集合里的元素都是唯一的。 接下来，需要声明一些集合可用的方法（我们会尝试模拟与ECMAScript 6实现相同的Set类）。 add(value)：向集合添加一个新的项。delete(value)：从集合移除一个值。has(value)：如果值在集合中，返回true，否则返回false。clear()：移除集合中的所有项。size()：返回集合所包含元素的数量。与数组的length属性类似。values()：返回一个包含集合中所有值的数组。 2.1 has(value)方法首先要实现的是has(value)方法。这是因为它会被add、remove等其他方法调用。下面看看它的实现： 123this.has = function(value)&#123; return value in items;&#125;; 既然我们使用对象来存储集合的值，就可以用JavaScript的in操作符来验证给定的值是否是items对象的属性。 但这个方法还有更好的实现方式，如下： 123this.has = function(value)&#123; return items.hasOwnProperty(value);&#125;; 所有JavaScript对象都有hasOwnProperty方法。这个方法返回一个表明对象是否具有特定属性的布尔值。 2.2 add方法接下来要实现add方法： 1234567this.add = function(value)&#123; if (!this.has(value))&#123; items[value] = value; //&#123;1&#125; return true; &#125; return false;&#125;; 对于给定的value，可以检查它是否存在于集合中。如果不存在，就把value添加到集合中（行{1}），返回true，表示添加了这个值。如果集合中已经有这个值，就返回false，表示没有添加它。 添加一个值的时候，把它同时作为键和值保存，因为这样有利于查找这个值。 2.3 remove 和 clear 方法下面要实现remove方法： 1234567this.remove = function(value)&#123;if (this.has(value))&#123; delete items[value]; //&#123;2&#125; return true;&#125;return false;&#125;; 在remove方法中，我们会验证给定的value是否存在于集合中。如果存在，就从集合中移除value（行{2}），返回true，表示值被移除；否则返回false。 既然用对象来存储集合的items对象，就可以简单地使用delete操作符从items对象中移除属性（行{2}）。 使用Set类的示例代码如下： 123let set = new Set();set.add(1); //trueset.add(2); //true 如果想移除集合中的所有值，可以用clear方法： 123this.clear = function()&#123; items = &#123;&#125;; // &#123;3&#125;&#125;; 要重置items对象，需要做的只是把一个空对象重新赋值给它（行{3}）。我们也可以迭代集合，用remove方法依次移除所有的值，但既然有更简单的方法，那样做就太麻烦了 2.4 size 方法下一个要实现的是size方法（返回集合中有多少项）。这个方法有三种实现方式。 第一种方法是使用一个length变量，每当使用add或remove方法时控制它，就像在上一章中使用LinkedList类一样。 第二种方法，使用JavaScript内建的Object类的一个内建函数（ECMAScript 5以上版本）： 123this.size = function()&#123; return Object.keys(items).length; //&#123;4&#125;&#125;; JavaScript的Object类有一个keys方法，它返回一个包含给定对象所有属性的数组。在这种情况下，可以使用这个数组的length属性（行{4}）来返回items对象的属性个数。以上代码只能在现代浏览器中运行（比如IE9以上版本、Firefox 4以上版本、Chrome 5以上版本、Opera 12以上版本、Safari 5以上版本，等等）。 第三种方法是手动提取items对象的每一个属性，记录属性的个数并返回这个数字。这个方法可以在任何浏览器上运行，和之前的代码是等价的： 12345678this.sizeLegacy = function()&#123; let count = 0; for(let key in items) &#123; //&#123;5&#125; if(items.hasOwnProperty(key)) //&#123;6&#125; ++count; //&#123;7&#125; &#125; return count;&#125;; 遍历items对象的所有属性（行{5}），检查它们是否是对象自身的属性（避免重复计数——行{6}）。如果是，就递增count变量的值（行{7}），最后在方法结束时返回这个数字。 不能简单地使用for-in语句遍历items对象的属性，并递增count变量的值。还需要使用hasOwnProperty方法（以验证items对象具有该属性），因为对象的原型包含了额外的属性（属性既有继承自JavaScript的Object类的，也有属于对象自身，未用于数据结构的）。 2.5 values 方法values方法也应用了相同的逻辑，提取items对象的所有属性，以数组的形式返回： 123456789this.values = function () &#123; let values = []; for (let key in items) &#123; //&#123;7&#125; if (items.hasOwnProperty(key)) &#123; //&#123;8&#125; values.push(items[key]); &#125; &#125; return values; &#125; 首先遍历items对象的所有属性（行{7}），把它们添加一个数组中（行{8}），并返回这个数组。该方法类似于我们开发的sizeLegacy方法，但我们添加一个数组，而不是计算属性个数。 2.6 使用 Set 类现在数据结构已经完成了，执行Set类的方法，测试我们的Set类： 12345678910111213let set = new Set();set.add(1);console.log(set.values()); //输出[\"1\"]console.log(set.has(1)); //输出trueconsole.log(set.size()); //输出1 set.add(2);console.log(set.values()); //输出[\"1\", \"2\"]console.log(set.has(2)); //trueconsole.log(set.size()); //2set.remove(1);console.log(set.values()); //输出[\"2\"]set.remove(2);console.log(set.values()); //输出[] 三、 集合操作对集合可以进行如下操作。 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。子集：验证一个给定集合是否是另一集合的子集。 3.1 并集并集的数学概念是集合A和集合B的并集，表示为： A∪B 该集合定义如下： A∪B = { x | x ∈ A∨x ∈ B } 意思是x（元素）存在于A中，或x存在于B中。下图展示了并集操作： 现在来实现Set类的union方法： 12345678910111213//union 方法this.union = function (otherSet) &#123; let unionSet = new Set(); //&#123;1&#125; let values = this.values(); //&#123;2&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); //&#123;3&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet;&#125;; 首先需要创建一个新的集合，代表两个集合的并集（行{1}）。接下来，获取第一个集合（当前的Set类实例）所有的值（values），遍历并全部添加到代表并集的集合中（行{2}）。然后对第二个集合做同样的事（行{3}）。最后返回结果。 测试一下上面的代码： 1234567891011let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(3);setB.add(4);setB.add(5);setB.add(6);let unionAB = setA.union(setB);console.log(unionAB.values()); //[1, 2, 3, 4, 5, 6] 输出为[“1”, “2”, “3”, “4”, “5”, “6”]。注意元素3同时存在于A和B中，它在结果的集合中只出现一次。 3.2 交集交集的数学概念是集合A和集合B的交集，表示为： A∩B 该集合定义如下： A∩B = { x | x ∈ A∧x ∈ B } 意思是x（元素）存在于A中，且x存在于B中。下图展示了交集操作： 现在来实现Set类的intersection方法： 12345678910this.intersection = function(otherSet)&#123; let intersectionSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; //&#123;2&#125; if (otherSet.has(values[i]))&#123; //&#123;3&#125; intersectionSet.add(values[i]); //&#123;4&#125; &#125; &#125; return intersectionSet;&#125; intersection方法需要找到当前Set实例中，所有也存在于给定Set实例中的元素。首先创建一个新的Set实例，这样就能用它返回共有的元素（行{1}）。接下来，遍历当前Set实例所有的值（行{2}），验证它们是否也存在于otherSet实例（行{3}）之中。可以用前面实现的has方法来验证元素是否存在于Set实例中。然后，如果这个值也存在于另一个Set实例中，就将其添加到创建的intersectionSet变量中（行{4}），最后返回它。 测试一下intersection方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let intersectionAB = setA.intersection(setB);console.log(intersectionAB.values()); 输出为[“2”, “3”]，因为2和3同时存在于两个集合中。 3.3 差集差集的数学概念是集合A和集合B的差集，表示为：AB，定义如下图： 意思是x（元素）存在于A中，且x不存在于B中。下图展示了集合A和B的差集操作： 现在来实现Set类的difference方法： 12345678910this.difference = function (otherSet) &#123; let differenceSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; differenceSet.add(values[i]); //&#123;4&#125; &#125; &#125; return differenceSet;&#125;; intersection方法会得到所有同时存在于两个集合中的值。而difference方法会得到所有存在于集合A但不存在于B的值。因此这两个方法在实现上唯一的区别就是行{3}。只获取不存在于otherSet实例中的值，而不是也存在于其中的值。行{1}、{2}和{4}是完全相同的。 测试difference方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let differenceAB = setA.difference(setB);console.log(differenceAB.values()); 输出为[“1”]，因为1是唯一一个仅存在于setA的元素。 3.4 子集子集的数学概念是集合A是集合B的子集（或集合B包含了A），表示为 A⊆B 该集合定义如下： ∀x { x ∈ A → x ∈ B } 意思是集合A中的每一个x（元素），也需要存在于B中。下图展示了集合A是集合B的子集： 现在来实现Set类的subset方法： 12345678910111213this.subset = function (otherSet) &#123; if (this.size() &gt; otherSet.size()) &#123; //&#123;1&#125; return false; &#125; else &#123; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; return false; //&#123;4&#125; &#125; &#125; return true; //&#123;5&#125; &#125;&#125;; 首先需要验证的是当前Set实例的大小。如果当前实例中的元素比otherSet实例更多，它就不是一个子集（行{1}）。子集的元素个数需要小于或等于要比较的集合。 接下来要遍历集合中的所有元素（行{2}），验证这些元素也存在于otherSet中（行{3}）。如果有任何元素不存在于otherSet中，就意味着它不是一个子集，返回false（行{4}）。如果所有元素都存在于otherSet中，行{4}就不会被执行，那么就返回true（行{5}）。 检验一下上面的代码效果如何： 12345678910111213let setA = new Set();setA.add(1); setA.add(2);let setB = new Set();setB.add(1);setB.add(2);setB.add(3);let setC = new Set();setC.add(2);setC.add(3);setC.add(4);console.log(setA.subset(setB));console.log(setA.subset(setC)); 我们有三个集合：setA是setB的子集（因此输出为true），然而setA不是setC的子集（setC只包含了setA中的2，而不包含1），因此输出为false。 四、 ES6——Set 类我们先看看原生的Set类怎么用。 还是用我们原来测试Set类的例子： 12345let set = new Set();set.add(1);console.log(set.values()); // 输出@Iteratorconsole.log(set.has(1)); // 输出trueconsole.log(set.size); // 输出1 和我们的Set不同，ES6的Set的values方法返回Iterator（第2章提到过），而不是值构成的数组。另一个区别是，我们实现的size方法返回set中存储的值的个数，而ES6的Set则有一个size属性。 可以用delete方法删除set中的元素： set.delete(1); clear方法会重置set数据结构，这跟我们实现的功能一样 4.1 ES6 Set 类的操作我们的Set类实现了并集、交集、差集、子集等数学操作，然而ES6原生的Set并没有这些功能。不过，有需要的话，我们也可以模拟。 我们的例子会用到下面两个集合 12345678let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4); 4.1.1 模拟并集操作我们可以创建一个新的集合，用来添加两个集合中所有的元素（行{1}）。迭代这两个集合（行{2}、行{3}），把所有元素都添加到并集的集合中。代码如下： 123let unionAb = new Set(); //&#123;1&#125;for (let x of setA) unionAb.add(x); //&#123;2&#125;for (let x of setB) unionAb.add(x); //&#123;3&#125; 4.1.2 模拟交集操作模拟交集操作需要创建一个辅助函数，来生成包含setA和setB都有的元素的新集合（行{1}）。代码如下： 12345678910let intersection = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if (setB.has(x)) &#123; //&#123;1&#125; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;;let intersectionAB = intersection(setA, setB); 交集可以用更简单的语法实现，代码如下： intersectionAb = new Set([x for (x of setA) if (setB.has(x))]); 这和intersection函数的效果完全一样。 4.1.3 模拟差集操作交集操作创建的集合包含setA和setB都有的元素，差集操作创建的集合包含的则是setA有而setB没有的元素。看下面的代码： 12345678910let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; //&#123;1&#125; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;;let differenceAB = difference(setA, setB); intersection函数和difference函数只有行{1}不同，因为差集中只添加setA有而setB没有的元素。 差集也可以用更简单的语法实现，代码如下： differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); 目前只有Firefox支持简化的语法，但在所有支持ES6的现代浏览器中都可以执行difference函数 五、小结在这片文章中，我们学习了如何从头实现一个与ECMAScript 6中定义的类似的Set类。我们还介绍了在其他编程语言的集合数据结构的实现中不常见的一些方法，比如并集、交集、差集和子集。因此，相比于其他编程语言目前的Set实现，我们实现了一个非常完备的Set类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法五（链表）","date":"2018-11-18T11:41:53.000Z","path":"2018/11/18/cjxe4h6pj001e6suptiy4xkeg/","text":"一、链表数据结构要存储多个元素，数组（或列表）可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管JavaScript的array类方法做这些事，但背后的情况同样是这样）。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展示了一个链表的结构： 相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。 另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法，就是从起点（第一条线索）顺着列表寻找。 还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或移除它。下图演示了一列火车。每节车皮都是列表的元素，车皮间的连接就是指针： 二、创建链表理解了链表是什么之后，现在就要开始实现我们的数据结构了，以下是我们的LinkedList类的骨架： 123456789101112131415161718function LinkedList() &#123; let Node = function (element) &#123; // &#123;1&#125; this.element = element; this.next = null; &#125;; let length = 0; // &#123;2&#125; let head = null; // &#123;3&#125; this.append = function (element) &#123; &#125;; this.insert = function (position, element) &#123; &#125;; this.removeAt = function (position) &#123; &#125;; this.remove = function (element) &#123; &#125;; this.indexOf = function (element) &#123; &#125;; this.isEmpty = function () &#123; &#125;; this.size = function () &#123; &#125;; this.getHead = function () &#123; &#125;; this.toString = function () &#123; &#125;; this.print = function () &#123; &#125;;&#125; LinkedList数据结构还需要一个Node辅助类（行{1}）。Node类表示要加入列表的项。它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。 LinkedList类也有存储列表项的数量的length属性（内部/私有变量）（行{2}）。 另一个重要的点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在一个称为head的变量中（行{3}） 然后就是LinkedList类的方法。在实现这些方法之前，先来看看它们的职责。 append(element)：向列表尾部添加一个新的项。 insert(position, element)：向列表的特定位置插入一个新的项。 remove(element)：从列表中移除一项。 indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 removeAt(position)：从列表的特定位置移除一项。 isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。 size()：返回链表包含的元素个数。与数组的length属性类似。 toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 2.1 向链表尾部追加元素向LinkedList对象尾部添加一个元素时，可能有两种场景：列表为空，添加的是第一个元素，或者列表不为空，向其追加元素。 下面是我们实现的append方法： 1234567891011121314151617181920212223242526// LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; // this.element = element; this.next = null; &#125;; let length = 0; // let head = null; // //实现LinkedList类的append方法 this.append = function (element) &#123; let node = new Node(element), //&#123;1&#125; current; //&#123;2&#125; if (head === null) &#123; //列表中第一个节点 //&#123;3&#125; head = node; &#125; else &#123; current = head; //&#123;4&#125; //循环列表，直到找到最后一项 while (current.next) &#123; current = current.next; &#125; //找到最后一项，将其next赋为node，建立链接 current.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 //&#123;6&#125; &#125;;&#125; 首先需要做的是把element作为值传入，创建Node项（行{1}）。 先来实现第一个场景：向为空的列表添加一个元素。当我们创建一个LinkedList对象时，head会指向null： 如果head元素为null（列表为空——行{3}），就意味着在向列表添加第一个元素。因此要做的就是让head元素指向node元素。下一个node元素将会自动成为null。 列表最后一个节点的下一个元素始终是null。 再来看看第二个场景，也就是向一个不为空的列表尾部添加元素。 要向列表的尾部添加一个元素，首先需要找到最后一个元素。记住，我们只有第一个元素的引用（行{4}），因此需要循环访问列表，直到找到最后一项。为此，我们需要一个指向列表中current项的变量（行{2}）。 循环访问列表时，当current.next元素为null时，我们就知道已经到达列表尾部了。然后要做的就是让当前（也就是最后一个）元素的next指针指向想要添加到列表的节点（行{5}）。下图展示了这个行为： 而当一个Node元素被创建时，它的next指针总是null。这没问题，因为我们知道它会是列表的最后一项。 当然，别忘了递增列表的长度，这样就能控制它，轻松地得到列表的长度（行{6}）。 我们可以通过以下代码来使用和测试目前创建的数据结构： let list = new LinkedList();list.append(15);list.append(10); 2.2 从链表中移除元素现在，让我们看看如何从LinkedList对象中移除元素。移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种remove方法：第一种是从特定位置移除一个元素，第二种是根据元素的值移除元素。 123456789101112131415161718192021222324252627282930313233//LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; &#125;; let length = 0; let head = null; //实现LinkedList类的append方法 this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; // &#123;1&#125; let current = head, // &#123;2&#125; previous, // &#123;3&#125; index = 0; // &#123;4&#125; //移除第一项 if (position === 0) &#123; // &#123;5&#125; head = current.next; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;6&#125; previous = current; // &#123;7&#125; current = current.next; // &#123;8&#125; &#125; //将previous与current的下一项链接起来：跳过current，从而移除它 previous.next = current.next; // &#123;9&#125; &#125; length--; // &#123;10&#125; return current.element; &#125; else &#123; return null; // &#123;11&#125; &#125; &#125;; &#125; 一步一步来看这段代码。该方法要得到需要移除的元素的位置，就需要验证这个位置是有效的（行{1}）。从0（包括0）到列表的长度（size – 1，因为索引是从零开始的）都是有效的位置。如果不是有效的位置，就返回null（意即没有从列表中移除元素）。 首先为第一种场景编写代码：我们要从列表中移除第一个元素（position === 0——行{5}）。下图展示了这个过程： 因此，如果想移除第一个元素，要做的就是让head指向列表的第二个元素。我们将用current变量创建一个对列表中第一个元素的引用（行{2}——我们还会用它来迭代列表，但稍等一下再说）。这样current变量就是对列表中第一个元素的引用。如果把head赋为current.next，就会移除第一个元素 现在，假设我们要移除列表的最后一项或者中间某一项。为此，需要依靠一个细节来迭代列表，直到到达目标位置（行{6}——我们会使用一个用于内部控制和递增的index变量）：current变量总是为对所循环列表的当前元素的引用（行{8}）。我们还需要一个对当前元素的前一个元素的引用（行{7}）；它被命名为previous（行{3}）。 因此，要从列表中移除当前元素，要做的就是将previous.next和current.next链接起来（行{9}）。这样，当前元素就会被丢弃在计算机内存中，等着被垃圾回收器清除。 我们试着通过一些图表来更好地理解。首先考虑移除最后一个元素： 对于最后一个元素，当我们在行{6}跳出循环时，current变量将是对列表中最后一个元素的引用（要移除的元素）。current.next的值将是null（因为它是最后一个元素）。由于还保留了对previous元素的引用（当前元素的前一个元素），previous.next就指向了current。那么要移除current，要做的就是把previous.next的值改变为current.next。 现在来看看，对于列表中间的元素是否可以应用相同的逻辑： current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。那么要移除current元素，需要做的就是将previous.next与current.next链接起来。因此，我们的逻辑对这两种情况都管用。 2.3 在任意位置插入元素接下来，我们要实现insert方法。使用这个方法可以在任意位置插入一个元素。我们来看一看它的实现： 123456789101112131415161718192021222324this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; //&#123;1&#125; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 node.next = current; //&#123;2&#125; head = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;3&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;4&#125; previous.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; //&#123;6&#125; &#125;&#125;; 由于我们处理的是位置，就需要检查越界值（行{1}，跟removeAt方法类似）。如果越界了，就返回false值，表示没有添加项到列表中（行{6}）。 现在我们要处理不同的场景。第一种场景，需要在列表的起点添加一个元素，也就是第一个位置。下图展示了这种场景： current变量是对列表中第一个元素的引用。我们需要做的是把node.next的值设为current（列表中第一个元素）。现在head和node.next都指向了current。接下来要做的就是把head的引用改为node（行{2}），这样列表中就有了一个新元素。 现在来处理第二种场景：在列表中间或尾部添加一个元素。首先，我们需要循环访问列表，找到目标位置（行{3}）。当跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用，而previous将是对想要插入新元素的位置之前一个元素的引用。在这种情况下，我们要在previous和current之间添加新项。因此，首先需要把新项（node）和当前项链接起来（行{4}），然后需要改变previous和current之间的链接。我们还需要让previous.next指向node（行{5}）。 我们通过一张图表来看看代码所做的事： 如果我们试图向最后一个位置添加一个新元素，previous将是对列表最后一项的引用，而current将是null。在这种情况下，node.next将指向current，而previous.next将指向node，这样列表中就有了一个新的项。 现在来看看如何向列表中间添加一个新元素： 在这种情况下，我们试图将新的项（node）插入到previous和current元素之间。首先，我们需要把node.next的值指向current。然后把previous.next的值设为node。这样列表中就有了一个新的项。 使用变量引用我们需要控制的节点非常重要，这样就不会丢失节点之间的链接。我们可以只使用一个变量（previous），但那样会很难控制节点之间的链接。由于这个原因，最好是声明一个额外的变量来帮助我们处理这些引用。 2.4 实现链表的其他方法2.4.1 toString方法toString方法会把LinkedList对象转换成一个字符串。下面是toString方法的实现： 123456789this.toString = function () &#123; let current = head, //&#123;1&#125; string = ''; //&#123;2&#125; while (current) &#123; //&#123;3&#125; string += current.element + (current.next ? 'n' : '');//&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return string; //&#123;6&#125;&#125;; 首先，要循环访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引（行{1}），控制循环访问列表。我们还需要初始化用于拼接元素值的变量（行{2}）。 接下来就是循环访问列表中的每个元素（行{3}）。我们要用current来检查元素是否存在（如果列表为空，或是到达列表中最后一个元素的下一位（null），while循环中的代码就不会执行）。然后我们就得到了元素的内容，将其拼接到字符串中（行{4}）。最后，继续迭代下一个元素（行{5}）。最后，返回列表内容的字符串（行{6}）。 2.4.2 indexOf方法indexOf方法接收一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回-1。 123456789101112this.indexOf = function(element)&#123; let current = head, //&#123;1&#125; index = -1; while (current) &#123; //&#123;2&#125; if (element === current.element) &#123; return index; //&#123;3&#125; &#125; index++; //&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return -1;&#125;; 一如既往，我们需要一个变量来帮助我们循环访问列表，这个变量是current，它的初始值是head（列表的第一个元素——我们还需要一个index变量来计算位置数（行{1}））。然后循环访问元素（行{2}），检查当前元素是否是我们要找的。如果是，就返回它的位置（行{3}）；如果不是，就继续计数（行{4}），检查列表中下一个节点（行{5}）。 如果列表为空，或是到达列表的尾部（current = current.next将是null），循环就不会执行。如果没有找到值，就返回-1。 2.4.3 remove方法实现了indexOf方法就可以实现remove方法了 1234this.remove = function(element)&#123; let index = this.indexOf(element); return this.removeAt(index);&#125;; 我们已经有一个移除给定位置的一个元素的removeAt方法了。现在有了indexOf方法，如果传入元素的值，就能找到它的位置，然后调用removeAt方法并传入找到的位置。这样非常简单，如果需要更改removeAt方法的代码，这样也更容易——两个方法都会被更改（这就是重用代码的妙处）。这样，我们就不需要维护两个从列表中移除一项的方法，只需要一个！同时，removeAt方法将会检查边界约束。 2.4.4 isEmpty、size和getHead方法isEmpty方法检查链表是否为空、size获取链表长度，这两个方法与队列中的isEmpty方法、size方法类似，如下实现： 123this.isEmpty = function() &#123; return length === 0;&#125;; 如果列表中没有元素，isEmpty方法就返回true，否则返回false。 123this.size = function() &#123; return length;&#125;; size方法返回列表的length。和已经实现的Queue类、Stack类有所不同，列表的length是内部控制的，因为LinkedList是从头构建的。 最后还有getHead方法： 123this.getHead = function()&#123; return head;&#125;; head变量是LinkedList类的私有变量（这意味着它不能在LinkedList实例外部被访问和更改，只有通过LinkedList实例才可以）。但是，如果我们需要在类的外部循环访问列表，就需要提供一种获取类的第一个元素的方法。 三、双向链表双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素，如下图所示 先从实现DoublyLinkedList类所需的变动开始 123456789101112//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法&#125; 在代码中可以看到，LinkedList类和DoublyLinkedList类之间的区别标为新增的。在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一项的引用的tail属性。 双向链表提供了两种迭代列表的方法：从头到尾，或者反过来。我们也可以访问一个特定节点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。 3.1 在任意位置插入新元素向双向链表中插入一个新项跟（单向）链表非常类似。区别在于，链表只要控制一个next指针，而双向链表则要同时控制next和prev（previous，前一个）这两个指针。 这是向任意位置插入一个新元素的算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法 this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 if (!head) &#123; //新增的 &#123;1&#125; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; //新增的 &#123;2&#125; head = node; &#125; &#125; else if (position === length) &#123; //最后一项 //新增的 current = tail; // &#123;3&#125; current.next = node; node.prev = current; tail = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;4&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;5&#125; previous.next = node; current.prev = node; //新增的 node.prev = previous; //新增的 &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; &#125; &#125;;&#125; 我们来分析第一种场景：在列表的第一个位置（列表的起点）插入一个新元素。如果列表为空（行{1}），只需要把head和tail都指向这个新节点。如果不为空，current变量将是对列表中第一个元素的引用。就像我们在链表中所做的，把node.next设为current，而head将指向node（它将成为列表中的第一个元素）。不同之处在于，我们还需要为指向上一个元素的指针设一个值。current.prev指针将由指向null变为指向新元素（node——行{2}）。node.prev指针已经是null，因此不需要再更新任何东西。下图演示了这个过程： 现在来分析一下，假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current变量将引用最后一个元素（行{3}）。然后开始建立第一个链接：node.prev将引用current。current.next指针（指向null）将指向node（由于构造函数，node.next已经指向了null）。然后只剩一件事了，就是更新tail，它将由指向current变为指向node。下图展示了这些行为： 然后还有第三种场景：在列表中间插入一个新元素。就像我们在之前的方法中所做的，迭代列表，直到到达要找的位置（行{4}）。我们将在current和previous元素之间插入新元素。首先，node.next将指向current（行{5}），而previous.next将指向node，这样就不会丢失节点之间的链接。然后需要处理所有的链接：current.prev将指向node，而node.prev将指向previous。下图展示了这一过程： 3.2 从任意位置移除元素从双向链表中移除元素跟链表非常类似。唯一的区别就是还需要设置前一个位置的指针。我们来看一下它的实现： 12345678910111213141516171819202122232425262728293031323334this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; //移除第一项 if (position === 0) &#123; head = current.next; // &#123;1&#125; //如果只有一项，更新tail //新增的 if (length === 1) &#123; // &#123;2&#125; tail = null; &#125; else &#123; head.prev = null; // &#123;3&#125; &#125; &#125; else if (position === length - 1) &#123; //最后一项 //新增的 current = tail; // &#123;4&#125; tail = current.prev; tail.next = null; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;5&#125; previous = current; current = current.next; &#125; //将previous与current的下一项链接起来——跳过current previous.next = current.next; // &#123;6&#125; current.next.prev = previous; //新增的 &#125; length--; return current.element; &#125; else &#123; return null; &#125;&#125;; 我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。 我们来看看如何移除第一个元素。current变量是对列表中第一个元素的引用，也就是我们想移除的元素。需要做的就是改变 head 的引用，将其从 current 改为下一个元素（current.next——行{1}）。但我们还需要更新current.next指向上一个元素的指针（因为第一个元素的prev指针是null）。因此，把head.prev的引用改为null（行{3}——因为head也指向列表中新的第一个元素，或者也可以用current.next.prev）。由于还需要控制tail的引用，我们可以检查要移除的元素是否是第一个元素，如果是，只需要把tail也设为null（行{2}）。 下图勾画了从双向链表移除第一个元素的过程： 下一种场景是从最后一个位置移除元素。既然已经有了对最后一个元素的引用（tail），我们就不需要为找到它而迭代列表。这样我们也就可以把tail的引用赋给current变量（行{4}）。接下来，需要把tail的引用更新为列表中倒数第二个元素（current.prev，或者tail.prev也可以）。既然tail指向了倒数第二个元素，我们就只需要把next指针更新为null（tail.next= null）。下图演示了这一行为： 第三种也是最后一种场景：从列表中间移除一个元素。首先需要迭代列表，直到到达要找的位置（行{5}）。current变量所引用的就是要移除的元素。那么要移除它，我们可以通过更新previous.next和current.next.prev的引用，在列表中跳过它。因此，previous.next将指向current.next，而current.next.prev将指向previous，如下图所示： 3.3 循环列表循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用null，而是指向第一个元素（head），如下图所示。 双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev。 四、小结本篇文章主要介绍链表这种数据结构，及其变体双向链表和循环链表。我们学习了如何在任意位置添加和移除元素，以及如何循环访问链表。还学习了链表相比数组最重要的优点，那就是无需移动链表中的元素，就能轻松地添加和移除元素。因此，当我们需要添加和移除很多元素时，最好的选择就是链表，而非数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法四（队列）","date":"2018-10-12T11:31:39.000Z","path":"2018/10/12/cjxe4h6k0000w6supyjsepeua/","text":"一、队列数据结构队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 在现实中，最常见的队列的例子就是排队： 1.1 创建队列首先需要创建自己的类表示队列，先从最基本的声明开始： 123function quene() &#123; //这里是属性和方法&#125; 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像在Stack类中那样使用（你会发现Queue类和Stack类非常类似，只是添加和移除元素的原则不同）： let items = []; 接下来需要声明一些队列可用的方法: 123456789enqueue(element(s))：向队列尾部添加一个（或多个）新的项。dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。front()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）。isEmpty()：如果队列中不包含任何元素，返回true，否则返回false。size()：返回队列包含的元素个数，与数组的length属性类似。 1.2 向队列添加元素首先要实现的是enqueue方法。这个方法负责向队列添加新元素。这里有一个非常重要的细节，新的项只能添加到队列末尾： 123this.enqueue = function(element)&#123; items.push(element);&#125;; 1.2 从队列移除元素接下来要实现dequeue方法。这个方法负责从队列移除项。由于队列遵循先进先出原则，最先添加的项也是最先被移除的。 123this.dequeue = function()&#123; return items.shift();&#125;; 只有enqueue方法和dequeue方法可以添加和移除元素，这样就确保了Queue类遵循先进先出原则。 1.3 查看队列头元素现在来为我们的类实现一些额外的辅助方法。如果想知道队列最前面的项是什么，可以用front方法。这个方法会返回队列最前面的项（数组的索引为0）： 123this.front = function()&#123; return items[0];&#125;; 1.4 检查队列是否为空下一个是isEmpty方法。如果队列为空，它会返回true，否则返回false（注意这个方法和Stack类里的一样）： 123this.isEmpty = function() &#123; return items.length == 0&#125; 对于isEmpty方法，可以简单地验证内部数组的length是否为0。 我们也可以为Queue类实现类似于array类的length属性的方法。size方法也跟Stack类里的一样： 123this.size = function()&#123; return items.length;&#125;; 1.5 打印队列元素我们的Queue类已经实现好了。为了方便也可以像Stack类一样增加一个print方法： 123this.print = function()&#123; console.log(items.toString());&#125;; 1.6 使用quene类首先要做的是实例化我们刚刚创建的Queue类，然后就可以验证它为空（输出为true，因为我们还没有向队列添加任何元素）： 1234567891011121314151617181920212223242526let items = [];function Queue() &#123; this.enqueue = function(element) &#123; return items.push(element); &#125; this.dequeue = function() &#123; return items.shift(); &#125; this.front = function() &#123; return items[0]; &#125; this.isEmpty = function() &#123; return items.length == 0; &#125; this.size = function() &#123; return items.length; &#125; this.print = function() &#123; return console.log(items.toString()); &#125;&#125;let queue = new Queue();console.log(queue.isEmpty()); //输出true 接下来，添加一些元素（添加”John”和”Jack”两个元素——你可以向队列添加任何类型的元素）： queue.enqueue(“John”); queue.enqueue(“Jack”); 添加另一个元素： queue.enqueue(&quot;Camila&quot;); 再执行一些其他的命令： 1234567891011queue.print(); //[\"John\", \"Jack\", \"Camila\"]console.log(queue.size()); //输出3console.log(queue.isEmpty()); //输出falsequeue.dequeue(); //\"John\"queue.dequeue(); //\"Jack\"queue.print(); //[\"Camila\"] 如果打印队列的内容，就会得到John、Jack和Camila这三个元素。因为我们向队列添加了三个元素，所以队列的大小为3（当然也就不为空了）。 下图展示了目前为止执行的所有入列操作，以及队列当前的状态： 然后，出列两个元素（执行两次dequeue方法）。下图展示了dequeue方法的执行过程： 最后，再次打印队列内容时，就只剩Camila一个元素了。前两个入列的元素出列了，最后入列的元素也将是最后出列的。也就是说，我们遵循了先进先出原则。 二、用ECMAscript6语法实现的Queue类和Stack类一样，我们也可以用ECMAScript 6语法编写Queue类。在这种方法中，我们要用一个WeakMap来保存私有属性items，并用外层函数（闭包）来封装Queue类。 123456789101112131415161718192021let Queue = (function() &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; items.get(this).push(element) return items.get(this); &#125; dequeue() &#123; items.get(this).shift(); return items.get(this) &#125; &#125; return Queue&#125;)();let queue = new Queue();console.log(queue.enqueue(10)); //[10]console.log(queue.enqueue(11)); //[10,11]console.log(queue.dequeue()); //[11] 三、优先队列队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和妇（或带小孩的妇女）登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的（急诊科）候诊室。医生会优先处理病情比较严重的患者。通常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此可以对它们使用默认的出列操作： 12345678910111213141516171819202122232425262728293031323334function PriorityQueue() &#123; let items = []; function QueueElement(element, priority) &#123; // &#123;1&#125; this.element = element; this.priority = priority; &#125; this.enqueue = function (element, priority) &#123; console.log(items) let queueElement = new QueueElement(element, priority); let added = false; for (let i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; // &#123;2&#125; items.splice(i, 0, queueElement); // &#123;3&#125; added = true; break; // &#123;4&#125; &#125; &#125; if (!added) &#123; items.push(queueElement); //&#123;5&#125; &#125; &#125;; this.print = function () &#123; for (let i = 0; i &lt; items.length; i++) &#123; console.log(`$&#123;items[i].element&#125; - $&#123;items[i].priority&#125;`); &#125; &#125;; //其他方法和默认的Queue实现相同&#125; let priorityQueue = new PriorityQueue();priorityQueue.enqueue(\"John\", 2);priorityQueue.enqueue(\"Jack\", 1);priorityQueue.enqueue(\"Camila\", 1);priorityQueue.print(); 默认的Queue类和PriorityQueue类实现上的区别是，要向PriorityQueue添加元素，需要创建一个特殊的元素（行{1}）。这个元素包含了要添加到队列的元素（它可以是任意类型）及其在队列中的优先级。 如果队列为空，可以直接将元素入列（行{2}）。否则，就需要比较该元素与其他元素的优先级。当找到一个比要添加的元素的priority值更大（优先级更低）的项时，就把新元素插入到它之前（根据这个逻辑，对于其他优先级相同，但是先添加到队列的元素，我们同样遵循先进先出的原则）。要做到这一点，我们可以用第2章学习过的JavaScript的array类的splice方法。一旦找到priority值更大的元素，就插入新元素（行{3}）并终止队列循环（行{4}）。这样，队列也就根据优先级排序了。 如果要添加元素的priority值大于任何已有的元素，把它添加到队列的末尾就行了（行{5}）: let priorityQueue = new PriorityQueue();priorityQueue.enqueue(“John”, 2);priorityQueue.enqueue(“Jack”, 1);priorityQueue.enqueue(“Camila”, 1);priorityQueue.print(); 以上代码是一个使用PriorityQueue类的示例。在下图中可以看到每条命令的结果（以上代码的结果） 第一个被添加的元素是优先级为2的John。因为此前队列为空，所以它是队列中唯一的元素。接下来，添加了优先级为1的Jack。由于Jack的优先级高于John，它就成了队列中的第一个元素。然后，添加了优先级也为1的Camila。Camila的优先级和Jack相同，所以它会被插入到Jack之后（因为Jack先被插入队列）；Camila的优先级高于John，所以它会被插入到John之前。 我们在这里实现的优先队列称为最小优先队列，因为优先级的值较小的元素被放置在队列最前面（1代表更高的优先级）。最大优先队列则与之相反，把优先级的值较大的元素放置在队列最前面。 四、循环队列——击鼓传花还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏（HotPotato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子（胜者）。 在下面这个示例中，我们要实现一个模拟的击鼓传花游戏： 123456789101112131415161718192021222324252627282930313233343536373839404142let Queue = (function () &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; return items.get(this).push(element) // return items.get(this); &#125; dequeue() &#123; return items.get(this).shift(); // return items.get(this); &#125; size() &#123; return items.get(this).length; &#125; print() &#123; console.log(items.get(this).toString()); &#125; &#125; return Queue&#125;)();function hotPotato(nameList, num) &#123; let queue = new Queue(); // &#123;1&#125; for (let i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); // &#123;2&#125; &#125; let eliminated = ''; while (queue.size() &gt; 1) &#123; for (let i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); // &#123;3&#125; John queue.print() &#125; eliminated = queue.dequeue();// &#123;4&#125; // console.log(eliminated + '在击鼓传花游戏中被淘汰。'); //Camila,Jack,Carl,Ingrid &#125; return queue.dequeue();// &#123;5&#125;&#125;let names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; let winner = hotPotato(names, 7); console.log('The winner is: ' + winner); //The winner is: John 实现一个模拟的击鼓传花游戏，要用到实现的Queue类（行{1}）。我们会得到一份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被淘汰的威胁立刻就解除了）。一旦传递次数达到给定的数字，拿着花的那个人就被淘汰了（从队列中移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）。 以上算法的输出如下： Camila在击鼓传花游戏中被淘汰。Jack在击鼓传花游戏中被淘汰。Carl在击鼓传花游戏中被淘汰。Ingrid在击鼓传花游戏中被淘汰。胜利者：John 下图模拟了这个输出过程：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法三（栈）","date":"2018-09-28T09:58:31.000Z","path":"2018/09/28/cjxe4h6js000o6sup5o5jgiud/","text":"一、栈数据结构栈是一种遵从后进先出(LIFO)原则的有序数据集合。新添加的或者待删除的元素保存在栈的同一端称为栈顶，另一端称为栈底。在栈里新添加的元素都靠近栈顶，旧添加的元素都接近栈底 1.1 创建栈先创建一个类表示栈，先声明一个类： function Stack() { //各种属性和方法的声明 } 首先，我们需要一种数据结构来保存栈里的元素。可以选择数组： let items = []; 接下来，要为我们的栈声明一些方法。 push(element(s))：添加一个（或几个）新元素到栈顶。 pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。 isEmpty()：如果栈里没有任何元素就返回true，否则返回false。 clear()：移除栈里的所有元素。 size()：返回栈里的元素个数。这个方法和数组的length属性很类似。 1.2 像栈中添加元素我们要实现的第一个方法是push。这个方法负责往栈里添加新元素，有一点很重要：该方法只添加元素到栈顶，也就是栈的末尾。push方法可以这样写： this.push = function(element){ items.push(element); }; 1.3 从栈中移除元素接着，我们来实现pop方法。这个方法主要用来移除栈里的元素。栈遵从LIFO原则，因此移出的是最后添加进去的元素。因此，我们可以用数组的pop方法。栈的pop方法可以这样写： this.pop = function(){ return items.pop(); }; 1.4 查看栈顶元素现在，为我们的类实现一些额外的辅助方法。如果想知道栈里最后添加的元素是什么，可以用peek方法。这个方法将返回栈顶的元素： this.peek = function(){ return items[items.length-1]; }; 1.5 检测栈是否为空下一个要实现的方法是 isEmpty，如果栈为空的话将返回true，否则就返回false： this.isEmpty = function(){ return items.length == 0; }; 使用isEmpty方法，我们能简单地判断内部数组的长度是否为0。 类似于数组的length属性，我们也能实现栈的length。对于集合，最好用size代替length。因为栈的内部使用数组保存元素，所以能简单地返回栈的长度： this.size = function(){ return items.length; }; 1.6 清空和打印栈元素最后，我们来实现clear方法。clear方法用来移除栈里所有的元素，把栈清空。实现这个方法最简单的方式是： this.clear = function(){ items = []; }; 另外也可以多次调用pop方法，把数组中的元素全部移除，这样也能实现clear方法。 如下案例，为了检查栈里的内容，实现一个辅助方法print。它会把栈里的元素都输出到控制台： this.print = function(){ console.log(items.toString()); }; 1.7 使用Stack类首先，我们需要初始化Stack类。然后，验证一下栈是否为空（输出是true，因为还没有往栈里添加元素）。 1234567891011121314151617181920212223242526function Stack()&#123; this.push = function (element) &#123; return items.push(element) &#125; this.pop = function () &#123; return items.pop(); &#125;; this.peek = function () &#123; return items[items.length - 1]; &#125;; this.isEmpty = function () &#123; return items.length == 0; &#125;; this.size = function () &#123; return items.length; &#125;; this.clear = function()&#123; items = []; &#125;; this.print = function()&#123; console.log(items.toString()); &#125;; &#125;let items = [];let stack = new Stack();console.log(stack.isEmpty()); //true 接下来，往栈里添加一些元素（这里我们添加数字5和8；你可以添加任意类型的元素）: Stack.push(5); Stack.push(8); 如果调用peek方法，将会输出8，因为它是往栈里添加的最后一个元素： console.log(stack.peek()); //输出8 再添加一个元素： stack.push(11); console.log(stack.size()); //输出3 console.log(stack.isEmpty()); //输出false 我们往栈里添加了11。如果调用size方法，输出为3，因为栈里有三个元素（5、8和11）。如果我们调用isEmpty方法，会看到输出了false（因为栈里有三个元素，不是空栈）。最后，我们再添加一个元素： stack.push(15); 下图描绘了目前为止我们对栈的操作，以及栈的当前状态： 然后，调用两次pop方法从栈里移除2个元素： stack.pop(); stack.pop(); console.log(stack.size()); //输出2 stack.print(); //输出[5, 8] 在两次调用pop方法前，我们的栈里有四个元素。调用两次后，现在栈里仅剩下5和8了。下图描绘这个过程的执行： 二、ECMAScript 6 和 Stack 类2.1 用 ES6 语法声明 Stack 类class Stack { constructor () { this.items = []; //{1} } push(element){ this.items.push(element); } //其他方法 } 我们只是用ES6的简化语法把Stack函数转换成Stack类。这种方法不能像其他语言（Java、C++、C#）一样直接在类里面声明变量，只能在类的构造函数constructor里声明（行{1}，在类的其他函数里用this.nameofVariable就可以引用这个变量。 尽管代码看起来更简洁、更漂亮，变量items却是公共的。ES6的类是基于原型的。虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性（变量）或方法。而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法。否则，就有可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。 2.1.1 用ES6的限定作用域Symbol实现类ES6新增了一种叫作Symbol的基本类型，它是不可变的，可以用作对象的属性。 let _items = Symbol(); //{1} class Stack { constructor () { this[_items] = []; //{2} } //Stack方法 } 在上面的代码中，我们声明了Symbol类型的变量_items（行{1}），在类的constructor函数中初始化它的值（行{2}）。要访问_items，只需把所有的this.items都换成this[_items]。 这种方法创建了一个假的私有属性，因为ES6新增的Object.getOwnPropertySymbols方法能够取到类里面声明的所有Symbols属性。下面是一个破坏Stack类的例子： let _items = Symbol(); class Stack { constructor() { this[_items] = []; } push(element) { return this[_items].push(element); }; print() { console.log(this[_items].toString()); }; } let stack = new Stack(); stack.push(5); stack.push(8); let objectSymbols = Object.getOwnPropertySymbols(stack); console.log(objectSymbols.length); // 1 console.log(objectSymbols); // [Symbol()] console.log(objectSymbols[0]); // Symbol() stack[objectSymbols[0]].push(1); stack.print(); //输出 5, 8, 1 从以上代码可以看到，访问stack[objectSymbols[0]]是可以得到_items的。并且，_items属性是一个数组，可以进行任意的数组操作，比如从中间删除或添加元素。我们操作的是栈，不应该出现这种行为。 2.1.2 用ES6的WeakMap实现类有一种数据类型可以确保属性是私有的，这就是WeakMap。WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。 如果用WeakMap来存储items变量，Stack类就是这样的： const items = new WeakMap(); //{1} class Stack { constructor () { items.set(this, []); //{2} } push(element) { let s = items.get(this); //{3} s.push(element); } pop() { let s = items.get(this); let r = s.pop(); return r; } //其他方法 } //行{1}，声明一个WeakMap类型的变量items。 //行{2}，在constructor中，以this（Stack类自己的引用）为键，把代表栈的数组存入items。 //行{3}，从WeakMap中取出值，即以this为键（行{2}设置的）从items中取值。 现在我们知道，items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap： let Stack = (function () { const items = new WeakMap(); class Stack { constructor () { items.set(this, []); } //其他方法 } return Stack; //{5} })(); //当Stack函数里的构造函数被调用时，会返回Stack类的一个实例（行{5}）。 现在，Stack类有一个名为items的私有属性。虽然它很丑陋，但毕竟实现了私有属性。然而，用这种方法的话，扩展类无法继承私有属性。鱼与熊掌不可兼得！ 把上面的代码跟本章最初实现的Stack类做个比较，我们会发现有一些相似之处： function Stack() { let items = []; //其他方法 } 事实上，尽管ES6引入了类的语法，我们仍然不能像在其他编程语言中一样声明私有属性或方法。有很多种方法都可以达到相同的效果，但无论是语法还是性能，这些方法都有各自的优点和缺点 哪种方法更好？这取决于你在实际项目中如何使用本书中这些算法，要处理的数据量，要创建的实例个数，以及其他约束条件。最终，还是取决于你。 2.2 用栈解决问题栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后续再讨论图和回溯问题时，我们会学习如何应用这个例子）。Java和C#用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 2.2.1 从十进制到二进制现实生活中，我们主要使用十进制。但在计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的（0和1）。没有十进制和二进制相互转化的能力，与计算机交流就很困难。 要把十进制转化成二进制，我们可以将该十进制数字和2整除（二进制是满二进一），直到结果是0为止。举个例子，把十进制的数字10转化成二进制的数字，过程大概是这样： 大学的计算机课一般都会先教这个进制转换。下面是对应的算法描述： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop(); } isEmpty() { return items.get(this).length == 0; }; } return Stack; })(); function divideBy2(decNumber) { var remStack = new Stack(), rem, binaryString = &apos;&apos;; while (decNumber &gt; 0) { //{1} rem = Math.floor(decNumber % 2); //{2} remStack.push(rem); //{3} decNumber = Math.floor(decNumber / 2); //{4} } while (!remStack.isEmpty()) { binaryString += remStack.pop().toString(); //{5} } return binaryString; } console.log(divideBy2(13)); //1101 在这段代码里，当结果满足和2做整除的条件时（行{2}），我们会获得当前结果和2的余数，放到栈里（行{2}、{3}）。然后让结果和2做整除（行{4}）。另外请注意：JavaScript有数字类型，但是它不会区分究竟是整数还是浮点数。因此，要使用Math.floor函数让除法的操作仅返回整数部分。最后，用pop方法把栈中的元素都移除，把出栈的元素变成连接成字符串（行{5}）。 2.2.2 进制转换算法我们很容易修改之前的算法，使之能把十进制转换成任何进制。除了让十进制数字和2整除转成二进制数，还可以传入其他任意进制的基数为参数，就像下面算法这样： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop() } isEmpty() { return items.get(this).length == 0; }; } return Stack; //{5} })(); function baseConverter(decNumber, base) { var remStack = new Stack(), rem, baseString = &apos;&apos;, digits = &apos;0123456789ABCDEF&apos;; //{6} while (decNumber &gt; 0) { rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); } while (!remStack.isEmpty()) { baseString += digits[remStack.pop()]; //{7} } return baseString; } console.log(baseConverter(13,2)); //1101 console.log(baseConverter(13,8)); //15 我们只需要改变一个地方。在将十进制转成二进制时，余数是0或1；在将十进制转成八进制时，余数是0到7之间的数；但是将十进制转成16进制时，余数是0到9之间的数字加上A、B、C、D、E和F（对应10、11、12、13、14和15）。因此，我们需要对栈中的数字做个转化才可以（行{6}和行{7}）。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法二（数组的使用）","date":"2018-09-10T11:24:31.000Z","path":"2018/09/10/cjxe4h6oe00136sup9d6myi80/","text":"一、创建和初始化数组1.1 创建数组用JavaScript声明、创建和初始化数组有两种方式 //使用new创建数组 var daysOfWeek = new Array(); //{1} var daysOfWeek = new Array(7); //{2} var daysOfWeek = new Array(&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;); //{3} 使用new关键字，就能简单地声明并初始化一个数组（行{1}）。用这种方式，还可以创建一 个指定长度的数组（行{2}）。另外，也可以直接将数组元素作为参数传递给它的构造器（行{3}）。 //使用[]创建数组 var daysOfWeek = []; 也可使用一些元素初始化数组，如下： var daysOfWeek = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; 使用数组的length属性获取数组的长度 console.log(daysOfWeek.length); //7 1.2 访问元素和迭代数组要访问数组里特定位置的元素，可以用中括号传递数值位置，得到想知道的值或者赋新的值。如下： for (var i=0; i&lt;daysOfWeek.length; i++){ console.log(daysOfWeek[i]); } 我们来看另一个例子：求斐波那契数列的前20个数字。已知斐波那契数列中第一个数字是1，第二个是2，从第三项开始，每一项都等于前两项之和： var fibonacci = []; //{1} fibonacci[1] = 1; //{2} fibonacci[2] = 2; //{3} for(var i = 3; i &lt; 20; i++){ fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]; ////{4} } for(var i = 1; i&lt;fibonacci.length; i++){ //{5} console.log(fibonacci[i]); //{6} } 在行{1}处，我们声明并创建了一个数组。 在行{2}和行{3}，把斐波那契数列中的前两个数字分别赋给了数组的第二和第三位（在JavaScript中，数组的第一位是0，这里我们略过，从第二位开始分别保存斐波那契数列中对应位置的元素）。 然后，我们需要做的就是想办法得到斐波那契数列的第三到第二十位的数字（前两个值我们已经初始化过了）。我们可以用循环来处理，把数组中前两位上的元素相加，结果赋给当前位置上的元素（行{4}——从数组中的索引3到索引19）。 最后，看看输出（行{6}），我们只需要循环遍历数组的各个元素（行{5}）。 1.3 添加元素1.3.1 使用数组索引直接添加var numbers = [0,1,2,3,4,5,6,7,8,9]; 如果想要给数组添加一个元素（比如10），只要把值赋给数组中最后一个空位上的元素即可。 numbers[numbers.length] = 10; 1.3.2 使用push方法push方法，能把元素添加到数组的末尾 numbers.push(11); numbers.push(12, 13); 1.3.3 插入元素到数组首位现在，我们希望在数组中插入一个值，不像之前那样插入到最后，而是放到数组的首位。为了实现这个需求，首先我们要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位+1（长度）开始，将其对应的前一个元素的值赋给它，依次处理，最后把我们想要的值赋给第一个位置（-1）上。 for (var i=numbers.length; i&gt;=0; i--){ numbers[i] = numbers[i-1]; } numbers[0] = -1; 下面这张图描述了我们刚才的操作过程： ; 也可以使用unshift方法 numbers.unshift(-2); numbers.unshift(-4, -3); 1.4 删除元素1.4.1 删除数组里最靠后的元素删除数组里最靠后的元素使用pop方法： numbers.pop(); 1.4.2 从数组首位删除元素如果要移除数组里的第一个元素，可以用下面的代码： for (var i = 0; i &lt; numbers.length; i++){ numbers[i] = numbers[i+1]; } 下面这张图呈现了这段代码的执行过程： 我们把数组里所有的元素都左移了一位。但数组的长度依然是17，这意味着数组中有额外的 一个元素（值是undefined）。在最后一次循环里，i + 1引用了一个数组里还未初始化的位置。 在Java、C/C+或C#等一些语言里，这样写可能就会抛出异常了，因此不得不在 numbers.length - 1处停止循环。 可以看到，我们只是把数组第一位的值用第二位覆盖了，并没有删除元素（因为数组的长度 和之前还是一样的，并且了多一个未定义元素）。 使用unshift()方法 numbers.shift(); //通过shift和unshift方法，就能用数组模拟基本的队列数据结构， 1.4.3 在任意位置添加或删除元素使用splice方法，简单地通过指定位置/索引，就可以删除相应位置和数量的元素： //如下 numbers.splice(5,3); //这行代码删除了从数组索引5开始的3个元素。这就意味着numbers[5]、numbers[6]和numbers[7]从数组中删除了。 splice方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除元素的个数（这个例子里，我们的目的不是删除元素，所以传入0）。第三个参数往后，就是要添加到数组里的值（元素2、3、4）。输出会发现值又变成了从3到12。 numbers.splice(5,3,2,3,4);//我们从索引5开始删除了3个元素，但也从索引5开始添加了元素2、3、4 对于JavaScript数组和对象，我们还可以用delete操作符删除数组中的元素，例如delete numbers[0]。然而，数组位置0的值会变成undefined，也就是说，以上操作等同于numbers[0] = undefined。因此，我们应该始终使用splice、pop或shift（马上就会学到）方法来删除数组元素。 二、 二维和多维数组JavaScript只支持一维数组，并不支持矩阵(二维数组)。但是，我们可以用数组套数组，实现矩阵或任一多维数组。代码也可以写成这样： var averageTemp = []; averageTemp[0] = []; averageTemp[0][0] = 72; averageTemp[0][1] = 75; averageTemp[0][2] = 79; averageTemp[0][3] = 79; averageTemp[0][4] = 81; averageTemp[0][5] = 81; //day 2 averageTemp[1] = []; averageTemp[1][0] = 81; averageTemp[1][1] = 79; averageTemp[1][2] = 75; averageTemp[1][3] = 75; averageTemp[1][4] = 73; averageTemp[1][5] = 72; 上面的代码里，我们分别指定了每天和每小时的数据。数组中的内容如下图所示： 每行就是每天的数据，每列是当天不同时段的气温 2.1 迭代二维数组的元素如果想看矩阵的输出，我们可以创建一个通用函数，专门输出其中的值： function printMatrix(myMatrix) { for (var i=0; i&lt;myMatrix.length; i++){ for (var j=0; j&lt;myMatrix[i].length; j++){ console.log(myMatrix[i][j]); } } } 需要遍历所有的行和列。因此，我们需要使用一个嵌套的for循环来处理，其中变量i为行，变量j为列。 使用以下代码查看矩阵averageTemp的输出： printMatrix(averageTemp); 2.2 多维数组我们也可以用这种方式来处理多维数组。假如我们要创建一个3×3×3的矩阵，每一格里包含矩阵的i（行）、j（列）及z（深度）之和： var matrix3x3x3 = []; for (var i=0; i&lt;3; i++){ matrix3x3x3[i] = []; for (var j=0; j&lt;3; j++){ matrix3x3x3[i][j] = []; for (var z=0; z&lt;3; z++){ matrix3x3x3[i][j][z] = i+j+z; } } } 数据结构中有几个维度都没关系，我们都可以用循环遍历每个维度来访问所有格子。3×3×3的矩阵也可用立体图表示如下： 可以用以下代码输出这个矩阵的内容： for (var i=0; i&lt;matrix3x3x3.length; i++){ for (var j=0; j&lt;matrix3x3x3[i].length; j++){ for (var z=0; z&lt;matrix3x3x3[i][j].length; z++){ console.log(matrix3x3x3[i][j][z]); } } } 如果是一个3×3×3×3的矩阵，代码中就会用四层嵌套的for语句，以此类推。 2.3 JavaScript 的数组方法参考 方法名 语法 concat 连接数组（一个或多个），返回连接后的结果 every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach 遍历数组 join 将所有的数组元素连接成一个字符串 indexOf 从数组开始查找数组元素在数组中的的位置，并返回，没有找到则返回-1 lastIndexOf 从数组结尾查找数组元素在数组中的的位置，并返回，没有找到则返回-1 map 遍历数组元素，并返回 reverse 颠倒数组中元素的顺序 slice 截取数组中的元素 some 对数组中的每一项运行给定函数，如果任一项返回true，则返回true sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 toString 将数组作为字符串返回 valueOf 和toString类似，将数组作为字符串返回 2.3.1 数组合并concat方法可以向一个数组传递数组、对象或是元素。数组会按照该方法传入的参数顺序连接指定数组。如下： var zero = 0; var positiveNumbers = [1,2,3]; var negativeNumbers = [-3,-2,-1]; var numbers = negativeNumbers.concat(zero, positiveNumbers); //[3,2,1,0,1,2,3] 2.3.1 迭代器函数迭代数组中的元素可以使用for循环，同样JavaScript内置了许多数组可用的迭代方法 解决如下案例： 假如有一个数组，它值是从1到15，如果数组里的元素可以被2整除（偶数），函数就返回true，否则返回false： var isEven = function (x) { // 如果x是2的倍数，就返回true console.log(x); return (x % 2 == 0) ? true : false; }; var numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; 用every方法迭代 numbers.every(isEven); //false //数组numbers的第一个元素是1，它不是2的倍数（1是奇数），因此isEven 函数返回false，然后every执行结束。 用some方法迭代 some方法会迭代数组的每个元素，直到函数返回true： numbers.some(isEven); //numbers数组中第一个偶数是2（第二个元素）。第一个被迭代的元素是1， isEven会返回false。第二个被迭代的元素是2，isEven返回true——迭代结束。 用forEach方法迭代 numbers.forEach(function(x){ console.log((x % 2 == 0)); }); 使用map和filter方法 var myMap = numbers.map(isEven); //[false, true, false, true, false, true, false, true,false, true, false, true, false, true, false]。 filter方法返回新数组由使函数返回true的元素组成： var evenNumbers = numbers.filter(isEven); //[2, 4, 6, 8, 10, 12, 14] 使用reduce方法 reduce方法接收一个函数作为参数，这个函数有四个参数：previousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器 numbers.reduce(function(previous, current, index){ return previous + current; //120 }); 2.4 ECMAScript 6 和数组的新功能下标展示了一些ES6和ES7新增的数组方法 方法 描述 @@iterator 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 copyWithin 复制数组中一系列元素到同一数组指定的起始位置 entries 返回包含数组所有键值对的@@iterator includes 如果数组中存在某个元素则返回true，否则返回false。ES7新增 find 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素 findIndex 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引-1 fill 用静态值填充数组-1 from 根据已有数组创建一个新数组 keys 返回包含数组所有索引的@@iterator of 根据传入的参数创建一个新数组 values 返回包含数组中所有值的@@iterator sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 除了这些新的方法，还有一种用for…of循环来迭代数组的新做法，以及可以从数组实例得到的迭代器对象 2.4.1 使用forEach和箭头函数迭代箭头函数可以简化使用forEach迭代数组元素的做法，如下 numbers.forEach(function (x) { console.log(x % 2 == 0); }); //这段代码可以简化如下： numbers.forEach(x =&gt; { console.log((x % 2 == 0)); }); 2.4.2 使用for…of循环迭代for (let n of numbers) { console.log((n % 2 == 0) ? &apos;even&apos; : &apos;odd&apos;); } 2.4.3 ES6新的迭代器（@@iterator）ES6还为Array类增加了一个@@iterator属性，需要通过Symbol.iterator来访问。代码如下: let iterator = numbers[Symbol.iterator](); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 console.log(iterator.next().value); // 4 console.log(iterator.next().value); // 5 然后，不断调用迭代器的next方法，就能依次得到数组中的值,数组中所有值都迭代完之后，iterator.next().value会返回undefined。 2.4.4 数组的entries、keys和values方法 entries: 返回包含键值对的@@iterator，如下案例： let numbers = [1,2,3] let aEntries = numbers.entries(); // 得到键值对的迭代器,key是数组中的位置，value是保存在数组索引的值。 console.log(aEntries.next().value); // [0, 1] - 位置0的值为1 console.log(aEntries.next().value); // [1, 2] - 位置1的值为2 console.log(aEntries.next().value); // [2, 3] - 位置2的值为3 entries方法会返回numbers数组位置以及对应的值，如果没有可迭代的值则返回undefined。 entries：方法返回包含数组索引的@@iterator，如下案例： let numbers = [1,2,3] let aKeys = numbers.keys(); // 得到数组索引的迭代器 console.log(aKeys.next()); // {value: 0, done: false } console.log(aKeys.next()); // {value: 1, done: false } console.log(aKeys.next()); // {value: 2, done: false } console.log(aKeys.next()); // {value: undefined, done: true } keys方法会返回numbers数组的索引。一旦没有可迭代的值，aKeys.next()就会返回一个value属性为undefined，done属性为true的对象。如果done属性的值为false，就意味着还有可迭代的值。 values：方法返回的@@iterator则包含数组的值 let numbers = [1,2,3] let aValues = numbers.values(); console.log(aValues.next()); // {value: 1, done: false } console.log(aValues.next()); // {value: 2, done: false } console.log(aValues.next()); // {value: 3, done: false } console.log(aValues.next()); // {value: undefined, done: true } 2.4.5 from方法Array.from方法根据已有的数组创建一个新数组，参数为过滤Array中元素的函数 let evens = Array.from(numbers, x =&gt; (x % 2 == 0)); 2.4.6 用Array.of方法Array.of方法根据传入的参数创建一个新数组 let numbers4 = Array.of(1, 2, 3, 4, 5, 6); //[1,2,3,4,5,6] 也可以用这个方法复制已有的数组 let numbersCopy = Array.of(...numbers4); //[1,2,3,4,5,6] 2.4.7 使用fill方法fill方法用静态值填充数组,参数为要添加的位置范围 let numbersCopy = Array.of(1, 2, 3, 4, 5, 6); numbersCopy.fill(0); //（[0, 0, 0, 0, 0, 0] numbersCopy.fill(1, 3, 5); //[0, 0, 0, 1, 1, 0] 创建数组并初始化值的时候，fill方法非常方便，如下： let ones = Array(6).fill(1); //[1, 1, 1, 1, 1, 1] 2.4.8 copyWithin方法copyWithin方法复制数组中的一系列元素到同一数组指定的起始位置 let copyArray = [1, 2, 3, 4, 5, 6]; copyArray.copyWithin(0, 3); // [4, 5, 6, 4, 5, 6] copyArray.copyWithin(1, 3, 5); //[4,4,5,4,5,6] 2.4.9 排序元素 反转数组reverse： let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. 15]; numbers.reverse(); //[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]; 对数组进行排序sort： numbers.sort(); //[1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9] //sort方法在对数组做排序时，把元素默认成字符串进行相互比较。 //所以在使用的时候传入自己写的比较函数 numbers.sort(function(a, b){ return a-b; }); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 自定义排序 我们可以对任何对象类型的数组排序，也可以创建compareFunction来比较元素。例如，对象Person有名字和年龄属性，我们希望根据年龄排序，就可以这么写： var friends = [ {name: &apos;John&apos;, age: 30}, {name: &apos;Ana&apos;, age: 20}, {name: &apos;Chris&apos;, age: 25} ]; function comparePerson(a, b){ if (a.age &lt; b.age){ return -1 } if (a.age &gt; b.age){ return 1 } return 0; } console.log(friends.sort(comparePerson)); //在这个例子里，最后会输出Ana(20), Chris(25), John(30)。 字符串排序 JavaScript在做字符比较的时候，是根据字符对应的ASCII值来比较的。 如下案例： var names =[&apos;Ana&apos;, &apos;ana&apos;, &apos;john&apos;, &apos;John&apos;]; console.log(names.sort()); //[&quot;Ana&quot;, &quot;John&quot;, &quot;ana&quot;, &quot;john&quot;] //因为A、J、a、j对应的ASCII值分别是65、75、97、106。 现在，如果给sort传入一个忽略大小写的比较函数，将会输出[“Ana”, “ana”, “John”,”john”]： names.sort(function(a, b){ if (a.toLowerCase() &lt; b.toLowerCase()){ return -1 } if (a.toLowerCase() &gt; b.toLowerCase()){ return 1 } return 0; }); 假如对带有重音符号的字符做排序的话，我们可以用localeCompare来实现： var names2 = [&apos;Maève&apos;, &apos;Maeve&apos;]; console.log(names2.sort(function(a, b){ return a.localeCompare(b); })); //[&quot;Maeve&quot;, &quot;Maève&quot;] 搜索（indexOf/lastIndexOf） 搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引,如果没有匹配的元素则返回-1。 console.log(numbers.indexOf(10)); //9 console.log(numbers.indexOf(100)); //-1 搜索（ECMAScript 6——find和findIndex方法） find和findIndex方法接收一个回调函数，搜索一个满足回调函数条件的值。 let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; function multipleOf13(element, index, array) { return (element % 13 == 0) ? true : false; } console.log(numbers.find(multipleOf13)); //13 console.log(numbers.findIndex(multipleOf13)); //12 //find和findIndex的不同之处在于，find方法返回第一个满足条件的值。 //findIndex方法则返回这个值在数组里的索引。 //如果没有满足条件的值，find会返回undefined，而findIndex返回-1。 搜索（ECMAScript 7——使用includes方法） 如果数组里存在某个元素，includes方法会返回true，否则返回false。 console.log(numbers.includes(15)); //true console.log(numbers.includes(20)); //false 如果给includes方法传入一个起始索引，搜索会从索引指定的位置开始： let numbers2 = [7, 6, 5, 4, 3, 2, 1]; console.log(numbers2.includes(4, 5)); //false 2.4.10 输出数组为字符串 toString 把数组里所有元素输出为一个字符串 let numbers = [1, 2, 3, 4] console.log(numbers.toString()); //1,2,3,4 如果想用一个不同的分隔符（比如-）把元素隔开，可以用join方法： var numbersString = numbers.join(&apos;-&apos;); console.log(numbersString); //1-2-3-4 三、 类型数组JavaScript数组不是强类型的，因此它可以存储任意类型的数据。而类型数组则用于存储单一类型的数据。它的语法是let myArray = new TypedArray(length)，其中TypedArray需替换为下表所列之一。 类型数组 数据类型 Int8Array 8位二进制补码整数 Uint8Array 8位无符号整数 Uint8ClampedArray 8位无符号整数 Int16Array 16位二进制补码整数 Uint16Array 16位无符号整数 Int32Array 32位二进制补码整数 Uint32Array 32位无符号整数 Float32Array 32位IEEE浮点数 Float64Array 64位IEEE浮点数 代码示例如下： let length = 5; let int16 = new Int16Array(length); for (let i=0; i&lt;length; i++){ int16[i] = i+1; } console.log(int16); //[1, 2, 3, 4, 5] 使用WebGL API、进行位操作、处理文件和图像时，类型数组都可以大展拳脚。它用起来和普通数组也毫无二致，本章所学的数组方法和功能都可以用于类型数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法一（javascript基础）","date":"2018-08-16T11:20:30.000Z","path":"2018/08/16/cjxe4h6ix00056supibhcfbql/","text":"一、相等操作符（==和===）1.相等操作符（==）在使用==时，不同类型的值也可以被看作相等下面表格展示了不同类型的值用相等操作符比较后的结果。 类型（x） 类型（y） 结 果 null undefined true undefined null true 数字 字符串 x == toNumber(y) 字符串 数字 toNumber(x) == y 布尔值 任意类型 toNumber(x) == y 任意类型 布尔值 x == toNumber(y) 字符串或数字 对象 x == toPrimitive(y) 对象 字符串或数字 toPrimitive(x) == y 如果x和y是相同类型，JavaScript会比较它们的值或对象值。其他没有列在这个表格中的情况都会返回false。toNumber和toPrimitive方法是内部的，并根据以下表格对其进行估值。toNumber方法对不同类型返回的结果如下： 值类型 结 果 undefined NAN null +0 布尔值 如果是true，返回1；如果是false，返回+0 数字 数字对应的值 字符串 将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字 对象 Number(toPrimitive(vale)) toPrimitive方法对不同类型返回的结果如下： 值类型 结 果 对象 如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误 例：console.log(&apos;packt&apos; == true); //输出false 首先，布尔值会被toNumber方法转成数字，因此得到packt == 1。 其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式就变成了NaN == 1，结果就是false。 1.相等操作符（===）如果比较的两个值或者类型不同则返回false，如果比较的两个值类型相同，结果会根据下表判断。 类型（x） 类型（y） 结 果 数字 x和y数值相同（但不是NaN） true 字符串 x和y是相同的字符 true 布尔值 x和y都是true或false true 对象 x和y引用同一个对象 true 例：console.log(&apos;packt&apos; === true); //false console.log(&apos;packt&apos; === &apos;packt&apos;); //true 二、声明展开和剩余参数2.1展开操作符在es5中使用apply()函数将数组转化为参数，在es6中使用展开操作符(…); 例： var params = [1, 3, 5] function sum(a=1, b=3, c=4) { return a+b+c } console.log(sum(...params)); //es6使用扩展符传入数组 console.log(sum.apply(null, params)); //es5使用apply传入数组 在函数中也可以使用展开操作符(…)代替arguments，当做剩余参数使用，如下案例： function restParamaterFunction (x, y, ...a) { return (x + y) * a.length; } console.log(restParamaterFunction(1, 2, &quot;hello&quot;, true, 7)); //输出9; es5中实现 function restParamaterFunction(x, y) { var a = Array.prototype.slice.call(arguments, 2); console.log(a) return (x + y) * a.length; }; 2.2数组解构es6引入数组解构的概念，可以一次初始化多个变量，如下： var [x, y] = [&apos;a&apos;, &apos;b&apos;]; 等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; 数组解构也可以用来进行值的互换，而不需要创建临时变量，如下： [x, y] = [y, x]; //等同于 var temp = x, x = y, y = temp; 对象也可以解构，如下： //属性简写的功能， var [x, y] = [&apos;a&apos;, &apos;b&apos;]; var obj = { x, y }; console.log(obj); // { x: &quot;a&quot;, y: &quot;b&quot; } //等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; var obj2 = { x: x, y: y }; console.log(obj2); // { x: &quot;a&quot;, y: &quot;b&quot; } //方法属性 var hello = { name : &apos;abcdef&apos;, printHello() { console.log(&apos;Hello&apos;); } } console.log(hello.printHello()); //等同于 var hello = { name: &apos;abcdef&apos;, printHello: function printHello() { console.log(&apos;Hello&apos;); } }; 三、使用类进行面向对象编程声明一个book类的方式 function Book(title, pages, isbn){ //{1} this.title = title; this.pages = pages; this.isbn = isbn; } Book.prototype.printTitle = function(){ console.log(this.title); }; 使用es6可以简化为一下语法 只需要使用class关键字声明一个constructor函数和其他函数 class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } //以上两种声明据用相同的效果和输出 let book = new Book(&apos;title&apos;, &apos;pag&apos;, &apos;isbn&apos;); console.log(book.title); //输出图书标题 book.title = &apos;new title&apos;; //更新图书标题 console.log(book.title); //输出图书标题 3.1继承es6简化声明类的方式 如下： class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } class ITBook extends Book { //{扩展book并继承其行为 constructor (title, pages, isbn, technology) { super(title, pages, isbn); //引用父类的构造函数 this.technology = technology; } printTechnology(){ console.log(this.technology); } } let jsBook = new ITBook(&apos;学习JS算法&apos;, &apos;200&apos;, &apos;1234567890&apos;, &apos;JavaScript&apos;); console.log(jsBook.title); console.log(jsBook.printTechnology()); //我们可以使用extends关键字扩展一个类并继承它的行为。在构造函数中，也可以通过super关键字引用父类的构造函数。 3.2使用属性存取器使用新的类语法也可以为属性创建存取器函数。如下： class Person { constructor(name) { this._name = name; //{1} } get name() { //{2} return this._name; } set name(value) { //{3} this._name = value; } } let lotrChar = new Person(&apos;Frodo&apos;); console.log(lotrChar.name); //Frodo lotrChar.name = &apos;Gandalf&apos;; console.log(lotrChar.name); //Gandalf lotrChar._name = &apos;Sam&apos;; console.log(lotrChar.name); //Sam //要声明get和set函数，只需要在我们要暴露和使用的函数名前面加上get或set关键字。可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的。 然后，只要像普通的属性一样，引用它们的名字，就可以执行get和set函数。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"认识es6","date":"2018-08-05T11:02:07.000Z","path":"2018/08/05/cjxe4h6jx000s6supiqrss18r/","text":"es6常用api介绍一、let和const命令介绍及区别1. let命令：1）、基本用法： es5只有两种方式声明变量var以及function，es6新增了四种let、const、import、class； let声明的变量的方式与var相似，但是声明的变量，只在let命令所在的代码块中生效; { let a = 1; var b = 2; } console.log(a);//Error in created hook: &quot;ReferenceError: a is not defined&quot; console.log(b);//2 上面在代码块中使用let，var分别声明了连个变量，然后再代码块外面调用，let声明的变量会报错，var声明的 返回值正常，表明let只在它所在的代码块中生效； 2）、let不存在变量提升问题 我们知道使用var声明的变量会存在变量提升问题，但是在let中不存在这种现象 console.log(a);//undefined var a = 1; console.log(b);//报错 let b = 2; 上述代码中，使用let声明了变量b，在声明之前使用会报错，而使用var声明的变量，在使用前值是undefined； 3）、暂时性死区在es6中规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，在声明前使用这些变量就会报错； var a = 1; { a = 3; console.log(a);//报错 let a; } 4）、不允许重复声明let不允许在相同作用域内重复声明同一个变量 // 报错 function fn1() { let a = 1; var a = 2; } // 报错 function fn2() { let a = 1; let a = 2; } function fn3(argements) { let argements; // 也会报错 } es6规定暂时性死区，以及let，const语句不提升变量，主要是为了减少运行时错误，防止在变量声明前就是用这个变量。从而导致意料之外的行为； 1. const命令：const声明一个常量，一旦声明，常量的值就不能改变了，所以const在声明是必须立即初始化，不能留到以后赋值，如果修改它的值会报错 const index = 1; console.log(index)//1 index = 3;// 报错 const num;报错 const声明的常量也不存在变量提升，同样的也是有暂时性死区，也不能重复声明变量 二、块级作用域1、块级作用域的用处在es5中只有全局作用域以及函数作用域，在许多情况下使用很不方便 var num = 1; function f() { console.log(num); if (false) { var num = 2; } } f(); // undefined //在上述代码中在函数内部声明的变量覆盖了外层声明的变量； var index = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 //在for循环中的计数变量会泄露到全局 2、es6中的块级作用域function fn1() { let i = 5; if (true) { let i = 10; } console.log(n); // 5 } //上述代码中存在两个代码块，都声明了变量i，在运行后输出5，说明function声明的代码块不受if(){}代码块的影响 { { {let i = 5}； console.log(i)//报错 } } //let只在当前代码块中生效,其他代码块中是无法使用的，在es6中允许使用作用域的任意嵌套 {{{ let i = 1; {let i = 2};//不报错，不同的作用域中可以声明同一个变量 }}} 3、块级作用域域函数作用域在es5中函数只能在顶层作用域中以及函数作用域中声明，不能再块级作用域中声明，而es6中则可以在块级作用域中声明函数，在块级作用域中声明的函数只在当前作用域中生效，对其他作用域不会造成影响；另外，es6的块级作用域内声明函数必须使用大括号，如果没有会报错 // 不报错 if (true) { function f() {} } // 报错 if (true) function f() {} 三、变量的解构赋值1、数组的解构赋值在es6以前为变量赋值只能指定值 let a = 1; let b = 2; let c = 3; 上述代码在es6中可以住这样写 let [a, b, c] = [1, 2, 3];//a=1,b=2,c=3 //只要等号两边的模式相同，左边的变量就会被赋值对应的值 { let [x, y] = [1, 2, 3] //x=1,y=2 }; { let [x, ,y] = [1, 2, 3] //x=1,y=3 }; { let [x, [y], [z]] = [1, [2], [3]] //x=1,y=2,z=3 }; { let [x, ...y] = [1, 2, 3, 4] //x=1,y=[2,3,4] }; { let [x, y, ...z] = [1] //x=1,y=undefined,z=[] }; 如果结构不成功就会返回undefined { let x = []; //x = undefined; } { let [x, y] = [1] //y =undefined; } 如果等号左边的变量只能匹配等号右边变量的一部分值，这种情况就是不完全解构，但是解构依然会成功； { let [x, y] = [1, 2, 3] //x=1,y=2; } { let [x, [y], z] = [1, [2, 4], 3] //x=1,y=2,z=3; } 如果等号右边不是数组（不可遍历的结构）就会报错 { let [x] = 1; let [y] = false; let [z] = NaN; let [a] = undefined; let [b] = null; let [c] = {}; } 结构赋值允许指定默认值 { let [x = 1] = [];//x = 1 let [i, n = 2] = [1];//i=1,n=2 let [a = 1, b = 2] = [3]//a=3,b=2 } 在es6内部使用严格相等运算符（===），来判断一个位置是否有值，所以只有一个数组成员严格等于undefined默认值才会生效 { let [x = 1] = [undefined] //x=1 let [y = 2] = [null] //y=null,以为null===undefined不成立； } 如果默认是一个表达式，那么这个表达式只有在用到的时候才会求值 { function fn() { console.log(111); } let [x = f()] = [1];//fn不会执行,因为x能取到值1 } 默认值也可以使用解构赋值的其他变量，但是该变量必须先声明 { let [x = 1, y = x] = [] //x= 1;y =2 } { let [x = 1, y = x] = [2] //x=2,y=2 } { let [x = y, y = 1] = [] //报错 y is not defined，因为y还没有声明 } 2、对象的解构赋值对象的结构和数组类似，但是数组的解构按数组的顺序一次取值，而对象是没有顺序的，变量名必须与属性名一直才能取到正确的值； { let {bar, foo} = {foo: 1, bar: 2} //foo:1,bar:2; let {bar1} = {foo1: 1, bar2: 2} //bar1的值为undefined； } 如果变量名与属性名不一致，必须要写成如下形式 { let {foo: foo1} = {foo: 1} //foo1:1 let foo2 = {num1: 10, num2: 20 }; let {num1: f1, num2: f2} = foo2; //f1:10, f2:20; } 变量结构的机制是先找到同名的属性，然后在赋值给对应的变量，如下： { let {bar: foo1} = {bar: 10, bar1: 20} //foo1:10; bar: error: bar is not defined //bar 只是匹配的模式，foo1才是变量，真正被赋值的是变量foo1而不是模式bar } 与数组解构一样对象的解构也可以嵌套 { let foo = { index: [ 10, { y: 20 } ] } let {index:[x, {y}]} = foo;//x:10,y:20 } 对象结构中要注意赋值的是变量，而不是模式，模式只是用来匹配变量的 { let obj = { foo: { index: { num: 1, col: 2 } } } let {foo:{index: {num,col}}} = obj; //num:1, col:2 } 对象的解构也可以指定默认值 { let {x=1} = {} //x=3 } { let {x: y= 1} = {} // y = 3; } { let {x: y= 1} = {null} // y:null; } //和数组一样默认值生效的条件也是严格等于undefined 如果解构失败，变量的值是undefined { let {foo} = {bar: 1} //foo:undefined } 如果解构模式是嵌套的对象，如果子对象所在的父对象不存在，则会报错 { let {foo: {bar}} = {x: 1} //报错 } 解构赋值允许等号左边的模式中，不放置任何变量名，因此如下写法是可以执行的 { ({} = [1, 2]) ({} = &apos;abc) ({} = []) } 也可以对数组进行对象属性的解构 { let arr = [1, 2, 3]; let {0: f1, [arr.length-1]: f2} = arr //f1:1, f2:3 } 2、字符串的解构赋值字符串在解构的时候会被转换成一个类似数组的对象 { let [A, B, C, D] = &apos;abcd&apos;; //A:a,B:b,C:c,D:d; } 3、数值和布尔值的解构赋值数值和布尔值的解构赋值会先转成对象（隐式调用toString方法） { let {toString: s} = 123;//true s === Number.prototype.toString(隐式调用) } { let {toString: s} = true;//true s === Boolean.prototype.toString } { let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError //undefined,null无法转成对象 } 4、函数参数的解构赋值{ function fn([x, y]) { return x + y; } fn([1, 2]);//3 } 函数参数的结解构也可以指定默认值 { function fn({x=3, y=4} = {}) { return [x, y] } fn({x:10, y:20});// [10, 20] fn(); // [3, 4] } 四、圆括号的使用es6对于圆括号的规则是可能导致解构发生歧义，就不能使用圆括号 1、不能使用圆括号的场景(1). 变量的声明赋值 { let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; //上面6个语句都会报错，因为它们都是变量声明语句，模式中不能使用圆括号 } (2). 函数参数 { function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } // 报错 //函数参数也属于变量声明，因此不能带有圆括号。 } (3). 赋值语句的模式 { ({ p: a }) = { p: 42 }; //报错 ([a]) = [5];//报错 } 1、能使用圆括号的场景(1). 赋值语句的非模式部分，可以使用圆括号。 { [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 } 五、函数1、箭头函数的使用在es6中允许使用“箭头”（=&gt;）定义函数 { var f = fn =&gt; v //以上代码等同于 var f = function fn(v) { return v } } 基本语法 { 用法一：参数1（单一参数） =&gt; {函数声明} //一个参数，多个执行语句 用法二：（参数1）（单一参数） =&gt; 表达式（只有一条语句）//单个参数一条执行语句 用法三：(参数1，参数2，... , 参数n) =&gt; {函数声明} //多个参数，多个执行语句 用法四：(参数1，参数2，... , 参数n) =&gt; 表达式（只有一条语句）//相当于(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }//多个参数，一条语句 用法五： () =&gt; {函数声明} //没有参数时使用()代替 } 其他使用 { var f = bar =&gt; ({foo: bar}) console.log(f(1)); //{foo: 1} //箭头函数如果想直接返回一个对象必须在对象外面加()，不然会报错 } { (参数1, 参数2, ...rest) =&gt; {函数声明} (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明} //可以使用默认参数以及剩余参数 } { let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6 //也可以使用解构 } 如果箭头函数不需要参数或者需要多个参数，则使用一个()代表参数部分 { var f1 = () =&gt; x //等同于 var f1 = function() {return x} } { var f1 = (index1, index2) =&gt; index1 + index2; //等同于var f1 = function(index1, index2) {return index1+index2} } 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 { var f1 = (index1, index2) =&gt; { return index1 + index2; } } 2、箭头函数注意点（1）、箭头函数内部的this是固定的，就是定义时所在的对象，而不是使用时调用的对象；（2）、不能当做构造函数使用，如果和new一起使用会抛出错误；（3）、箭头函数内部不存在arguments对象，但是可以用rest参数代替arguments对象；（4）、call 或 apply 调用在箭头函数中不能修改this指针，他们的第一个参数会被忽略（5）、箭头函数没有prototype属性。（6）、箭头函数在参数和箭头之间不能换行。","tags":[{"name":"es6","slug":"es6","permalink":"https://www.23ybob.club/tags/es6/"}]},{"title":"drafting","date":"2018-07-21T06:46:21.000Z","path":"2018/07/21/cjxe4h6il00006sup98ws1u5d/","text":"实现目标div在另一个div中的拖拽效果最近项目中遇到的一个小功能，总结了一下，感觉还不错.github地址： https://github.com/Abriams/js-drafting 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #draft_big &#123; border: 1px solid #FF3300; width: 300px; height: 300px; position: relative; margin-left: 400px; margin-top: 400px; &#125; #draft_small &#123; background: #99CC00; width: 50px; height: 50px; position: absolute; cursor: pointer; right: -80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"draft_big\"&gt; &lt;div id=\"draft_small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=\"javascript\"&gt; window.onload = function () &#123; var draftBig = document.getElementById(\"draft_big\"); var draftSmall = document.getElementById(\"draft_small\"); draftSmall.onmousedown = function (event) &#123; var e = e || window.event; //记录并保存可拖拽div（id为draftSmall的盒子）拖拽前的坐标 var startX = e.clientX - draftSmall.offsetLeft; var startY = e.clientY - draftSmall.offsetTop; // offsetHeight,包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话）; // offsetLeft,目标元素距离最近定位的父级元素左边的距离； // offsetTop,目标元素距离最近定位的父级元素上边的距离； // clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。 // clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的垂直坐标。 /*鼠标的移动事件*/ document.onmousemove = function(e) &#123; //判断被拖拽的盒子（id为draftSmall的盒子）必须拖拽到目标盒子（id为draftBig盒子中）才能移动； if(e.clientX - 400 &lt; draftBig.offsetHeight &amp;&amp; e.clientX &gt; 400) &#123; if(e.clientY -400 &lt; draftBig.offsetWidth &amp;&amp; e.clientY &gt; 400) &#123; var e = e || window.event; //计算当前拖拽的盒子（id为draftSmall的盒子）在目标盒子（id为draftBig盒子）中的坐标； draftSmall.style.left = e.clientX - startX + \"px\"; draftSmall.style.top = e.clientY - startY + \"px\"; /*判断拖拽边界（id为draftSmall的盒子四个边界的判断）*/ if (e.clientX - startX &lt;= 0) &#123; draftSmall.style.left = 0 + \"px\"; &#125; if (e.clientY - startX &lt;= 0) &#123; draftSmall.style.top = 0 + \"px\"; &#125; if (e.clientX - startX &gt;= 250) &#123; draftSmall.style.left = 250 + \"px\"; &#125; if (e.clientY - startX &gt;= 250) &#123; draftSmall.style.top = 250 + \"px\"; &#125; &#125; &#125; &#125;; /*鼠标的抬起事件,终止拖动*/ document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; &#125;; &#125;; &#125;; &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"js实现拖拽","slug":"js实现拖拽","permalink":"https://www.23ybob.club/tags/js实现拖拽/"}]},{"title":"vue slot使用小结","date":"2018-07-14T11:20:30.000Z","path":"2018/07/14/cjxe4h6j000076supq1787j3p/","text":"一、slot简介在vue实际项目开发当中，我们经常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在Vue中被称为内容分发。在Vue中，slot也分多种，从Vue的官网中可以获知，其主要分为：单个插槽、具名插槽和作用域插槽三种。下面就逐一介绍这三种插槽的用法： 二、slot插槽具体用法2.1单个插槽的使用从官网中（https://cn.vuejs.org/）我们知道，如果子组件template中没有包含任何一个时，就算父组件分发再多的内容也将会被丢弃。如下案例： 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; 父组件slotdemo组件 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图：上图所示在中添加内容并不会显示 只有子组件模板只中拥有一个没有属性的slot（可以有多个带属性的slot，后面的内容会介绍），父组件传入的整个内容片段才会被插入到slot所在的位置，并将替换掉slot本身，如果传入的内容为空则会显示slot的默认内容。如下案例： 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 当派发的内容为空时，会默认显示slot的内容 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.2具名插槽的使用可以用一个特殊的属性name来配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将根据name属性匹配内容片段中有对应slot属性的元素。 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div slot=&quot;header&quot;&gt;新的slotchildrenheader&lt;/div&gt; &lt;div slot=&quot;main&quot;&gt;新的内容&lt;/div&gt; &lt;div&gt;没有name&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt;//如果匹配不到内容显示在这 &lt;/header&gt; &lt;main&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.3作用域插槽的使用作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将prop传递给组件一样： &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;slot :text=&quot;msg&quot;&gt;&lt;/slot&gt;&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;&apos;, data() { return { msg: &quot;slot分发内容&quot;, } }, } &lt;/script&gt; 在父组件中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;template slot-scope=&quot;props&quot;&gt;//作用域模板插槽必须存在 &lt;div&gt;新的slotchildrenheader&lt;/div&gt; &lt;div&gt;新的内容&lt;div&gt;{{props.text}}&lt;/div&gt;&lt;/div&gt; &lt;/template&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图： 三、小结这篇文章主要介绍vue中的插槽的使用方法。只是一个空壳子，他的显示以及如何显示手父组件的控制，插槽显示的位置由子组件自身决定。父组件传过来的模板显示组件的template。使用slot可以帮助我们更容易，灵活的使用组件，同时也提高了组件的复用性。","tags":[{"name":"slot","slug":"slot","permalink":"https://www.23ybob.club/tags/slot/"},{"name":"vue","slug":"vue","permalink":"https://www.23ybob.club/tags/vue/"}]},{"title":"工作中遇到的问题总结","date":"2018-07-04T11:20:30.000Z","path":"2018/07/04/cjxe4h6j2000a6supkqk1j6tr/","text":"一、element ui 的使用总结1.1. 自定义验证规则的使用在自定义验证规则的时候每一个判断里（if()else()或者if()else if() else()）都要有callback,否则表单在执行this.$refs[formName].validate((valid) =&gt; {}) 的时候，内部代码是不会执行的； &lt;el-form :model=&quot;ruleForm2&quot; status-icon :rules=&quot;rules2&quot; ref=&quot;ruleForm2&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt; &lt;el-input v-model.number=&quot;ruleForm2.age&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm2&apos;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;resetForm(&apos;ruleForm2&apos;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;script&gt; export default { data() { var checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&apos;年龄不能为空&apos;)); } setTimeout(() =&gt; { if (!Number.isInteger(value)) { callback(new Error(&apos;请输入数字值&apos;)); } else { if (value &lt; 18) { callback(new Error(&apos;必须年满18岁&apos;)); } else { callback();//不能省略，不然无法执行 } } }, 1000); }; var validatePass = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请输入密码&apos;)); } else { if (this.ruleForm2.checkPass !== &apos;&apos;) { this.$refs.ruleForm2.validateField(&apos;checkPass&apos;); } callback(); } }; var validatePass2 = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请再次输入密码&apos;)); } else if (value !== this.ruleForm2.pass) { callback(new Error(&apos;两次输入密码不一致!&apos;)); } else { callback(); } }; return { ruleForm2: { pass: &apos;&apos;, checkPass: &apos;&apos;, age: &apos;&apos; }, rules2: { pass: [ { validator: validatePass, trigger: &apos;blur&apos; } ], checkPass: [ { validator: validatePass2, trigger: &apos;blur&apos; } ], age: [ { validator: checkAge, trigger: &apos;blur&apos; } ] } }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { alert(&apos;submit!&apos;); } else { console.log(&apos;error submit!!&apos;); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); } } } &lt;/script&gt; 1.2移动端ios以及andriod兼容问题1.2.1 ios以及andriod使用overflow: scroll;遇到的问题；页面滚动时使用overflow：scroll;在ios端会出现滑动不流畅问题。 为了解决这个问题，首先我使用了-webkit-overflow-scrolling : touch;这个属性，发现使用这个属性以后，ios页面在滑动到底部或者顶部会出现页面卡死问题，在网上找了好多方法参考这篇文章https://hk.saowen.com/a/ba965995919b5f04ed8bcb7ccc5b4af1e95792e9769fd92a8d36881d1fad8683个人觉得这篇文章写得很好，试了一下这些方法，发现最后还是没有解决，最后发现不要用原生的滚动也就是overflow：scroll;并且阻止ios的默认滑动效果，改为使用better-scroll这个滚动插件完美解决了以上的问题；参考如下案例： &lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;contain-img wrapper&quot; ref=&quot;menuWrapper&quot; v-show=&quot;Show&quot; id=&quot;contain-img&quot;&gt; &lt;ul class=&quot;content&quot; id=&quot;content&quot; ref=&quot;content&quot;&gt; //合同图片显示 &lt;div class=&quot;img01&quot; id=&quot;img01&quot;&gt;&lt;img src=&quot;../../static/img/demo-detail01.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img02&quot;&gt; &lt;img id=&quot;img01&quot; src=&quot;../../static/img/demo-detail02.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;pact-sign&quot; v-show=&quot;isSubmit&quot; @click=&quot;sign()&quot;&gt;提交&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import BScroll from &apos;better-scroll&apos; export default { data() { return { contractImg: &apos;&apos;, isSubmit: true, Show: true } }, created() { this.$nextTick(()=&gt;{ //异步执行 setTimeout(() =&gt; { let containImg = document.getElementById(&quot;img01&quot;).offsetHeight; let bodyHeight = document.body.clientHeight; let distance = bodyHeight-containImg; let scrollHeight = containImg-distance; this.meunScroll=new BScroll(this.$refs.menuWrapper,{});//初始化better-scroll插件 this.meunScroll.scrollTo(0,-scrollHeight); //页面加载完滚动到某个位置 }, 100) }); this.$nextTick(function(){ document.getElementsByTagName(&quot;img&quot;)[0].onload =function() { document.body.addEventListener(&apos;touchmove&apos;, function (e) { e.preventDefault() // 阻止默认的处理方式(阻止下拉滑动的效果) }, {passive: false}) // passive 参数不能省略，用来兼容ios和android } }); }, beforeCreate() { document.title = &apos;签署确认&apos;; }, } &lt;/script&gt; &lt;style scoped&gt; *{ margin: 0; padding: 0; } body, html { height: 100%; width: 100%; background-color: #fff; } .container { width: 100%; height: 100%; } .contain-img { width: 100%; height: 100%; position: absolute; /* overflow: scroll; -webkit-overflow-scrolling : touch; */ } .container img { width: 100%; height: 100%; } .pact-sign { width: 40px; height: 40px; line-height: 40px; position: fixed; bottom: 40px; right: 20px; border-radius: 50%; background-color: #409EFF; text-align: center; color: #ffffff; z-index: 10; } .img01, .img02 { position: relative; overflow: hidden; } &lt;/style&gt; 1.3 prop以及attr的使用使用attr获取checked属性、disabled属性、select属性，如果这些属性默认选中可以取到值，如果未选中值返回undefined，使用prop则可以解决这些问题 官方文档建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()； 1.4 npm打包卡死问题修改为淘宝源：（npm config set registry http://registry.cnpmjs.org）；","tags":[]},{"title":"javascript权威指南理解片一","date":"2018-06-24T09:38:29.000Z","path":"2018/06/24/cjxe4h6iz00066supr90lqy2l/","text":"eval函数eval函数执行另一段javascript代码; eval(&quot;function f() {return x + 1}&quot;); //eval函数只有一个参数，如果参数不是字符串则直接返回这个函数 console.log(eval(11)); //11 //如果参数是字符串则会将字符串当做javascript代码进行编译执行 //并且返回最后一个表达式或语句得值，如果最后一个表达式或语句没有值则返回undefined； //eval使用的作用域是调用他的作用域；如果eval调用了全局函数，则返回的是全局变量的值，如果eval调用了局部函数，他会返回局部变量的值； var geval = eval; var x = &quot;global&quot;, y = &quot;global&quot;; function f() { var x = &quot;local &quot;; eval(&quot;x += &apos;changed&apos;;&quot;) //改变局部变量x的值 return x; } function g() { var y = &quot;local&quot;; geval(&quot;y += &apos; changed&apos;;&quot;); //改变全局变量y的值 return y; } console.log(f(), x); //local changed global console.log(g(), y); //local global changed 三元运算符x &gt; 0 ? x : -x 条件运算符的操作数可以是任意类型，第一个操作符如果是真值，那么返回第二个操作符的结果，如果第一个操作符是假值，则返回第三个操作符的结果； typeof 运算符","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"vuex个人理解","date":"2018-06-14T11:20:30.000Z","path":"2018/06/14/cjxe4h6j4000b6supo9yj7jgl/","text":"什么是vuex及其作用vuex是一个转为vue.js开发的状态管理模式（如同redux是为react提供的状态管理模式），采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 什么是”状态管理模式”在我看来就是在vue中把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中，以供其他任意组件使用； vuex核心vuex核心就是store仓库，也就是一个容器，在这个容器中存储着vuex应用的状态（state） vuex特点 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 在vuex中你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 vuex案例实现1、将state,mutations,actions写在一起 安装vuex，在命令行执行如下命令（注意点：要加上–save，因为这个包在生产环境中是要使用的） npm install vuex –save 新建store文件夹（名称不唯一），并在store文件夹中新家store.js文件，然后引入vue,以及vuex；代码实现如下 import Vue from ‘vue’; import Vuex from ‘vuex’; 使用vuex，代码如下 Vue.use(Vuex); 通过以上3步vuex就可以使用了，接下来就用一个小案例具体实现 在main.js中引入刚新建的store文件 import store from ‘./store/store’ 在实例化Vue对象中加入store对象 new Vue({ el: &apos;#app&apos;, router, store,//使用store template: &apos;&lt;App/&gt;&apos;, components: { App } }) demo介绍 在store.js定义要使用的对象 const state = { count:1 } 在store.js中加入改变state的方法 //提交state的唯一途径（mutations），state对应上边const state中存储的值； const mutations={ add(state){ state.count++; } } actions提交mutations（actions不能直接提交state，只能通过提交mutations改变state） //提交mutations const actions ={ //Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象 addCount(context){ context.commit(&apos;add&apos;) } } getter获取store中的 state 中派生出的一些状态 getters: { counts: state =&gt; { return state.count - 1 } } 在组建中使用 新建count.vue组建具体代码如下 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;addCount&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; //在组件中通过mapState对象赋值 //首先引入mapState对象&apos;; //然后在computed计算属性里获取值并操作： &lt;script&gt; import {mapState} from &apos;vuex&apos;; export default { computed:mapState({ //理解为传入state对象，修改state.count属性； count:state=&gt;state.count }) } &lt;/script&gt; 2、将state,mutations,actions分开管理1.建立相应目录 src文件夹下新建store文件夹 在store文件夹下新建cart文件夹，index.js文件 在cart文件夹下新建state.js, mutations.js, mutation_type, actions.js, getters.js, index.js 在store文件夹下的index.js问价下添加如下代码 import Vue from ‘vue’; import Vuex from ‘vuex’; Vue.use(Vuex); import cart from ‘./cart/‘; export default new Vuex.Store({ modules: { cart } }); 在cart文件夹下的state.js定义要使用的对象 export default { count: 1, isshow: false, params: &apos;hide&apos; } 在mutations.js问价中改变state.js中的状态 import * as types from ‘./mutations_types’ export default { [types.COUNT_LOCAL](state) { state.count += 1 } , [types.REDUCE_LOCAL](state) { state.count -= 1 } , [types.ISSHOW_LOCAl](state,params) { state.isshow = !state.isshow state.params = &apos;hide&apos; ? &apos;show&apos; : &apos;hide&apos; } } 在mutations_type.js中分离mutations.js，便于后期维护 export const COUNT_LOCAL = ‘COUNT_LOCAL’ export const ISSHOW_LOCAl = ‘ISSHOW_LOCAl’ export const REDUCE_LOCAL = ‘REDUCE_LOCAL’ 在action.js中提交mutations import * as types from ‘./mutations_types’ export default { change_count: ({ commit }) =&gt; { commit(types.COUNT_LOCAL); }, change_isshow: ({ commit },{params}) =&gt; { commit(types.ISSHOW_LOCAl,{params}); }, change_reduce: ({ commit }) =&gt; { commit(types.REDUCE_LOCAL) } } 7.在getters.js中获取state中的派生状态 export default { getCount(state) { return state.count; } }; 在caet文件夹下的index.js中导出数据 import state from ‘./state’; import mutations from ‘./mutations’; import getters from ‘./getters’; import actions from ‘./actions’; export default { state, mutations, getters, actions }; 在组件中使用（使用dispatch提交） &lt;div&gt; &lt;h3&gt;&lt;/h3&gt; &lt;button @click=&quot;change()&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&apos;change_reduce&apos;)&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;getmessage()&quot;&gt;get&lt;/button&gt; &lt;input type=&quot;text&quot; :value=&quot;$store.state.cart.count&quot;&gt; &lt;button @click=&quot;changeShow()&quot; ref=&quot;hide&quot;&gt;hide&lt;/button&gt; &lt;input type=&quot;text&quot; v-show=&quot;show&quot; value=&quot;11&quot;&gt; &lt;/div&gt; &lt;script&gt; import { mapState } from &apos;vuex&apos; export default { data () { return { msg: &apos;Hellow Vuex&apos;, show: false } }, methods: { getmessage() { console.log(this.$store.state.cart.count) }, change() { this.$store.dispatch(&apos;change_count&apos;); }, changeShow() { let ishide = this.$store.state.cart.params; if( ishide == &apos;hide&apos;) { ishide = &apos;show&apos; } else { ishide = &apos;hide&apos; } console.log(ishide); this.$store.dispatch(&apos;change_isshow&apos;,&apos;ishide&apos;) this.show = this.$store.state.cart.isshow this.$refs.hide.innerHTML = this.$store.state.cart.params // console.log(this.$store.state.cart.params) } }, computed: { ...mapState({ count: state =&gt; { console.log(state.count) } }) } } &lt;/script&gt; 小结假如你的项目需要数据 和 组件 分离，分别处理，使用 Vuex 是非常合适的，相反，如果不需要分离处理，那么不使用 Vuex 也没关系。","tags":[{"name":"vuex","slug":"vuex","permalink":"https://www.23ybob.club/tags/vuex/"}]},{"title":"从零开始使用github page + hexo搭建个人博客","date":"2018-05-15T11:20:30.000Z","path":"2018/05/15/cjxe4h6jz000u6supbwcnckhm/","text":"首先附上我使用hexo搭建的博客：https://23ybob.club/github地址: https://github.com/Abriams/Abriams.github.io 简介：个人刚使用hexo+github page搭建完博客，感觉还是很有成就感，所以把自己的一些在搭建过程中遇到的问题总结了一下，并为大家介绍hexo的详细配置，如何将hexo布置到github上，以及最后绑定域名 写在前面：我是一名前端开发人员，经常都会浏览别人的博客，感觉很高大上，一直以后也希望有一个属于自己的博客，虽然以前也搭建过博客，但是做的不是很精细，博客也没有去维护，最近看了别人的文章感触挺深，所以参考一些资料自己完完全全搭建了一个博客，总体来说很简单，如果你是一名程序开发爱好者，刚好你也想搭建自己的博客，你可以认认真真阅读这篇文章，相信对你搭建博客会有很大帮助 废话不多说，直接开始搭建过程 一、安装搭建必须软件1. 安装node.js(直接去node官网下载自己需要的版本即可，这个应该不用多说了吧)2. 安装git（https://git-scm.com/download/win）2.1安装完成后再命令行输入git version查看是否安装成功如果安装成功鼠标右键就会出现Git GUI Here和Git Bash Here两个按钮，然后选择Git Bash Here即可打开git命令行 1. 安装教程：https://git-scm.com/download/win 2. Git入门教程：http://git.oschina.net/progit/ 3. git常用命令 - git clone仓库地址：将远程仓库clone到本地 - git init ：新建仓库 - git pull： 抓取远程仓库所有分支更新并合并到本地 - git add 文件名或者.：添加新文件 - git commit：提交你的修改 - git push：推送本地仓库更新到远程仓库 二、hexo介绍及安装Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.hexo安装在命令行输入 npm install -g hexo-cli 即可安装hexo安装完hexo还需安装将hexo部署到git page的deployer，在命令行输入 npm install hexo-deployer-git –save 2.使用hexo建立建立需要的文件选择自己要存放文件的目录，右键打开点击Git Bash Here，进入命令行执行 hexo init，安装完以后会在指定文件夹的中新建需要的文件，目录结构如下.git├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themeshexo配置参数可在https://hexo.io/zh-cn/docs/setup.html 中参看 3.执行hexohexo根目录中执行hexo generate 以及 hexo server，并且登录localhost:4000，即可看到本地的效果： 三、将博客布置到github Pages上经过以上步骤我们已经使用hexo搭建了一篇博客，但是我们只能通过本地查看，别人是不能看我们的博客的，所以现在我们需要将本地博客发布到服务器上，让别人也可以访问我们的博客，github Pages就可以帮我们实现这件事情，我们都知道github Pages的代码是保存在github上的所以现在我们需要在github上新建一个项目 1.注册github账号访问github官网： https://github.com/ 点击Sign Up注册自己的账号 2.创建项目代码库新用户点击New repository即可创建github Pages（如果已经创建过github Pages，点击github + 弹出新建github Pages主页，示例如下） 在弹出的github Pages主页中填写需要的内容 3.配置SSH密钥Github的SSH密钥可以使本地git项目与远程的github建立联系，这样我们就能将本地代码通过git操作实现与Github库的代码同步，具体操作如下： 1). 查看本机是否已经存在 SSH密钥（keys）打开git命令行（可在任一位置打开）运行 cd ~/. ssh 检查本机用户home目录下是否存在.ssh目录，如果，不存在此目录，则进行2).操作，否则，你本机已经存在ssh公钥和私钥，可以略过2).步，直接进入3).操作 2). 创建SSH密钥（keys）$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;（按照你提供的邮箱地址，创建一对密钥） 直接回车，会将密钥按默认文件进行存储当然了你也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 然后按照提示需要输入密码以及确认密码（一般其实也很安全，不需要密码，直接回车即可） 最后，输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 3). 在github中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。（运行完成后直接右键赋值即可 ） clip &lt; ~/.ssh/id_rsa.pub 3.1 登录github登录github进入Setting，如下图所示 3.2 选择SSH and GPG keys选择SSH and GPG keys，如下图所示 3.2 选择New SSH key点击右上角New SSH key即可添加 3.3 粘贴密钥将密钥粘贴在下方文本框中，如图 3.4 测试密钥输入下方命令，查看是否成功 ssh -T git@github.com 如果是如下所示，输入yes回车即可 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 3.5 设置用户信息现在已经通过SSH链接到了Github，但是git是根据用户的名字和邮箱来提交的，github也是用名字和邮箱处理权限的，为了方便可以使用如下命令设置自己的 邮箱和名字 git config --global user.name &quot;ryanlijianchang&quot;//用户名 git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 此时，SSH key已经配置成功，本机成功连接到github 四. 将hexo更新到github上4.1 打开github pages登录自己的github，选择刚才新建的github pages （Amriams/Amriams.github.io） 4.2 获取SSH类型地址进去页面选择clone or download， 再选择Use SSH，复制SSH密钥 4.3 配置hexo连接SSH打开新建的hexo根目录下的_config.yml文件 4.3 配置SSH在打开的文件里添加配置 deploy: type: git repository: git@github.com:Abriams/Abriams.github.io.git branch: master 如图： 4.4 将本地hexo代码布置到github上执行 hexo g -d 即可 执行时会让你输入github账号以及密码，输入完成后，回车即可在github pages服务器上访问我们的博客了，对应的地址就是username.github.io（我的博客是Abriams.github.io） 如果在上述执行过程中出现 ERROR Deployer not found: git，这个提示是你的deployer没有安装成功，所以需要安装 执行npm install hexo-deployer-git –save， 然后在执行hexo g -d就可将博客部署到github pages 上了 4.5 访问自己的博客访问https://Abriams.github.io就可看到自己的博客啦（https://您的用户名.github.io） 4.6 美化博客进入hexo官网https://hexo.io/themes/选择自己喜欢的主题即可 选择好主题后再打开Hexo文件夹下的themes目录（E:\\hexo\\BIOG\\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 等待下载完成后，打开Hexo文件夹下的配置文件_config.yml，修改参数为：theme: hexo-theme-next 然后依次执行 hexo g ， hexo s，打开浏览器，输入 http://localhost:4000/ 即可看见刚更新的主题啦。 更多hexo配置请在hexo官网https://hexo.io/zh-cn/docs/configuration.html查看详情 4.7部署新内容到github打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 执行完成后访问https://您的用户名.github.io即可 五. 使用hexo写博客首先新建文件 hexo n “文章标题” ，执行完成后会在项目E:\\hexo\\BIOG\\source_posts中生成 文章标题.md文件，当然，也可以直接在\\Hexo\\source_posts中新建一个md文件，然后使用markdown书写文章即可，文章完成后使用执行hexo g（生成）， hexo d（部署），就会将文章部署到github上 六.在hexo中华添加图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，（上传本地图片的插件） 3 等待一段时间后，再运行hexo n “xxxx”来生成md文件时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 七、将独立域名关联到github pages上1. 购买域名选择自己喜欢的域名购买即可，我是在腾讯云购买的一下一腾讯云为例https://cloud.tencent.com/?fromSource=gwzcw.234976.234976.234976 2. 配置域名域名买好后在https://console.qcloud.com/domain/mydomain 中管理自己的域名 进去我的域名页面点击解析，如下图 选择添加记录，添加即可，如下图 然后打开github pages你的项目，选择Settings 下拉到github pages设置添加域名 八.hexo中添加标签选项1 生成“标签页”并添加type属性打开命令行执行如下命令 hexo new page tags 成功后会提示INFO Created: ~/Documents/blog/source/tags/index.md 找到blog/source/tags/index.md的文件并添加type: “tags”如下所示： --- title: 文章分类 date: 2017-05-27 13:47:40 type: &quot;tags&quot; --- 2 给文章添加”tags”属性打开需要添加标签的文章，并添加tags属性，如下（tags后的- vuex就是标签内容） --- title: vuex个人理解 tags: - vuex --- 注意：只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 九.添加微博秀首先获取在微博上获取微博秀 &lt;iframe width=&quot;100%&quot; height=&quot;550&quot; class=&quot;share_self&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1&quot;&gt;&lt;/iframe&gt; 找到BIOG/themes/BlueLake/layout/_widget/weibo.jade文件将src=””里面的内容换成微博秀src=””里面的内容 然后找到跟目录下的_config.yml文件，将widgets:添加- weibo 如下： widgets: - recent_posts - category - tag - archive - weibo - links 注意：如果网站使用的是https协议，需要将微博秀中的http换成https即可； 10.设置百度分享（https）首先下载百度分享的文件 https://themebetter.com/uploads/2017/09/static.zip （解压码：themebetter）；将下载后的文件放到主题文件夹下的source文件夹下 修改百度分享代码：在主题文件夹下的layout/_partial/comment_js.jade 下全局搜索http://bgimg.share.baidu.com并去掉http://bgimg.share.baidu.com即可； window._bd_share_config={&quot;common&quot;:{&quot;bdSnsKey&quot;:{},&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;2&quot;,&quot;bdMiniList&quot;:[&quot;mshare&quot;,&quot;weixin&quot;,&quot;tsina&quot;,&quot;qzone&quot;,&quot;linkedin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;print&quot;,&quot;renren&quot;,&quot;sqq&quot;,&quot;evernotecn&quot;,&quot;bdysc&quot;,&quot;tqq&quot;,&quot;tqf&quot;,&quot;bdxc&quot;,&quot;kaixin001&quot;,&quot;tieba&quot;,&quot;douban&quot;,&quot;bdhome&quot;,&quot;thx&quot;,&quot;ibaidu&quot;,&quot;meilishuo&quot;,&quot;mogujie&quot;,&quot;diandian&quot;,&quot;huaban&quot;,&quot;duitang&quot;,&quot;hx&quot;,&quot;fx&quot;,&quot;youdao&quot;,&quot;sdo&quot;,&quot;qingbiji&quot;,&quot;people&quot;,&quot;xinhua&quot;,&quot;mail&quot;,&quot;isohu&quot;,&quot;yaolan&quot;,&quot;wealink&quot;,&quot;ty&quot;,&quot;iguba&quot;,&quot;h163&quot;,&quot;copy&quot;],&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;1&quot;,&quot;bdSize&quot;:&quot;16&quot;},&quot;share&quot;:{},&quot;image&quot;:{&quot;viewList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;],&quot;viewText&quot;:&quot;分享到：&quot;,&quot;viewSize&quot;:&quot;16&quot;},&quot;selectShare&quot;:{&quot;bdContainerClass&quot;:null,&quot;bdSelectMiniList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;]}};with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||head).appendChild(createElement(&apos;script&apos;)).src=&apos;http://bgimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)] //执行完上面几部发现请求的百度分享地址已经替换成了本地，但是在控制台会报错；这是hexo编译了static文件夹导致的； 最后修改根目录下的—_config.yml文件 找到skip_render并添加static/** ，如下所示 skip_render: static/** //防止hexo编译static文件导致报错； 小结：通过以上操作，一篇博客终于搭建成功了，虽然在搭建的过程中会遇到各种问题，这需要我们耐心解决，当所有问题都完成后，我个人收货到了很大成果，也希望各位小伙伴能有自己的收获，另外，既然博客搭建成功了，那么就一定要坚持下去，不需要每天都写，但是每个月写自己的总结心得，总是不过分的吧","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.23ybob.club/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://www.23ybob.club/tags/github-pages/"}]},{"title":"初识前端","date":"2018-05-06T11:20:30.000Z","path":"2018/05/06/cjxe4h6is00026supgn6rcpjx/","text":"个人对前端的理解前端发展1.什么是前端虽然是做前端的，但是具体概念还真不知道，个人感觉就是写页面，渲染数据 2.前端演进史2.1.从静态走向动态大约1994就是前端发展的历史吧，前端都知道1943年10月13日网景公司推出了第一版Navigator；Tim Berners-Lee创建了W3C；Tim的基友发布了CSS。同样在这一年，为动态web网页设计的服务端脚本PHP诞生。 早期网页都是为了方便科学家看文章，传论文而制造的，这也就是为什么Web网页都基于Document，随着网页技术从学术机构走向社会，网页承载的功能已经不足以满足当前需求，因此早期网页的局限性也显示出来了 2.1.1 所有的网页都基于HTML页面，因为没有任何手段可以控制局部内容的显示和隐藏，因此任何局部的变化哪怕只多出一个标点符号，都只能重新下载一个新的页面。2.1.2 计算任务只能在服务端实现。由于网速限制，与服务器通信的过程是非常缓慢的，并且此过程是同步阻塞的，于是会出现这样的场景：用户提交一个表单，然后整个页面消失，浏览器呈现白屏，经过漫长的等待，浏览器渲染出一个和之前一模一样的页面，只不过输入框旁边多了一排红色小字：用户名错误。2.1.3 所有页面都是静态的，这意味着一个电商网站有一千种商品，哪怕页面布局一模一样，也必须写一千个单独的页面。1994年Rasmus Lerdorf为了维护个人网站而创建了PHP，PHP实现了与数据库的交互以及用于生产动态页面的模板引擎，是Web领域中最主流的服务端语言。 1995年网景推出了JavaScript，实现了客户端的计算任务（如表单验证）。 1996年微软推出了iframe标签，实现了异步的局部加载。 1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。 2006年，XMLHttpRequest被W3C正式纳入标准。 至此，早期的Document终于进化为了Web page，早期网页的三个局限都得到了妥善的解决。 2.2从后端走向前端早期网页都是有后端主导的，前端也就只是操作dom，2006年 John Resig发布了jQuery，主要用于操作DOM 起初制约Web开发从后到前的因素很简单，就是前端很多事干不了或干不好，当时的浏览器性能弱，标准化程度低，2008年问世的谷歌V8引擎改变了这一局面，现代浏览器的崛起终结了微软的垄断时代 ECMA也在2009年发布了第五代JavaScript 2009年AngularJS诞生，随后被谷歌收购。 2010年backbone.js诞生。 2011年React和Ember诞生。 2014年Vue.js诞生……前后端分离可谓大势所趋。 参考： Web开发的发展史http://blog.jobbole.com/45169/ https://www.cnblogs.com/leolovexx/p/7249314.html","tags":[{"name":"前端历史","slug":"前端历史","permalink":"https://www.23ybob.club/tags/前端历史/"}]}]