[{"title":"javascript数据结构与算法二（数组的使用）","date":"2019-02-14T06:24:31.000Z","path":"2019/02/14/cjs5vw75k000onovbo154oduj/","text":"一、创建和初始化数组1.1 创建数组用JavaScript声明、创建和初始化数组有两种方式 //使用new创建数组 var daysOfWeek = new Array(); //{1} var daysOfWeek = new Array(7); //{2} var daysOfWeek = new Array(&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;); //{3} 使用new关键字，就能简单地声明并初始化一个数组（行{1}）。用这种方式，还可以创建一 个指定长度的数组（行{2}）。另外，也可以直接将数组元素作为参数传递给它的构造器（行{3}）。 //使用[]创建数组 var daysOfWeek = []; 也可使用一些元素初始化数组，如下： var daysOfWeek = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; 使用数组的length属性获取数组的长度 console.log(daysOfWeek.length); //7 1.2 访问元素和迭代数组要访问数组里特定位置的元素，可以用中括号传递数值位置，得到想知道的值或者赋新的值。如下： for (var i=0; i&lt;daysOfWeek.length; i++){ console.log(daysOfWeek[i]); } 我们来看另一个例子：求斐波那契数列的前20个数字。已知斐波那契数列中第一个数字是1，第二个是2，从第三项开始，每一项都等于前两项之和： var fibonacci = []; //{1} fibonacci[1] = 1; //{2} fibonacci[2] = 2; //{3} for(var i = 3; i &lt; 20; i++){ fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]; ////{4} } for(var i = 1; i&lt;fibonacci.length; i++){ //{5} console.log(fibonacci[i]); //{6} } 在行{1}处，我们声明并创建了一个数组。 在行{2}和行{3}，把斐波那契数列中的前两个数字分别赋给了数组的第二和第三位（在JavaScript中，数组的第一位是0，这里我们略过，从第二位开始分别保存斐波那契数列中对应位置的元素）。 然后，我们需要做的就是想办法得到斐波那契数列的第三到第二十位的数字（前两个值我们已经初始化过了）。我们可以用循环来处理，把数组中前两位上的元素相加，结果赋给当前位置上的元素（行{4}——从数组中的索引3到索引19）。 最后，看看输出（行{6}），我们只需要循环遍历数组的各个元素（行{5}）。 1.3 添加元素1.3.1 使用数组索引直接添加var numbers = [0,1,2,3,4,5,6,7,8,9]; 如果想要给数组添加一个元素（比如10），只要把值赋给数组中最后一个空位上的元素即可。 numbers[numbers.length] = 10; 1.3.2 使用push方法push方法，能把元素添加到数组的末尾 numbers.push(11); numbers.push(12, 13); 1.3.3 插入元素到数组首位现在，我们希望在数组中插入一个值，不像之前那样插入到最后，而是放到数组的首位。为了实现这个需求，首先我们要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位+1（长度）开始，将其对应的前一个元素的值赋给它，依次处理，最后把我们想要的值赋给第一个位置（-1）上。 for (var i=numbers.length; i&gt;=0; i--){ numbers[i] = numbers[i-1]; } numbers[0] = -1; 下面这张图描述了我们刚才的操作过程： ; 也可以使用unshift方法 numbers.unshift(-2); numbers.unshift(-4, -3); 1.4 删除元素1.4.1 删除数组里最靠后的元素删除数组里最靠后的元素使用pop方法： numbers.pop(); 1.4.2 从数组首位删除元素如果要移除数组里的第一个元素，可以用下面的代码： for (var i = 0; i &lt; numbers.length; i++){ numbers[i] = numbers[i+1]; } 下面这张图呈现了这段代码的执行过程： 我们把数组里所有的元素都左移了一位。但数组的长度依然是17，这意味着数组中有额外的 一个元素（值是undefined）。在最后一次循环里，i + 1引用了一个数组里还未初始化的位置。 在Java、C/C+或C#等一些语言里，这样写可能就会抛出异常了，因此不得不在 numbers.length - 1处停止循环。 可以看到，我们只是把数组第一位的值用第二位覆盖了，并没有删除元素（因为数组的长度 和之前还是一样的，并且了多一个未定义元素）。 使用unshift()方法 numbers.shift(); //通过shift和unshift方法，就能用数组模拟基本的队列数据结构， 1.4.3 在任意位置添加或删除元素使用splice方法，简单地通过指定位置/索引，就可以删除相应位置和数量的元素： //如下 numbers.splice(5,3); //这行代码删除了从数组索引5开始的3个元素。这就意味着numbers[5]、numbers[6]和numbers[7]从数组中删除了。 splice方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除元素的个数（这个例子里，我们的目的不是删除元素，所以传入0）。第三个参数往后，就是要添加到数组里的值（元素2、3、4）。输出会发现值又变成了从3到12。 numbers.splice(5,3,2,3,4);//我们从索引5开始删除了3个元素，但也从索引5开始添加了元素2、3、4 对于JavaScript数组和对象，我们还可以用delete操作符删除数组中的元素，例如delete numbers[0]。然而，数组位置0的值会变成undefined，也就是说，以上操作等同于numbers[0] = undefined。因此，我们应该始终使用splice、pop或shift（马上就会学到）方法来删除数组元素。 二、 二维和多维数组JavaScript只支持一维数组，并不支持矩阵(二维数组)。但是，我们可以用数组套数组，实现矩阵或任一多维数组。代码也可以写成这样： var averageTemp = []; averageTemp[0] = []; averageTemp[0][0] = 72; averageTemp[0][1] = 75; averageTemp[0][2] = 79; averageTemp[0][3] = 79; averageTemp[0][4] = 81; averageTemp[0][5] = 81; //day 2 averageTemp[1] = []; averageTemp[1][0] = 81; averageTemp[1][1] = 79; averageTemp[1][2] = 75; averageTemp[1][3] = 75; averageTemp[1][4] = 73; averageTemp[1][5] = 72; 上面的代码里，我们分别指定了每天和每小时的数据。数组中的内容如下图所示： 每行就是每天的数据，每列是当天不同时段的气温 2.1 迭代二维数组的元素如果想看矩阵的输出，我们可以创建一个通用函数，专门输出其中的值： function printMatrix(myMatrix) { for (var i=0; i&lt;myMatrix.length; i++){ for (var j=0; j&lt;myMatrix[i].length; j++){ console.log(myMatrix[i][j]); } } } 需要遍历所有的行和列。因此，我们需要使用一个嵌套的for循环来处理，其中变量i为行，变量j为列。 使用以下代码查看矩阵averageTemp的输出： printMatrix(averageTemp); 2.2 多维数组我们也可以用这种方式来处理多维数组。假如我们要创建一个3×3×3的矩阵，每一格里包含矩阵的i（行）、j（列）及z（深度）之和： var matrix3x3x3 = []; for (var i=0; i&lt;3; i++){ matrix3x3x3[i] = []; for (var j=0; j&lt;3; j++){ matrix3x3x3[i][j] = []; for (var z=0; z&lt;3; z++){ matrix3x3x3[i][j][z] = i+j+z; } } } 数据结构中有几个维度都没关系，我们都可以用循环遍历每个维度来访问所有格子。3×3×3的矩阵也可用立体图表示如下： 可以用以下代码输出这个矩阵的内容： for (var i=0; i&lt;matrix3x3x3.length; i++){ for (var j=0; j&lt;matrix3x3x3[i].length; j++){ for (var z=0; z&lt;matrix3x3x3[i][j].length; z++){ console.log(matrix3x3x3[i][j][z]); } } } 如果是一个3×3×3×3的矩阵，代码中就会用四层嵌套的for语句，以此类推。 2.3 JavaScript 的数组方法参考 方法名 语法 concat 连接数组（一个或多个），返回连接后的结果 every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach 遍历数组 join 将所有的数组元素连接成一个字符串 indexOf 从数组开始查找数组元素在数组中的的位置，并返回，没有找到则返回-1 lastIndexOf 从数组结尾查找数组元素在数组中的的位置，并返回，没有找到则返回-1 map 遍历数组元素，并返回 reverse 颠倒数组中元素的顺序 slice 截取数组中的元素 some 对数组中的每一项运行给定函数，如果任一项返回true，则返回true sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 toString 将数组作为字符串返回 valueOf 和toString类似，将数组作为字符串返回 2.3.1 数组合并concat方法可以向一个数组传递数组、对象或是元素。数组会按照该方法传入的参数顺序连接指定数组。如下： var zero = 0; var positiveNumbers = [1,2,3]; var negativeNumbers = [-3,-2,-1]; var numbers = negativeNumbers.concat(zero, positiveNumbers); //[3,2,1,0,1,2,3] 2.3.1 迭代器函数迭代数组中的元素可以使用for循环，同样JavaScript内置了许多数组可用的迭代方法 解决如下案例： 假如有一个数组，它值是从1到15，如果数组里的元素可以被2整除（偶数），函数就返回true，否则返回false： var isEven = function (x) { // 如果x是2的倍数，就返回true console.log(x); return (x % 2 == 0) ? true : false; }; var numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; 用every方法迭代 numbers.every(isEven); //false //数组numbers的第一个元素是1，它不是2的倍数（1是奇数），因此isEven 函数返回false，然后every执行结束。 用some方法迭代 some方法会迭代数组的每个元素，直到函数返回true： numbers.some(isEven); //numbers数组中第一个偶数是2（第二个元素）。第一个被迭代的元素是1， isEven会返回false。第二个被迭代的元素是2，isEven返回true——迭代结束。 用forEach方法迭代 numbers.forEach(function(x){ console.log((x % 2 == 0)); }); 使用map和filter方法 var myMap = numbers.map(isEven); //[false, true, false, true, false, true, false, true,false, true, false, true, false, true, false]。 filter方法返回新数组由使函数返回true的元素组成： var evenNumbers = numbers.filter(isEven); //[2, 4, 6, 8, 10, 12, 14] 使用reduce方法 reduce方法接收一个函数作为参数，这个函数有四个参数：previousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器 numbers.reduce(function(previous, current, index){ return previous + current; //120 }); 2.4 ECMAScript 6 和数组的新功能下标展示了一些ES6和ES7新增的数组方法 方法 描述 @@iterator 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 copyWithin 复制数组中一系列元素到同一数组指定的起始位置 entries 返回包含数组所有键值对的@@iterator includes 如果数组中存在某个元素则返回true，否则返回false。ES7新增 find 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素 findIndex 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引-1 fill 用静态值填充数组-1 from 根据已有数组创建一个新数组 keys 返回包含数组所有索引的@@iterator of 根据传入的参数创建一个新数组 values 返回包含数组中所有值的@@iterator sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 除了这些新的方法，还有一种用for…of循环来迭代数组的新做法，以及可以从数组实例得到的迭代器对象 2.4.1 使用forEach和箭头函数迭代箭头函数可以简化使用forEach迭代数组元素的做法，如下 numbers.forEach(function (x) { console.log(x % 2 == 0); }); //这段代码可以简化如下： numbers.forEach(x =&gt; { console.log((x % 2 == 0)); }); 2.4.2 使用for…of循环迭代for (let n of numbers) { console.log((n % 2 == 0) ? &apos;even&apos; : &apos;odd&apos;); } 2.4.3 ES6新的迭代器（@@iterator）ES6还为Array类增加了一个@@iterator属性，需要通过Symbol.iterator来访问。代码如下: let iterator = numbers[Symbol.iterator](); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 console.log(iterator.next().value); // 4 console.log(iterator.next().value); // 5 然后，不断调用迭代器的next方法，就能依次得到数组中的值,数组中所有值都迭代完之后，iterator.next().value会返回undefined。 2.4.4 数组的entries、keys和values方法","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法一（javascript基础）","date":"2019-02-13T06:24:30.000Z","path":"2019/02/13/cjs5vw6ys0005novb1bay2qam/","text":"一、相等操作符（==和===）1.相等操作符（==）在使用==时，不同类型的值也可以被看作相等下面表格展示了不同类型的值用相等操作符比较后的结果。 类型（x） 类型（y） 结 果 null undefined true undefined null true 数字 字符串 x == toNumber(y) 字符串 数字 toNumber(x) == y 布尔值 任意类型 toNumber(x) == y 任意类型 布尔值 x == toNumber(y) 字符串或数字 对象 x == toPrimitive(y) 对象 字符串或数字 toPrimitive(x) == y 如果x和y是相同类型，JavaScript会比较它们的值或对象值。其他没有列在这个表格中的情况都会返回false。toNumber和toPrimitive方法是内部的，并根据以下表格对其进行估值。toNumber方法对不同类型返回的结果如下： 值类型 结 果 undefined NAN null +0 布尔值 如果是true，返回1；如果是false，返回+0 数字 数字对应的值 字符串 将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字 对象 Number(toPrimitive(vale)) toPrimitive方法对不同类型返回的结果如下： 值类型 结 果 对象 如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误 例：console.log(&apos;packt&apos; == true); //输出false 首先，布尔值会被toNumber方法转成数字，因此得到packt == 1。 其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式就变成了NaN == 1，结果就是false。 1.相等操作符（===）如果比较的两个值或者类型不同则返回false，如果比较的两个值类型相同，结果会根据下表判断。 类型（x） 类型（y） 结 果 数字 x和y数值相同（但不是NaN） true 字符串 x和y是相同的字符 true 布尔值 x和y都是true或false true 对象 x和y引用同一个对象 true 例：console.log(&apos;packt&apos; === true); //false console.log(&apos;packt&apos; === &apos;packt&apos;); //true 二、声明展开和剩余参数2.1展开操作符在es5中使用apply()函数将数组转化为参数，在es6中使用展开操作符(…); 例： var params = [1, 3, 5] function sum(a=1, b=3, c=4) { return a+b+c } console.log(sum(...params)); //es6使用扩展符传入数组 console.log(sum.apply(null, params)); //es5使用apply传入数组 在函数中也可以使用展开操作符(…)代替arguments，当做剩余参数使用，如下案例： function restParamaterFunction (x, y, ...a) { return (x + y) * a.length; } console.log(restParamaterFunction(1, 2, &quot;hello&quot;, true, 7)); //输出9; es5中实现 function restParamaterFunction(x, y) { var a = Array.prototype.slice.call(arguments, 2); console.log(a) return (x + y) * a.length; }; 2.2数组解构es6引入数组解构的概念，可以一次初始化多个变量，如下： var [x, y] = [&apos;a&apos;, &apos;b&apos;]; 等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; 数组解构也可以用来进行值的互换，而不需要创建临时变量，如下： [x, y] = [y, x]; //等同于 var temp = x, x = y, y = temp; 对象也可以解构，如下： //属性简写的功能， var [x, y] = [&apos;a&apos;, &apos;b&apos;]; var obj = { x, y }; console.log(obj); // { x: &quot;a&quot;, y: &quot;b&quot; } //等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; var obj2 = { x: x, y: y }; console.log(obj2); // { x: &quot;a&quot;, y: &quot;b&quot; } //方法属性 var hello = { name : &apos;abcdef&apos;, printHello() { console.log(&apos;Hello&apos;); } } console.log(hello.printHello()); //等同于 var hello = { name: &apos;abcdef&apos;, printHello: function printHello() { console.log(&apos;Hello&apos;); } }; 三、使用类进行面向对象编程声明一个book类的方式 function Book(title, pages, isbn){ //{1} this.title = title; this.pages = pages; this.isbn = isbn; } Book.prototype.printTitle = function(){ console.log(this.title); }; 使用es6可以简化为一下语法 只需要使用class关键字声明一个constructor函数和其他函数 class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } //以上两种声明据用相同的效果和输出 let book = new Book(&apos;title&apos;, &apos;pag&apos;, &apos;isbn&apos;); console.log(book.title); //输出图书标题 book.title = &apos;new title&apos;; //更新图书标题 console.log(book.title); //输出图书标题 3.1继承es6简化声明类的方式 如下： class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } class ITBook extends Book { //{扩展book并继承其行为 constructor (title, pages, isbn, technology) { super(title, pages, isbn); //引用父类的构造函数 this.technology = technology; } printTechnology(){ console.log(this.technology); } } let jsBook = new ITBook(&apos;学习JS算法&apos;, &apos;200&apos;, &apos;1234567890&apos;, &apos;JavaScript&apos;); console.log(jsBook.title); console.log(jsBook.printTechnology()); //我们可以使用extends关键字扩展一个类并继承它的行为。在构造函数中，也可以通过super关键字引用父类的构造函数。 3.2使用属性存取器使用新的类语法也可以为属性创建存取器函数。如下： class Person { constructor(name) { this._name = name; //{1} } get name() { //{2} return this._name; } set name(value) { //{3} this._name = value; } } let lotrChar = new Person(&apos;Frodo&apos;); console.log(lotrChar.name); //Frodo lotrChar.name = &apos;Gandalf&apos;; console.log(lotrChar.name); //Gandalf lotrChar._name = &apos;Sam&apos;; console.log(lotrChar.name); //Sam //要声明get和set函数，只需要在我们要暴露和使用的函数名前面加上get或set关键字。可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的。 然后，只要像普通的属性一样，引用它们的名字，就可以执行get和set函数。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"工作中遇到的问题总结","date":"2018-10-15T01:58:24.433Z","path":"2018/10/15/cjs5vw6yz000bnovbsx1w4m1q/","text":"一、element ui 的使用总结1.1. 自定义验证规则的使用在自定义验证规则的时候每一个判断里（if()else()或者if()else if() else()）都要有callback,否则表单在执行this.$refs[formName].validate((valid) =&gt; {}) 的时候，内部代码是不会执行的； &lt;el-form :model=&quot;ruleForm2&quot; status-icon :rules=&quot;rules2&quot; ref=&quot;ruleForm2&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt; &lt;el-input v-model.number=&quot;ruleForm2.age&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm2&apos;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;resetForm(&apos;ruleForm2&apos;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;script&gt; export default { data() { var checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&apos;年龄不能为空&apos;)); } setTimeout(() =&gt; { if (!Number.isInteger(value)) { callback(new Error(&apos;请输入数字值&apos;)); } else { if (value &lt; 18) { callback(new Error(&apos;必须年满18岁&apos;)); } else { callback();//不能省略，不然无法执行 } } }, 1000); }; var validatePass = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请输入密码&apos;)); } else { if (this.ruleForm2.checkPass !== &apos;&apos;) { this.$refs.ruleForm2.validateField(&apos;checkPass&apos;); } callback(); } }; var validatePass2 = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请再次输入密码&apos;)); } else if (value !== this.ruleForm2.pass) { callback(new Error(&apos;两次输入密码不一致!&apos;)); } else { callback(); } }; return { ruleForm2: { pass: &apos;&apos;, checkPass: &apos;&apos;, age: &apos;&apos; }, rules2: { pass: [ { validator: validatePass, trigger: &apos;blur&apos; } ], checkPass: [ { validator: validatePass2, trigger: &apos;blur&apos; } ], age: [ { validator: checkAge, trigger: &apos;blur&apos; } ] } }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { alert(&apos;submit!&apos;); } else { console.log(&apos;error submit!!&apos;); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); } } } &lt;/script&gt; 1.2移动端ios以及andriod兼容问题1.2.1 ios以及andriod使用overflow: scroll;遇到的问题；页面滚动时使用overflow：scroll;在ios端会出现滑动不流畅问题。 为了解决这个问题，首先我使用了-webkit-overflow-scrolling : touch;这个属性，发现使用这个属性以后，ios页面在滑动到底部或者顶部会出现页面卡死问题，在网上找了好多方法参考这篇文章https://hk.saowen.com/a/ba965995919b5f04ed8bcb7ccc5b4af1e95792e9769fd92a8d36881d1fad8683个人觉得这篇文章写得很好，试了一下这些方法，发现最后还是没有解决，最后发现不要用原生的滚动也就是overflow：scroll;并且阻止ios的默认滑动效果，改为使用better-scroll这个滚动插件完美解决了以上的问题；参考如下案例： &lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;contain-img wrapper&quot; ref=&quot;menuWrapper&quot; v-show=&quot;Show&quot; id=&quot;contain-img&quot;&gt; &lt;ul class=&quot;content&quot; id=&quot;content&quot; ref=&quot;content&quot;&gt; //合同图片显示 &lt;div class=&quot;img01&quot; id=&quot;img01&quot;&gt;&lt;img src=&quot;../../static/img/demo-detail01.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img02&quot;&gt; &lt;img id=&quot;img01&quot; src=&quot;../../static/img/demo-detail02.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;pact-sign&quot; v-show=&quot;isSubmit&quot; @click=&quot;sign()&quot;&gt;提交&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import BScroll from &apos;better-scroll&apos; export default { data() { return { contractImg: &apos;&apos;, isSubmit: true, Show: true } }, created() { this.$nextTick(()=&gt;{ //异步执行 setTimeout(() =&gt; { let containImg = document.getElementById(&quot;img01&quot;).offsetHeight; let bodyHeight = document.body.clientHeight; let distance = bodyHeight-containImg; let scrollHeight = containImg-distance; this.meunScroll=new BScroll(this.$refs.menuWrapper,{});//初始化better-scroll插件 this.meunScroll.scrollTo(0,-scrollHeight); //页面加载完滚动到某个位置 }, 100) }); this.$nextTick(function(){ document.getElementsByTagName(&quot;img&quot;)[0].onload =function() { document.body.addEventListener(&apos;touchmove&apos;, function (e) { e.preventDefault() // 阻止默认的处理方式(阻止下拉滑动的效果) }, {passive: false}) // passive 参数不能省略，用来兼容ios和android } }); }, beforeCreate() { document.title = &apos;签署确认&apos;; }, } &lt;/script&gt; &lt;style scoped&gt; *{ margin: 0; padding: 0; } body, html { height: 100%; width: 100%; background-color: #fff; } .container { width: 100%; height: 100%; } .contain-img { width: 100%; height: 100%; position: absolute; /* overflow: scroll; -webkit-overflow-scrolling : touch; */ } .container img { width: 100%; height: 100%; } .pact-sign { width: 40px; height: 40px; line-height: 40px; position: fixed; bottom: 40px; right: 20px; border-radius: 50%; background-color: #409EFF; text-align: center; color: #ffffff; z-index: 10; } .img01, .img02 { position: relative; overflow: hidden; } &lt;/style&gt; 1.3 prop以及attr的使用使用attr获取checked属性、disabled属性、select属性，如果这些属性默认选中可以取到值，如果未选中值返回undefined，使用prop则可以解决这些问题 官方文档建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()； 1.4 npm打包卡死问题修改为淘宝源：（npm config set registry http://registry.cnpmjs.org）；","tags":[]},{"title":"vue slot使用小结","date":"2018-10-11T08:51:22.124Z","path":"2018/10/11/cjs5vw6yw0007novb9z8g58iv/","text":"一、slot简介在vue实际项目开发当中，我们经常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在Vue中被称为内容分发。在Vue中，slot也分多种，从Vue的官网中可以获知，其主要分为：单个插槽、具名插槽和作用域插槽三种。下面就逐一介绍这三种插槽的用法： 二、slot插槽具体用法2.1单个插槽的使用从官网中（https://cn.vuejs.org/）我们知道，如果子组件template中没有包含任何一个时，就算父组件分发再多的内容也将会被丢弃。如下案例： 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; 父组件slotdemo组件 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图：上图所示在中添加内容并不会显示 只有子组件模板只中拥有一个没有属性的slot（可以有多个带属性的slot，后面的内容会介绍），父组件传入的整个内容片段才会被插入到slot所在的位置，并将替换掉slot本身，如果传入的内容为空则会显示slot的默认内容。如下案例： 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 当派发的内容为空时，会默认显示slot的内容 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.2具名插槽的使用可以用一个特殊的属性name来配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将根据name属性匹配内容片段中有对应slot属性的元素。 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div slot=&quot;header&quot;&gt;新的slotchildrenheader&lt;/div&gt; &lt;div slot=&quot;main&quot;&gt;新的内容&lt;/div&gt; &lt;div&gt;没有name&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt;//如果匹配不到内容显示在这 &lt;/header&gt; &lt;main&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.3作用域插槽的使用作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将prop传递给组件一样： &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;slot :text=&quot;msg&quot;&gt;&lt;/slot&gt;&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;&apos;, data() { return { msg: &quot;slot分发内容&quot;, } }, } &lt;/script&gt; 在父组件中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;template slot-scope=&quot;props&quot;&gt;//作用域模板插槽必须存在 &lt;div&gt;新的slotchildrenheader&lt;/div&gt; &lt;div&gt;新的内容&lt;div&gt;{{props.text}}&lt;/div&gt;&lt;/div&gt; &lt;/template&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图： 三、小结这篇文章主要介绍vue中的插槽的使用方法。只是一个空壳子，他的显示以及如何显示手父组件的控制，插槽显示的位置由子组件自身决定。父组件传过来的模板显示组件的template。使用slot可以帮助我们更容易，灵活的使用组件，同时也提高了组件的复用性。","tags":[{"name":"slot","slug":"slot","permalink":"https://www.23ybob.club/tags/slot/"},{"name":"vue","slug":"vue","permalink":"https://www.23ybob.club/tags/vue/"}]},{"title":"javascript权威指南理解片一","date":"2018-08-27T05:38:29.000Z","path":"2018/08/27/cjs5vw6yu0006novb0ebutf27/","text":"eval函数eval函数执行另一段javascript代码; eval(&quot;function f() {return x + 1}&quot;); //eval函数只有一个参数，如果参数不是字符串则直接返回这个函数 console.log(eval(11)); //11 //如果参数是字符串则会将字符串当做javascript代码进行编译执行 //并且返回最后一个表达式或语句得值，如果最后一个表达式或语句没有值则返回undefined； //eval使用的作用域是调用他的作用域；如果eval调用了全局函数，则返回的是全局变量的值，如果eval调用了局部函数，他会返回局部变量的值； var geval = eval; var x = &quot;global&quot;, y = &quot;global&quot;; function f() { var x = &quot;local &quot;; eval(&quot;x += &apos;changed&apos;;&quot;) //改变局部变量x的值 return x; } function g() { var y = &quot;local&quot;; geval(&quot;y += &apos; changed&apos;;&quot;); //改变全局变量y的值 return y; } console.log(f(), x); //local changed global console.log(g(), y); //local global changed 三元运算符x &gt; 0 ? x : -x 条件运算符的操作数可以是任意类型，第一个操作符如果是真值，那么返回第二个操作符的结果，如果第一个操作符是假值，则返回第三个操作符的结果； typeof 运算符","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"drafting","date":"2018-08-21T06:46:21.000Z","path":"2018/08/21/cjs5vw6yh0000novbxj6ctp98/","text":"实现目标div在另一个div中的拖拽效果最近项目中遇到的一个小功能，总结了一下，感觉还不错.github地址： https://github.com/Abriams/js-drafting &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;style&gt; *{ margin: 0; padding: 0; } #draft_big { border: 1px solid #FF3300; width: 300px; height: 300px; position: relative; margin-left: 400px; margin-top: 400px; } #draft_small { background: #99CC00; width: 50px; height: 50px; position: absolute; cursor: pointer; right: -80px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;draft_big&quot;&gt; &lt;div id=&quot;draft_small&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=&quot;javascript&quot;&gt; window.onload = function () { var draftBig = document.getElementById(&quot;draft_big&quot;); var draftSmall = document.getElementById(&quot;draft_small&quot;); draftSmall.onmousedown = function (event) { var e = e || window.event; //记录并保存可拖拽div（id为draftSmall的盒子）拖拽前的坐标 var startX = e.clientX - draftSmall.offsetLeft; var startY = e.clientY - draftSmall.offsetTop; // offsetHeight,包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话）; // offsetLeft,目标元素距离最近定位的父级元素左边的距离； // offsetTop,目标元素距离最近定位的父级元素上边的距离； // clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。 // clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的垂直坐标。 /*鼠标的移动事件*/ document.onmousemove = function(e) { //判断被拖拽的盒子（id为draftSmall的盒子）必须拖拽到目标盒子（id为draftBig盒子中）才能移动； if(e.clientX - 400 &lt; draftBig.offsetHeight &amp;&amp; e.clientX &gt; 400) { if(e.clientY -400 &lt; draftBig.offsetWidth &amp;&amp; e.clientY &gt; 400) { var e = e || window.event; //计算当前拖拽的盒子（id为draftSmall的盒子）在目标盒子（id为draftBig盒子）中的坐标； draftSmall.style.left = e.clientX - startX + &quot;px&quot;; draftSmall.style.top = e.clientY - startY + &quot;px&quot;; /*判断拖拽边界（id为draftSmall的盒子四个边界的判断）*/ if (e.clientX - startX &lt;= 0) { draftSmall.style.left = 0 + &quot;px&quot;; } if (e.clientY - startX &lt;= 0) { draftSmall.style.top = 0 + &quot;px&quot;; } if (e.clientX - startX &gt;= 250) { draftSmall.style.left = 250 + &quot;px&quot;; } if (e.clientY - startX &gt;= 250) { draftSmall.style.top = 250 + &quot;px&quot;; } } } }; /*鼠标的抬起事件,终止拖动*/ document.onmouseup = function() { document.onmousemove = null; document.onmouseup = null; }; }; }; &lt;/script&gt; &lt;/html&gt;","tags":[{"name":"js实现拖拽","slug":"js实现拖拽","permalink":"https://www.23ybob.club/tags/js实现拖拽/"}]},{"title":"认识es6","date":"2018-08-15T02:02:07.000Z","path":"2018/08/15/cjs5vw75i000nnovbcgz3fzmi/","text":"es6常用api介绍一、let和const命令介绍及区别1. let命令：1）、基本用法： es5只有两种方式声明变量var以及function，es6新增了四种let、const、import、class； let声明的变量的方式与var相似，但是声明的变量，只在let命令所在的代码块中生效; { let a = 1; var b = 2; } console.log(a);//Error in created hook: &quot;ReferenceError: a is not defined&quot; console.log(b);//2 上面在代码块中使用let，var分别声明了连个变量，然后再代码块外面调用，let声明的变量会报错，var声明的 返回值正常，表明let只在它所在的代码块中生效； 2）、let不存在变量提升问题 我们知道使用var声明的变量会存在变量提升问题，但是在let中不存在这种现象 console.log(a);//undefined var a = 1; console.log(b);//报错 let b = 2; 上述代码中，使用let声明了变量b，在声明之前使用会报错，而使用var声明的变量，在使用前值是undefined； 3）、暂时性死区在es6中规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，在声明前使用这些变量就会报错； var a = 1; { a = 3; console.log(a);//报错 let a; } 4）、不允许重复声明let不允许在相同作用域内重复声明同一个变量 // 报错 function fn1() { let a = 1; var a = 2; } // 报错 function fn2() { let a = 1; let a = 2; } function fn3(argements) { let argements; // 也会报错 } es6规定暂时性死区，以及let，const语句不提升变量，主要是为了减少运行时错误，防止在变量声明前就是用这个变量。从而导致意料之外的行为； 1. const命令：const声明一个常量，一旦声明，常量的值就不能改变了，所以const在声明是必须立即初始化，不能留到以后赋值，如果修改它的值会报错 const index = 1; console.log(index)//1 index = 3;// 报错 const num;报错 const声明的常量也不存在变量提升，同样的也是有暂时性死区，也不能重复声明变量 二、块级作用域1、块级作用域的用处在es5中只有全局作用域以及函数作用域，在许多情况下使用很不方便 var num = 1; function f() { console.log(num); if (false) { var num = 2; } } f(); // undefined //在上述代码中在函数内部声明的变量覆盖了外层声明的变量； var index = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 //在for循环中的计数变量会泄露到全局 2、es6中的块级作用域function fn1() { let i = 5; if (true) { let i = 10; } console.log(n); // 5 } //上述代码中存在两个代码块，都声明了变量i，在运行后输出5，说明function声明的代码块不受if(){}代码块的影响 { { {let i = 5}； console.log(i)//报错 } } //let只在当前代码块中生效,其他代码块中是无法使用的，在es6中允许使用作用域的任意嵌套 {{{ let i = 1; {let i = 2};//不报错，不同的作用域中可以声明同一个变量 }}} 3、块级作用域域函数作用域在es5中函数只能在顶层作用域中以及函数作用域中声明，不能再块级作用域中声明，而es6中则可以在块级作用域中声明函数，在块级作用域中声明的函数只在当前作用域中生效，对其他作用域不会造成影响；另外，es6的块级作用域内声明函数必须使用大括号，如果没有会报错 // 不报错 if (true) { function f() {} } // 报错 if (true) function f() {} 三、变量的解构赋值1、数组的解构赋值在es6以前为变量赋值只能指定值 let a = 1; let b = 2; let c = 3; 上述代码在es6中可以住这样写 let [a, b, c] = [1, 2, 3];//a=1,b=2,c=3 //只要等号两边的模式相同，左边的变量就会被赋值对应的值 { let [x, y] = [1, 2, 3] //x=1,y=2 }; { let [x, ,y] = [1, 2, 3] //x=1,y=3 }; { let [x, [y], [z]] = [1, [2], [3]] //x=1,y=2,z=3 }; { let [x, ...y] = [1, 2, 3, 4] //x=1,y=[2,3,4] }; { let [x, y, ...z] = [1] //x=1,y=undefined,z=[] }; 如果结构不成功就会返回undefined { let x = []; //x = undefined; } { let [x, y] = [1] //y =undefined; } 如果等号左边的变量只能匹配等号右边变量的一部分值，这种情况就是不完全解构，但是解构依然会成功； { let [x, y] = [1, 2, 3] //x=1,y=2; } { let [x, [y], z] = [1, [2, 4], 3] //x=1,y=2,z=3; } 如果等号右边不是数组（不可遍历的结构）就会报错 { let [x] = 1; let [y] = false; let [z] = NaN; let [a] = undefined; let [b] = null; let [c] = {}; } 结构赋值允许指定默认值 { let [x = 1] = [];//x = 1 let [i, n = 2] = [1];//i=1,n=2 let [a = 1, b = 2] = [3]//a=3,b=2 } 在es6内部使用严格相等运算符（===），来判断一个位置是否有值，所以只有一个数组成员严格等于undefined默认值才会生效 { let [x = 1] = [undefined] //x=1 let [y = 2] = [null] //y=null,以为null===undefined不成立； } 如果默认是一个表达式，那么这个表达式只有在用到的时候才会求值 { function fn() { console.log(111); } let [x = f()] = [1];//fn不会执行,因为x能取到值1 } 默认值也可以使用解构赋值的其他变量，但是该变量必须先声明 { let [x = 1, y = x] = [] //x= 1;y =2 } { let [x = 1, y = x] = [2] //x=2,y=2 } { let [x = y, y = 1] = [] //报错 y is not defined，因为y还没有声明 } 2、对象的解构赋值对象的结构和数组类似，但是数组的解构按数组的顺序一次取值，而对象是没有顺序的，变量名必须与属性名一直才能取到正确的值； { let {bar, foo} = {foo: 1, bar: 2} //foo:1,bar:2; let {bar1} = {foo1: 1, bar2: 2} //bar1的值为undefined； } 如果变量名与属性名不一致，必须要写成如下形式 { let {foo: foo1} = {foo: 1} //foo1:1 let foo2 = {num1: 10, num2: 20 }; let {num1: f1, num2: f2} = foo2; //f1:10, f2:20; } 变量结构的机制是先找到同名的属性，然后在赋值给对应的变量，如下： { let {bar: foo1} = {bar: 10, bar1: 20} //foo1:10; bar: error: bar is not defined //bar 只是匹配的模式，foo1才是变量，真正被赋值的是变量foo1而不是模式bar } 与数组解构一样对象的解构也可以嵌套 { let foo = { index: [ 10, { y: 20 } ] } let {index:[x, {y}]} = foo;//x:10,y:20 } 对象结构中要注意赋值的是变量，而不是模式，模式只是用来匹配变量的 { let obj = { foo: { index: { num: 1, col: 2 } } } let {foo:{index: {num,col}}} = obj; //num:1, col:2 } 对象的解构也可以指定默认值 { let {x=1} = {} //x=3 } { let {x: y= 1} = {} // y = 3; } { let {x: y= 1} = {null} // y:null; } //和数组一样默认值生效的条件也是严格等于undefined 如果解构失败，变量的值是undefined { let {foo} = {bar: 1} //foo:undefined } 如果解构模式是嵌套的对象，如果子对象所在的父对象不存在，则会报错 { let {foo: {bar}} = {x: 1} //报错 } 解构赋值允许等号左边的模式中，不放置任何变量名，因此如下写法是可以执行的 { ({} = [1, 2]) ({} = &apos;abc) ({} = []) } 也可以对数组进行对象属性的解构 { let arr = [1, 2, 3]; let {0: f1, [arr.length-1]: f2} = arr //f1:1, f2:3 } 2、字符串的解构赋值字符串在解构的时候会被转换成一个类似数组的对象 { let [A, B, C, D] = &apos;abcd&apos;; //A:a,B:b,C:c,D:d; } 3、数值和布尔值的解构赋值数值和布尔值的解构赋值会先转成对象（隐式调用toString方法） { let {toString: s} = 123;//true s === Number.prototype.toString(隐式调用) } { let {toString: s} = true;//true s === Boolean.prototype.toString } { let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError //undefined,null无法转成对象 } 4、函数参数的解构赋值{ function fn([x, y]) { return x + y; } fn([1, 2]);//3 } 函数参数的结解构也可以指定默认值 { function fn({x=3, y=4} = {}) { return [x, y] } fn({x:10, y:20});// [10, 20] fn(); // [3, 4] } 四、圆括号的使用es6对于圆括号的规则是可能导致解构发生歧义，就不能使用圆括号 1、不能使用圆括号的场景(1). 变量的声明赋值 { let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; //上面6个语句都会报错，因为它们都是变量声明语句，模式中不能使用圆括号 } (2). 函数参数 { function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } // 报错 //函数参数也属于变量声明，因此不能带有圆括号。 } (3). 赋值语句的模式 { ({ p: a }) = { p: 42 }; //报错 ([a]) = [5];//报错 } 1、能使用圆括号的场景(1). 赋值语句的非模式部分，可以使用圆括号。 { [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 } 五、函数1、箭头函数的使用在es6中允许使用“箭头”（=&gt;）定义函数 { var f = fn =&gt; v //以上代码等同于 var f = function fn(v) { return v } } 基本语法 { 用法一：参数1（单一参数） =&gt; {函数声明} //一个参数，多个执行语句 用法二：（参数1）（单一参数） =&gt; 表达式（只有一条语句）//单个参数一条执行语句 用法三：(参数1，参数2，... , 参数n) =&gt; {函数声明} //多个参数，多个执行语句 用法四：(参数1，参数2，... , 参数n) =&gt; 表达式（只有一条语句）//相当于(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }//多个参数，一条语句 用法五： () =&gt; {函数声明} //没有参数时使用()代替 } 其他使用 { var f = bar =&gt; ({foo: bar}) console.log(f(1)); //{foo: 1} //箭头函数如果想直接返回一个对象必须在对象外面加()，不然会报错 } { (参数1, 参数2, ...rest) =&gt; {函数声明} (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明} //可以使用默认参数以及剩余参数 } { let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6 //也可以使用解构 } 如果箭头函数不需要参数或者需要多个参数，则使用一个()代表参数部分 { var f1 = () =&gt; x //等同于 var f1 = function() {return x} } { var f1 = (index1, index2) =&gt; index1 + index2; //等同于var f1 = function(index1, index2) {return index1+index2} } 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 { var f1 = (index1, index2) =&gt; { return index1 + index2; } } 2、箭头函数注意点（1）、箭头函数内部的this是固定的，就是定义时所在的对象，而不是使用时调用的对象；（2）、不能当做构造函数使用，如果和new一起使用会抛出错误；（3）、箭头函数内部不存在arguments对象，但是可以用rest参数代替arguments对象；（4）、call 或 apply 调用在箭头函数中不能修改this指针，他们的第一个参数会被忽略（5）、箭头函数没有prototype属性。（6）、箭头函数在参数和箭头之间不能换行。","tags":[{"name":"es6","slug":"es6","permalink":"https://www.23ybob.club/tags/es6/"}]},{"title":"从零开始使用github page + hexo搭建个人博客","date":"2018-07-23T02:44:09.714Z","path":"2018/07/23/cjs5vw75m000qnovb9wn3jlki/","text":"首先附上我使用hexo搭建的博客：https://23ybob.club/github地址: https://github.com/Abriams/Abriams.github.io 简介：个人刚使用hexo+github page搭建完博客，感觉还是很有成就感，所以把自己的一些在搭建过程中遇到的问题总结了一下，并为大家介绍hexo的详细配置，如何将hexo布置到github上，以及最后绑定域名 写在前面：我是一名前端开发人员，经常都会浏览别人的博客，感觉很高大上，一直以后也希望有一个属于自己的博客，虽然以前也搭建过博客，但是做的不是很精细，博客也没有去维护，最近看了别人的文章感触挺深，所以参考一些资料自己完完全全搭建了一个博客，总体来说很简单，如果你是一名程序开发爱好者，刚好你也想搭建自己的博客，你可以认认真真阅读这篇文章，相信对你搭建博客会有很大帮助 废话不多说，直接开始搭建过程 一、安装搭建必须软件1. 安装node.js(直接去node官网下载自己需要的版本即可，这个应该不用多说了吧)2. 安装git（https://git-scm.com/download/win）2.1安装完成后再命令行输入git version查看是否安装成功如果安装成功鼠标右键就会出现Git GUI Here和Git Bash Here两个按钮，然后选择Git Bash Here即可打开git命令行 1. 安装教程：https://git-scm.com/download/win 2. Git入门教程：http://git.oschina.net/progit/ 3. git常用命令 - git clone仓库地址：将远程仓库clone到本地 - git init ：新建仓库 - git pull： 抓取远程仓库所有分支更新并合并到本地 - git add 文件名或者.：添加新文件 - git commit：提交你的修改 - git push：推送本地仓库更新到远程仓库 二、hexo介绍及安装Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.hexo安装在命令行输入 npm install -g hexo-cli 即可安装hexo安装完hexo还需安装将hexo部署到git page的deployer，在命令行输入 npm install hexo-deployer-git –save 2.使用hexo建立建立需要的文件选择自己要存放文件的目录，右键打开点击Git Bash Here，进入命令行执行 hexo init，安装完以后会在指定文件夹的中新建需要的文件，目录结构如下.git├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themeshexo配置参数可在https://hexo.io/zh-cn/docs/setup.html 中参看 3.执行hexohexo根目录中执行hexo generate 以及 hexo server，并且登录localhost:4000，即可看到本地的效果： 三、将博客布置到github Pages上经过以上步骤我们已经使用hexo搭建了一篇博客，但是我们只能通过本地查看，别人是不能看我们的博客的，所以现在我们需要将本地博客发布到服务器上，让别人也可以访问我们的博客，github Pages就可以帮我们实现这件事情，我们都知道github Pages的代码是保存在github上的所以现在我们需要在github上新建一个项目 1.注册github账号访问github官网： https://github.com/ 点击Sign Up注册自己的账号 2.创建项目代码库新用户点击New repository即可创建github Pages（如果已经创建过github Pages，点击github + 弹出新建github Pages主页，示例如下） 在弹出的github Pages主页中填写需要的内容 3.配置SSH密钥Github的SSH密钥可以使本地git项目与远程的github建立联系，这样我们就能将本地代码通过git操作实现与Github库的代码同步，具体操作如下： 1). 查看本机是否已经存在 SSH密钥（keys）打开git命令行（可在任一位置打开）运行 cd ~/. ssh 检查本机用户home目录下是否存在.ssh目录，如果，不存在此目录，则进行2).操作，否则，你本机已经存在ssh公钥和私钥，可以略过2).步，直接进入3).操作 2). 创建SSH密钥（keys）$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;（按照你提供的邮箱地址，创建一对密钥） 直接回车，会将密钥按默认文件进行存储当然了你也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 然后按照提示需要输入密码以及确认密码（一般其实也很安全，不需要密码，直接回车即可） 最后，输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 3). 在github中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。（运行完成后直接右键赋值即可 ） clip &lt; ~/.ssh/id_rsa.pub 3.1 登录github登录github进入Setting，如下图所示 3.2 选择SSH and GPG keys选择SSH and GPG keys，如下图所示 3.2 选择New SSH key点击右上角New SSH key即可添加 3.3 粘贴密钥将密钥粘贴在下方文本框中，如图 3.4 测试密钥输入下方命令，查看是否成功 ssh -T git@github.com 如果是如下所示，输入yes回车即可 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 3.5 设置用户信息现在已经通过SSH链接到了Github，但是git是根据用户的名字和邮箱来提交的，github也是用名字和邮箱处理权限的，为了方便可以使用如下命令设置自己的 邮箱和名字 git config --global user.name &quot;ryanlijianchang&quot;//用户名 git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 此时，SSH key已经配置成功，本机成功连接到github 四. 将hexo更新到github上4.1 打开github pages登录自己的github，选择刚才新建的github pages （Amriams/Amriams.github.io） 4.2 获取SSH类型地址进去页面选择clone or download， 再选择Use SSH，复制SSH密钥 4.3 配置hexo连接SSH打开新建的hexo根目录下的_config.yml文件 4.3 配置SSH在打开的文件里添加配置 deploy: type: git repository: git@github.com:Abriams/Abriams.github.io.git branch: master 如图： 4.4 将本地hexo代码布置到github上执行 hexo g -d 即可 执行时会让你输入github账号以及密码，输入完成后，回车即可在github pages服务器上访问我们的博客了，对应的地址就是username.github.io（我的博客是Abriams.github.io） 如果在上述执行过程中出现 ERROR Deployer not found: git，这个提示是你的deployer没有安装成功，所以需要安装 执行npm install hexo-deployer-git –save， 然后在执行hexo g -d就可将博客部署到github pages 上了 4.5 访问自己的博客访问https://Abriams.github.io就可看到自己的博客啦（https://您的用户名.github.io） 4.6 美化博客进入hexo官网https://hexo.io/themes/选择自己喜欢的主题即可 选择好主题后再打开Hexo文件夹下的themes目录（E:\\hexo\\BIOG\\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 等待下载完成后，打开Hexo文件夹下的配置文件_config.yml，修改参数为：theme: hexo-theme-next 然后依次执行 hexo g ， hexo s，打开浏览器，输入 http://localhost:4000/ 即可看见刚更新的主题啦。 更多hexo配置请在hexo官网https://hexo.io/zh-cn/docs/configuration.html查看详情 4.7部署新内容到github打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 执行完成后访问https://您的用户名.github.io即可 五. 使用hexo写博客首先新建文件 hexo n “文章标题” ，执行完成后会在项目E:\\hexo\\BIOG\\source_posts中生成 文章标题.md文件，当然，也可以直接在\\Hexo\\source_posts中新建一个md文件，然后使用markdown书写文章即可，文章完成后使用执行hexo g（生成）， hexo d（部署），就会将文章部署到github上 六.在hexo中华添加图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，（上传本地图片的插件） 3 等待一段时间后，再运行hexo n “xxxx”来生成md文件时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 七、将独立域名关联到github pages上1. 购买域名选择自己喜欢的域名购买即可，我是在腾讯云购买的一下一腾讯云为例https://cloud.tencent.com/?fromSource=gwzcw.234976.234976.234976 2. 配置域名域名买好后在https://console.qcloud.com/domain/mydomain 中管理自己的域名 进去我的域名页面点击解析，如下图 选择添加记录，添加即可，如下图 然后打开github pages你的项目，选择Settings 下拉到github pages设置添加域名 八.hexo中添加标签选项1 生成“标签页”并添加type属性打开命令行执行如下命令 hexo new page tags 成功后会提示INFO Created: ~/Documents/blog/source/tags/index.md 找到blog/source/tags/index.md的文件并添加type: “tags”如下所示： --- title: 文章分类 date: 2017-05-27 13:47:40 type: &quot;tags&quot; --- 2 给文章添加”tags”属性打开需要添加标签的文章，并添加tags属性，如下（tags后的- vuex就是标签内容） --- title: vuex个人理解 tags: - vuex --- 注意：只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 九.添加微博秀首先获取在微博上获取微博秀 &lt;iframe width=&quot;100%&quot; height=&quot;550&quot; class=&quot;share_self&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1&quot;&gt;&lt;/iframe&gt; 找到BIOG/themes/BlueLake/layout/_widget/weibo.jade文件将src=””里面的内容换成微博秀src=””里面的内容 然后找到跟目录下的_config.yml文件，将widgets:添加- weibo 如下： widgets: - recent_posts - category - tag - archive - weibo - links 注意：如果网站使用的是https协议，需要将微博秀中的http换成https即可； 10.设置百度分享（https）首先下载百度分享的文件 https://themebetter.com/uploads/2017/09/static.zip （解压码：themebetter）；将下载后的文件放到主题文件夹下的source文件夹下 修改百度分享代码：在主题文件夹下的layout/_partial/comment_js.jade 下全局搜索http://bgimg.share.baidu.com并去掉http://bgimg.share.baidu.com即可； window._bd_share_config={&quot;common&quot;:{&quot;bdSnsKey&quot;:{},&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;2&quot;,&quot;bdMiniList&quot;:[&quot;mshare&quot;,&quot;weixin&quot;,&quot;tsina&quot;,&quot;qzone&quot;,&quot;linkedin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;print&quot;,&quot;renren&quot;,&quot;sqq&quot;,&quot;evernotecn&quot;,&quot;bdysc&quot;,&quot;tqq&quot;,&quot;tqf&quot;,&quot;bdxc&quot;,&quot;kaixin001&quot;,&quot;tieba&quot;,&quot;douban&quot;,&quot;bdhome&quot;,&quot;thx&quot;,&quot;ibaidu&quot;,&quot;meilishuo&quot;,&quot;mogujie&quot;,&quot;diandian&quot;,&quot;huaban&quot;,&quot;duitang&quot;,&quot;hx&quot;,&quot;fx&quot;,&quot;youdao&quot;,&quot;sdo&quot;,&quot;qingbiji&quot;,&quot;people&quot;,&quot;xinhua&quot;,&quot;mail&quot;,&quot;isohu&quot;,&quot;yaolan&quot;,&quot;wealink&quot;,&quot;ty&quot;,&quot;iguba&quot;,&quot;h163&quot;,&quot;copy&quot;],&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;1&quot;,&quot;bdSize&quot;:&quot;16&quot;},&quot;share&quot;:{},&quot;image&quot;:{&quot;viewList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;],&quot;viewText&quot;:&quot;分享到：&quot;,&quot;viewSize&quot;:&quot;16&quot;},&quot;selectShare&quot;:{&quot;bdContainerClass&quot;:null,&quot;bdSelectMiniList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;]}};with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||head).appendChild(createElement(&apos;script&apos;)).src=&apos;http://bgimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)] //执行完上面几部发现请求的百度分享地址已经替换成了本地，但是在控制台会报错；这是hexo编译了static文件夹导致的； 最后修改根目录下的—_config.yml文件 找到skip_render并添加static/** ，如下所示 skip_render: static/** //防止hexo编译static文件导致报错； 小结：通过以上操作，一篇博客终于搭建成功了，虽然在搭建的过程中会遇到各种问题，这需要我们耐心解决，当所有问题都完成后，我个人收货到了很大成果，也希望各位小伙伴能有自己的收获，另外，既然博客搭建成功了，那么就一定要坚持下去，不需要每天都写，但是每个月写自己的总结心得，总是不过分的吧","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.23ybob.club/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://www.23ybob.club/tags/github-pages/"}]},{"title":"vuex个人理解","date":"2018-07-19T07:17:01.654Z","path":"2018/07/19/cjs5vw6yy000anovb2ejseh1p/","text":"什么是vuex及其作用vuex是一个转为vue.js开发的状态管理模式（如同redux是为react提供的状态管理模式），采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 什么是”状态管理模式”在我看来就是在vue中把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中，以供其他任意组件使用； vuex核心vuex核心就是store仓库，也就是一个容器，在这个容器中存储着vuex应用的状态（state） vuex特点 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 在vuex中你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 vuex案例实现1、将state,mutations,actions写在一起 安装vuex，在命令行执行如下命令（注意点：要加上–save，因为这个包在生产环境中是要使用的） npm install vuex –save 新建store文件夹（名称不唯一），并在store文件夹中新家store.js文件，然后引入vue,以及vuex；代码实现如下 import Vue from ‘vue’; import Vuex from ‘vuex’; 使用vuex，代码如下 Vue.use(Vuex); 通过以上3步vuex就可以使用了，接下来就用一个小案例具体实现 在main.js中引入刚新建的store文件 import store from ‘./store/store’ 在实例化Vue对象中加入store对象 new Vue({ el: &apos;#app&apos;, router, store,//使用store template: &apos;&lt;App/&gt;&apos;, components: { App } }) demo介绍 在store.js定义要使用的对象 const state = { count:1 } 在store.js中加入改变state的方法 //提交state的唯一途径（mutations），state对应上边const state中存储的值； const mutations={ add(state){ state.count++; } } actions提交mutations（actions不能直接提交state，只能通过提交mutations改变state） //提交mutations const actions ={ //Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象 addCount(context){ context.commit(&apos;add&apos;) } } getter获取store中的 state 中派生出的一些状态 getters: { counts: state =&gt; { return state.count - 1 } } 在组建中使用 新建count.vue组建具体代码如下 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;addCount&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; //在组件中通过mapState对象赋值 //首先引入mapState对象&apos;; //然后在computed计算属性里获取值并操作： &lt;script&gt; import {mapState} from &apos;vuex&apos;; export default { computed:mapState({ //理解为传入state对象，修改state.count属性； count:state=&gt;state.count }) } &lt;/script&gt; 2、将state,mutations,actions分开管理1.建立相应目录 src文件夹下新建store文件夹 在store文件夹下新建cart文件夹，index.js文件 在cart文件夹下新建state.js, mutations.js, mutation_type, actions.js, getters.js, index.js 在store文件夹下的index.js问价下添加如下代码 import Vue from ‘vue’; import Vuex from ‘vuex’; Vue.use(Vuex); import cart from ‘./cart/‘; export default new Vuex.Store({ modules: { cart } }); 在cart文件夹下的state.js定义要使用的对象 export default { count: 1, isshow: false, params: &apos;hide&apos; } 在mutations.js问价中改变state.js中的状态 import * as types from ‘./mutations_types’ export default { [types.COUNT_LOCAL](state) { state.count += 1 } , [types.REDUCE_LOCAL](state) { state.count -= 1 } , [types.ISSHOW_LOCAl](state,params) { state.isshow = !state.isshow state.params = &apos;hide&apos; ? &apos;show&apos; : &apos;hide&apos; } } 在mutations_type.js中分离mutations.js，便于后期维护 export const COUNT_LOCAL = ‘COUNT_LOCAL’ export const ISSHOW_LOCAl = ‘ISSHOW_LOCAl’ export const REDUCE_LOCAL = ‘REDUCE_LOCAL’ 在action.js中提交mutations import * as types from ‘./mutations_types’ export default { change_count: ({ commit }) =&gt; { commit(types.COUNT_LOCAL); }, change_isshow: ({ commit },{params}) =&gt; { commit(types.ISSHOW_LOCAl,{params}); }, change_reduce: ({ commit }) =&gt; { commit(types.REDUCE_LOCAL) } } 7.在getters.js中获取state中的派生状态 export default { getCount(state) { return state.count; } }; 在caet文件夹下的index.js中导出数据 import state from ‘./state’; import mutations from ‘./mutations’; import getters from ‘./getters’; import actions from ‘./actions’; export default { state, mutations, getters, actions }; 在组件中使用（使用dispatch提交） &lt;div&gt; &lt;h3&gt;&lt;/h3&gt; &lt;button @click=&quot;change()&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&apos;change_reduce&apos;)&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;getmessage()&quot;&gt;get&lt;/button&gt; &lt;input type=&quot;text&quot; :value=&quot;$store.state.cart.count&quot;&gt; &lt;button @click=&quot;changeShow()&quot; ref=&quot;hide&quot;&gt;hide&lt;/button&gt; &lt;input type=&quot;text&quot; v-show=&quot;show&quot; value=&quot;11&quot;&gt; &lt;/div&gt; &lt;script&gt; import { mapState } from &apos;vuex&apos; export default { data () { return { msg: &apos;Hellow Vuex&apos;, show: false } }, methods: { getmessage() { console.log(this.$store.state.cart.count) }, change() { this.$store.dispatch(&apos;change_count&apos;); }, changeShow() { let ishide = this.$store.state.cart.params; if( ishide == &apos;hide&apos;) { ishide = &apos;show&apos; } else { ishide = &apos;hide&apos; } console.log(ishide); this.$store.dispatch(&apos;change_isshow&apos;,&apos;ishide&apos;) this.show = this.$store.state.cart.isshow this.$refs.hide.innerHTML = this.$store.state.cart.params // console.log(this.$store.state.cart.params) } }, computed: { ...mapState({ count: state =&gt; { console.log(state.count) } }) } } &lt;/script&gt; 小结假如你的项目需要数据 和 组件 分离，分别处理，使用 Vuex 是非常合适的，相反，如果不需要分离处理，那么不使用 Vuex 也没关系。","tags":[{"name":"vuex","slug":"vuex","permalink":"https://www.23ybob.club/tags/vuex/"}]},{"title":"初识前端","date":"2018-07-19T06:02:57.119Z","path":"2018/07/19/cjs5vw6yo0002novb8z5ru6w8/","text":"在前端这个行业里漂泊也有几年了，一直都听别人说要随时写博客，记录工作中的一些问题，以此提升自己，可能由于各种原因吧，一直以后也没有写过博客，今天花了2个小时终于使用hexo+github page搭建了自己的博客，虽然中间遇到一些问题，但是在自己成功搭建博客后还是很开心的，很有成就感，以后还是要多写博客，记录自己经理过的一些问题 个人对前端的理解前端发展1.什么是前端虽然是做前端的，但是具体概念还真不知道，个人感觉就是写页面，渲染数据 2.前端演进史2.1.从静态走向动态大约1994就是前端发展的历史吧，前端都知道1943年10月13日网景公司推出了第一版Navigator；Tim Berners-Lee创建了W3C；Tim的基友发布了CSS。同样在这一年，为动态web网页设计的服务端脚本PHP诞生。 早期网页都是为了方便科学家看文章，传论文而制造的，这也就是为什么Web网页都基于Document，随着网页技术从学术机构走向社会，网页承载的功能已经不足以满足当前需求，因此早期网页的局限性也显示出来了 2.1.1 所有的网页都基于HTML页面，因为没有任何手段可以控制局部内容的显示和隐藏，因此任何局部的变化哪怕只多出一个标点符号，都只能重新下载一个新的页面。2.1.2 计算任务只能在服务端实现。由于网速限制，与服务器通信的过程是非常缓慢的，并且此过程是同步阻塞的，于是会出现这样的场景：用户提交一个表单，然后整个页面消失，浏览器呈现白屏，经过漫长的等待，浏览器渲染出一个和之前一模一样的页面，只不过输入框旁边多了一排红色小字：用户名错误。2.1.3 所有页面都是静态的，这意味着一个电商网站有一千种商品，哪怕页面布局一模一样，也必须写一千个单独的页面。1994年Rasmus Lerdorf为了维护个人网站而创建了PHP，PHP实现了与数据库的交互以及用于生产动态页面的模板引擎，是Web领域中最主流的服务端语言。 1995年网景推出了JavaScript，实现了客户端的计算任务（如表单验证）。 1996年微软推出了iframe标签，实现了异步的局部加载。 1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。 2006年，XMLHttpRequest被W3C正式纳入标准。 至此，早期的Document终于进化为了Web page，早期网页的三个局限都得到了妥善的解决。 2.2从后端走向前端早期网页都是有后端主导的，前端也就只是操作dom，2006年 John Resig发布了jQuery，主要用于操作DOM 起初制约Web开发从后到前的因素很简单，就是前端很多事干不了或干不好，当时的浏览器性能弱，标准化程度低，2008年问世的谷歌V8引擎改变了这一局面，现代浏览器的崛起终结了微软的垄断时代 ECMA也在2009年发布了第五代JavaScript 2009年AngularJS诞生，随后被谷歌收购。 2010年backbone.js诞生。 2011年React和Ember诞生。 2014年Vue.js诞生……前后端分离可谓大势所趋。 参考： Web开发的发展史http://blog.jobbole.com/45169/ https://www.cnblogs.com/leolovexx/p/7249314.html","tags":[{"name":"前端历史","slug":"前端历史","permalink":"https://www.23ybob.club/tags/前端历史/"}]}]