[{"title":"javascript数据结构与算法十（排序和搜索算法）","date":"2019-05-05T02:51:50.000Z","path":"2019/05/05/cjvasuimq000lckvbs9g1rqas/","text":"一、排序算法在开始排序算法之前，我们先创建一个数组（列表）来表示待排序和搜索的数据结构。 123456789function ArrayList() &#123; var array = []; //&#123;1&#125; this.insert = function (item) &#123; //&#123;2&#125; array.push(item); &#125;; this.toString = function () &#123; //&#123;3&#125; return array.join(); &#125;;&#125; 如你所见，ArrayList是一个简单的数据结构，它将项存储在数组中（行{1}）。我们只需要一个插入方法来向数据结构中添加元素（行{2}），用JavaScript Array类原生的push方法即可。最后，为了帮助我们验证结果，toString方法使用JavaScript原生Array类的join方法，来拼接数组中的所有元素至一个单一的字符串，这样我们就可以轻松地在浏览器的控制台输出结果了。 注意ArrayList类并没有任何方法来移除数据或插入数据到特定位置。我们刻意保持简单是为了能够专注于排序和搜索算法。所有的排序和搜索算法会添加至这个类中。 1.1 冒泡排序在开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 让我们来实现一下冒泡排序： 12345678910this.bubbleSort = function () &#123; var length = array.length; //&#123;1&#125; for (var i = 0; i &lt; length; i++) &#123; //&#123;2&#125; for (var j = 0; j &lt; length - 1; j++) &#123; //&#123;3&#125; if (array[j] &gt; array[j + 1]) &#123; //&#123;4&#125; swap(array, j, j + 1); //&#123;5&#125; &#125; &#125; &#125;&#125;; 首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。 现在我们得声明swap函数（一个私有函数，只能用在ArrayList类的内部代码中）： 12345var swap = function (array, index1, index2) &#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;&#125;; 交换时，我们用一个中间值来存储某一交换项的值。其他排序法也会用到这个方法，因此我们声明一个方法放置这段交换代码以便重用。 如果使用在第1章学过的ES6（ECMAScript 2015）增强的对象属性，这个函数可以写成下面这样： 1[array[index1], array[index2]] = [array[index2], array[index1]]; 下面这个示意图展示了冒泡排序的工作过程： 该示意图中每一小段表示外循环的一轮（行{2}），而相邻两项的比较则是在内循环中进行的（行{3}）。 我们将使用下面这段代码来测试冒泡排序算法，看结果是否和示意图所示一致： 1234567891011function createNonSortedArray(size) &#123; //&#123;6&#125; var array = new ArrayList(); for (var i = size; i &gt; 0; i--) &#123; array.insert(i); &#125; return array;&#125;var array = createNonSortedArray(5); //&#123;7&#125;console.log(array.toString()); //&#123;8&#125;array.bubbleSort(); //&#123;9&#125;console.log(array.toString()); //&#123;10&#125; 为了辅助测试本章将要学习的排序算法，我们将创建一个函数来自动地创建一个未排序的数组，数组的长度由函数参数指定（行{6}）。如果传递5作为参数，该函数会创建如下数组：[5, 4 ,3, 2, 1]。调用这个函数并将返回值存储在一个变量中，该变量将包含这个以某些数字来初始化的ArrayList类实例（行{7}）。我们在控制台上输出这个数组内容，确保这是一个未排序数组（行{8}），接着我们调用冒泡排序方法（行{9}）并再次在控制台上输出数组内容以验证数组已被排序了（行{10}）。 注意当算法执行外循环的第二轮的时候，数字4和5已经是正确排序的了。尽管如此，在后续比较中，它们还一直在进行着比较，即使这是不必要的。因此，我们可以稍稍改进一下冒泡排序算法。 改进后的冒泡排序 如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较（行{1}）。 12345678910this.modifiedBubbleSort = function()&#123; var length = array.length; for (var i=0; i&lt;length; i++)&#123; for (var j=0; j&lt;length-1-i; j++ )&#123; //&#123;1&#125; if (array[j] &gt; array[j+1])&#123; swap(j, j+1); &#125; &#125; &#125;&#125;; 下面这个示意图展示了改进后的冒泡排序算法是如何执行的： 1.2 选择排序选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。 下面是选择排序算法的源代码： 123456789101112131415this.selectionSort = function () &#123; var length = array.length, //&#123;1&#125; indexMin; for (var i = 0; i &lt; length - 1; i++) &#123; //&#123;2&#125; indexMin = i; //&#123;3&#125; for (var j = i; j &lt; length; j++) &#123; //&#123;4&#125; if (array[indexMin] &gt; array[j]) &#123; //&#123;5&#125; indexMin = j; //&#123;6&#125; &#125; &#125; if (i !== indexMin) &#123; //&#123;7&#125; swap(array, i, indexMin); &#125; &#125;&#125;; 首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。 用以下代码段来测试选择排序算法： 1234array = createNonSortedArray(5);console.log(array.toString()); //[5, 4, 3, 2, 1]array.selectionSort(); console.log(array.toString()); //[1, 2, 3, 4, 5] 下面的示意图展示了选择排序算法，此例基于之前代码中所用的数组。 数组底部的箭头指示出当前迭代轮寻找最小值的数组范围（内循环{4}），示意图中的每一步则表示外循环。 选择排序同样也是一个复杂度为O(n2)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。然而，接下来要学的插入排序比选择排序性能要好。 1.3 插入排序插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。 下面这段代码表示插入排序算法： 照例，算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。 下面的示意图展示了一个插入排序的实例： 举个例子，假定待排序数组是[3, 5, 1, 4, 2]。这些值将被插入排序算法按照下面形容的步骤进行排序。 (1) 3已被排序，所以我们从数组第二个值5开始。3比5小，所以5待在原位（数组的第二位）。3和5排序完毕。(2) 下一个待排序和插到正确位置上去的值是1（目前在数组的第三位）。5比1大，所以5被移至第三位去了。我们得分析1是否应该被插入到第二位——1比3大吗？不，所以3被移到第二位去了。接着，我们得证明1应该插入到数组的第一位上。因为0是第一个位置且没有负数位，所以1必须被插入到第一位。1、3、5三个数字已经排序。(3) 4应该在当前位置（索引3）还是要移动到索引较低的位置上呢？4比5小，所以5移动到索引3位置上去。那么应该把4插到索引2的位置上去吗？4要比3大，所以4插入到数组的位置3上。 下一个待插入的数字是2（数组的位置4）。5比2大，所以5移动至索引4。4比2大，所以4也得移动（位置3）。3也比2大，所以3还得移动。1比2小，所以2插入到数组的第二位置上。至此，数组已排序完成。 排序小型数组时，此算法比选择排序和冒泡排序性能要好。 1.4 归并排序归并排序是第一个可以被实际使用的排序算法。前面学到的三个排序算法性能不好，但归并排序性能不错，其复杂度为O(nlogn)。 JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。 归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 由于是分治法，归并排序也是递归的： 123this.mergeSort = function()&#123; array = mergeSortRec(array);&#125;; 像之前的章节一样，每当要实现一个递归函数，我们都会实现一个实际被执行的辅助函数。对归并排序我们也会这么做。我们将声明mergeSort方法以供随后使用，而mergeSort方法将会调用mergeSortRec，该函数是一个递归函数： 12345678910var mergeSortRec = function(array)&#123; var length = array.length; if(length === 1) &#123; //&#123;1&#125; return array; //&#123;2&#125; &#125; var mid = Math.floor(length / 2), //&#123;3&#125; left = array.slice(0, mid), //&#123;4&#125; right = array.slice(mid, length); //&#123;5&#125; return merge(mergeSortRec(left), mergeSortRec(right)); //&#123;6&#125;&#125;; 归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。 如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。 下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。 12345678910111213141516171819var merge = function (left, right) &#123; var result = [], // &#123;7&#125; il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; // &#123;8&#125; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); // &#123;9&#125; &#125; else &#123; result.push(right[ir++]); // &#123;10&#125; &#125; &#125; while (il &lt; left.length) &#123; // &#123;11&#125; result.push(left[il++]); &#125; while (ir &lt; right.length) &#123; // &#123;12&#125; result.push(right[ir++]); &#125; return result; // &#123;13&#125;&#125;; merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。 接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。 如果执行mergeSort函数，下图是具体的执行过程： 可以看到，算法首先将原始数组分割直至只有一个元素的子数组，然后开始归并。归并过程也会完成排序，直至原始数组完全合并并完成排序。 1.5 快速排序","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法九（图）","date":"2019-03-08T01:45:50.000Z","path":"2019/03/08/cjvasuiso001ackvbvhv71kkg/","text":"一、图的相关术语图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。 任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。 我们还可以使用图来表示道路、航班以及通信状态，如下图所示： 让我们来学习一下图在数学及技术上的概念。 一个图G = (V, E)由以下元素组成。 V：一组顶点E：一组边，连接V中的顶点 下图表示一个图： 在着手实现算法之前，让我们先了解一下图的一些术语。 由一条边连接在一起的顶点称为相邻顶点。比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。 一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3；E和其他两个顶点相连，因此，E的度为2。 路径是顶点v1, v2,…,vk的一个连续序列，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。 简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如A D C A（最后一个顶点重新回到A）。 如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。 1.1 有向图和无向图图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向： 如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的，而A和B不是强连通的。 图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值： 我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。 二、 图的表示从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。 2.1 邻接矩阵图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0，如下图所示： 不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而2维数组不太灵活。 2.2 邻接表我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。 尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质（例如，要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。在本书的示例中，我们将会使用邻接表表示法。 2.3 关联矩阵我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。 关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。 三、创建Graph类照例，我们声明类的骨架： 1234function Graph() &#123; var vertices = []; //&#123;1&#125; var adjList = new Dictionary(); //&#123;2&#125;&#125; 我们使用一个数组来存储图中所有顶点的名字（行{1}），以及一个字典（在第7章中已经实现）来存储邻接表（行{2}）。字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和adjList字典两者都是我们Graph类的私有属性。 接着，我们将实现两个方法：一个用来向图中添加一个新的顶点（因为图实例化后是空的），另外一个方法用来添加顶点之间的边。我们先实现addVertex方法： 1234this.addVertex = function(v)&#123; vertices.push(v); //&#123;3&#125; adjList.set(v, []); //&#123;4&#125;&#125;; 这个方法接受顶点v作为参数。我们将该顶点添加到顶点列表中（行{3}），并且在邻接表中，设置顶点v作为键对应的字典值为一个空数组（行{4}）。 现在，我们来实现addEdge方法： 1234this.addEdge = function(v, w)&#123; adjList.get(v).push(w); //&#123;5&#125; adjList.get(w).push(v); //&#123;6&#125;&#125;; 这个方法接受两个顶点作为参数。首先，通过将w加入到v的邻接表中，我们添加了一条自顶点v到顶点w的边。如果你想实现一个有向图，则行{5}就足够了。由于本章中大多数的例子都是基于无向图的，我们需要添加一条自w向v的边（行{6}）。 为了更方便一些，让我们来实现一下Graph类的toString方法，以便于在控制台输出图。 123456789101112this.toString = function()&#123; var s = ''; for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;10&#125; s += vertices[i] + ' -&gt; '; var neighbors = adjList.get(vertices[i]); //&#123;11&#125; for (var j=0; j&lt;neighbors.length; j++)&#123; //&#123;12&#125; s += neighbors[j] + ' '; &#125; s += '\\n'; //&#123;13&#125; &#125; return s;&#125;; 我们为邻接表表示法构建了一个字符串。首先，迭代vertices数组列表（行{10}），将顶点的名字加入字符串中。接着，取得该顶点的邻接表（行{11}），同样也迭代该邻接表（行{12}），将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符（行{13}），这样就可以在控制台看到一个漂亮的输出了。运行如下代码： 测试以上代码： 12345678910111213141516var graph = new Graph();var myVertices = ['A','B','C','D','E','F','G','H','I']; //&#123;7&#125;for (var i=0; i&lt;myVertices.length; i++)&#123; //&#123;8&#125; graph.addVertex(myVertices[i]);&#125;graph.addEdge('A', 'B'); //&#123;9&#125;graph.addEdge('A', 'C');graph.addEdge('A', 'D');graph.addEdge('C', 'D');graph.addEdge('C', 'G');graph.addEdge('D', 'G');graph.addEdge('D', 'H');graph.addEdge('B', 'E');graph.addEdge('B', 'F');graph.addEdge('E', 'I');console.log(graph.toString()); 为方便起见，我们创建了一个数组，包含所有我们想添加到图中的顶点（行{7}）。接下来，我们只要遍历vertices数组并将其中的值逐一添加到我们的图中（行{8}）。最后，我们添加想要的边（行{9}）。这段代码将会创建一个图，也就是到目前为止本章的示意图所使用的。 输出如下： 123456789A -&gt; B C DB -&gt; A E FC -&gt; A D GD -&gt; A C G HE -&gt; B IF -&gt; BG -&gt; C DH -&gt; DI -&gt; E 一个漂亮的邻接表！从该输出中，我们知道顶点A有这几个相邻顶点：B、C和D。 四、图的遍历和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。 在实现算法之前，让我们来更好地理解一下图遍历的思想方法。 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。 完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。 为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。 广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。 算 法 数据结构 描述 深度优先搜索 栈 通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 广度优先搜索 队列 通过将顶点存入队列中，最先入队列的顶点先被探索 当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。 白色：表示该顶点还没有被访问。灰色：表示该顶点被访问过，但并未被探索过。黑色：表示该顶点被访问过且被完全探索过。 这就是之前提到的务必访问每个顶点最多两次的原因。 4.1 广度优先搜索广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示： 以下是从顶点v开始的广度优先搜索算法所遵循的步骤。 (1) 创建一个队列Q。(2) 将v标注为被发现的（灰色），并将v入队列Q。(3) 如果Q非空，则运行以下步骤： (a) 将u从Q中出队列； (b) 将标注u为被发现的（灰色）； (c) 将u所有未被访问过的邻点（白色）入队列； (d) 将u标注为已被探索的（黑色）。 让我们来实现广度优先搜索算法： 12345678910111213141516171819202122232425262728var initializeColor = function () &#123; var color = []; for (var i = 0; i &lt; vertices.length; i++) &#123; color[vertices[i]] = 'white'; //&#123;1&#125; &#125; return color;&#125;; this.bfs = function (v, callback) &#123; var color = initializeColor(), //&#123;2&#125; queue = new Queue(); //&#123;3&#125; queue.enqueue(v); //&#123;4&#125; while (!queue.isEmpty()) &#123; //&#123;5&#125; var u = queue.dequeue(), //&#123;6&#125; neighbors = adjList.get(u); //&#123;7&#125; color[u] = 'grey'; // &#123;8&#125; for (var i = 0; i &lt; neighbors.length; i++) &#123; // &#123;9&#125; var w = neighbors[i]; // &#123;10&#125; if (color[w] === 'white') &#123; // &#123;11&#125; color[w] = 'grey'; // &#123;12&#125; queue.enqueue(w); // &#123;13&#125; &#125; &#125; color[u] = 'black'; // &#123;14&#125; if (callback) &#123; // &#123;15&#125; callback(u); &#125; &#125;&#125;; 广度优先搜索和深度优先搜索都需要标注被访问过的顶点。为此，我们将使用一个辅助数组color。由于当算法开始执行时，所有的顶点颜色都是白色（行{1}），所以我们可以创建一个辅助函数initializeColor，为这两个算法执行此初始化操作。 让我们深入学习广度优先搜索方法的实现。我们要做的第一件事情是用initializeColor函数来将color数组初始化为white（行{2}）。我们还需要声明和创建一个Queue实例（行{3}），它将会存储待访问和待探索的顶点。 照着本章开头解释过的步骤，bfs方法接受一个顶点作为算法的起始点。起始顶点是必要的，我们将此顶点入队列（行{4}）。 如果队列非空（行{5}），我们将通过出队列（行{6}）操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表（行{7}）。该顶点将被标注为grey（行{8}），表示我们发现了它（但还未完成对其的探索）。 对于u（行{9}）的每个邻点，我们取得其值（该顶点的名字——行{10}），如果它还未被访问过（颜色为white——行{11}），则将其标注为我们已经发现了它（颜色设置为grey——行{12}），并将这个顶点加入队列中（行{13}），这样当其从队列中出列的时候，我们可以完成对其的探索。 当完成探索该顶点和其相邻顶点后，我们将该顶点标注为已探索过的（颜色设置为black——行{14}）。 我们实现的这个bfs方法也接受一个回调（我们在第8章中遍历树时使用了一个相似的方法）。这个参数是可选的，如果我们传递了回调函数（行{15}），会用到它。 让我们执行下面这段代码来测试一下这个算法： 1234function printNode(value)&#123; //&#123;16&#125; console.log('Visited vertex: ' + value); //&#123;17&#125;&#125;graph.bfs(myVertices[0], printNode); //&#123;18&#125; 首先，我们声明了一个回调函数（行{16}），它仅仅在浏览器控制台上输出已经被完全探索过的顶点的名字。接着，我们会调用bfs方法，给它传递第一个顶点（A——从本章开头声明的myVertices数组）和回调函数。当我们执行这段代码时，该算法会在浏览器控制台输出下示的结果： Visited vertex: AVisited vertex: BVisited vertex: CVisited vertex: DVisited vertex: EVisited vertex: FVisited vertex: GVisited vertex: HVisited vertex: I 顶点被访问的顺序和本节开头的示意图中所展示的一致。 4.1.1 使用BFS寻找最短路径到目前为止，我们只展示了BFS算法的工作原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面这个问题。 给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。 对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改bfs方法以返回给我们一些信息： 从v到u的距离d[u]； 前溯点pred[u]，用来推导出从v到其他每个顶点u的最短路径。 123456789101112131415161718192021222324252627282930this.BFS = function (v) &#123; var color = initializeColor(), queue = new Queue(), d = [], //&#123;1&#125; pred = []; //&#123;2&#125; queue.enqueue(v); for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;3&#125; d[vertices[i]] = 0; //&#123;4&#125; pred[vertices[i]] = null; //&#123;5&#125; &#125; while (!queue.isEmpty()) &#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; color[w] = 'grey'; d[w] = d[u] + 1; //&#123;6&#125; pred[w] = u; //&#123;7&#125; queue.enqueue(w); &#125; &#125; color[u] = 'black'; &#125; return &#123; //&#123;8&#125; distances: d, predecessors: pred &#125;;&#125;; 让我们来看看改进过的广度优先方法的实现： 我们还需要声明数组d（行{1}）来表示距离，以及pred数组来表示前溯点。下一步则是对图中的每一个顶点，用0来初始化数组d（行{4}），用null来初始化数组pred。 当我们发现顶点u的邻点w时，则设置w的前溯点值为u（行{7}）。我们还通过给d[u]加1来设置v和w之间的距离（u是w的前溯点，d[u]的值已经有了）。 方法最后返回了一个包含d和pred的对象（行{8}）。 现在，我们可以再次执行BFS方法，并将其返回值存在一个变量中： 12var shortestPathA = graph.BFS(myVertices[0]);console.log(shortestPathA); 对顶点A执行BFS方法，以下将会是输出： 12distances: [A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3],predecessors: [A: null, B: \"A\", C: \"A\", D: \"A\", E: \"B\", F: \"B\", G: \"C\", H: \"D\", I: \"E\"] 这意味着顶点A与顶点B、C和D的距离为1；与顶点E、F、G和H的距离为2；与顶点I的距离为3。 通过前溯点数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径： 1234567891011121314var fromVertex = myVertices[0]; //&#123;9&#125;for (var i = 1; i &lt; myVertices.length; i++) &#123; //&#123;10&#125; var toVertex = myVertices[i], //&#123;11&#125; path = new Stack(); //&#123;12&#125; for (var v = toVertex; v !== fromVertex;v = shortestPathA.predecessors[v]) &#123; //&#123;13&#125; path.push(v); //&#123;14&#125; &#125; path.push(fromVertex); //&#123;15&#125; var s = path.pop(); //&#123;16&#125; while (!path.isEmpty()) &#123; //&#123;17&#125; s += ' - ' + path.pop(); //&#123;18&#125; &#125; console.log(s); //&#123;19&#125;&#125; 我们用顶点A作为源顶点（行{9}）。对于每个其他顶点（除了顶点A——行{10}），我们会计算顶点A到它的路径。我们从顶点数组得到toVertex（行{11}），然后会创建一个栈来存储路径值（行{12}）。 接着，我们追溯toVertex到fromVertex的路径（行{13}）。变量v被赋值为其前溯点的值，这样我们能够反向追溯这条路径。将变量v添加到栈中（行{14}）。最后，源顶点也会被添加到栈中，以得到完整路径。 这之后，我们创建了一个s字符串，并将源顶点赋值给它（它是最后一个加入栈中的，所以它是第一个被弹出的项 ——行{16}）。当栈是非空的，我们就从栈中移出一个项并将其拼接到字符串s的后面（行{18}）。最后（行{19}）在控制台上输出路径。 执行该代码段，我们会得到如下输出： A - BA - CA - DA - B - EA - B - FA - C - GA - D - HA - B - E - I 这里，我们得到了从顶点A到图中其他顶点的最短路径（衡量标准是边的数量）。 4.1.2 深入学习最短路径算法本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法），广度优先搜索未必合适。 举些例子，Dijkstra算法解决了单源最短路径问题。Bellman-Ford算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。Floyd-Warshall算法解决了求所有顶点对间的最短路径这一问题。 如文章开头提到的，图是一个广泛的主题，对最短路径问题及其变种问题，我们有很多的解决方案。但在开始学习这些其他解决方案前，我们需要掌握好图的基本概念，这是本章涵盖的内容。而这些其他解决方案则不会在本章讲述，但你可以自行探索图的奇妙世界 4.2深度优先搜索深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示： 深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。 要访问顶点v，照如下步骤做。 (1) 标注v为被发现的（灰色）。(2) 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。 如你所见，深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。 让我们来实现一下深度优先算法 12345678910111213141516171819202122this.dfs = function (callback) &#123; var color = initializeColor(); //&#123;1&#125; for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;2&#125; if (color[vertices[i]] === 'white') &#123; //&#123;3&#125; dfsVisit(vertices[i], color, callback); //&#123;4&#125; &#125; &#125;&#125;;var dfsVisit = function (u, color, callback) &#123; color[u] = 'grey'; //&#123;5&#125; if (callback) &#123; //&#123;6&#125; callback(u); &#125; var neighbors = adjList.get(u); //&#123;7&#125; for (var i = 0; i &lt; neighbors.length; i++) &#123; //&#123;8&#125; var w = neighbors[i]; //&#123;9&#125; if (color[w] === 'white') &#123; //&#123;10&#125; dfsVisit(w, color, callback); //&#123;11&#125; &#125; &#125; color[u] = 'black'; //&#123;12&#125;&#125;; 首先，我们创建颜色数组（行{1}），并用值white为图中的每个顶点对其做初始化，广度优先搜索也这么做的。接着，对于图实例中每一个未被访问过的顶点（行{2}和{3}），我们调用私有的递归函数dfsVisit，传递的参数为顶点、颜色数组以及回调函数（行{4}）。 当访问u顶点时，我们标注其为被发现的（grey——行{5}）。如果有callback函数的话（行{6}），则执行该函数输出已访问过的顶点。接下来一步是取得包含顶点u所有邻点的列表（行{7}）。对于顶点u的每一个未被访问过（颜色为white——行{10}和行{8}）的邻点w（行{9}），我们将调用dfsVisit函数，传递w和其他参数（行{11}——添加顶点w入栈，这样接下来就能访问它）。最后，在该顶点和邻点按深度访问之后，我们回退，意思是该顶点已被完全探索，并将其标注为black（行{12}）。 让我们执行下面的代码段来测试一下dfs方法： 输出如下： Visited vertex: AVisited vertex: BVisited vertex: EVisited vertex: IVisited vertex: FVisited vertex: CVisited vertex: DVisited vertex: GVisited vertex: H 这个顺序和本节开头处示意图所展示的一致。下面这个示意图展示了该算法每一步的执行过程： 在我们示例所用的图中，行{4}只会被执行一次，因为所有其他的顶点都有路径到第一个调用dfsVisit函数的顶点（顶点A）。如果顶点B第一个调用函数，则行{4}将会为其他顶点再执行一次（比如顶点A）。 4.2.1 深度优先搜索到目前为止，我们只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事情，而不只是输出被访问顶点的顺序。 对于给定的图G，我们希望深度优先搜索算法遍历图G的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。我们可以修改dfs方法来返回给我们一些信息： 顶点u的发现时间d[u]；当顶点u被标注为黑色时，u的完成探索时间f[u]；顶点u的前溯点p[u]。 让我们来看看改进了的DFS方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839var time = 0; //&#123;1&#125;this.DFS = function () &#123; var color = initializeColor(), //&#123;2&#125; d = [], f = [], p = []; time = 0; for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;3&#125; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for (i = 0; i &lt; vertices.length; i++) &#123; if (color[vertices[i]] === 'white') &#123; DFSVisit(vertices[i], color, d, f, p); &#125; &#125; return &#123; //&#123;4&#125; discovery: d, finished: f, predecessors: p &#125;;&#125;;var DFSVisit = function (u, color, d, f, p) &#123; console.log('discovered ' + u); color[u] = 'grey'; d[u] = ++time; //&#123;5&#125; var neighbors = adjList.get(u); for (var i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; p[w] = u; // &#123;6&#125; DFSVisit(w, color, d, f, p); &#125; &#125; color[u] = 'black'; f[u] = ++time; //&#123;7&#125; console.log('explored ' + u);&#125;; 我们需要一个变量来要追踪发现时间和完成探索时间（行{1}）。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他JavaScript方法（将变量作为引用传递的意思是如果该变量在其他方法内部被修改，新值会在原始变量中反映出来）。接下来，我们声明数组d、f和p（行{2}）。我们需要为图的每一个顶点来初始化这些数组（行{3}）。在这个方法结尾处返回这些值（行{4}），之后我们要用到它们。 当一个顶点第一次被发现时，我们追踪其发现时间（行{5}）。当它是由引自顶点u的边而被发现的，我们追踪它的前溯点（行{6}）。最后，当这个顶点被完全探索后，我们追踪其完成时间（行{7}）。 深度优先算法背后的思想是什么？边是从最近发现的顶点u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法回退到u被发现的地方去探索其他的边。这个过程持续到我们发现了所有从原始顶点能够触及的顶点。如果还留有任何其他未被发现的顶点，我们对新源顶点重复这个过程。重复该算法，直到图中所有的顶点都被探索了。 对于改进过的深度优先搜索，有两点需要我们注意： 时间（time）变量值的范围只可能在图顶点数量的一倍到两倍之间；对于所有的顶点u，d[u]&lt;f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）。 在这两个假设下，我们有如下的规则： 1 ≤ d [u] &lt; f [u] ≤ 2|V| 如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间： 4.2.2 拓扑排序——使用深度优先搜索给定下图，假定每个顶点都是一个我们需要去执行的任务： 这是一个有向图，意味着任务的执行是有顺序的。例如，任务F不能在任务A之前执行。注意这个图没有环，意味着这是一个无环图。所以，我们可以说该图是一个有向无环图（DAG）。 当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting，英文亦写作topsort或是toposort）。在日常生活中，这个问题在不同情形下都会出现。例如，当我们开始学习一门计算机科学课程，在学习某些知识之前得按顺序完成一些知识储备（你不可以在上算法I前先上算法II）。当我们在开发一个项目时，需要按顺序执行一些步骤，例如，首先我们得从客户那里得到需求，接着开发客户要求的东西，最后交付项目。你不能先交付项目再去收集需求。 拓扑排序只能应用于DAG。那么，如何使用深度优先搜索来实现拓扑排序呢？让我们在本节开头的示意图上执行一下深度优先搜索。 123456789101112graph = new Graph();myVertices = ['A','B','C','D','E','F'];for (i=0; i&lt;myVertices.length; i++)&#123;graph.addVertex(myVertices[i]);&#125;graph.addEdge('A', 'C');graph.addEdge('A', 'D');graph.addEdge('B', 'D');graph.addEdge('B', 'E');graph.addEdge('C', 'F');graph.addEdge('F', 'E');var result = graph.DFS(); 这段代码将创建图，添加边，执行改进版本的深度优先搜索算法，并将结果保存到result变量。下图展示了深度优先搜索算法执行后，该图的发现和完成时间 现在要做的仅仅是以倒序来排序完成时间数组，这便得出了该图的拓扑排序： B - A - D - C - F - E 注意之前的拓扑排序结果仅是多种可能性之一。如果我们稍微修改一下算法，就会有不同的结果，比如下面这个结果也是众多其他可能性中的一个： A - B - C - D - F - E 五、 最短路径算法设想你要从街道地图上的A点，通过可能的最短路径到达B点。举例来说，从洛杉矶的圣莫尼卡大道到好莱坞大道，如下图所示： 这种问题在生活中非常常见，我们（特别是生活在大城市的人们）会求助于苹果地图、谷歌地图、Waze等应用程序。当然，我们也有其他的考虑，如时间或路况，但根本的问题仍然是：从A到B的最短路径是什么？ 我们可以用图来解决这个问题，相应的算法被称为最短路径。本节我们将介绍两种非常著名的算法，即Dijkstra算法和Floyd-Warshall算法。 5.1 Dijkstra 算法Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。 考虑下图： 我们来看看如何找到顶点A和其余顶点之间的最短路径。但首先，我们需要声明表示上图的邻接矩阵，如下所示： 123456var graph = [[0, 2, 4, 0, 0, 0], [0, 0, 1, 4, 2, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 2], [0, 0, 0, 3, 0, 2], [0, 0, 0, 0, 0, 0]]; 现在，通过下面的代码来看看Dijkstra算法是如何工作的： 1234567891011121314151617181920this.dijkstra = function (src) &#123; var dist = [], visited = [], length = this.graph.length; for (var i = 0; i &lt; length; i++) &#123; //&#123;1&#125; dist[i] = Number.MAX_SAFE_INTEGER; visited[i] = false; &#125; dist[src] = 0; //&#123;2&#125; for (var i = 0; i &lt; length - 1; i++) &#123; //&#123;3&#125; var u = minDistance(dist, visited); //&#123;4&#125; visited[u] = true; //&#123;5&#125; for (var v = 0; v &lt; length; v++) &#123; if (!visited[v] &amp;&amp; this.graph[u][v] != 0 &amp;&amp; dist[u] != Number.MAX_SAFE_INTEGER &amp;&amp; dist[u] + this.graph[u][v] &lt; dist[v]) &#123; //&#123;6&#125; dist[v] = dist[u] + this.graph[u][v]; //&#123;7&#125; &#125; &#125; &#125; return dist; //&#123;8&#125;&#125;; 下面是对算法过程的描述。 行{1}：首先，把所有的距离（dist）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），将visited[]初始化为false。行{2}：然后，把源顶点到自己的距离设为0。行{3}：接下来，要找出到其余顶点的最短路径。行{4}：为此，我们需要从尚未处理的顶点中选出距离最近的顶点。行{5}：把选出的顶点标为visited，以免重复计算。行{6}：如果找到更短的路径，则更新最短路径的值（行{7}）。行{8}：处理完所有顶点后，返回从源顶点（src）到图中其他顶点最短路径的结果。 要计算顶点间的minDistance，就要搜索dist数组中的最小值，返回它在数组中的索引： 12345678910var minDistance = function(dist, visited) &#123; var min = INF, minIndex = -1; for (var v = 0; v &lt; dist.length; v++) &#123; if (visited[v] == false &amp;&amp; dist[v] &lt;= min) &#123; min = dist[v]; minIndex = v; &#125; &#125; return minIndex;&#125;; 对本节开始的图执行以上算法，会得到如下输出： 1234560 01 22 33 64 45 6 5.2 Floyd-Warshall 算法Floyd-Warshall算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。 Floyd-Warshall算法实现如下： 1234567891011121314151617181920212223242526272829303132333435363738 this.floydWarshall = function() &#123; var dist = [], length = this.graph.length, i, j, k; for (i = 0; i &lt; length; i++) &#123; //&#123;1&#125; dist[i] = []; for (j = 0; j &lt; length; j++) &#123; dist[i][j] = this.graph[i][j]; &#125; &#125; for (k = 0; k &lt; length; k++) &#123; //&#123;2&#125; for (i = 0; i &lt; length; i++) &#123; for (j = 0; j &lt; length; j++) &#123; if (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; //&#123;3&#125; dist[i][j] = dist[i][k] + dist[k][j]; //&#123;4&#125; &#125; &#125; &#125; &#125; return dist; &#125;; 下面是对算法过程的描述:&gt; 行&#123;1&#125;：首先，把dist数组初始化为每个顶点之间的权值，因为i到j可能的最短距离就是这些顶点间的权值。&gt; 行&#123;2&#125;：通过k，得到i途径顶点0至k，到达j的最短路径。&gt; 行&#123;3&#125;：判断i经过顶点k到达j的路径是否比已有的最短路径更短。&gt; 行&#123;4&#125;：如果是更短的路径，则更新最短路径的值。行&#123;3&#125;是Floyd-Warshall算法的核心。对本节开始的图执行以上算法，会得到如下输出：```javascript 0 2 3 6 4 6 INF 0 1 4 2 4 INF INF 0 6 3 5 INF INF INF 0 INF 2 INF INF INF 3 0 2 INF INF INF INF INF 0 其中，INF代表顶点i到j的最短路径不存在。 对图中每一个顶点执行Dijkstra算法，也可以得到相同的结果。 六、 最小生成树最小生成树（MST）问题是网络设计中常见的问题。想象一下，你的公司有几间办公室，要以最低的成本实现办公室电话线路相互连通，以节省资金，最好的办法是什么？ 这也可以应用于岛桥问题。设想你要在n个岛屿之间建造桥梁，想用最低的成本实现所有岛屿相互连通。 这两个问题都可以用MST算法来解决，其中的办公室或者岛屿可以表示为图中的一个顶点，边代表成本。这里我们有一个图的例子，其中较粗的边是一个MST的解决方案。 6.1 Prim 算法Prim算法是一种求解加权无向连通图的MST问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。 现在，通过下面的代码来看看Prim算法是如何工作的： 123456789101112131415161718192021222324this.prim = function() &#123; var parent = [], key = [], visited = []; length = this.graph.length, i; for (i = 0; i &lt; length; i++) &#123; //&#123;1&#125; key[i] = INF; visited[i] = false; &#125; key[0] = 0; //&#123;2&#125; parent[0] = -1; for (i = 0; i &lt; length-1; i++) &#123; //&#123;3&#125; var u = minKey(key, visited); //&#123;4&#125; visited[u] = true; //&#123;5&#125; for (var v = 0; v &lt; length; v++) &#123; if (this.graph[u][v] &amp;&amp; visited[v] == false &amp;&amp; this.graph[u][v] &lt; key[v]) &#123; //&#123;6&#125; parent[v] = u; //&#123;7&#125; key[v] = this.graph[u][v]; //&#123;8&#125; &#125; &#125; &#125; return parent; //&#123;9&#125;&#125;; 下面是对算法过程的描述。 行{1}：首先，把所有顶点（key）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），visited[]初始化为false。行{2}：其次，选择第一个key作为第一个顶点，同时，因为第一个顶点总是MST的根节点，所以parent[0] = -1。行{3}：然后，对所有顶点求MST。行{4}：从未处理的顶点集合中选出key值最小的顶点（与Dijkstra算法中使用的函数一样，只是名字不同）。行{5}：把选出的顶点标为visited，以免重复计算。行{6}：如果得到更小的权值，则保存MST路径（parent，行{7}）并更新其权值（行{8}）。行{9}：处理完所有顶点后，返回包含MST的结果。 比较Prim算法和Dijkstra算法，我们会发现除了行{7}和行{8}之外，两者非常相似。行{7}用parent数组保存MST的结果。行{8}用key数组保存权值最小的边，而在Dijkstra算法中，用dist数组保存距离。我们可以修改Dijkstra算法，加入parent数组。这样，就可以在求出距离的同时得到路径。 对如下的图执行以上算法： 123456var graph = [[0, 2, 4, 0, 0, 0], [2, 0, 2, 4, 2, 0], [4, 2, 0, 0, 3, 0], [0, 4, 0, 0, 3, 2], [0, 2, 3, 3, 0, 2], [0, 0, 0, 2, 2, 0]]; 我们会得到如下输出： 123456Edge Weight0 - 1 21 - 2 25 - 3 21 - 4 24 - 5 2 6.1 Kruskal 算法和Prim算法类似，Kruskal算法也是一种求加权无向连通图的MST的贪心算法。 现在，通过下面的代码来看看Kruskal算法是如何工作的： 123456789101112131415161718192021222324this.kruskal = function() &#123; var length = this.graph.length, parent = [], cost, ne = 0, a, b, u, v, i, j, min; cost = initializeCost(); //&#123;1&#125; while (ne &lt; length-1) &#123; //&#123;2&#125; for (i = 0, min = INF; i &lt; length; i++) &#123; //&#123;3&#125; for (j = 0; j &lt; length; j++) &#123; if (cost[i][j] &lt; min) &#123; min = cost[i][j]; u = i; v = j; &#125; &#125; &#125; u = find(u, parent); //&#123;4&#125; v = find(v, parent); //&#123;5&#125; if (union(u, v, parent)) &#123; //&#123;6&#125; ne++; &#125; cost[u][v] = cost[v][u] = INF; //&#123;7&#125; &#125; return parent;&#125; 下面是对算法过程的描述。 行{1}：首先，把邻接矩阵的值复制到cost数组，以方便修改且可以保留原始值行{7}。行{2}：当MST的边数小于顶点总数减1时。行{3}：找出权值最小的边。行{4}和行{5}：检查MST中是否已存在这条边，以避免环路。行{6}：如果u和v是不同的边，则将其加入MST。行{7}：从列表中移除这些边，以免重复计算。行{8}：返回MST。 下面是find函数的定义。它能防止MST出现环路： 123456var find = function(i, parent) &#123; while (parent[i]) &#123; i = parent[i]; &#125; return i;&#125;; union函数的定义如下: 1234567var union = function(i, j, parent) &#123; if (i != j) &#123; parent[j] = i; return true; &#125; return false;&#125;; 这个算法有几种变体。这取决于对边的权值排序时所使用的数据结构（如优先队列），以及图是如何表示的。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法八（树）","date":"2019-02-28T08:08:07.000Z","path":"2019/02/28/cjvasuisn0019ckvb3bu8e97g/","text":"到目前为止，我们学习了一些顺序数据结构，学习的第一个非顺序数据结构是散列表。在节章，我们将要学习另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用。 一、 树数据结构树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图，如下图所示： 二、 树的相关术语一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点： 位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。 一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）。 三、 二叉树和二叉搜索树二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。 二叉搜索树将是我们在本章中要研究的数据结构。 3.1 创建 BinarySearchTree 类让我们开始创建自己的BinarySearchTree类。首先，声明它的结构： 12345678function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125;&#125; 下图展现了二叉搜索树数据结构的组织方式： 和链表一样，将通过指针来表示节点之间的关系（术语称其为边）。在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树，使用同样的方式（也使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。因此，将声明一个Node类来表示树中的每个节点（行{1}）。值得注意的一个小细节是，不同于在之前的章节中将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼。 我们将会遵循和LinkedList类中相同的模式，这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是根元素（行{2}） 然后，我们需要实现一些方法。下面是将要在树类中实现的方法。 insert(key)：向树中插入一个新的键。 search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。 inOrderTraverse：通过中序遍历方式遍历所有节点。 preOrderTraverse：通过先序遍历方式遍历所有节点。 postOrderTraverse：通过后序遍历方式遍历所有节点。 min：返回树中最小的值/键。 max：返回树中最大的值/键。 remove(key)：从树中移除某个键。 3.1.1 向树中插入一个键下面的代码是用来向树插入一个新键的算法的第一部分： 12345678this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125;&#125;; 要向树中插入一个新的节点（或项），要经历三个步骤。 第一步是创建用来表示新节点的Node类实例（行{1}）。只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针的值会由构造函数自动设置为null。 第二步要验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点（行{2}）。如果是，就将根节点指向新节点 第三步是将节点加在非根节点的其他位置。这种情况下，需要一个私有的辅助函数（行{3}），函数定义如下： 123456789101112131415var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125;&#125;; 如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入树的根节点和要插入的节点。 如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}），那么需要检查当前节点的左侧子节点。如果它没有左侧子节点（行{5}），就在那里插入新的节点。 如果有左侧子节点，需要通过递归调用insertNode方法（行{7}）继续找到树的下一层。在这里，下次将要比较的节点将会是当前节点的左侧子节点。 如果节点的键比当前节点的键大，同时当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。如果有右侧子节点，同样需要递归调用insertNode方法，但是要用来和新节点比较的节点将会是右侧子节点。 让我们通过一个例子来更好地理解这个过程。 考虑下面的情景：我们有一个新的树，并且想要向它插入第一个值。 12var tree = new BinarySearchTree();tree.insert(11); 这种情况下，树中有一个单独的节点，根指针将会指向它。源代码的行{2}将会执行。 现在，来考虑下图所示树结构的情况： 创建上图所示的树的代码如下，它们接着上面一段代码（插入了键为11的节点）之后输入执行： 12345678910111213tree.insert(7);tree.insert(15);tree.insert(5);tree.insert(3);tree.insert(9);tree.insert(8);tree.insert(10);tree.insert(13);tree.insert(12);tree.insert(14);tree.insert(20);tree.insert(18);tree.insert(25); 同时我们想要插入一个值为6的键，执行下面的代码： tree.insert(6); 下面的步骤将会被执行。 树不是空的，行{3}的代码将会执行。insertNode方法将会被调用（root, key[6]）。 算法将会检测行{4}（key[6] &lt; root[11]为真），并继续检测行{5}（node.left[7]不是null），然后将到达行{7}并调用insertNode（node.left[7], key[6]）。 将再次进入insertNode方法内部，但是使用了不同的参数。它会再次检测行{4}（key[6]&lt; node[7]为真），然后再检测行{5}（node.left[5]不是null），接着到达行{7}，调用insertNode（node.left[5], key[6]）。 将再一次进入insertNode方法内部。它会再次检测行{4}（key[6] &lt; node[5]为假），然后到达行{8}（node.right是null 然后，方法调用会依次出栈，代码执行过程结束 这是插入键6后的结果： 四、树的遍历遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做呢？应该从树的顶端还是底端开始呢？从左开始还是从右开始呢？访问树的所有节点有三种方式：中序、先序和后序。 4.1 中序遍历中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。我们来看它的实现： 123this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback); //&#123;1&#125;&#125;; inOrderTraverse方法接收一个回调函数作为参数。回调函数用来定义我们对遍历到的每个节点进行的操作（这也叫作访问者模式，要了解更多关于访问者模式的信息，请参考http://en.wikipedia.org/wiki/Visitor_pattern）。由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）。 1234567var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125;&#125;; 要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为null（这就是停止递归继续执行的判断条件——行{2}——递归算法的基本条件）。 然后，递归调用相同的函数来访问左侧子节点（行{3}）。接着对这个节点进行一些操作（callback），然后再访问右侧子节点（行{5}）。 我们试着在之前展示的树上执行下面的方法： 1234function printNode(value)&#123; //&#123;6&#125; console.log(value);&#125;tree.inOrderTraverse(printNode); //&#123;7&#125; 但首先，需要创建一个回调函数（行{6}）。我们要做的，是在浏览器的控制台上输出节点的值。然后，调用inOrderTraverse方法并将回调函数作为参数传入（行{7}）。当执行上面的代码后，下面的结果将会在控制台上输出（每个数字将会输出在不同的行）： 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25 完整案例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//创建 BinarySearchTree 类function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125; //私有的辅助函数 var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125; &#125;; //insert向树中插入一个键 this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125; &#125;; //inOrderTraverse中序遍历 this.inOrderTraverse = function (callback) &#123; // console.log(callback) inOrderTraverseNode(root, callback); //&#123;1&#125; &#125;; var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125; &#125;; // tree.inOrderTraverse(printNode); //&#123;7&#125; &#125; let binarySearchTree = new BinarySearchTree();function printNode(value) &#123; //&#123;6&#125; console.log(value);&#125;binarySearchTree.insert(7);binarySearchTree.insert(15);binarySearchTree.insert(5);binarySearchTree.insert(3);binarySearchTree.insert(9);binarySearchTree.insert(8);binarySearchTree.insert(10);binarySearchTree.insert(13);binarySearchTree.insert(12);binarySearchTree.insert(14);binarySearchTree.insert(20);binarySearchTree.insert(18);binarySearchTree.insert(25); binarySearchTree.insert(6); binarySearchTree.inOrderTraverse(printNode) 下面的图描绘了inOrderTraverse方法的访问路径： 4.2 先序遍历先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。 我们来看实现: 1234567891011this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback);&#125;; //preOrderTraverseNode方法的实现如下：var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key); //&#123;1&#125; preOrderTraverseNode(node.left, callback); //&#123;2&#125; preOrderTraverseNode(node.right, callback); //&#123;3&#125; &#125;&#125;; 先序遍历和中序遍历的不同点是，先序遍历会先访问节点本身（行{1}），然后再访问它的左侧子节点（行{2}），最后是右侧子节点（行{3}），而中序遍历的执行顺序是：{2}、{1}和{3}。 下面是控制台上的输出结果（每个数字将会输出在不同的行）： 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25 下面的图描绘了preOrderTraverse方法的访问路径： 4.3 后序遍历后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。 我们来看它的实现： 1234567891011this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback);&#125;;//postOrderTraverseNode方法的实现如下：var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); //&#123;1&#125; postOrderTraverseNode(node.right, callback); //&#123;2&#125; callback(node.key); //&#123;3&#125; &#125;&#125;; 这个例子中，后序遍历会先访问左侧子节点（行{1}），然后是右侧子节点（行{2}），最后是父节点本身（行{3}）。 你会发现，中序、先序和后序遍历的实现方式是很相似的，唯一不同的是行{1}、{2}和{3}的执行顺序。 下面是控制台的输出结果（每个数字将会输出在不同行）： 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11 下面的图描绘了postOrderTraverse方法的访问路径： 五、搜索树中的值在树中，有三种经常执行的搜索类型： 搜索最小值搜索最大值搜索特定的值 5.1 搜索最小值和最大值我们使用下面的树作为示例： 只用眼睛看这张图，你能一下找到树中的最小值和最大值吗？ 如果你看一眼树最后一层最左侧的节点，会发现它的值为3，这是这棵树中最小的键。如果你再看一眼树最右端的节点（同样是树的最后一层），会发现它的值为25，这是这棵树中最大的键。这条信息在我们实现搜索树节点的最小值和最大值的方法时能给予我们很大的帮助。 首先，我们来看寻找树的最小键的方法： 123this.min = function() &#123; return minNode(root);&#125; min方法将会暴露给用户。这个方法调用了minNode方法（行{1}）： 123456789var minNode = function(node) &#123; if(node) &#123; while(node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node.key; &#125; return null;&#125; minNode方法允许我们从树中任意一个节点开始寻找最小的键。我们可以使用它来找到一棵树或它的子树中最小的键。因此，我们在调用minNode方法的时候传入树的根节点（行{1}），因为我们想要找到整棵树的最小键。 在minNode内部，我们会遍历树的左边（行{2}和行{3}）直到找到树的最下层（最左端）。 以相似的方式，可以实现max方法： 1234567891011121314this.max = function() &#123; return maxNode(root);&#125;//maxNode方法实现var maxNode = function(node) &#123; if(node) &#123; while(node &amp;&amp; node.right !== null) &#123; node = node.right; &#125; return node.key; &#125; return null;&#125; 要找到最大的键，我们要沿着树的右边进行遍历（行{5}）直到找到最右端的节点。 因此，对于寻找最小值，总是沿着树的左边；而对于寻找最大值，总是沿着树的右边。 5.2 搜索一个特定的值在之前的学习中，我们同样实现了find、search或get方法来查找数据结构中的一个特定的值（和之前实现的has方法相似）。我们将同样在BST中实现搜索的方法，来看它的实现： 123456789101112131415this.search = function (key) &#123; return searchNode(root, key); //&#123;1&#125;&#125;;var searchNode = function (node, key) &#123; if (node === null) &#123; //&#123;2&#125; return false; &#125; if (key &lt; node.key) &#123; //&#123;3&#125; return searchNode(node.left, key); //&#123;4&#125; &#125; else if (key &gt; node.key) &#123; //&#123;5&#125; return searchNode(node.right, key); //&#123;6&#125; &#125; else &#123; return true; //&#123;7&#125; &#125;&#125;; 我们要做的第一件事，是声明search方法。和BST中声明的其他方法的模式相同，我们将会使用一个辅助函数（行{1}）。 searchNode方法可以用来寻找一棵树或它的任意子树中的一个特定的值。这也是为什么在行{1}中调用它的时候传入树的根节点作为参数。 在开始算法之前，先要验证作为参数传入的node是否合法（不是null）。如果是null的话，说明要找的键没有找到，返回false。 如果传入的节点不是null，需要继续验证。如果要找的键比当前的节点小（行{3}），那么继续在左侧的子树上搜索（行{4}）。如果要找的键比当前的节点大，那么就从右侧子节点开始继续搜索（行{6}），否则就说明要找的键和当前节点的键相等，就返回true来表示找到了这个键（行{7}）。 可以通过下面的代码来测试这个方法： console.log(binarySearchTree.search(1) ? ‘Key 1 found.’ : ‘Key 1 not found.’);console.log(binarySearchTree.search(8) ? ‘Key 8 found.’ : ‘Key 8 not found.’); 输出结果如下： Value 1 not found.Value 8 found. 让我们详细展示查找1这个键的时候方法是如何执行的。 (1) 调用searchNode方法，传入根节点作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们执行到行{3}。(2) （key[1] &lt; node[11]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[7], key[1]）作为参数。(3) （node[7]）不是null（{2}），因此继续执行行{3}。(4) （key[1] &lt; node[7]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[5], key[1]）作为参数。(5) （node[5]）不是null（行{2}），因此继续执行行{3}。(6) （key[1] &lt; node[5]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[3], key[1]）作为参数。(7) （node[3]）不是null（行{2}），因此来到行{3}。(8) （key[1] &lt; node[3]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（null, key[1]）作为参数。null被作为参数传入是因为node[3]是一个叶节点（它没有子节点，所以它的左侧子节点的值为null）。(9) 节点（null）的值为null（行{2}，这时要搜索的节点为null），因此返回false。(10) 然后，方法调用会依次出栈，代码执行过程结束。 让我们再来查找值为8的节点。 (1) 调用searchNode方法，传入root作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们来到行{3}。(2) （key[8] &lt; node[11]）为真（行{3}），因此执行到行{4}并再次调用searchNode方法，传入（node[7], key[8]）作为参数。(3) （node[7]）不是null，因此来到行{3}。(4) （key[8] &lt; node[7]）为假（行{3}），因此来到行{5}。(5) （key[8] &gt; node[7]）为真（行{5}），因此来到行{6}并再次调用searchNode方法，传入（node[9], key[8]）作为参数。(6) （node[9]）不是null（行{2}），因此来到行{3}。(7) （key[8] &lt; node[9]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[8], key[8]）作为参数。(8) （node[8]）不是null（行{2}），因此来到行{3}。(9) （key[8] &lt; node[8]）为假（行{3}），因此来到行{5}。(10)（key[8] &gt; node[8]）为假（行{5}），因此来到行{7}并返回true，因为node[8]就是要找的键。(11) 然后，方法调用会依次出栈，代码执行过程结束。 5.3 移除一个节点我们要为BST实现的下一个、也是最后一个方法是remove方法。这是我们在本书中要实现的最复杂的方法。我们先创建这个方法，使它能够在树的实例上被调用： 123this.remove = function(key)&#123; root = removeNode(root, key); //&#123;1&#125; &#125;; 这个方法接收要移除的键并且它调用了removeNode方法，传入root和要移除的键作为参数（行{1}）。我要提醒大家的一件非常重要的事情是，root被赋值为removeNode方法的返回值。我们稍后会明白其中的原因。 removeNode方法的复杂之处在于我们要处理不同的运行场景，当然也包括它同样是通过递归来实现的。 我们来看removeNode方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940this.remove = function (key) &#123; root = removeNode(root, key); //&#123;1&#125; &#125;; var removeNode = function (node, key) &#123; if (node === null) &#123; //&#123;2&#125; return null; &#125; if (key &lt; node.key) &#123; //&#123;3&#125; node.left = removeNode(node.left, key); //&#123;4&#125; return node; //&#123;5&#125; &#125; else if (key &gt; node.key) &#123; //&#123;6&#125; node.right = removeNode(node.right, key); //&#123;7&#125; return node; //&#123;8&#125; &#125; else &#123; //键等于node.key //第一种情况——一个叶节点 if (node.left === null &amp;&amp; node.right === null) &#123; //&#123;9&#125; node = null; //&#123;10&#125; return node; //&#123;11&#125; &#125; //第二种情况——一个只有一个子节点的节点 if (node.left === null) &#123; //&#123;12&#125; node = node.right; //&#123;13&#125; return node; //&#123;14&#125; &#125; else if (node.right === null) &#123; //&#123;15&#125; node = node.left; //&#123;16&#125; return node; //&#123;17&#125; &#125; //第三种情况——一个有两个子节点的节点 var aux = findMinNode(node.right); //&#123;18&#125; node.key = aux.key; //&#123;19&#125; node.right = removeNode(node.right, aux.key); //&#123;20&#125; return node; //&#123;21&#125; &#125; var findMinNode = function (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node; &#125;; &#125;; 我们来看行{2}，如果正在检测的节点是null，那么说明键不存在于树中，所以返回null。 然后，我们要做的第一件事，就是在树中找到要移除的节点。因此，如果要找的键比当前节点的值小（行{3}），就沿着树的左边找到下一个节点（行{4}）。如果要找的键比当前节点的值大（行{6}），那么就沿着树的右边找到下一个节点（行{7}）。 如果我们找到了要找的键（键和node.key相等），就需要处理三种不同的情况。 5.3.1第一种情况是该节点是一个没有左侧或右侧子节点的叶节点——行{9}。在这种情况下，我们要做的就是给这个节点赋予null值来移除它（行{9}）。但是当学习了链表的实现之后，我们知道仅仅赋一个null值是不够的，还需要处理指针。在这里，这个节点没有任何子节点，但是它有一个父节点，需要通过返回null来将对应的父节点指针赋予null值（行{11}）。 现在节点的值已经是null了，父节点指向它的指针也会接收到这个值，这也是我们要在函数中返回节点的值的原因。父节点总是会接收到函数的返回值。另一种可行的办法是将父节点和节点本身都作为参数传入方法内部。 如果回头来看方法的第一行代码，会发现我们在行{4}和行{7}更新了节点左右指针的值，同样也在行{5}和行{8}返回了更新后的节点。 下图展现了移除一个叶节点的过程： 5.3.2 移除有一个左侧或右侧子节点的节点现在我们来看第二种情况，移除有一个左侧子节点或右侧子节点的节点。这种情况下，需要跳过这个节点，直接将父节点指向它的指针指向子节点。如果这个节点没有左侧子节点（行{12}），也就是说它有一个右侧子节点。因此我们把对它的引用改为对它右侧子节点的引用（行{13}）并返回更新后的节点（行{14}）。如果这个节点没有右侧子节点，也是一样——把对它的引用改为对它左侧子节点的引用（行{16}）并返回更新后的值（行{17}）。 下图展现了移除只有一个左侧子节点或右侧子节点的节点的过程： 5.3.3 移除有两个子节点的节点现在是第三种情况，也是最复杂的情况，那就是要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。 (1) 当找到了需要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们改变了这个节点的键，也就是说它被移除了。(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。 findMinNode方法的实现和min方法的实现方式是一样的。唯一不同之处在于，在min方法中只返回键，而在findMinNode中返回了节点。 下图展现了移除有两个子节点的节点的过程： 六、 自平衡树BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层，如下图所示： 这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作Adelson-Velskii-Landi树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树。 6.1 Adelson-Velskii-Landi 树（AVL 树）AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1。添加或移除节点时，AVL树会尽可能尝试转换为完全树。 6.1.1 在AVL树中插入节点在AVL树中插入或移除节点和BST完全相同。然而，AVL树的不同之处在于我们需要检验它的平衡因子，如果有需要，则将其逻辑应用于树的自平衡。 下面的代码是向AVL树插入新节点的例子： 12345678910111213141516var insertNode = function(node, element) &#123; if (node === null) &#123; node = new Node(element); &#125; else if (element &lt; node.key) &#123; node.left = insertNode(node.left, element); if (node.left !== null) &#123; // 确认是否需要平衡 &#123;1&#125; &#125; &#125; else if (element &gt; node.key) &#123; node.right = insertNode(node.right, element); if (node.right !== null) &#123; // 确认是否需要平衡 &#123;2&#125; &#125; &#125; return node;&#125;; 然而，插入新节点时，还要检查是否需要平衡树（行{1}和行{2}） 计算平衡因子 在AVL树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）的差值，该值（hr－hl）应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。这就是平衡因子的概念。 下图举例说明了一些树的平衡因子（所有的树都是平衡的）： 计算节点高度的代码如下： 1234567var heightNode = function(node) &#123; if (node === null) &#123; return -1; &#125; else &#123; return Math.max(heightNode(node.left),heightNode(node.right)) + 1; &#125;&#125;; 因此，向左子树插入新节点时，需要计算其高度；如果高度大于1（即不为-1、0和1之一），就需要平衡左子树。代码如下： 12345678910// 替换insertNode方法的行&#123;1&#125;if ((heightNode(node.left) - heightNode(node.right)) &gt; 1) &#123; // 旋转 &#123;3&#125;&#125;//向右子树插入新节点时，应用同样的逻辑，代码如下：// 替换insertNode方法的行&#123;2&#125;if ((heightNode(node.right) - heightNode(node.left)) &gt; 1) &#123; // 旋转 &#123;4&#125;&#125; AVL旋转 向AVL树插入节点时，可以执行单旋转或双旋转两种平衡操作，分别对应四种场景。 右-右（RR）：向左的单旋转左-左（LL）：向右的单旋转左-右（LR）：向右的双旋转右-左（RL）：向左的双旋转 我们依次看看它们是如何工作的。 右-右（RR）：向左的单旋转 如下图所示： 假设向AVL树插入节点90，这会造成树失衡（节点50-Y高度为-2），因此需要恢复树的平衡。下面是我们执行的操作： 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为-2）所在的位置（行{1}）；节点X的右子树保持不变；将节点Y的右子节点置为节点X的左子节点Z（行{2}）；将节点X的左子节点置为节点Y（行{3}）。 下面的代码举例说明了整个过程： 123456var rotationRR = function(node) &#123; var tmp = node.right; // &#123;1&#125; node.right = tmp.left; // &#123;2&#125; tmp.left = node; // &#123;3&#125; return tmp;&#125;; 左-左（LL）：向右的单旋转 如下图所示： 假设向AVL树插入节点5，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作： 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为+2）所在的位置（行{1}）；节点X的左子树保持不变；将节点Y的左子节点置为节点X的右子节点Z（行{2}）；将节点X的右子节点置为节点Y（行{3}）。 下面的代码举例说明了整个过程： 123456var rotationLL = function(node) &#123; var tmp = node.left; // &#123;1&#125; node.left = tmp.right; // &#123;2&#125; tmp.right = node; // &#123;3&#125; return tmp;&#125;; 左-右（LR）：向右的双旋转 如下图所示： 假设向AVL树插入节点35，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作： 将节点X置于节点Y（平衡因子为+2）所在的位置；将节点Y的左子节点置为节点X的右子节点；将节点Z的右子节点置为节点X的左子节点；将节点X的右子节点置为节点Y；将节点X的左子节点置为节点Z。 基本上，就是先做一次RR旋转，再做一次LL旋转 下面的代码举例说明了整个过程： 1234var rotationLR = function(node) &#123; node.left = rotationRR(node.left); return rotationLL(node);&#125;; 右-左（RL）：向左的双旋转 如下图所示： 假设向AVL树插入节点75，这会造成树失衡（节点70-Y高度为-2），需要恢复树的平衡。下面是我们执行的操作： 将节点X置于节点Y（平衡因子为-2）所在的位置；将节点Z的左子节点置为节点X的右子节点；将节点Y的右子节点置为节点X的左子节点；将节点X的左子节点置为节点Y；将节点X的右子节点置为节点Z。 基本上，就是先做一次LL旋转，再做一次RR旋转 下面的代码举例说明了整个过程： 1234var rotationRL = function(node) &#123; node.right = rotationLL(node.right); return rotationRR(node);&#125;; 完成insertNode方法 确认树需要平衡后，就需要对每种情况分别应用正确的旋转。 向左子树插入新节点，且节点的值小于其左子节点时，应进行LL旋转。否则，进行LR旋转。该过程的代码如下： 123456789// 替换insertNode方法的行&#123;1&#125;if ((heightNode(node.left) - heightNode(node.right)) &gt; 1)&#123; // 旋转 &#123;3&#125; if (element &lt; node.left.key)&#123; node = rotationLL(node); &#125; else &#123; node = rotationLR(node); &#125;&#125; 向右子树插入新节点，且节点的值大于其右子节点时，应进行RR旋转。否则，进行RL旋转。该过程的代码如下： 123456789// 替换insertNode方法的行&#123;2&#125;if ((heightNode(node.right) - heightNode(node.left)) &gt; 1)&#123; // 旋转 &#123;4&#125; if (element &gt; node.right.key)&#123; node = rotationRR(node); &#125; else &#123; node = rotationRL(node); &#125;&#125; 七、 小结在本节中，我们学习了在计算机科学中被广泛使用的基本树数据结构——二叉搜索树中添加、搜索和移除项的算法。我们同样介绍了访问树中每个节点的三种遍历方式。此外还学习了如何开发名叫AVL的自平衡树。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法七（字典和散列表）","date":"2019-01-18T11:40:59.000Z","path":"2019/01/18/cjvasuird0016ckvbis2b71yf/","text":"字典和散也是用来存储唯一值（不重复的值）的数据结构。 集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。 一、 字典前面已经学习过，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。 1.1 创建字典首先创建Dictionary类的骨架： 123function Dictionary() &#123; var items = &#123;&#125;;&#125; 与Set类类似，我们将在一个Object的实例而不是数组中存储元素。然后，我们需要声明一些映射/字典所能使用的方法。 set(key,value)：向字典中添加新元素。delete(key)：通过使用键值来从字典中移除键值对应的数据值。has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。get(key)：通过键值查找特定的数值并返回。clear()：将这个字典中的所有元素全部删除。size()：返回字典所包含元素的数量。与数组的length属性类似。keys()：将字典所包含的所有键名以数组形式返回。values()：将字典所包含的所有数值以数组形式返回。 1.1.1 has 和 set 方法我们首先来实现has(key)方法。之所以要先实现这个方法，是因为它会被set和remove等其他方法调用。我们可以通过如下代码来实现： 123this.has = function(key) &#123; return key in items;&#125;; 这个方法的实现和我们之前在Set类中的实现是一样的。我们使用JavaScript中的in操作符来验证一个key是否是items对象的一个属性。 然后是set方法的实现： 123this.set = function(key, value) &#123; items[key] = value; //&#123;1&#125;&#125;; 该方法接受一个key和一个value作为参数。我们直接将value设为items对象的key属性的值。它可以用来给字典添加一个新的值，或者用来更新一个已有的值。 1.1.2 delete方法接下来，我们实现delete方法。它和Set类中的delete方法很相似，唯一的不同点在于我们将先搜索key（而不是value）： 1234567this.delete= function(key) &#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false;&#125;; 然后我们可以使用JavaScript的delete操作符来从items对象中移除key属性。 1.1.3 get和values方法如果我们想在字典中查找一个特定的项，并检索它的值，可以使用下面的方法： 123this.get = function(key) &#123; return this.has(key) ? items[key] : undefined;&#125;; get方法首先会验证我们想要检索的值是否存在（通过查找key值），如果存在，将返回该值，反之将返回一个undefined值（请记住undefined值和null值是不一样的 下一个是values方法。这个方法以数组的形式返回字典中所有values实例的值： 123456789this.values = function() &#123; let values = []; for(var key in items) &#123; //&#123;1&#125; if(this.has(key)) &#123; values.push(items[key]) //&#123;2&#125; &#125; &#125; return values&#125; 首先，我们遍历items对象的所有属性值（行{1}）。为了确定值存在，我们使用has函数来验证key确实存在，然后将它的值加入values数组（行{2}）。最后，我们就能返回所有找到的值。 我们不能仅仅使用for-in语句来遍历items对象的所有属性，还需要使用hasOwnProperty方法（验证items对象是否包含某个属性），因为对象的原型也会包含对象的其他属性（JavaScript基本的Object类中的属性将会被继承，并存在于当前对象中，而对于这个数据结构来说，我们并不需要它们）。 1.1.4 clear、size、keys和getItems方法clear和size 方法与前面介绍的Set类中对应的方法是完全一样的。 keys方法返回在Dictionary类中所有用于标识值的键名。要取出一个JavaScript对象中所有的键名，可以把这个对象作为参数传入Object类的keys方法（到目前为止，书中创建的类，包括Dictionary在内，都是JavaScript对象），如下： 123this.keys = function() &#123; return object.keys(items)&#125; 最后，我们来验证items属性的输出值。我们可以实现一个返回items变量的方法，叫作getItems： 123this.getItems = function() &#123; return items;&#125; 1.1.5 使用Dictionary首先，我们来创建一个Dictionary类的实例，然后给它添加三条电子邮件地址。我们将会使用这个dictionary实例来实现一个电子邮件地址簿。 使用我们创建的类来执行如下代码： 1234var dictionary = new Dictionary();dictionary.set('Gandalf', 'gandalf@email.com');dictionary.set('John', 'johnsnow@email.com');dictionary.set('Tyrion', 'tyrion@email.com'); 如果执行了如下代码，输出结果将会是true： console.log(dictionary.has(‘Gandalf’)); 下面的代码将会输出3，因为我们向字典实例中添加了三个元素： console.log(dictionary.size()); 现在，执行下面的几行代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.get(‘Tyrion’)); 输出结果分别如下所示： [“Gandalf”, “John”, “Tyrion”][“gandalf@email.com“, “johnsnow@email.com“, “tyrion@email.com“]tyrion@email.com 最后，再执行几行代码： dictionary.delete(‘John’); 再执行下面的代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.getItems()); 输出结果如下所示： [“Gandalf”, “Tyrion”][“gandalf@email.com“, “tyrion@email.com“]Object {Gandalf: “gandalf@email.com“, Tyrion:”tyrion@email.com“} 移除了一个元素后，现在的dictionary实例中只包含两个元素了。 二、 散列表接下来我们会学到HashTable类，也叫HashMap类，它是Dictionary类的一种散列表实现方式。 散列算法的作用是尽可能快地在数据结构中找到一个值。在前面我们已经知道如果要在数据结构中获得一个值（使用get方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址 举个例子，我们继续使用字典中的案例使用电子邮件地址簿。我们将要使用最常见的散列函数——“lose lose”散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。 2.1 创建散列表我们将使用数组来表示我们的数据结构，该数据结构的图表（“lose lose”）所用的非常相似。 和之前一样，我们从搭建类的骨架开始： 123function HashTable() &#123; var table = [];&#125; 然后，给类添加一些方法。我们给每个类实现三个基本方法 put(key,value)：向散列表增加一个新的项（也能更新散列表）。remove(key)：根据键值从散列表中移除值。get(key)：返回根据键值检索到的特定的值。 在实现这三个方法之前，要实现的第一个方法是散列函数，它是HashTable类中的一个私有方法： 1234567var loseloseHashCode = function (key) &#123; var hash = 0; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash += key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 37; //&#123;4&#125;&#125;; 给定一个key参数，我们就能根据组成key的每个字符的ASCII码值的和得到一个数字。所以，首先需要一个变量来存储这个总和（行{1}）。然后，遍历key（行{2}）并将从ASCII表中查到的每个字符对应的ASCII值加到hash变量中（可以使用JavaScript的String类中的charCodeAt方法——行{3}）。最后，返回hash值。为了得到比较小的数值，我们会使用hash值和一个任意数做除法的余数（mod）。 现在，有了散列函数，我们就可以实现put方法了： 12345this.put = function (key, value) &#123; var position = loseloseHashCode(key); //&#123;5&#125; console.log(position + ' - ' + key); //&#123;6&#125; table[position] = value; //&#123;7&#125;&#125;; 首先，根据给定的key，我们需要根据所创建的散列函数计算出它在表中的位置（行{5}）。为了便于展示信息，我们将计算出的位置输出至控制台（行{6}）。由于它不是必需的，我们也可以将这行代码移除。然后要做的，是将value参数添加到用散列函数计算出的对应的位置上。（行{7}）。 从HashTable实例中查找一个值也很简单。为此，我们将会实现一个get方法： 123this.get = function (key) &#123; return table[loseloseHashCode(key)];&#125;; 首先，我们会使用所创建的散列函数来求出给定key所对应的位置。这个函数会返回值的位置，因此我们所要做的就是根据这个位置从数组table中获得这个值。 我们要实现的最后一个方法是remove方法： 123this.remove = function(key) &#123; table[loseloseHashCode(key)] = undefined;&#125;; 要从HashTable实例中移除一个元素，只需要求出元素的位置（可以使用散列函数来获取）并赋值为undefined。 对于HashTable类来说，我们不需要像ArrayList类一样从table数组中将位置也移除。由于元素分布于整个数组范围内，一些位置会没有任何元素占据，并默认为undefined值。我们也不能将位置本身从数组中移除（这会改变其他元素的位置），否则，当下次需要获得或移除一个元素的时候，这个元素会不在我们用散列函数求出的位置上。 2.2 使用 HashTable 类让我们执行一些代码来测试HashTable类: var hash = new HashTable();hash.put(‘Gandalf’, &#39;gandalf@email.com‘);hash.put(‘John’, &#39;johnsnow@email.com‘);hash.put(‘Tyrion’, &#39;tyrion@email.com‘); 执行上述代码，会在控制台中获得如下输出： 19 - Gandalf29 - John16 - Tyrion 下面的图表展现了包含这三个元素的HashTable数据结构： 现在来测试get方法： console.log(hash.get(‘Gandalf’));console.log(hash.get(‘Loiane’)); 获得如下的输出： gandalf@email.comundefined 由于Gandalf是一个在散列表中存在的键，get方法将会返回它的值。而由于Loiane是一个不存在的键，当我们试图在数组中根据位置获取值的时候（一个由散列函数生成的位置），返回值将会是undefined（即不存在）。 然后，我们试试从散列表中移除Gandalf： hash.remove(‘Gandalf’);console.log(hash.get(‘Gandalf’)); 由于Gandalf不再存在于表中，hash.get(‘Gandalf’)方法将会在控制台上给出undefined的输出结果。 2.3 散列表和散列集合散列表和散列映射是一样的，我们学习过这种数据结构了。 在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是散列函数。我们可以重用本章实现HashTable的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。 2.4 处理散列表中的冲突有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。例如，我们看看下面的代码会得到怎样的输出结果： 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 注意，Tyrion和Aaron有相同的散列值（16）。Donnie和Ana有相同的散列值（13），Jonathan、Jamie和Sue有相同的散列值（5），Mindy和Paul也有相同的散列值（32）。 那HashTable实例会怎样呢？执行之前的代码后散列表中会有哪些值呢？ 为了获得结果，我们来实现一个叫作print的辅助方法，它会在控制台上输出HashTable中的值： 1234567this.print = function () &#123; for (var i = 0; i &lt; table.length; ++i) &#123; //&#123;1&#125; if (table[i] !== undefined) &#123; //&#123;2&#125; console.log(i + \": \" + table[i]);//&#123;3&#125; &#125; &#125;&#125;; 现在来使用这个方法： hash.print(); 在控制台上得到如下的输出结果： 12345675: sue @email.com10: nathan@email.com13: ana@email.com16: aaron@email.com19: gandalf@email.com29: johnsnow@email.com32: paul@email.com Jonathan、Jamie和Sue有相同的散列值，也就是5。由于Sue是最后一个被添加的，Sue将是在HashTable实例中占据位置5的元素。首先，Jonathan会占据这个位置，然后Jamie会覆盖它，然后Sue会再次覆盖。这对于其他发生冲突的元素来说也是一样的。 使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接、线性探查和双散列法。在本节中，我们会介绍前两种方法。 2.4.1 分离链接分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。 例如，我们在之前的测试代码中使用分离链接的话，输出结果将会是这样： 在位置5上，将会有包含三个元素的LinkedList实例；在位置13、16和32上，将会有包含两个元素的LinkedList实例；在位置10、19和29上，将会有包含单个元素的LinkedList实例。 对于分离链接和线性探查来说，只需要重写三个方法：put、get和remove。这三个方法在每种技术实现中都是不同的。 为了实现一个使用了分离链接的HashTable实例，我们需要一个新的辅助类来表示将要加入LinkedList实例的元素。我们管它叫ValuePair类（在HashTable类内部定义）： 1234567var ValuePair = function (key, value) &#123; this.key = key; this.value = value; this.toString = function () &#123; return '[' + this.key + ' - ' + this.value + ']'; &#125;&#125;; 这个类只会将key和value存储在一个Object实例中。我们也重写了toString方法，以便之后在浏览器控制台中输出结果。 put方法 我们来实现第一个方法，put方法，代码如下： 1234567this.put = function (key, value) &#123; var position = loseloseHashCode(key); if (table[position] == undefined) &#123; //&#123;1&#125; table[position] = new LinkedList(); &#125; table[position].append(new ValuePair(key, value)); //&#123;2&#125;&#125;; 在这个方法中，将验证要加入新元素的位置是否已经被占据（行{1}）。如果这个位置是第一次被加入元素，我们会在这个位置上初始化一个LinkedList类的实例（你已经在第5章中学习过）。然后，使用第5章中实现的append方法向LinkedList实例中添加一个ValuePair实例（键和值）（行{2}）。 (2) get方法 然后，我们实现用来获取特定值的get方法： 123456789101112131415161718this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;3&#125; //遍历链表来寻找键/值 var current = table[position].getHead(); //&#123;4&#125; while (current.next) &#123; //&#123;5&#125; if (current.element.key === key) &#123; //&#123;6&#125; return current.element.value; //&#123;7&#125; &#125; current = current.next; //&#123;8&#125; &#125; //检查元素在链表第一个或最后一个节点的情况 if (current.element.key === key) &#123; //&#123;9&#125; return current.element.value; &#125; &#125; return undefined; //&#123;10&#125;&#125;; 我们要做的第一个验证，是确定在特定的位置上是否有元素存在（行{3}）。如果没有，则返回一个undefined表示在HashTable实例中没有找到这个值（行{10}）。如果在这个位置上有值存在，我们知道这是一个LinkedList实例。现在要做的是遍历这个链表来寻找我们需要的元素。在遍历之前先要获取链表表头的引用（行{4}），然后就可以从链表的头部遍历到尾部（行{5}，current.next将会是null）。 Node链表包含next指针和element属性。而element属性又是ValuePair的实例，所以它又有value和key属性。可以通过current.element.key来获得Node链表的key属性，并通过比较它来确定它是否就是我们要找的键（行{6}）。（这就是要使用ValuePair这个辅助类来存储元素的原因。我们不能简单地存储值本身，这样就不能确定哪个值对应着特定的键。）如果key值相同，就返回Node的值（行{7}）；如果不相同，就继续遍历链表，访问下一个节点（行{8}）。 如果要找的元素是链表的第一个或最后一个节点，那么就不会进入while循环的内部。因此，需要在行{9}处理这种特殊的情况 remove方法 使用分离链接法从HashTable实例中移除一个元素和之前在本章实现的remove方法有一些不同。现在使用的是链表，我们需要从链表中移除一个元素。来看看remove方法的实现： 12345678910111213141516171819202122232425this.remove = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; var current = table[position].getHead(); while (current.next) &#123; if (current.element.key === key) &#123; //&#123;11&#125; table[position].remove(current.element); //&#123;12&#125; if (table[position].isEmpty()) &#123; //&#123;13&#125; table[position] = undefined; //&#123;14&#125; &#125; return true; //&#123;15&#125; &#125; current = current.next; &#125; // 检查是否为第一个或最后一个元素 if (current.element.key === key) &#123; //&#123;16&#125; table[position].remove(current.element); if (table[position].isEmpty()) &#123; table[position] = undefined; &#125; return true; &#125; &#125; return false; //&#123;17&#125;&#125;; 在remove方法中，我们使用和get方法一样的步骤找到要找的元素。遍历LinkedList实例时，如果链表中的current元素就是要找的元素（行{11}），使用remove方法将其从链表中移除。然后进行一步额外的验证：如果链表为空了（行{13}——链表中不再有任何元素了），就将散列表这个位置的值设为undefined（行{14}），这样搜索一个元素或打印它的内容的时候，就可以跳过这个位置了。最后，返回true表示这个元素已经被移除（行{15}）或者在最后返回false表示这个元素在散列表中不存在（行{17}）。同样，需要和get方法一样，处理元素在第一个或最后一个的情况（行{16}）。 重写了这三个方法后，我们就拥有了一个使用了分离链接法来处理冲突的HashMap实例。 2.4.1 线性探查另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推 然后重写put、get、remove方法 put方法 123456789101112this.put = function (key, value) &#123; var position = loseloseHashCode(key); // &#123;1&#125; if (table[position] == undefined) &#123; // &#123;2&#125; table[position] = new ValuePair(key, value); // &#123;3&#125; &#125; else &#123; var index = ++position; // &#123;4&#125; while (table[index] != undefined) &#123; // &#123;5&#125; index++; // &#123;6&#125; &#125; table[index] = new ValuePair(key, value); // &#123;7&#125; &#125;&#125;; 和之前一样，先获得由散列函数生成的位置（行{1}），然后验证这个位置是否有元素存在（如果这个位置被占据了，将会通过行{2}的验证）。如果没有元素存在，就在这个位置加入新元素（行{3}——一个ValuePair的实例）。 如果这个位置已经被占据了，需要找到下一个没有被占据的位置（position的值是undefined），因此我们声明一个index变量并赋值为position+1（行{4}——在变量名前使用自增运算符++会先递增变量值然后再将其赋值给index）。然后验证这个位置是否被占据（行{5}），如果被占据了，继续将index递增（行{6}），直到找到一个没有被占据的位置。然后要做的，就是将值分配到这个位置（行{7}）。 如果再次执行插入数据的代码: 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 下图展示使用了线性探查的散列表的最终结果： 让我们来模拟一下散列表中的插入操作。 (1) 试着插入Gandalf。它的散列值是19，由于散列表刚刚被创建，位置19还是空的——可以在这里插入数据。(2) 试着在位置29插入John。它也是空的，所以可以插入这个姓名。(3) 试着在位置16插入Tyrion。它是空的，所以可以插入这个姓名。(4) 试着插入Aaron，它的散列值也是16。位置16已经被Tyrion占据了，所以需要检查索引值为position+1的位置（16+1）。位置17是空的，所以可以在位置17插入Aaron。(5) 接着，试着在位置13插入Donnie。它是空的，所以可以插入这个姓名。(6) 想在位置13插入Ana，但是这个位置被占据了。因此在位置14进行尝试，它是空的，所以可以在这里插入姓名。(7) 然后，在位置5插入Jonathan，这个位置是空的，所以可以插入这个姓名。(8) 试着在位置5插入Jamie，但是这个位置被占了。所以跳至位置6，这个位置是空的，因此可以在这个位置插入姓名。(9) 试着在位置5插入Sue，但是位置被占据了。所以跳至位置6，但也被占了。接着跳至位置7，这里是空的，所以可以在这里插入姓名。以此类推。 get方法 现在插入了所有的元素，让我们实现get方法来获取它们的值吧： 1234567891011121314151617this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;8&#125; if (table[position].key === key) &#123; //&#123;9&#125; return table[position].value; //&#123;10&#125; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key) &#123; //&#123;11&#125; index++; &#125; if (table[index].key === key) &#123; //&#123;12&#125; return table[index].value; //&#123;13&#125; &#125; &#125; &#125; return undefined; //&#123;14&#125; &#125;; 要获得一个键对应的值，先要确定这个键存在（行{8}）。如果这个键不存在，说明要查找的值不在散列表中，因此可以返回undefined（行{14}）。如果这个键存在，需要检查我们要找的值是否就是这个位置上的值（行{9}）。如果是，就返回这个值（行{10}）。 如果不是，就在散列表中的下一个位置继续查找，直到找到一个键值与我们要找的键值相同的元素（行{11}）。然后，验证一下当前项就是我们要找的项（行{12}——只是为了确认一下）并且将它的值返回（行{13}）。 我们无法确定要找的元素实际上在哪个位置，这就是使用ValuePair来表示HashTable元素的原因。 remove方法 remove方法和get方法基本相同，不同之处在于行{10}和{13}，它们将会由下面的代码代替： table[index] = undefined; 要移除一个元素，只需要给其赋值为undefined，来表示这个位置不再被占据并且可以在必要时接受一个新元素。 2.5 创建更好的散列函数我们实现的“lose lose”散列函数并不是一个表现良好的散列函数，因为它会产生太多的冲突。如果我们使用这个函数的话，会产生各种各样的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。我们可以在网上找到一些不同的实现方法，或者也可以实现自己的散列函数。 另一个可以实现的比“lose lose”更好的散列函数是djb2： 1234567var djb2HashCode = function (key) &#123; var hash = 5381; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 1013; //&#123;4&#125;&#125;; 它包括初始化一个hash变量并赋值为一个质数（行{1}——大多数实现都使用5381），然后迭代参数key（行{2}），将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加（行{3}）。 最后，我们将使用相加的和与另一个随机质数（比我们认为的散列表的大小要大——在本例中，我们认为散列表的大小为1000）相除的余数。 如果再次执行插入数据的代码，这将是使用djb2HashCode代替loseloseHashCode的最终结果： 123456789101112798 - Gandalf838 - John624 - Tyrion215 - Aaron278 - Donnie925 - Ana288 - Jonathan962 - Jamie502 - Sue804 - Mindy54 - Paul223 - Nathan 这并不是最好的散列函数，但这是最受社区推崇的散列函数之一。 三、es6——Map类我们看看原生的Map类怎么用。 还是用我们原来测试Dictionary类的例子： 123456789var map = new Map();map.set('Gandalf', 'gandalf@email.com');map.set('John', 'johnsnow@email.com');map.set('Tyrion', 'tyrion@email.com');console.log(map.has('Gandalf')); //输出trueconsole.log(map.size); //输出3console.log(map.keys()); //输出[\"Gandalf\", \"John\", \"Tyrion\"]console.log(map.values()); //输出[\"gandalf@email.com\", s\"johnsnow@email.com\", \"tyrion@email.com\"]console.log(map.get('Tyrion')); //输出tyrion@email.com 和我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator（第2章提到过），而不是值或键构成的数组。另一个区别是，我们实现的size方法返回字典中存储的值的个数，而ES6的Map类则有一个size属性。 删除map中的元素可以用delete方法： map.delete(‘John’); clear方法会重置map数据结构，这跟我们在Dictionary类里实现的一样。 四、ES6——WeakMap 类和 WeakSet 类除了Set和Map这两种新的数据结构，ES6还增加了它们的弱化版本，WeakSet和WeakMap。 基本上，Map和Set与其弱化版本之间仅有的区别是： WeakSet或WeakMap类没有entries、keys和values等方法； 只能用对象作为键。 创建和使用这两个类主要是为了性能。WeakSet和WeakMap是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。 另一个优点是，必须用键才可以取出值。这些类没有entries、keys和values等迭代器方法，因此，除非你知道键，否则没有办法取出值。这印证了我们在前面的做法，即使用WeakMap类封装ES6类的私有属性。 使用WeakMap类的例子如下： 12345678910var map = new WeakMap();var ob1 = &#123;name:'Gandalf'&#125;, //&#123;1&#125;ob2 = &#123;name:'John'&#125;,ob3 = &#123;name:'Tyrion'&#125;;map.set(ob1, 'gandalf@email.com'); //&#123;2&#125;map.set(ob2, 'johnsnow@email.com');map.set(ob3, 'tyrion@email.com');console.log(map.has(ob1)); //&#123;3&#125; 输出trueconsole.log(map.get(ob3)); //&#123;4&#125; 输出tyrion@email.commap.delete(ob2); //&#123;5&#125; WeakMap类也可以用set方法，但不能使用数字、字符串、布尔值等基本数据类型，需要将名字转换为对象（行{1}和行{2}）。搜索（行{3}）、读取（行{4}）和删除值（行{5}），也要传入作为键的对象。同样的逻辑也适用于WeakSet类。 五、小结在本节中，我们学习了字典的相关知识，了解了如何添加、移除和获取元素以及其他的一些方法。我们还了解了字典和集合的不同之处。 我们也学习了散列运算，怎样创建一个散列表（或者说散列映射）数据结构，如何添加、移除和获取元素，以及如何创建散列函数。我们学习了怎样使用两种不同的方法解决散列表中的冲突问题。 我们还介绍了如何使用ES6的Map、WeakMap和WeakSet类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法六（集合）","date":"2018-12-28T08:10:32.000Z","path":"2018/12/28/cjvasuinx0012ckvbzht2qt6y/","text":"一、构建数据集合集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。 在深入学习集合的计算机科学实现之前，我们先看看它的数学概念。在数学中，集合是一组不同的对象（的集）。 比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6, …}。集合中的对象列表用“{}”（大括号）包围。 还有一个概念叫空集。空集就是不包含任何元素的集合。比如24和29之间的素数集合。由于24和29之间没有素数（除了1和自身，没有其他正因数的大于1的自然数），这个集合就是空集。空集用“{ }”表示。 你也可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。 在数学中，集合也有并集、交集、差集等基本操作。在本片文章中我们也会介绍这些操作 二、创建集合首先创建set类，Set类的骨架如下： 123function Set() &#123; let items = &#123;&#125;;&#125; 有一个非常重要的细节，我们使用对象而不是数组来表示集合（items）。但也可以用数组实现。在这里我们用对象来实现，稍微有点儿不一样，也学习一下实现相似数据结构的新方法。同时，JavaScript的对象不允许一个键指向两个不同的属性，也保证了集合里的元素都是唯一的。 接下来，需要声明一些集合可用的方法（我们会尝试模拟与ECMAScript 6实现相同的Set类）。 add(value)：向集合添加一个新的项。delete(value)：从集合移除一个值。has(value)：如果值在集合中，返回true，否则返回false。clear()：移除集合中的所有项。size()：返回集合所包含元素的数量。与数组的length属性类似。values()：返回一个包含集合中所有值的数组。 2.1 has(value)方法首先要实现的是has(value)方法。这是因为它会被add、remove等其他方法调用。下面看看它的实现： 123this.has = function(value)&#123; return value in items;&#125;; 既然我们使用对象来存储集合的值，就可以用JavaScript的in操作符来验证给定的值是否是items对象的属性。 但这个方法还有更好的实现方式，如下： 123this.has = function(value)&#123; return items.hasOwnProperty(value);&#125;; 所有JavaScript对象都有hasOwnProperty方法。这个方法返回一个表明对象是否具有特定属性的布尔值。 2.2 add方法接下来要实现add方法： 1234567this.add = function(value)&#123; if (!this.has(value))&#123; items[value] = value; //&#123;1&#125; return true; &#125; return false;&#125;; 对于给定的value，可以检查它是否存在于集合中。如果不存在，就把value添加到集合中（行{1}），返回true，表示添加了这个值。如果集合中已经有这个值，就返回false，表示没有添加它。 添加一个值的时候，把它同时作为键和值保存，因为这样有利于查找这个值。 2.3 remove 和 clear 方法下面要实现remove方法： 1234567this.remove = function(value)&#123;if (this.has(value))&#123; delete items[value]; //&#123;2&#125; return true;&#125;return false;&#125;; 在remove方法中，我们会验证给定的value是否存在于集合中。如果存在，就从集合中移除value（行{2}），返回true，表示值被移除；否则返回false。 既然用对象来存储集合的items对象，就可以简单地使用delete操作符从items对象中移除属性（行{2}）。 使用Set类的示例代码如下： 123let set = new Set();set.add(1); //trueset.add(2); //true 如果想移除集合中的所有值，可以用clear方法： 123this.clear = function()&#123; items = &#123;&#125;; // &#123;3&#125;&#125;; 要重置items对象，需要做的只是把一个空对象重新赋值给它（行{3}）。我们也可以迭代集合，用remove方法依次移除所有的值，但既然有更简单的方法，那样做就太麻烦了 2.4 size 方法下一个要实现的是size方法（返回集合中有多少项）。这个方法有三种实现方式。 第一种方法是使用一个length变量，每当使用add或remove方法时控制它，就像在上一章中使用LinkedList类一样。 第二种方法，使用JavaScript内建的Object类的一个内建函数（ECMAScript 5以上版本）： 123this.size = function()&#123; return Object.keys(items).length; //&#123;4&#125;&#125;; JavaScript的Object类有一个keys方法，它返回一个包含给定对象所有属性的数组。在这种情况下，可以使用这个数组的length属性（行{4}）来返回items对象的属性个数。以上代码只能在现代浏览器中运行（比如IE9以上版本、Firefox 4以上版本、Chrome 5以上版本、Opera 12以上版本、Safari 5以上版本，等等）。 第三种方法是手动提取items对象的每一个属性，记录属性的个数并返回这个数字。这个方法可以在任何浏览器上运行，和之前的代码是等价的： 12345678this.sizeLegacy = function()&#123; let count = 0; for(let key in items) &#123; //&#123;5&#125; if(items.hasOwnProperty(key)) //&#123;6&#125; ++count; //&#123;7&#125; &#125; return count;&#125;; 遍历items对象的所有属性（行{5}），检查它们是否是对象自身的属性（避免重复计数——行{6}）。如果是，就递增count变量的值（行{7}），最后在方法结束时返回这个数字。 不能简单地使用for-in语句遍历items对象的属性，并递增count变量的值。还需要使用hasOwnProperty方法（以验证items对象具有该属性），因为对象的原型包含了额外的属性（属性既有继承自JavaScript的Object类的，也有属于对象自身，未用于数据结构的）。 2.5 values 方法values方法也应用了相同的逻辑，提取items对象的所有属性，以数组的形式返回： 123456789this.values = function () &#123; let values = []; for (let key in items) &#123; //&#123;7&#125; if (items.hasOwnProperty(key)) &#123; //&#123;8&#125; values.push(items[key]); &#125; &#125; return values; &#125; 首先遍历items对象的所有属性（行{7}），把它们添加一个数组中（行{8}），并返回这个数组。该方法类似于我们开发的sizeLegacy方法，但我们添加一个数组，而不是计算属性个数。 2.6 使用 Set 类现在数据结构已经完成了，执行Set类的方法，测试我们的Set类： 12345678910111213let set = new Set();set.add(1);console.log(set.values()); //输出[\"1\"]console.log(set.has(1)); //输出trueconsole.log(set.size()); //输出1 set.add(2);console.log(set.values()); //输出[\"1\", \"2\"]console.log(set.has(2)); //trueconsole.log(set.size()); //2set.remove(1);console.log(set.values()); //输出[\"2\"]set.remove(2);console.log(set.values()); //输出[] 三、 集合操作对集合可以进行如下操作。 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。子集：验证一个给定集合是否是另一集合的子集。 3.1 并集并集的数学概念是集合A和集合B的并集，表示为： A∪B 该集合定义如下： A∪B = { x | x ∈ A∨x ∈ B } 意思是x（元素）存在于A中，或x存在于B中。下图展示了并集操作： 现在来实现Set类的union方法： 12345678910111213//union 方法this.union = function (otherSet) &#123; let unionSet = new Set(); //&#123;1&#125; let values = this.values(); //&#123;2&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); //&#123;3&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet;&#125;; 首先需要创建一个新的集合，代表两个集合的并集（行{1}）。接下来，获取第一个集合（当前的Set类实例）所有的值（values），遍历并全部添加到代表并集的集合中（行{2}）。然后对第二个集合做同样的事（行{3}）。最后返回结果。 测试一下上面的代码： 1234567891011let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(3);setB.add(4);setB.add(5);setB.add(6);let unionAB = setA.union(setB);console.log(unionAB.values()); //[1, 2, 3, 4, 5, 6] 输出为[“1”, “2”, “3”, “4”, “5”, “6”]。注意元素3同时存在于A和B中，它在结果的集合中只出现一次。 3.2 交集交集的数学概念是集合A和集合B的交集，表示为： A∩B 该集合定义如下： A∩B = { x | x ∈ A∧x ∈ B } 意思是x（元素）存在于A中，且x存在于B中。下图展示了交集操作： 现在来实现Set类的intersection方法： 12345678910this.intersection = function(otherSet)&#123; let intersectionSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; //&#123;2&#125; if (otherSet.has(values[i]))&#123; //&#123;3&#125; intersectionSet.add(values[i]); //&#123;4&#125; &#125; &#125; return intersectionSet;&#125; intersection方法需要找到当前Set实例中，所有也存在于给定Set实例中的元素。首先创建一个新的Set实例，这样就能用它返回共有的元素（行{1}）。接下来，遍历当前Set实例所有的值（行{2}），验证它们是否也存在于otherSet实例（行{3}）之中。可以用前面实现的has方法来验证元素是否存在于Set实例中。然后，如果这个值也存在于另一个Set实例中，就将其添加到创建的intersectionSet变量中（行{4}），最后返回它。 测试一下intersection方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let intersectionAB = setA.intersection(setB);console.log(intersectionAB.values()); 输出为[“2”, “3”]，因为2和3同时存在于两个集合中。 3.3 差集差集的数学概念是集合A和集合B的差集，表示为：AB，定义如下图： 意思是x（元素）存在于A中，且x不存在于B中。下图展示了集合A和B的差集操作： 现在来实现Set类的difference方法： 12345678910this.difference = function (otherSet) &#123; let differenceSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; differenceSet.add(values[i]); //&#123;4&#125; &#125; &#125; return differenceSet;&#125;; intersection方法会得到所有同时存在于两个集合中的值。而difference方法会得到所有存在于集合A但不存在于B的值。因此这两个方法在实现上唯一的区别就是行{3}。只获取不存在于otherSet实例中的值，而不是也存在于其中的值。行{1}、{2}和{4}是完全相同的。 测试difference方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let differenceAB = setA.difference(setB);console.log(differenceAB.values()); 输出为[“1”]，因为1是唯一一个仅存在于setA的元素。 3.4 子集子集的数学概念是集合A是集合B的子集（或集合B包含了A），表示为 A⊆B 该集合定义如下： ∀x { x ∈ A → x ∈ B } 意思是集合A中的每一个x（元素），也需要存在于B中。下图展示了集合A是集合B的子集： 现在来实现Set类的subset方法： 12345678910111213this.subset = function (otherSet) &#123; if (this.size() &gt; otherSet.size()) &#123; //&#123;1&#125; return false; &#125; else &#123; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; return false; //&#123;4&#125; &#125; &#125; return true; //&#123;5&#125; &#125;&#125;; 首先需要验证的是当前Set实例的大小。如果当前实例中的元素比otherSet实例更多，它就不是一个子集（行{1}）。子集的元素个数需要小于或等于要比较的集合。 接下来要遍历集合中的所有元素（行{2}），验证这些元素也存在于otherSet中（行{3}）。如果有任何元素不存在于otherSet中，就意味着它不是一个子集，返回false（行{4}）。如果所有元素都存在于otherSet中，行{4}就不会被执行，那么就返回true（行{5}）。 检验一下上面的代码效果如何： 12345678910111213let setA = new Set();setA.add(1); setA.add(2);let setB = new Set();setB.add(1);setB.add(2);setB.add(3);let setC = new Set();setC.add(2);setC.add(3);setC.add(4);console.log(setA.subset(setB));console.log(setA.subset(setC)); 我们有三个集合：setA是setB的子集（因此输出为true），然而setA不是setC的子集（setC只包含了setA中的2，而不包含1），因此输出为false。 四、 ES6——Set 类我们先看看原生的Set类怎么用。 还是用我们原来测试Set类的例子： 12345let set = new Set();set.add(1);console.log(set.values()); // 输出@Iteratorconsole.log(set.has(1)); // 输出trueconsole.log(set.size); // 输出1 和我们的Set不同，ES6的Set的values方法返回Iterator（第2章提到过），而不是值构成的数组。另一个区别是，我们实现的size方法返回set中存储的值的个数，而ES6的Set则有一个size属性。 可以用delete方法删除set中的元素： set.delete(1); clear方法会重置set数据结构，这跟我们实现的功能一样 4.1 ES6 Set 类的操作我们的Set类实现了并集、交集、差集、子集等数学操作，然而ES6原生的Set并没有这些功能。不过，有需要的话，我们也可以模拟。 我们的例子会用到下面两个集合 12345678let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4); 4.1.1 模拟并集操作我们可以创建一个新的集合，用来添加两个集合中所有的元素（行{1}）。迭代这两个集合（行{2}、行{3}），把所有元素都添加到并集的集合中。代码如下： 123let unionAb = new Set(); //&#123;1&#125;for (let x of setA) unionAb.add(x); //&#123;2&#125;for (let x of setB) unionAb.add(x); //&#123;3&#125; 4.1.2 模拟交集操作模拟交集操作需要创建一个辅助函数，来生成包含setA和setB都有的元素的新集合（行{1}）。代码如下： 12345678910let intersection = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if (setB.has(x)) &#123; //&#123;1&#125; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;;let intersectionAB = intersection(setA, setB); 交集可以用更简单的语法实现，代码如下： intersectionAb = new Set([x for (x of setA) if (setB.has(x))]); 这和intersection函数的效果完全一样。 4.1.3 模拟差集操作交集操作创建的集合包含setA和setB都有的元素，差集操作创建的集合包含的则是setA有而setB没有的元素。看下面的代码： 12345678910let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; //&#123;1&#125; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;;let differenceAB = difference(setA, setB); intersection函数和difference函数只有行{1}不同，因为差集中只添加setA有而setB没有的元素。 差集也可以用更简单的语法实现，代码如下： differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); 目前只有Firefox支持简化的语法，但在所有支持ES6的现代浏览器中都可以执行difference函数 五、小结在这片文章中，我们学习了如何从头实现一个与ECMAScript 6中定义的类似的Set类。我们还介绍了在其他编程语言的集合数据结构的实现中不常见的一些方法，比如并集、交集、差集和子集。因此，相比于其他编程语言目前的Set实现，我们实现了一个非常完备的Set类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法五（链表）","date":"2018-11-18T11:41:53.000Z","path":"2018/11/18/cjvasuirc0015ckvbotb483d3/","text":"一、链表数据结构要存储多个元素，数组（或列表）可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管JavaScript的array类方法做这些事，但背后的情况同样是这样）。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展示了一个链表的结构： 相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。 另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法，就是从起点（第一条线索）顺着列表寻找。 还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或移除它。下图演示了一列火车。每节车皮都是列表的元素，车皮间的连接就是指针： 二、创建链表理解了链表是什么之后，现在就要开始实现我们的数据结构了，以下是我们的LinkedList类的骨架： 123456789101112131415161718function LinkedList() &#123; let Node = function (element) &#123; // &#123;1&#125; this.element = element; this.next = null; &#125;; let length = 0; // &#123;2&#125; let head = null; // &#123;3&#125; this.append = function (element) &#123; &#125;; this.insert = function (position, element) &#123; &#125;; this.removeAt = function (position) &#123; &#125;; this.remove = function (element) &#123; &#125;; this.indexOf = function (element) &#123; &#125;; this.isEmpty = function () &#123; &#125;; this.size = function () &#123; &#125;; this.getHead = function () &#123; &#125;; this.toString = function () &#123; &#125;; this.print = function () &#123; &#125;;&#125; LinkedList数据结构还需要一个Node辅助类（行{1}）。Node类表示要加入列表的项。它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。 LinkedList类也有存储列表项的数量的length属性（内部/私有变量）（行{2}）。 另一个重要的点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在一个称为head的变量中（行{3}） 然后就是LinkedList类的方法。在实现这些方法之前，先来看看它们的职责。 append(element)：向列表尾部添加一个新的项。 insert(position, element)：向列表的特定位置插入一个新的项。 remove(element)：从列表中移除一项。 indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 removeAt(position)：从列表的特定位置移除一项。 isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。 size()：返回链表包含的元素个数。与数组的length属性类似。 toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 2.1 向链表尾部追加元素向LinkedList对象尾部添加一个元素时，可能有两种场景：列表为空，添加的是第一个元素，或者列表不为空，向其追加元素。 下面是我们实现的append方法： 1234567891011121314151617181920212223242526// LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; // this.element = element; this.next = null; &#125;; let length = 0; // let head = null; // //实现LinkedList类的append方法 this.append = function (element) &#123; let node = new Node(element), //&#123;1&#125; current; //&#123;2&#125; if (head === null) &#123; //列表中第一个节点 //&#123;3&#125; head = node; &#125; else &#123; current = head; //&#123;4&#125; //循环列表，直到找到最后一项 while (current.next) &#123; current = current.next; &#125; //找到最后一项，将其next赋为node，建立链接 current.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 //&#123;6&#125; &#125;;&#125; 首先需要做的是把element作为值传入，创建Node项（行{1}）。 先来实现第一个场景：向为空的列表添加一个元素。当我们创建一个LinkedList对象时，head会指向null： 如果head元素为null（列表为空——行{3}），就意味着在向列表添加第一个元素。因此要做的就是让head元素指向node元素。下一个node元素将会自动成为null。 列表最后一个节点的下一个元素始终是null。 再来看看第二个场景，也就是向一个不为空的列表尾部添加元素。 要向列表的尾部添加一个元素，首先需要找到最后一个元素。记住，我们只有第一个元素的引用（行{4}），因此需要循环访问列表，直到找到最后一项。为此，我们需要一个指向列表中current项的变量（行{2}）。 循环访问列表时，当current.next元素为null时，我们就知道已经到达列表尾部了。然后要做的就是让当前（也就是最后一个）元素的next指针指向想要添加到列表的节点（行{5}）。下图展示了这个行为： 而当一个Node元素被创建时，它的next指针总是null。这没问题，因为我们知道它会是列表的最后一项。 当然，别忘了递增列表的长度，这样就能控制它，轻松地得到列表的长度（行{6}）。 我们可以通过以下代码来使用和测试目前创建的数据结构： let list = new LinkedList();list.append(15);list.append(10); 2.2 从链表中移除元素现在，让我们看看如何从LinkedList对象中移除元素。移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种remove方法：第一种是从特定位置移除一个元素，第二种是根据元素的值移除元素。 123456789101112131415161718192021222324252627282930313233//LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; &#125;; let length = 0; let head = null; //实现LinkedList类的append方法 this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; // &#123;1&#125; let current = head, // &#123;2&#125; previous, // &#123;3&#125; index = 0; // &#123;4&#125; //移除第一项 if (position === 0) &#123; // &#123;5&#125; head = current.next; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;6&#125; previous = current; // &#123;7&#125; current = current.next; // &#123;8&#125; &#125; //将previous与current的下一项链接起来：跳过current，从而移除它 previous.next = current.next; // &#123;9&#125; &#125; length--; // &#123;10&#125; return current.element; &#125; else &#123; return null; // &#123;11&#125; &#125; &#125;; &#125; 一步一步来看这段代码。该方法要得到需要移除的元素的位置，就需要验证这个位置是有效的（行{1}）。从0（包括0）到列表的长度（size – 1，因为索引是从零开始的）都是有效的位置。如果不是有效的位置，就返回null（意即没有从列表中移除元素）。 首先为第一种场景编写代码：我们要从列表中移除第一个元素（position === 0——行{5}）。下图展示了这个过程： 因此，如果想移除第一个元素，要做的就是让head指向列表的第二个元素。我们将用current变量创建一个对列表中第一个元素的引用（行{2}——我们还会用它来迭代列表，但稍等一下再说）。这样current变量就是对列表中第一个元素的引用。如果把head赋为current.next，就会移除第一个元素 现在，假设我们要移除列表的最后一项或者中间某一项。为此，需要依靠一个细节来迭代列表，直到到达目标位置（行{6}——我们会使用一个用于内部控制和递增的index变量）：current变量总是为对所循环列表的当前元素的引用（行{8}）。我们还需要一个对当前元素的前一个元素的引用（行{7}）；它被命名为previous（行{3}）。 因此，要从列表中移除当前元素，要做的就是将previous.next和current.next链接起来（行{9}）。这样，当前元素就会被丢弃在计算机内存中，等着被垃圾回收器清除。 我们试着通过一些图表来更好地理解。首先考虑移除最后一个元素： 对于最后一个元素，当我们在行{6}跳出循环时，current变量将是对列表中最后一个元素的引用（要移除的元素）。current.next的值将是null（因为它是最后一个元素）。由于还保留了对previous元素的引用（当前元素的前一个元素），previous.next就指向了current。那么要移除current，要做的就是把previous.next的值改变为current.next。 现在来看看，对于列表中间的元素是否可以应用相同的逻辑： current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。那么要移除current元素，需要做的就是将previous.next与current.next链接起来。因此，我们的逻辑对这两种情况都管用。 2.3 在任意位置插入元素接下来，我们要实现insert方法。使用这个方法可以在任意位置插入一个元素。我们来看一看它的实现： 123456789101112131415161718192021222324this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; //&#123;1&#125; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 node.next = current; //&#123;2&#125; head = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;3&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;4&#125; previous.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; //&#123;6&#125; &#125;&#125;; 由于我们处理的是位置，就需要检查越界值（行{1}，跟removeAt方法类似）。如果越界了，就返回false值，表示没有添加项到列表中（行{6}）。 现在我们要处理不同的场景。第一种场景，需要在列表的起点添加一个元素，也就是第一个位置。下图展示了这种场景： current变量是对列表中第一个元素的引用。我们需要做的是把node.next的值设为current（列表中第一个元素）。现在head和node.next都指向了current。接下来要做的就是把head的引用改为node（行{2}），这样列表中就有了一个新元素。 现在来处理第二种场景：在列表中间或尾部添加一个元素。首先，我们需要循环访问列表，找到目标位置（行{3}）。当跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用，而previous将是对想要插入新元素的位置之前一个元素的引用。在这种情况下，我们要在previous和current之间添加新项。因此，首先需要把新项（node）和当前项链接起来（行{4}），然后需要改变previous和current之间的链接。我们还需要让previous.next指向node（行{5}）。 我们通过一张图表来看看代码所做的事： 如果我们试图向最后一个位置添加一个新元素，previous将是对列表最后一项的引用，而current将是null。在这种情况下，node.next将指向current，而previous.next将指向node，这样列表中就有了一个新的项。 现在来看看如何向列表中间添加一个新元素： 在这种情况下，我们试图将新的项（node）插入到previous和current元素之间。首先，我们需要把node.next的值指向current。然后把previous.next的值设为node。这样列表中就有了一个新的项。 使用变量引用我们需要控制的节点非常重要，这样就不会丢失节点之间的链接。我们可以只使用一个变量（previous），但那样会很难控制节点之间的链接。由于这个原因，最好是声明一个额外的变量来帮助我们处理这些引用。 2.4 实现链表的其他方法2.4.1 toString方法toString方法会把LinkedList对象转换成一个字符串。下面是toString方法的实现： 123456789this.toString = function () &#123; let current = head, //&#123;1&#125; string = ''; //&#123;2&#125; while (current) &#123; //&#123;3&#125; string += current.element + (current.next ? 'n' : '');//&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return string; //&#123;6&#125;&#125;; 首先，要循环访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引（行{1}），控制循环访问列表。我们还需要初始化用于拼接元素值的变量（行{2}）。 接下来就是循环访问列表中的每个元素（行{3}）。我们要用current来检查元素是否存在（如果列表为空，或是到达列表中最后一个元素的下一位（null），while循环中的代码就不会执行）。然后我们就得到了元素的内容，将其拼接到字符串中（行{4}）。最后，继续迭代下一个元素（行{5}）。最后，返回列表内容的字符串（行{6}）。 2.4.2 indexOf方法indexOf方法接收一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回-1。 123456789101112this.indexOf = function(element)&#123; let current = head, //&#123;1&#125; index = -1; while (current) &#123; //&#123;2&#125; if (element === current.element) &#123; return index; //&#123;3&#125; &#125; index++; //&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return -1;&#125;; 一如既往，我们需要一个变量来帮助我们循环访问列表，这个变量是current，它的初始值是head（列表的第一个元素——我们还需要一个index变量来计算位置数（行{1}））。然后循环访问元素（行{2}），检查当前元素是否是我们要找的。如果是，就返回它的位置（行{3}）；如果不是，就继续计数（行{4}），检查列表中下一个节点（行{5}）。 如果列表为空，或是到达列表的尾部（current = current.next将是null），循环就不会执行。如果没有找到值，就返回-1。 2.4.3 remove方法实现了indexOf方法就可以实现remove方法了 1234this.remove = function(element)&#123; let index = this.indexOf(element); return this.removeAt(index);&#125;; 我们已经有一个移除给定位置的一个元素的removeAt方法了。现在有了indexOf方法，如果传入元素的值，就能找到它的位置，然后调用removeAt方法并传入找到的位置。这样非常简单，如果需要更改removeAt方法的代码，这样也更容易——两个方法都会被更改（这就是重用代码的妙处）。这样，我们就不需要维护两个从列表中移除一项的方法，只需要一个！同时，removeAt方法将会检查边界约束。 2.4.4 isEmpty、size和getHead方法isEmpty方法检查链表是否为空、size获取链表长度，这两个方法与队列中的isEmpty方法、size方法类似，如下实现： 123this.isEmpty = function() &#123; return length === 0;&#125;; 如果列表中没有元素，isEmpty方法就返回true，否则返回false。 123this.size = function() &#123; return length;&#125;; size方法返回列表的length。和已经实现的Queue类、Stack类有所不同，列表的length是内部控制的，因为LinkedList是从头构建的。 最后还有getHead方法： 123this.getHead = function()&#123; return head;&#125;; head变量是LinkedList类的私有变量（这意味着它不能在LinkedList实例外部被访问和更改，只有通过LinkedList实例才可以）。但是，如果我们需要在类的外部循环访问列表，就需要提供一种获取类的第一个元素的方法。 三、双向链表双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素，如下图所示 先从实现DoublyLinkedList类所需的变动开始 123456789101112//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法&#125; 在代码中可以看到，LinkedList类和DoublyLinkedList类之间的区别标为新增的。在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一项的引用的tail属性。 双向链表提供了两种迭代列表的方法：从头到尾，或者反过来。我们也可以访问一个特定节点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。 3.1 在任意位置插入新元素向双向链表中插入一个新项跟（单向）链表非常类似。区别在于，链表只要控制一个next指针，而双向链表则要同时控制next和prev（previous，前一个）这两个指针。 这是向任意位置插入一个新元素的算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法 this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 if (!head) &#123; //新增的 &#123;1&#125; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; //新增的 &#123;2&#125; head = node; &#125; &#125; else if (position === length) &#123; //最后一项 //新增的 current = tail; // &#123;3&#125; current.next = node; node.prev = current; tail = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;4&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;5&#125; previous.next = node; current.prev = node; //新增的 node.prev = previous; //新增的 &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; &#125; &#125;;&#125; 我们来分析第一种场景：在列表的第一个位置（列表的起点）插入一个新元素。如果列表为空（行{1}），只需要把head和tail都指向这个新节点。如果不为空，current变量将是对列表中第一个元素的引用。就像我们在链表中所做的，把node.next设为current，而head将指向node（它将成为列表中的第一个元素）。不同之处在于，我们还需要为指向上一个元素的指针设一个值。current.prev指针将由指向null变为指向新元素（node——行{2}）。node.prev指针已经是null，因此不需要再更新任何东西。下图演示了这个过程： 现在来分析一下，假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current变量将引用最后一个元素（行{3}）。然后开始建立第一个链接：node.prev将引用current。current.next指针（指向null）将指向node（由于构造函数，node.next已经指向了null）。然后只剩一件事了，就是更新tail，它将由指向current变为指向node。下图展示了这些行为： 然后还有第三种场景：在列表中间插入一个新元素。就像我们在之前的方法中所做的，迭代列表，直到到达要找的位置（行{4}）。我们将在current和previous元素之间插入新元素。首先，node.next将指向current（行{5}），而previous.next将指向node，这样就不会丢失节点之间的链接。然后需要处理所有的链接：current.prev将指向node，而node.prev将指向previous。下图展示了这一过程： 3.2 从任意位置移除元素从双向链表中移除元素跟链表非常类似。唯一的区别就是还需要设置前一个位置的指针。我们来看一下它的实现： 12345678910111213141516171819202122232425262728293031323334this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; //移除第一项 if (position === 0) &#123; head = current.next; // &#123;1&#125; //如果只有一项，更新tail //新增的 if (length === 1) &#123; // &#123;2&#125; tail = null; &#125; else &#123; head.prev = null; // &#123;3&#125; &#125; &#125; else if (position === length - 1) &#123; //最后一项 //新增的 current = tail; // &#123;4&#125; tail = current.prev; tail.next = null; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;5&#125; previous = current; current = current.next; &#125; //将previous与current的下一项链接起来——跳过current previous.next = current.next; // &#123;6&#125; current.next.prev = previous; //新增的 &#125; length--; return current.element; &#125; else &#123; return null; &#125;&#125;; 我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。 我们来看看如何移除第一个元素。current变量是对列表中第一个元素的引用，也就是我们想移除的元素。需要做的就是改变 head 的引用，将其从 current 改为下一个元素（current.next——行{1}）。但我们还需要更新current.next指向上一个元素的指针（因为第一个元素的prev指针是null）。因此，把head.prev的引用改为null（行{3}——因为head也指向列表中新的第一个元素，或者也可以用current.next.prev）。由于还需要控制tail的引用，我们可以检查要移除的元素是否是第一个元素，如果是，只需要把tail也设为null（行{2}）。 下图勾画了从双向链表移除第一个元素的过程： 下一种场景是从最后一个位置移除元素。既然已经有了对最后一个元素的引用（tail），我们就不需要为找到它而迭代列表。这样我们也就可以把tail的引用赋给current变量（行{4}）。接下来，需要把tail的引用更新为列表中倒数第二个元素（current.prev，或者tail.prev也可以）。既然tail指向了倒数第二个元素，我们就只需要把next指针更新为null（tail.next= null）。下图演示了这一行为： 第三种也是最后一种场景：从列表中间移除一个元素。首先需要迭代列表，直到到达要找的位置（行{5}）。current变量所引用的就是要移除的元素。那么要移除它，我们可以通过更新previous.next和current.next.prev的引用，在列表中跳过它。因此，previous.next将指向current.next，而current.next.prev将指向previous，如下图所示： 3.3 循环列表循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用null，而是指向第一个元素（head），如下图所示。 双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev。 四、小结本篇文章主要介绍链表这种数据结构，及其变体双向链表和循环链表。我们学习了如何在任意位置添加和移除元素，以及如何循环访问链表。还学习了链表相比数组最重要的优点，那就是无需移动链表中的元素，就能轻松地添加和移除元素。因此，当我们需要添加和移除很多元素时，最好的选择就是链表，而非数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法四（队列）","date":"2018-10-12T11:31:39.000Z","path":"2018/10/12/cjvasuimy000uckvbtjaxods3/","text":"一、队列数据结构队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 在现实中，最常见的队列的例子就是排队： 1.1 创建队列首先需要创建自己的类表示队列，先从最基本的声明开始： 123function quene() &#123; //这里是属性和方法&#125; 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像在Stack类中那样使用（你会发现Queue类和Stack类非常类似，只是添加和移除元素的原则不同）： let items = []; 接下来需要声明一些队列可用的方法: 123456789enqueue(element(s))：向队列尾部添加一个（或多个）新的项。dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。front()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）。isEmpty()：如果队列中不包含任何元素，返回true，否则返回false。size()：返回队列包含的元素个数，与数组的length属性类似。 1.2 向队列添加元素首先要实现的是enqueue方法。这个方法负责向队列添加新元素。这里有一个非常重要的细节，新的项只能添加到队列末尾： 123this.enqueue = function(element)&#123; items.push(element);&#125;; 1.2 从队列移除元素接下来要实现dequeue方法。这个方法负责从队列移除项。由于队列遵循先进先出原则，最先添加的项也是最先被移除的。 123this.dequeue = function()&#123; return items.shift();&#125;; 只有enqueue方法和dequeue方法可以添加和移除元素，这样就确保了Queue类遵循先进先出原则。 1.3 查看队列头元素现在来为我们的类实现一些额外的辅助方法。如果想知道队列最前面的项是什么，可以用front方法。这个方法会返回队列最前面的项（数组的索引为0）： 123this.front = function()&#123; return items[0];&#125;; 1.4 检查队列是否为空下一个是isEmpty方法。如果队列为空，它会返回true，否则返回false（注意这个方法和Stack类里的一样）： 123this.isEmpty = function() &#123; return items.length == 0&#125; 对于isEmpty方法，可以简单地验证内部数组的length是否为0。 我们也可以为Queue类实现类似于array类的length属性的方法。size方法也跟Stack类里的一样： 123this.size = function()&#123; return items.length;&#125;; 1.5 打印队列元素我们的Queue类已经实现好了。为了方便也可以像Stack类一样增加一个print方法： 123this.print = function()&#123; console.log(items.toString());&#125;; 1.6 使用quene类首先要做的是实例化我们刚刚创建的Queue类，然后就可以验证它为空（输出为true，因为我们还没有向队列添加任何元素）： 1234567891011121314151617181920212223242526let items = [];function Queue() &#123; this.enqueue = function(element) &#123; return items.push(element); &#125; this.dequeue = function() &#123; return items.shift(); &#125; this.front = function() &#123; return items[0]; &#125; this.isEmpty = function() &#123; return items.length == 0; &#125; this.size = function() &#123; return items.length; &#125; this.print = function() &#123; return console.log(items.toString()); &#125;&#125;let queue = new Queue();console.log(queue.isEmpty()); //输出true 接下来，添加一些元素（添加”John”和”Jack”两个元素——你可以向队列添加任何类型的元素）： queue.enqueue(“John”); queue.enqueue(“Jack”); 添加另一个元素： queue.enqueue(&quot;Camila&quot;); 再执行一些其他的命令： 1234567891011queue.print(); //[\"John\", \"Jack\", \"Camila\"]console.log(queue.size()); //输出3console.log(queue.isEmpty()); //输出falsequeue.dequeue(); //\"John\"queue.dequeue(); //\"Jack\"queue.print(); //[\"Camila\"] 如果打印队列的内容，就会得到John、Jack和Camila这三个元素。因为我们向队列添加了三个元素，所以队列的大小为3（当然也就不为空了）。 下图展示了目前为止执行的所有入列操作，以及队列当前的状态： 然后，出列两个元素（执行两次dequeue方法）。下图展示了dequeue方法的执行过程： 最后，再次打印队列内容时，就只剩Camila一个元素了。前两个入列的元素出列了，最后入列的元素也将是最后出列的。也就是说，我们遵循了先进先出原则。 二、用ECMAscript6语法实现的Queue类和Stack类一样，我们也可以用ECMAScript 6语法编写Queue类。在这种方法中，我们要用一个WeakMap来保存私有属性items，并用外层函数（闭包）来封装Queue类。 123456789101112131415161718192021let Queue = (function() &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; items.get(this).push(element) return items.get(this); &#125; dequeue() &#123; items.get(this).shift(); return items.get(this) &#125; &#125; return Queue&#125;)();let queue = new Queue();console.log(queue.enqueue(10)); //[10]console.log(queue.enqueue(11)); //[10,11]console.log(queue.dequeue()); //[11] 三、优先队列队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和妇（或带小孩的妇女）登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的（急诊科）候诊室。医生会优先处理病情比较严重的患者。通常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此可以对它们使用默认的出列操作： 12345678910111213141516171819202122232425262728293031323334function PriorityQueue() &#123; let items = []; function QueueElement(element, priority) &#123; // &#123;1&#125; this.element = element; this.priority = priority; &#125; this.enqueue = function (element, priority) &#123; console.log(items) let queueElement = new QueueElement(element, priority); let added = false; for (let i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; // &#123;2&#125; items.splice(i, 0, queueElement); // &#123;3&#125; added = true; break; // &#123;4&#125; &#125; &#125; if (!added) &#123; items.push(queueElement); //&#123;5&#125; &#125; &#125;; this.print = function () &#123; for (let i = 0; i &lt; items.length; i++) &#123; console.log(`$&#123;items[i].element&#125; - $&#123;items[i].priority&#125;`); &#125; &#125;; //其他方法和默认的Queue实现相同&#125; let priorityQueue = new PriorityQueue();priorityQueue.enqueue(\"John\", 2);priorityQueue.enqueue(\"Jack\", 1);priorityQueue.enqueue(\"Camila\", 1);priorityQueue.print(); 默认的Queue类和PriorityQueue类实现上的区别是，要向PriorityQueue添加元素，需要创建一个特殊的元素（行{1}）。这个元素包含了要添加到队列的元素（它可以是任意类型）及其在队列中的优先级。 如果队列为空，可以直接将元素入列（行{2}）。否则，就需要比较该元素与其他元素的优先级。当找到一个比要添加的元素的priority值更大（优先级更低）的项时，就把新元素插入到它之前（根据这个逻辑，对于其他优先级相同，但是先添加到队列的元素，我们同样遵循先进先出的原则）。要做到这一点，我们可以用第2章学习过的JavaScript的array类的splice方法。一旦找到priority值更大的元素，就插入新元素（行{3}）并终止队列循环（行{4}）。这样，队列也就根据优先级排序了。 如果要添加元素的priority值大于任何已有的元素，把它添加到队列的末尾就行了（行{5}）: let priorityQueue = new PriorityQueue();priorityQueue.enqueue(“John”, 2);priorityQueue.enqueue(“Jack”, 1);priorityQueue.enqueue(“Camila”, 1);priorityQueue.print(); 以上代码是一个使用PriorityQueue类的示例。在下图中可以看到每条命令的结果（以上代码的结果） 第一个被添加的元素是优先级为2的John。因为此前队列为空，所以它是队列中唯一的元素。接下来，添加了优先级为1的Jack。由于Jack的优先级高于John，它就成了队列中的第一个元素。然后，添加了优先级也为1的Camila。Camila的优先级和Jack相同，所以它会被插入到Jack之后（因为Jack先被插入队列）；Camila的优先级高于John，所以它会被插入到John之前。 我们在这里实现的优先队列称为最小优先队列，因为优先级的值较小的元素被放置在队列最前面（1代表更高的优先级）。最大优先队列则与之相反，把优先级的值较大的元素放置在队列最前面。 四、循环队列——击鼓传花还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏（HotPotato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子（胜者）。 在下面这个示例中，我们要实现一个模拟的击鼓传花游戏： 123456789101112131415161718192021222324252627282930313233343536373839404142let Queue = (function () &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; return items.get(this).push(element) // return items.get(this); &#125; dequeue() &#123; return items.get(this).shift(); // return items.get(this); &#125; size() &#123; return items.get(this).length; &#125; print() &#123; console.log(items.get(this).toString()); &#125; &#125; return Queue&#125;)();function hotPotato(nameList, num) &#123; let queue = new Queue(); // &#123;1&#125; for (let i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); // &#123;2&#125; &#125; let eliminated = ''; while (queue.size() &gt; 1) &#123; for (let i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); // &#123;3&#125; John queue.print() &#125; eliminated = queue.dequeue();// &#123;4&#125; // console.log(eliminated + '在击鼓传花游戏中被淘汰。'); //Camila,Jack,Carl,Ingrid &#125; return queue.dequeue();// &#123;5&#125;&#125;let names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; let winner = hotPotato(names, 7); console.log('The winner is: ' + winner); //The winner is: John 实现一个模拟的击鼓传花游戏，要用到实现的Queue类（行{1}）。我们会得到一份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被淘汰的威胁立刻就解除了）。一旦传递次数达到给定的数字，拿着花的那个人就被淘汰了（从队列中移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）。 以上算法的输出如下： Camila在击鼓传花游戏中被淘汰。Jack在击鼓传花游戏中被淘汰。Carl在击鼓传花游戏中被淘汰。Ingrid在击鼓传花游戏中被淘汰。胜利者：John 下图模拟了这个输出过程：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法三（栈）","date":"2018-09-28T09:58:31.000Z","path":"2018/09/28/cjvasuimt000nckvb2wi0e10c/","text":"一、栈数据结构栈是一种遵从后进先出(LIFO)原则的有序数据集合。新添加的或者待删除的元素保存在栈的同一端称为栈顶，另一端称为栈底。在栈里新添加的元素都靠近栈顶，旧添加的元素都接近栈底 1.1 创建栈先创建一个类表示栈，先声明一个类： function Stack() { //各种属性和方法的声明 } 首先，我们需要一种数据结构来保存栈里的元素。可以选择数组： let items = []; 接下来，要为我们的栈声明一些方法。 push(element(s))：添加一个（或几个）新元素到栈顶。 pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。 isEmpty()：如果栈里没有任何元素就返回true，否则返回false。 clear()：移除栈里的所有元素。 size()：返回栈里的元素个数。这个方法和数组的length属性很类似。 1.2 像栈中添加元素我们要实现的第一个方法是push。这个方法负责往栈里添加新元素，有一点很重要：该方法只添加元素到栈顶，也就是栈的末尾。push方法可以这样写： this.push = function(element){ items.push(element); }; 1.3 从栈中移除元素接着，我们来实现pop方法。这个方法主要用来移除栈里的元素。栈遵从LIFO原则，因此移出的是最后添加进去的元素。因此，我们可以用数组的pop方法。栈的pop方法可以这样写： this.pop = function(){ return items.pop(); }; 1.4 查看栈顶元素现在，为我们的类实现一些额外的辅助方法。如果想知道栈里最后添加的元素是什么，可以用peek方法。这个方法将返回栈顶的元素： this.peek = function(){ return items[items.length-1]; }; 1.5 检测栈是否为空下一个要实现的方法是 isEmpty，如果栈为空的话将返回true，否则就返回false： this.isEmpty = function(){ return items.length == 0; }; 使用isEmpty方法，我们能简单地判断内部数组的长度是否为0。 类似于数组的length属性，我们也能实现栈的length。对于集合，最好用size代替length。因为栈的内部使用数组保存元素，所以能简单地返回栈的长度： this.size = function(){ return items.length; }; 1.6 清空和打印栈元素最后，我们来实现clear方法。clear方法用来移除栈里所有的元素，把栈清空。实现这个方法最简单的方式是： this.clear = function(){ items = []; }; 另外也可以多次调用pop方法，把数组中的元素全部移除，这样也能实现clear方法。 如下案例，为了检查栈里的内容，实现一个辅助方法print。它会把栈里的元素都输出到控制台： this.print = function(){ console.log(items.toString()); }; 1.7 使用Stack类首先，我们需要初始化Stack类。然后，验证一下栈是否为空（输出是true，因为还没有往栈里添加元素）。 1234567891011121314151617181920212223242526function Stack()&#123; this.push = function (element) &#123; return items.push(element) &#125; this.pop = function () &#123; return items.pop(); &#125;; this.peek = function () &#123; return items[items.length - 1]; &#125;; this.isEmpty = function () &#123; return items.length == 0; &#125;; this.size = function () &#123; return items.length; &#125;; this.clear = function()&#123; items = []; &#125;; this.print = function()&#123; console.log(items.toString()); &#125;; &#125;let items = [];let stack = new Stack();console.log(stack.isEmpty()); //true 接下来，往栈里添加一些元素（这里我们添加数字5和8；你可以添加任意类型的元素）: Stack.push(5); Stack.push(8); 如果调用peek方法，将会输出8，因为它是往栈里添加的最后一个元素： console.log(stack.peek()); //输出8 再添加一个元素： stack.push(11); console.log(stack.size()); //输出3 console.log(stack.isEmpty()); //输出false 我们往栈里添加了11。如果调用size方法，输出为3，因为栈里有三个元素（5、8和11）。如果我们调用isEmpty方法，会看到输出了false（因为栈里有三个元素，不是空栈）。最后，我们再添加一个元素： stack.push(15); 下图描绘了目前为止我们对栈的操作，以及栈的当前状态： 然后，调用两次pop方法从栈里移除2个元素： stack.pop(); stack.pop(); console.log(stack.size()); //输出2 stack.print(); //输出[5, 8] 在两次调用pop方法前，我们的栈里有四个元素。调用两次后，现在栈里仅剩下5和8了。下图描绘这个过程的执行： 二、ECMAScript 6 和 Stack 类2.1 用 ES6 语法声明 Stack 类class Stack { constructor () { this.items = []; //{1} } push(element){ this.items.push(element); } //其他方法 } 我们只是用ES6的简化语法把Stack函数转换成Stack类。这种方法不能像其他语言（Java、C++、C#）一样直接在类里面声明变量，只能在类的构造函数constructor里声明（行{1}，在类的其他函数里用this.nameofVariable就可以引用这个变量。 尽管代码看起来更简洁、更漂亮，变量items却是公共的。ES6的类是基于原型的。虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性（变量）或方法。而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法。否则，就有可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。 2.1.1 用ES6的限定作用域Symbol实现类ES6新增了一种叫作Symbol的基本类型，它是不可变的，可以用作对象的属性。 let _items = Symbol(); //{1} class Stack { constructor () { this[_items] = []; //{2} } //Stack方法 } 在上面的代码中，我们声明了Symbol类型的变量_items（行{1}），在类的constructor函数中初始化它的值（行{2}）。要访问_items，只需把所有的this.items都换成this[_items]。 这种方法创建了一个假的私有属性，因为ES6新增的Object.getOwnPropertySymbols方法能够取到类里面声明的所有Symbols属性。下面是一个破坏Stack类的例子： let _items = Symbol(); class Stack { constructor() { this[_items] = []; } push(element) { return this[_items].push(element); }; print() { console.log(this[_items].toString()); }; } let stack = new Stack(); stack.push(5); stack.push(8); let objectSymbols = Object.getOwnPropertySymbols(stack); console.log(objectSymbols.length); // 1 console.log(objectSymbols); // [Symbol()] console.log(objectSymbols[0]); // Symbol() stack[objectSymbols[0]].push(1); stack.print(); //输出 5, 8, 1 从以上代码可以看到，访问stack[objectSymbols[0]]是可以得到_items的。并且，_items属性是一个数组，可以进行任意的数组操作，比如从中间删除或添加元素。我们操作的是栈，不应该出现这种行为。 2.1.2 用ES6的WeakMap实现类有一种数据类型可以确保属性是私有的，这就是WeakMap。WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。 如果用WeakMap来存储items变量，Stack类就是这样的： const items = new WeakMap(); //{1} class Stack { constructor () { items.set(this, []); //{2} } push(element) { let s = items.get(this); //{3} s.push(element); } pop() { let s = items.get(this); let r = s.pop(); return r; } //其他方法 } //行{1}，声明一个WeakMap类型的变量items。 //行{2}，在constructor中，以this（Stack类自己的引用）为键，把代表栈的数组存入items。 //行{3}，从WeakMap中取出值，即以this为键（行{2}设置的）从items中取值。 现在我们知道，items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap： let Stack = (function () { const items = new WeakMap(); class Stack { constructor () { items.set(this, []); } //其他方法 } return Stack; //{5} })(); //当Stack函数里的构造函数被调用时，会返回Stack类的一个实例（行{5}）。 现在，Stack类有一个名为items的私有属性。虽然它很丑陋，但毕竟实现了私有属性。然而，用这种方法的话，扩展类无法继承私有属性。鱼与熊掌不可兼得！ 把上面的代码跟本章最初实现的Stack类做个比较，我们会发现有一些相似之处： function Stack() { let items = []; //其他方法 } 事实上，尽管ES6引入了类的语法，我们仍然不能像在其他编程语言中一样声明私有属性或方法。有很多种方法都可以达到相同的效果，但无论是语法还是性能，这些方法都有各自的优点和缺点 哪种方法更好？这取决于你在实际项目中如何使用本书中这些算法，要处理的数据量，要创建的实例个数，以及其他约束条件。最终，还是取决于你。 2.2 用栈解决问题栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后续再讨论图和回溯问题时，我们会学习如何应用这个例子）。Java和C#用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 2.2.1 从十进制到二进制现实生活中，我们主要使用十进制。但在计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的（0和1）。没有十进制和二进制相互转化的能力，与计算机交流就很困难。 要把十进制转化成二进制，我们可以将该十进制数字和2整除（二进制是满二进一），直到结果是0为止。举个例子，把十进制的数字10转化成二进制的数字，过程大概是这样： 大学的计算机课一般都会先教这个进制转换。下面是对应的算法描述： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop(); } isEmpty() { return items.get(this).length == 0; }; } return Stack; })(); function divideBy2(decNumber) { var remStack = new Stack(), rem, binaryString = &apos;&apos;; while (decNumber &gt; 0) { //{1} rem = Math.floor(decNumber % 2); //{2} remStack.push(rem); //{3} decNumber = Math.floor(decNumber / 2); //{4} } while (!remStack.isEmpty()) { binaryString += remStack.pop().toString(); //{5} } return binaryString; } console.log(divideBy2(13)); //1101 在这段代码里，当结果满足和2做整除的条件时（行{2}），我们会获得当前结果和2的余数，放到栈里（行{2}、{3}）。然后让结果和2做整除（行{4}）。另外请注意：JavaScript有数字类型，但是它不会区分究竟是整数还是浮点数。因此，要使用Math.floor函数让除法的操作仅返回整数部分。最后，用pop方法把栈中的元素都移除，把出栈的元素变成连接成字符串（行{5}）。 2.2.2 进制转换算法我们很容易修改之前的算法，使之能把十进制转换成任何进制。除了让十进制数字和2整除转成二进制数，还可以传入其他任意进制的基数为参数，就像下面算法这样： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop() } isEmpty() { return items.get(this).length == 0; }; } return Stack; //{5} })(); function baseConverter(decNumber, base) { var remStack = new Stack(), rem, baseString = &apos;&apos;, digits = &apos;0123456789ABCDEF&apos;; //{6} while (decNumber &gt; 0) { rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); } while (!remStack.isEmpty()) { baseString += digits[remStack.pop()]; //{7} } return baseString; } console.log(baseConverter(13,2)); //1101 console.log(baseConverter(13,8)); //15 我们只需要改变一个地方。在将十进制转成二进制时，余数是0或1；在将十进制转成八进制时，余数是0到7之间的数；但是将十进制转成16进制时，余数是0到9之间的数字加上A、B、C、D、E和F（对应10、11、12、13、14和15）。因此，我们需要对栈中的数字做个转化才可以（行{6}和行{7}）。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法二（数组的使用）","date":"2018-09-10T11:24:31.000Z","path":"2018/09/10/cjvasuinv0011ckvba2omrsut/","text":"一、创建和初始化数组1.1 创建数组用JavaScript声明、创建和初始化数组有两种方式 //使用new创建数组 var daysOfWeek = new Array(); //{1} var daysOfWeek = new Array(7); //{2} var daysOfWeek = new Array(&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;); //{3} 使用new关键字，就能简单地声明并初始化一个数组（行{1}）。用这种方式，还可以创建一 个指定长度的数组（行{2}）。另外，也可以直接将数组元素作为参数传递给它的构造器（行{3}）。 //使用[]创建数组 var daysOfWeek = []; 也可使用一些元素初始化数组，如下： var daysOfWeek = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; 使用数组的length属性获取数组的长度 console.log(daysOfWeek.length); //7 1.2 访问元素和迭代数组要访问数组里特定位置的元素，可以用中括号传递数值位置，得到想知道的值或者赋新的值。如下： for (var i=0; i&lt;daysOfWeek.length; i++){ console.log(daysOfWeek[i]); } 我们来看另一个例子：求斐波那契数列的前20个数字。已知斐波那契数列中第一个数字是1，第二个是2，从第三项开始，每一项都等于前两项之和： var fibonacci = []; //{1} fibonacci[1] = 1; //{2} fibonacci[2] = 2; //{3} for(var i = 3; i &lt; 20; i++){ fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]; ////{4} } for(var i = 1; i&lt;fibonacci.length; i++){ //{5} console.log(fibonacci[i]); //{6} } 在行{1}处，我们声明并创建了一个数组。 在行{2}和行{3}，把斐波那契数列中的前两个数字分别赋给了数组的第二和第三位（在JavaScript中，数组的第一位是0，这里我们略过，从第二位开始分别保存斐波那契数列中对应位置的元素）。 然后，我们需要做的就是想办法得到斐波那契数列的第三到第二十位的数字（前两个值我们已经初始化过了）。我们可以用循环来处理，把数组中前两位上的元素相加，结果赋给当前位置上的元素（行{4}——从数组中的索引3到索引19）。 最后，看看输出（行{6}），我们只需要循环遍历数组的各个元素（行{5}）。 1.3 添加元素1.3.1 使用数组索引直接添加var numbers = [0,1,2,3,4,5,6,7,8,9]; 如果想要给数组添加一个元素（比如10），只要把值赋给数组中最后一个空位上的元素即可。 numbers[numbers.length] = 10; 1.3.2 使用push方法push方法，能把元素添加到数组的末尾 numbers.push(11); numbers.push(12, 13); 1.3.3 插入元素到数组首位现在，我们希望在数组中插入一个值，不像之前那样插入到最后，而是放到数组的首位。为了实现这个需求，首先我们要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位+1（长度）开始，将其对应的前一个元素的值赋给它，依次处理，最后把我们想要的值赋给第一个位置（-1）上。 for (var i=numbers.length; i&gt;=0; i--){ numbers[i] = numbers[i-1]; } numbers[0] = -1; 下面这张图描述了我们刚才的操作过程： ; 也可以使用unshift方法 numbers.unshift(-2); numbers.unshift(-4, -3); 1.4 删除元素1.4.1 删除数组里最靠后的元素删除数组里最靠后的元素使用pop方法： numbers.pop(); 1.4.2 从数组首位删除元素如果要移除数组里的第一个元素，可以用下面的代码： for (var i = 0; i &lt; numbers.length; i++){ numbers[i] = numbers[i+1]; } 下面这张图呈现了这段代码的执行过程： 我们把数组里所有的元素都左移了一位。但数组的长度依然是17，这意味着数组中有额外的 一个元素（值是undefined）。在最后一次循环里，i + 1引用了一个数组里还未初始化的位置。 在Java、C/C+或C#等一些语言里，这样写可能就会抛出异常了，因此不得不在 numbers.length - 1处停止循环。 可以看到，我们只是把数组第一位的值用第二位覆盖了，并没有删除元素（因为数组的长度 和之前还是一样的，并且了多一个未定义元素）。 使用unshift()方法 numbers.shift(); //通过shift和unshift方法，就能用数组模拟基本的队列数据结构， 1.4.3 在任意位置添加或删除元素使用splice方法，简单地通过指定位置/索引，就可以删除相应位置和数量的元素： //如下 numbers.splice(5,3); //这行代码删除了从数组索引5开始的3个元素。这就意味着numbers[5]、numbers[6]和numbers[7]从数组中删除了。 splice方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除元素的个数（这个例子里，我们的目的不是删除元素，所以传入0）。第三个参数往后，就是要添加到数组里的值（元素2、3、4）。输出会发现值又变成了从3到12。 numbers.splice(5,3,2,3,4);//我们从索引5开始删除了3个元素，但也从索引5开始添加了元素2、3、4 对于JavaScript数组和对象，我们还可以用delete操作符删除数组中的元素，例如delete numbers[0]。然而，数组位置0的值会变成undefined，也就是说，以上操作等同于numbers[0] = undefined。因此，我们应该始终使用splice、pop或shift（马上就会学到）方法来删除数组元素。 二、 二维和多维数组JavaScript只支持一维数组，并不支持矩阵(二维数组)。但是，我们可以用数组套数组，实现矩阵或任一多维数组。代码也可以写成这样： var averageTemp = []; averageTemp[0] = []; averageTemp[0][0] = 72; averageTemp[0][1] = 75; averageTemp[0][2] = 79; averageTemp[0][3] = 79; averageTemp[0][4] = 81; averageTemp[0][5] = 81; //day 2 averageTemp[1] = []; averageTemp[1][0] = 81; averageTemp[1][1] = 79; averageTemp[1][2] = 75; averageTemp[1][3] = 75; averageTemp[1][4] = 73; averageTemp[1][5] = 72; 上面的代码里，我们分别指定了每天和每小时的数据。数组中的内容如下图所示： 每行就是每天的数据，每列是当天不同时段的气温 2.1 迭代二维数组的元素如果想看矩阵的输出，我们可以创建一个通用函数，专门输出其中的值： function printMatrix(myMatrix) { for (var i=0; i&lt;myMatrix.length; i++){ for (var j=0; j&lt;myMatrix[i].length; j++){ console.log(myMatrix[i][j]); } } } 需要遍历所有的行和列。因此，我们需要使用一个嵌套的for循环来处理，其中变量i为行，变量j为列。 使用以下代码查看矩阵averageTemp的输出： printMatrix(averageTemp); 2.2 多维数组我们也可以用这种方式来处理多维数组。假如我们要创建一个3×3×3的矩阵，每一格里包含矩阵的i（行）、j（列）及z（深度）之和： var matrix3x3x3 = []; for (var i=0; i&lt;3; i++){ matrix3x3x3[i] = []; for (var j=0; j&lt;3; j++){ matrix3x3x3[i][j] = []; for (var z=0; z&lt;3; z++){ matrix3x3x3[i][j][z] = i+j+z; } } } 数据结构中有几个维度都没关系，我们都可以用循环遍历每个维度来访问所有格子。3×3×3的矩阵也可用立体图表示如下： 可以用以下代码输出这个矩阵的内容： for (var i=0; i&lt;matrix3x3x3.length; i++){ for (var j=0; j&lt;matrix3x3x3[i].length; j++){ for (var z=0; z&lt;matrix3x3x3[i][j].length; z++){ console.log(matrix3x3x3[i][j][z]); } } } 如果是一个3×3×3×3的矩阵，代码中就会用四层嵌套的for语句，以此类推。 2.3 JavaScript 的数组方法参考 方法名 语法 concat 连接数组（一个或多个），返回连接后的结果 every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach 遍历数组 join 将所有的数组元素连接成一个字符串 indexOf 从数组开始查找数组元素在数组中的的位置，并返回，没有找到则返回-1 lastIndexOf 从数组结尾查找数组元素在数组中的的位置，并返回，没有找到则返回-1 map 遍历数组元素，并返回 reverse 颠倒数组中元素的顺序 slice 截取数组中的元素 some 对数组中的每一项运行给定函数，如果任一项返回true，则返回true sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 toString 将数组作为字符串返回 valueOf 和toString类似，将数组作为字符串返回 2.3.1 数组合并concat方法可以向一个数组传递数组、对象或是元素。数组会按照该方法传入的参数顺序连接指定数组。如下： var zero = 0; var positiveNumbers = [1,2,3]; var negativeNumbers = [-3,-2,-1]; var numbers = negativeNumbers.concat(zero, positiveNumbers); //[3,2,1,0,1,2,3] 2.3.1 迭代器函数迭代数组中的元素可以使用for循环，同样JavaScript内置了许多数组可用的迭代方法 解决如下案例： 假如有一个数组，它值是从1到15，如果数组里的元素可以被2整除（偶数），函数就返回true，否则返回false： var isEven = function (x) { // 如果x是2的倍数，就返回true console.log(x); return (x % 2 == 0) ? true : false; }; var numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; 用every方法迭代 numbers.every(isEven); //false //数组numbers的第一个元素是1，它不是2的倍数（1是奇数），因此isEven 函数返回false，然后every执行结束。 用some方法迭代 some方法会迭代数组的每个元素，直到函数返回true： numbers.some(isEven); //numbers数组中第一个偶数是2（第二个元素）。第一个被迭代的元素是1， isEven会返回false。第二个被迭代的元素是2，isEven返回true——迭代结束。 用forEach方法迭代 numbers.forEach(function(x){ console.log((x % 2 == 0)); }); 使用map和filter方法 var myMap = numbers.map(isEven); //[false, true, false, true, false, true, false, true,false, true, false, true, false, true, false]。 filter方法返回新数组由使函数返回true的元素组成： var evenNumbers = numbers.filter(isEven); //[2, 4, 6, 8, 10, 12, 14] 使用reduce方法 reduce方法接收一个函数作为参数，这个函数有四个参数：previousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器 numbers.reduce(function(previous, current, index){ return previous + current; //120 }); 2.4 ECMAScript 6 和数组的新功能下标展示了一些ES6和ES7新增的数组方法 方法 描述 @@iterator 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 copyWithin 复制数组中一系列元素到同一数组指定的起始位置 entries 返回包含数组所有键值对的@@iterator includes 如果数组中存在某个元素则返回true，否则返回false。ES7新增 find 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素 findIndex 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引-1 fill 用静态值填充数组-1 from 根据已有数组创建一个新数组 keys 返回包含数组所有索引的@@iterator of 根据传入的参数创建一个新数组 values 返回包含数组中所有值的@@iterator sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 除了这些新的方法，还有一种用for…of循环来迭代数组的新做法，以及可以从数组实例得到的迭代器对象 2.4.1 使用forEach和箭头函数迭代箭头函数可以简化使用forEach迭代数组元素的做法，如下 numbers.forEach(function (x) { console.log(x % 2 == 0); }); //这段代码可以简化如下： numbers.forEach(x =&gt; { console.log((x % 2 == 0)); }); 2.4.2 使用for…of循环迭代for (let n of numbers) { console.log((n % 2 == 0) ? &apos;even&apos; : &apos;odd&apos;); } 2.4.3 ES6新的迭代器（@@iterator）ES6还为Array类增加了一个@@iterator属性，需要通过Symbol.iterator来访问。代码如下: let iterator = numbers[Symbol.iterator](); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 console.log(iterator.next().value); // 4 console.log(iterator.next().value); // 5 然后，不断调用迭代器的next方法，就能依次得到数组中的值,数组中所有值都迭代完之后，iterator.next().value会返回undefined。 2.4.4 数组的entries、keys和values方法 entries: 返回包含键值对的@@iterator，如下案例： let numbers = [1,2,3] let aEntries = numbers.entries(); // 得到键值对的迭代器,key是数组中的位置，value是保存在数组索引的值。 console.log(aEntries.next().value); // [0, 1] - 位置0的值为1 console.log(aEntries.next().value); // [1, 2] - 位置1的值为2 console.log(aEntries.next().value); // [2, 3] - 位置2的值为3 entries方法会返回numbers数组位置以及对应的值，如果没有可迭代的值则返回undefined。 entries：方法返回包含数组索引的@@iterator，如下案例： let numbers = [1,2,3] let aKeys = numbers.keys(); // 得到数组索引的迭代器 console.log(aKeys.next()); // {value: 0, done: false } console.log(aKeys.next()); // {value: 1, done: false } console.log(aKeys.next()); // {value: 2, done: false } console.log(aKeys.next()); // {value: undefined, done: true } keys方法会返回numbers数组的索引。一旦没有可迭代的值，aKeys.next()就会返回一个value属性为undefined，done属性为true的对象。如果done属性的值为false，就意味着还有可迭代的值。 values：方法返回的@@iterator则包含数组的值 let numbers = [1,2,3] let aValues = numbers.values(); console.log(aValues.next()); // {value: 1, done: false } console.log(aValues.next()); // {value: 2, done: false } console.log(aValues.next()); // {value: 3, done: false } console.log(aValues.next()); // {value: undefined, done: true } 2.4.5 from方法Array.from方法根据已有的数组创建一个新数组，参数为过滤Array中元素的函数 let evens = Array.from(numbers, x =&gt; (x % 2 == 0)); 2.4.6 用Array.of方法Array.of方法根据传入的参数创建一个新数组 let numbers4 = Array.of(1, 2, 3, 4, 5, 6); //[1,2,3,4,5,6] 也可以用这个方法复制已有的数组 let numbersCopy = Array.of(...numbers4); //[1,2,3,4,5,6] 2.4.7 使用fill方法fill方法用静态值填充数组,参数为要添加的位置范围 let numbersCopy = Array.of(1, 2, 3, 4, 5, 6); numbersCopy.fill(0); //（[0, 0, 0, 0, 0, 0] numbersCopy.fill(1, 3, 5); //[0, 0, 0, 1, 1, 0] 创建数组并初始化值的时候，fill方法非常方便，如下： let ones = Array(6).fill(1); //[1, 1, 1, 1, 1, 1] 2.4.8 copyWithin方法copyWithin方法复制数组中的一系列元素到同一数组指定的起始位置 let copyArray = [1, 2, 3, 4, 5, 6]; copyArray.copyWithin(0, 3); // [4, 5, 6, 4, 5, 6] copyArray.copyWithin(1, 3, 5); //[4,4,5,4,5,6] 2.4.9 排序元素 反转数组reverse： let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. 15]; numbers.reverse(); //[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]; 对数组进行排序sort： numbers.sort(); //[1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9] //sort方法在对数组做排序时，把元素默认成字符串进行相互比较。 //所以在使用的时候传入自己写的比较函数 numbers.sort(function(a, b){ return a-b; }); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 自定义排序 我们可以对任何对象类型的数组排序，也可以创建compareFunction来比较元素。例如，对象Person有名字和年龄属性，我们希望根据年龄排序，就可以这么写： var friends = [ {name: &apos;John&apos;, age: 30}, {name: &apos;Ana&apos;, age: 20}, {name: &apos;Chris&apos;, age: 25} ]; function comparePerson(a, b){ if (a.age &lt; b.age){ return -1 } if (a.age &gt; b.age){ return 1 } return 0; } console.log(friends.sort(comparePerson)); //在这个例子里，最后会输出Ana(20), Chris(25), John(30)。 字符串排序 JavaScript在做字符比较的时候，是根据字符对应的ASCII值来比较的。 如下案例： var names =[&apos;Ana&apos;, &apos;ana&apos;, &apos;john&apos;, &apos;John&apos;]; console.log(names.sort()); //[&quot;Ana&quot;, &quot;John&quot;, &quot;ana&quot;, &quot;john&quot;] //因为A、J、a、j对应的ASCII值分别是65、75、97、106。 现在，如果给sort传入一个忽略大小写的比较函数，将会输出[“Ana”, “ana”, “John”,”john”]： names.sort(function(a, b){ if (a.toLowerCase() &lt; b.toLowerCase()){ return -1 } if (a.toLowerCase() &gt; b.toLowerCase()){ return 1 } return 0; }); 假如对带有重音符号的字符做排序的话，我们可以用localeCompare来实现： var names2 = [&apos;Maève&apos;, &apos;Maeve&apos;]; console.log(names2.sort(function(a, b){ return a.localeCompare(b); })); //[&quot;Maeve&quot;, &quot;Maève&quot;] 搜索（indexOf/lastIndexOf） 搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引,如果没有匹配的元素则返回-1。 console.log(numbers.indexOf(10)); //9 console.log(numbers.indexOf(100)); //-1 搜索（ECMAScript 6——find和findIndex方法） find和findIndex方法接收一个回调函数，搜索一个满足回调函数条件的值。 let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; function multipleOf13(element, index, array) { return (element % 13 == 0) ? true : false; } console.log(numbers.find(multipleOf13)); //13 console.log(numbers.findIndex(multipleOf13)); //12 //find和findIndex的不同之处在于，find方法返回第一个满足条件的值。 //findIndex方法则返回这个值在数组里的索引。 //如果没有满足条件的值，find会返回undefined，而findIndex返回-1。 搜索（ECMAScript 7——使用includes方法） 如果数组里存在某个元素，includes方法会返回true，否则返回false。 console.log(numbers.includes(15)); //true console.log(numbers.includes(20)); //false 如果给includes方法传入一个起始索引，搜索会从索引指定的位置开始： let numbers2 = [7, 6, 5, 4, 3, 2, 1]; console.log(numbers2.includes(4, 5)); //false 2.4.10 输出数组为字符串 toString 把数组里所有元素输出为一个字符串 let numbers = [1, 2, 3, 4] console.log(numbers.toString()); //1,2,3,4 如果想用一个不同的分隔符（比如-）把元素隔开，可以用join方法： var numbersString = numbers.join(&apos;-&apos;); console.log(numbersString); //1-2-3-4 三、 类型数组JavaScript数组不是强类型的，因此它可以存储任意类型的数据。而类型数组则用于存储单一类型的数据。它的语法是let myArray = new TypedArray(length)，其中TypedArray需替换为下表所列之一。 类型数组 数据类型 Int8Array 8位二进制补码整数 Uint8Array 8位无符号整数 Uint8ClampedArray 8位无符号整数 Int16Array 16位二进制补码整数 Uint16Array 16位无符号整数 Int32Array 32位二进制补码整数 Uint32Array 32位无符号整数 Float32Array 32位IEEE浮点数 Float64Array 64位IEEE浮点数 代码示例如下： let length = 5; let int16 = new Int16Array(length); for (let i=0; i&lt;length; i++){ int16[i] = i+1; } console.log(int16); //[1, 2, 3, 4, 5] 使用WebGL API、进行位操作、处理文件和图像时，类型数组都可以大展拳脚。它用起来和普通数组也毫无二致，本章所学的数组方法和功能都可以用于类型数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法一（javascript基础）","date":"2018-08-16T11:20:30.000Z","path":"2018/08/16/cjvasui2d0003ckvb4s6mrhpa/","text":"一、相等操作符（==和===）1.相等操作符（==）在使用==时，不同类型的值也可以被看作相等下面表格展示了不同类型的值用相等操作符比较后的结果。 类型（x） 类型（y） 结 果 null undefined true undefined null true 数字 字符串 x == toNumber(y) 字符串 数字 toNumber(x) == y 布尔值 任意类型 toNumber(x) == y 任意类型 布尔值 x == toNumber(y) 字符串或数字 对象 x == toPrimitive(y) 对象 字符串或数字 toPrimitive(x) == y 如果x和y是相同类型，JavaScript会比较它们的值或对象值。其他没有列在这个表格中的情况都会返回false。toNumber和toPrimitive方法是内部的，并根据以下表格对其进行估值。toNumber方法对不同类型返回的结果如下： 值类型 结 果 undefined NAN null +0 布尔值 如果是true，返回1；如果是false，返回+0 数字 数字对应的值 字符串 将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字 对象 Number(toPrimitive(vale)) toPrimitive方法对不同类型返回的结果如下： 值类型 结 果 对象 如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误 例：console.log(&apos;packt&apos; == true); //输出false 首先，布尔值会被toNumber方法转成数字，因此得到packt == 1。 其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式就变成了NaN == 1，结果就是false。 1.相等操作符（===）如果比较的两个值或者类型不同则返回false，如果比较的两个值类型相同，结果会根据下表判断。 类型（x） 类型（y） 结 果 数字 x和y数值相同（但不是NaN） true 字符串 x和y是相同的字符 true 布尔值 x和y都是true或false true 对象 x和y引用同一个对象 true 例：console.log(&apos;packt&apos; === true); //false console.log(&apos;packt&apos; === &apos;packt&apos;); //true 二、声明展开和剩余参数2.1展开操作符在es5中使用apply()函数将数组转化为参数，在es6中使用展开操作符(…); 例： var params = [1, 3, 5] function sum(a=1, b=3, c=4) { return a+b+c } console.log(sum(...params)); //es6使用扩展符传入数组 console.log(sum.apply(null, params)); //es5使用apply传入数组 在函数中也可以使用展开操作符(…)代替arguments，当做剩余参数使用，如下案例： function restParamaterFunction (x, y, ...a) { return (x + y) * a.length; } console.log(restParamaterFunction(1, 2, &quot;hello&quot;, true, 7)); //输出9; es5中实现 function restParamaterFunction(x, y) { var a = Array.prototype.slice.call(arguments, 2); console.log(a) return (x + y) * a.length; }; 2.2数组解构es6引入数组解构的概念，可以一次初始化多个变量，如下： var [x, y] = [&apos;a&apos;, &apos;b&apos;]; 等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; 数组解构也可以用来进行值的互换，而不需要创建临时变量，如下： [x, y] = [y, x]; //等同于 var temp = x, x = y, y = temp; 对象也可以解构，如下： //属性简写的功能， var [x, y] = [&apos;a&apos;, &apos;b&apos;]; var obj = { x, y }; console.log(obj); // { x: &quot;a&quot;, y: &quot;b&quot; } //等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; var obj2 = { x: x, y: y }; console.log(obj2); // { x: &quot;a&quot;, y: &quot;b&quot; } //方法属性 var hello = { name : &apos;abcdef&apos;, printHello() { console.log(&apos;Hello&apos;); } } console.log(hello.printHello()); //等同于 var hello = { name: &apos;abcdef&apos;, printHello: function printHello() { console.log(&apos;Hello&apos;); } }; 三、使用类进行面向对象编程声明一个book类的方式 function Book(title, pages, isbn){ //{1} this.title = title; this.pages = pages; this.isbn = isbn; } Book.prototype.printTitle = function(){ console.log(this.title); }; 使用es6可以简化为一下语法 只需要使用class关键字声明一个constructor函数和其他函数 class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } //以上两种声明据用相同的效果和输出 let book = new Book(&apos;title&apos;, &apos;pag&apos;, &apos;isbn&apos;); console.log(book.title); //输出图书标题 book.title = &apos;new title&apos;; //更新图书标题 console.log(book.title); //输出图书标题 3.1继承es6简化声明类的方式 如下： class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } class ITBook extends Book { //{扩展book并继承其行为 constructor (title, pages, isbn, technology) { super(title, pages, isbn); //引用父类的构造函数 this.technology = technology; } printTechnology(){ console.log(this.technology); } } let jsBook = new ITBook(&apos;学习JS算法&apos;, &apos;200&apos;, &apos;1234567890&apos;, &apos;JavaScript&apos;); console.log(jsBook.title); console.log(jsBook.printTechnology()); //我们可以使用extends关键字扩展一个类并继承它的行为。在构造函数中，也可以通过super关键字引用父类的构造函数。 3.2使用属性存取器使用新的类语法也可以为属性创建存取器函数。如下： class Person { constructor(name) { this._name = name; //{1} } get name() { //{2} return this._name; } set name(value) { //{3} this._name = value; } } let lotrChar = new Person(&apos;Frodo&apos;); console.log(lotrChar.name); //Frodo lotrChar.name = &apos;Gandalf&apos;; console.log(lotrChar.name); //Gandalf lotrChar._name = &apos;Sam&apos;; console.log(lotrChar.name); //Sam //要声明get和set函数，只需要在我们要暴露和使用的函数名前面加上get或set关键字。可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的。 然后，只要像普通的属性一样，引用它们的名字，就可以执行get和set函数。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"认识es6","date":"2018-08-05T11:02:07.000Z","path":"2018/08/05/cjvasuimv000qckvb5pspszls/","text":"es6常用api介绍一、let和const命令介绍及区别1. let命令：1）、基本用法： es5只有两种方式声明变量var以及function，es6新增了四种let、const、import、class； let声明的变量的方式与var相似，但是声明的变量，只在let命令所在的代码块中生效; { let a = 1; var b = 2; } console.log(a);//Error in created hook: &quot;ReferenceError: a is not defined&quot; console.log(b);//2 上面在代码块中使用let，var分别声明了连个变量，然后再代码块外面调用，let声明的变量会报错，var声明的 返回值正常，表明let只在它所在的代码块中生效； 2）、let不存在变量提升问题 我们知道使用var声明的变量会存在变量提升问题，但是在let中不存在这种现象 console.log(a);//undefined var a = 1; console.log(b);//报错 let b = 2; 上述代码中，使用let声明了变量b，在声明之前使用会报错，而使用var声明的变量，在使用前值是undefined； 3）、暂时性死区在es6中规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，在声明前使用这些变量就会报错； var a = 1; { a = 3; console.log(a);//报错 let a; } 4）、不允许重复声明let不允许在相同作用域内重复声明同一个变量 // 报错 function fn1() { let a = 1; var a = 2; } // 报错 function fn2() { let a = 1; let a = 2; } function fn3(argements) { let argements; // 也会报错 } es6规定暂时性死区，以及let，const语句不提升变量，主要是为了减少运行时错误，防止在变量声明前就是用这个变量。从而导致意料之外的行为； 1. const命令：const声明一个常量，一旦声明，常量的值就不能改变了，所以const在声明是必须立即初始化，不能留到以后赋值，如果修改它的值会报错 const index = 1; console.log(index)//1 index = 3;// 报错 const num;报错 const声明的常量也不存在变量提升，同样的也是有暂时性死区，也不能重复声明变量 二、块级作用域1、块级作用域的用处在es5中只有全局作用域以及函数作用域，在许多情况下使用很不方便 var num = 1; function f() { console.log(num); if (false) { var num = 2; } } f(); // undefined //在上述代码中在函数内部声明的变量覆盖了外层声明的变量； var index = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 //在for循环中的计数变量会泄露到全局 2、es6中的块级作用域function fn1() { let i = 5; if (true) { let i = 10; } console.log(n); // 5 } //上述代码中存在两个代码块，都声明了变量i，在运行后输出5，说明function声明的代码块不受if(){}代码块的影响 { { {let i = 5}； console.log(i)//报错 } } //let只在当前代码块中生效,其他代码块中是无法使用的，在es6中允许使用作用域的任意嵌套 {{{ let i = 1; {let i = 2};//不报错，不同的作用域中可以声明同一个变量 }}} 3、块级作用域域函数作用域在es5中函数只能在顶层作用域中以及函数作用域中声明，不能再块级作用域中声明，而es6中则可以在块级作用域中声明函数，在块级作用域中声明的函数只在当前作用域中生效，对其他作用域不会造成影响；另外，es6的块级作用域内声明函数必须使用大括号，如果没有会报错 // 不报错 if (true) { function f() {} } // 报错 if (true) function f() {} 三、变量的解构赋值1、数组的解构赋值在es6以前为变量赋值只能指定值 let a = 1; let b = 2; let c = 3; 上述代码在es6中可以住这样写 let [a, b, c] = [1, 2, 3];//a=1,b=2,c=3 //只要等号两边的模式相同，左边的变量就会被赋值对应的值 { let [x, y] = [1, 2, 3] //x=1,y=2 }; { let [x, ,y] = [1, 2, 3] //x=1,y=3 }; { let [x, [y], [z]] = [1, [2], [3]] //x=1,y=2,z=3 }; { let [x, ...y] = [1, 2, 3, 4] //x=1,y=[2,3,4] }; { let [x, y, ...z] = [1] //x=1,y=undefined,z=[] }; 如果结构不成功就会返回undefined { let x = []; //x = undefined; } { let [x, y] = [1] //y =undefined; } 如果等号左边的变量只能匹配等号右边变量的一部分值，这种情况就是不完全解构，但是解构依然会成功； { let [x, y] = [1, 2, 3] //x=1,y=2; } { let [x, [y], z] = [1, [2, 4], 3] //x=1,y=2,z=3; } 如果等号右边不是数组（不可遍历的结构）就会报错 { let [x] = 1; let [y] = false; let [z] = NaN; let [a] = undefined; let [b] = null; let [c] = {}; } 结构赋值允许指定默认值 { let [x = 1] = [];//x = 1 let [i, n = 2] = [1];//i=1,n=2 let [a = 1, b = 2] = [3]//a=3,b=2 } 在es6内部使用严格相等运算符（===），来判断一个位置是否有值，所以只有一个数组成员严格等于undefined默认值才会生效 { let [x = 1] = [undefined] //x=1 let [y = 2] = [null] //y=null,以为null===undefined不成立； } 如果默认是一个表达式，那么这个表达式只有在用到的时候才会求值 { function fn() { console.log(111); } let [x = f()] = [1];//fn不会执行,因为x能取到值1 } 默认值也可以使用解构赋值的其他变量，但是该变量必须先声明 { let [x = 1, y = x] = [] //x= 1;y =2 } { let [x = 1, y = x] = [2] //x=2,y=2 } { let [x = y, y = 1] = [] //报错 y is not defined，因为y还没有声明 } 2、对象的解构赋值对象的结构和数组类似，但是数组的解构按数组的顺序一次取值，而对象是没有顺序的，变量名必须与属性名一直才能取到正确的值； { let {bar, foo} = {foo: 1, bar: 2} //foo:1,bar:2; let {bar1} = {foo1: 1, bar2: 2} //bar1的值为undefined； } 如果变量名与属性名不一致，必须要写成如下形式 { let {foo: foo1} = {foo: 1} //foo1:1 let foo2 = {num1: 10, num2: 20 }; let {num1: f1, num2: f2} = foo2; //f1:10, f2:20; } 变量结构的机制是先找到同名的属性，然后在赋值给对应的变量，如下： { let {bar: foo1} = {bar: 10, bar1: 20} //foo1:10; bar: error: bar is not defined //bar 只是匹配的模式，foo1才是变量，真正被赋值的是变量foo1而不是模式bar } 与数组解构一样对象的解构也可以嵌套 { let foo = { index: [ 10, { y: 20 } ] } let {index:[x, {y}]} = foo;//x:10,y:20 } 对象结构中要注意赋值的是变量，而不是模式，模式只是用来匹配变量的 { let obj = { foo: { index: { num: 1, col: 2 } } } let {foo:{index: {num,col}}} = obj; //num:1, col:2 } 对象的解构也可以指定默认值 { let {x=1} = {} //x=3 } { let {x: y= 1} = {} // y = 3; } { let {x: y= 1} = {null} // y:null; } //和数组一样默认值生效的条件也是严格等于undefined 如果解构失败，变量的值是undefined { let {foo} = {bar: 1} //foo:undefined } 如果解构模式是嵌套的对象，如果子对象所在的父对象不存在，则会报错 { let {foo: {bar}} = {x: 1} //报错 } 解构赋值允许等号左边的模式中，不放置任何变量名，因此如下写法是可以执行的 { ({} = [1, 2]) ({} = &apos;abc) ({} = []) } 也可以对数组进行对象属性的解构 { let arr = [1, 2, 3]; let {0: f1, [arr.length-1]: f2} = arr //f1:1, f2:3 } 2、字符串的解构赋值字符串在解构的时候会被转换成一个类似数组的对象 { let [A, B, C, D] = &apos;abcd&apos;; //A:a,B:b,C:c,D:d; } 3、数值和布尔值的解构赋值数值和布尔值的解构赋值会先转成对象（隐式调用toString方法） { let {toString: s} = 123;//true s === Number.prototype.toString(隐式调用) } { let {toString: s} = true;//true s === Boolean.prototype.toString } { let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError //undefined,null无法转成对象 } 4、函数参数的解构赋值{ function fn([x, y]) { return x + y; } fn([1, 2]);//3 } 函数参数的结解构也可以指定默认值 { function fn({x=3, y=4} = {}) { return [x, y] } fn({x:10, y:20});// [10, 20] fn(); // [3, 4] } 四、圆括号的使用es6对于圆括号的规则是可能导致解构发生歧义，就不能使用圆括号 1、不能使用圆括号的场景(1). 变量的声明赋值 { let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; //上面6个语句都会报错，因为它们都是变量声明语句，模式中不能使用圆括号 } (2). 函数参数 { function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } // 报错 //函数参数也属于变量声明，因此不能带有圆括号。 } (3). 赋值语句的模式 { ({ p: a }) = { p: 42 }; //报错 ([a]) = [5];//报错 } 1、能使用圆括号的场景(1). 赋值语句的非模式部分，可以使用圆括号。 { [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 } 五、函数1、箭头函数的使用在es6中允许使用“箭头”（=&gt;）定义函数 { var f = fn =&gt; v //以上代码等同于 var f = function fn(v) { return v } } 基本语法 { 用法一：参数1（单一参数） =&gt; {函数声明} //一个参数，多个执行语句 用法二：（参数1）（单一参数） =&gt; 表达式（只有一条语句）//单个参数一条执行语句 用法三：(参数1，参数2，... , 参数n) =&gt; {函数声明} //多个参数，多个执行语句 用法四：(参数1，参数2，... , 参数n) =&gt; 表达式（只有一条语句）//相当于(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }//多个参数，一条语句 用法五： () =&gt; {函数声明} //没有参数时使用()代替 } 其他使用 { var f = bar =&gt; ({foo: bar}) console.log(f(1)); //{foo: 1} //箭头函数如果想直接返回一个对象必须在对象外面加()，不然会报错 } { (参数1, 参数2, ...rest) =&gt; {函数声明} (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明} //可以使用默认参数以及剩余参数 } { let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6 //也可以使用解构 } 如果箭头函数不需要参数或者需要多个参数，则使用一个()代表参数部分 { var f1 = () =&gt; x //等同于 var f1 = function() {return x} } { var f1 = (index1, index2) =&gt; index1 + index2; //等同于var f1 = function(index1, index2) {return index1+index2} } 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 { var f1 = (index1, index2) =&gt; { return index1 + index2; } } 2、箭头函数注意点（1）、箭头函数内部的this是固定的，就是定义时所在的对象，而不是使用时调用的对象；（2）、不能当做构造函数使用，如果和new一起使用会抛出错误；（3）、箭头函数内部不存在arguments对象，但是可以用rest参数代替arguments对象；（4）、call 或 apply 调用在箭头函数中不能修改this指针，他们的第一个参数会被忽略（5）、箭头函数没有prototype属性。（6）、箭头函数在参数和箭头之间不能换行。","tags":[{"name":"es6","slug":"es6","permalink":"https://www.23ybob.club/tags/es6/"}]},{"title":"drafting","date":"2018-07-21T06:46:21.000Z","path":"2018/07/21/cjvasui1r0000ckvb1de7kefl/","text":"实现目标div在另一个div中的拖拽效果最近项目中遇到的一个小功能，总结了一下，感觉还不错.github地址： https://github.com/Abriams/js-drafting 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #draft_big &#123; border: 1px solid #FF3300; width: 300px; height: 300px; position: relative; margin-left: 400px; margin-top: 400px; &#125; #draft_small &#123; background: #99CC00; width: 50px; height: 50px; position: absolute; cursor: pointer; right: -80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"draft_big\"&gt; &lt;div id=\"draft_small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=\"javascript\"&gt; window.onload = function () &#123; var draftBig = document.getElementById(\"draft_big\"); var draftSmall = document.getElementById(\"draft_small\"); draftSmall.onmousedown = function (event) &#123; var e = e || window.event; //记录并保存可拖拽div（id为draftSmall的盒子）拖拽前的坐标 var startX = e.clientX - draftSmall.offsetLeft; var startY = e.clientY - draftSmall.offsetTop; // offsetHeight,包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话）; // offsetLeft,目标元素距离最近定位的父级元素左边的距离； // offsetTop,目标元素距离最近定位的父级元素上边的距离； // clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。 // clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的垂直坐标。 /*鼠标的移动事件*/ document.onmousemove = function(e) &#123; //判断被拖拽的盒子（id为draftSmall的盒子）必须拖拽到目标盒子（id为draftBig盒子中）才能移动； if(e.clientX - 400 &lt; draftBig.offsetHeight &amp;&amp; e.clientX &gt; 400) &#123; if(e.clientY -400 &lt; draftBig.offsetWidth &amp;&amp; e.clientY &gt; 400) &#123; var e = e || window.event; //计算当前拖拽的盒子（id为draftSmall的盒子）在目标盒子（id为draftBig盒子）中的坐标； draftSmall.style.left = e.clientX - startX + \"px\"; draftSmall.style.top = e.clientY - startY + \"px\"; /*判断拖拽边界（id为draftSmall的盒子四个边界的判断）*/ if (e.clientX - startX &lt;= 0) &#123; draftSmall.style.left = 0 + \"px\"; &#125; if (e.clientY - startX &lt;= 0) &#123; draftSmall.style.top = 0 + \"px\"; &#125; if (e.clientX - startX &gt;= 250) &#123; draftSmall.style.left = 250 + \"px\"; &#125; if (e.clientY - startX &gt;= 250) &#123; draftSmall.style.top = 250 + \"px\"; &#125; &#125; &#125; &#125;; /*鼠标的抬起事件,终止拖动*/ document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; &#125;; &#125;; &#125;; &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"js实现拖拽","slug":"js实现拖拽","permalink":"https://www.23ybob.club/tags/js实现拖拽/"}]},{"title":"vue slot使用小结","date":"2018-07-14T11:20:30.000Z","path":"2018/07/14/cjvasui2k0005ckvb1byk5g6f/","text":"一、slot简介在vue实际项目开发当中，我们经常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在Vue中被称为内容分发。在Vue中，slot也分多种，从Vue的官网中可以获知，其主要分为：单个插槽、具名插槽和作用域插槽三种。下面就逐一介绍这三种插槽的用法： 二、slot插槽具体用法2.1单个插槽的使用从官网中（https://cn.vuejs.org/）我们知道，如果子组件template中没有包含任何一个时，就算父组件分发再多的内容也将会被丢弃。如下案例： 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; 父组件slotdemo组件 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图：上图所示在中添加内容并不会显示 只有子组件模板只中拥有一个没有属性的slot（可以有多个带属性的slot，后面的内容会介绍），父组件传入的整个内容片段才会被插入到slot所在的位置，并将替换掉slot本身，如果传入的内容为空则会显示slot的默认内容。如下案例： 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 当派发的内容为空时，会默认显示slot的内容 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.2具名插槽的使用可以用一个特殊的属性name来配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将根据name属性匹配内容片段中有对应slot属性的元素。 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div slot=&quot;header&quot;&gt;新的slotchildrenheader&lt;/div&gt; &lt;div slot=&quot;main&quot;&gt;新的内容&lt;/div&gt; &lt;div&gt;没有name&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt;//如果匹配不到内容显示在这 &lt;/header&gt; &lt;main&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.3作用域插槽的使用作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将prop传递给组件一样： &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;slot :text=&quot;msg&quot;&gt;&lt;/slot&gt;&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;&apos;, data() { return { msg: &quot;slot分发内容&quot;, } }, } &lt;/script&gt; 在父组件中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;template slot-scope=&quot;props&quot;&gt;//作用域模板插槽必须存在 &lt;div&gt;新的slotchildrenheader&lt;/div&gt; &lt;div&gt;新的内容&lt;div&gt;{{props.text}}&lt;/div&gt;&lt;/div&gt; &lt;/template&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图： 三、小结这篇文章主要介绍vue中的插槽的使用方法。只是一个空壳子，他的显示以及如何显示手父组件的控制，插槽显示的位置由子组件自身决定。父组件传过来的模板显示组件的template。使用slot可以帮助我们更容易，灵活的使用组件，同时也提高了组件的复用性。","tags":[{"name":"slot","slug":"slot","permalink":"https://www.23ybob.club/tags/slot/"},{"name":"vue","slug":"vue","permalink":"https://www.23ybob.club/tags/vue/"}]},{"title":"工作中遇到的问题总结","date":"2018-07-04T11:20:30.000Z","path":"2018/07/04/cjvasui2n0008ckvb53fcwoju/","text":"一、element ui 的使用总结1.1. 自定义验证规则的使用在自定义验证规则的时候每一个判断里（if()else()或者if()else if() else()）都要有callback,否则表单在执行this.$refs[formName].validate((valid) =&gt; {}) 的时候，内部代码是不会执行的； &lt;el-form :model=&quot;ruleForm2&quot; status-icon :rules=&quot;rules2&quot; ref=&quot;ruleForm2&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt; &lt;el-input v-model.number=&quot;ruleForm2.age&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm2&apos;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;resetForm(&apos;ruleForm2&apos;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;script&gt; export default { data() { var checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&apos;年龄不能为空&apos;)); } setTimeout(() =&gt; { if (!Number.isInteger(value)) { callback(new Error(&apos;请输入数字值&apos;)); } else { if (value &lt; 18) { callback(new Error(&apos;必须年满18岁&apos;)); } else { callback();//不能省略，不然无法执行 } } }, 1000); }; var validatePass = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请输入密码&apos;)); } else { if (this.ruleForm2.checkPass !== &apos;&apos;) { this.$refs.ruleForm2.validateField(&apos;checkPass&apos;); } callback(); } }; var validatePass2 = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请再次输入密码&apos;)); } else if (value !== this.ruleForm2.pass) { callback(new Error(&apos;两次输入密码不一致!&apos;)); } else { callback(); } }; return { ruleForm2: { pass: &apos;&apos;, checkPass: &apos;&apos;, age: &apos;&apos; }, rules2: { pass: [ { validator: validatePass, trigger: &apos;blur&apos; } ], checkPass: [ { validator: validatePass2, trigger: &apos;blur&apos; } ], age: [ { validator: checkAge, trigger: &apos;blur&apos; } ] } }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { alert(&apos;submit!&apos;); } else { console.log(&apos;error submit!!&apos;); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); } } } &lt;/script&gt; 1.2移动端ios以及andriod兼容问题1.2.1 ios以及andriod使用overflow: scroll;遇到的问题；页面滚动时使用overflow：scroll;在ios端会出现滑动不流畅问题。 为了解决这个问题，首先我使用了-webkit-overflow-scrolling : touch;这个属性，发现使用这个属性以后，ios页面在滑动到底部或者顶部会出现页面卡死问题，在网上找了好多方法参考这篇文章https://hk.saowen.com/a/ba965995919b5f04ed8bcb7ccc5b4af1e95792e9769fd92a8d36881d1fad8683个人觉得这篇文章写得很好，试了一下这些方法，发现最后还是没有解决，最后发现不要用原生的滚动也就是overflow：scroll;并且阻止ios的默认滑动效果，改为使用better-scroll这个滚动插件完美解决了以上的问题；参考如下案例： &lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;contain-img wrapper&quot; ref=&quot;menuWrapper&quot; v-show=&quot;Show&quot; id=&quot;contain-img&quot;&gt; &lt;ul class=&quot;content&quot; id=&quot;content&quot; ref=&quot;content&quot;&gt; //合同图片显示 &lt;div class=&quot;img01&quot; id=&quot;img01&quot;&gt;&lt;img src=&quot;../../static/img/demo-detail01.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img02&quot;&gt; &lt;img id=&quot;img01&quot; src=&quot;../../static/img/demo-detail02.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;pact-sign&quot; v-show=&quot;isSubmit&quot; @click=&quot;sign()&quot;&gt;提交&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import BScroll from &apos;better-scroll&apos; export default { data() { return { contractImg: &apos;&apos;, isSubmit: true, Show: true } }, created() { this.$nextTick(()=&gt;{ //异步执行 setTimeout(() =&gt; { let containImg = document.getElementById(&quot;img01&quot;).offsetHeight; let bodyHeight = document.body.clientHeight; let distance = bodyHeight-containImg; let scrollHeight = containImg-distance; this.meunScroll=new BScroll(this.$refs.menuWrapper,{});//初始化better-scroll插件 this.meunScroll.scrollTo(0,-scrollHeight); //页面加载完滚动到某个位置 }, 100) }); this.$nextTick(function(){ document.getElementsByTagName(&quot;img&quot;)[0].onload =function() { document.body.addEventListener(&apos;touchmove&apos;, function (e) { e.preventDefault() // 阻止默认的处理方式(阻止下拉滑动的效果) }, {passive: false}) // passive 参数不能省略，用来兼容ios和android } }); }, beforeCreate() { document.title = &apos;签署确认&apos;; }, } &lt;/script&gt; &lt;style scoped&gt; *{ margin: 0; padding: 0; } body, html { height: 100%; width: 100%; background-color: #fff; } .container { width: 100%; height: 100%; } .contain-img { width: 100%; height: 100%; position: absolute; /* overflow: scroll; -webkit-overflow-scrolling : touch; */ } .container img { width: 100%; height: 100%; } .pact-sign { width: 40px; height: 40px; line-height: 40px; position: fixed; bottom: 40px; right: 20px; border-radius: 50%; background-color: #409EFF; text-align: center; color: #ffffff; z-index: 10; } .img01, .img02 { position: relative; overflow: hidden; } &lt;/style&gt; 1.3 prop以及attr的使用使用attr获取checked属性、disabled属性、select属性，如果这些属性默认选中可以取到值，如果未选中值返回undefined，使用prop则可以解决这些问题 官方文档建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()； 1.4 npm打包卡死问题修改为淘宝源：（npm config set registry http://registry.cnpmjs.org）；","tags":[]},{"title":"javascript权威指南理解片一","date":"2018-06-24T09:38:29.000Z","path":"2018/06/24/cjvasui2i0004ckvbaiklz9r4/","text":"eval函数eval函数执行另一段javascript代码; eval(&quot;function f() {return x + 1}&quot;); //eval函数只有一个参数，如果参数不是字符串则直接返回这个函数 console.log(eval(11)); //11 //如果参数是字符串则会将字符串当做javascript代码进行编译执行 //并且返回最后一个表达式或语句得值，如果最后一个表达式或语句没有值则返回undefined； //eval使用的作用域是调用他的作用域；如果eval调用了全局函数，则返回的是全局变量的值，如果eval调用了局部函数，他会返回局部变量的值； var geval = eval; var x = &quot;global&quot;, y = &quot;global&quot;; function f() { var x = &quot;local &quot;; eval(&quot;x += &apos;changed&apos;;&quot;) //改变局部变量x的值 return x; } function g() { var y = &quot;local&quot;; geval(&quot;y += &apos; changed&apos;;&quot;); //改变全局变量y的值 return y; } console.log(f(), x); //local changed global console.log(g(), y); //local global changed 三元运算符x &gt; 0 ? x : -x 条件运算符的操作数可以是任意类型，第一个操作符如果是真值，那么返回第二个操作符的结果，如果第一个操作符是假值，则返回第三个操作符的结果； typeof 运算符","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"vuex个人理解","date":"2018-06-14T11:20:30.000Z","path":"2018/06/14/cjvasui2p0009ckvba4gmi8w9/","text":"什么是vuex及其作用vuex是一个转为vue.js开发的状态管理模式（如同redux是为react提供的状态管理模式），采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 什么是”状态管理模式”在我看来就是在vue中把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中，以供其他任意组件使用； vuex核心vuex核心就是store仓库，也就是一个容器，在这个容器中存储着vuex应用的状态（state） vuex特点 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 在vuex中你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 vuex案例实现1、将state,mutations,actions写在一起 安装vuex，在命令行执行如下命令（注意点：要加上–save，因为这个包在生产环境中是要使用的） npm install vuex –save 新建store文件夹（名称不唯一），并在store文件夹中新家store.js文件，然后引入vue,以及vuex；代码实现如下 import Vue from ‘vue’; import Vuex from ‘vuex’; 使用vuex，代码如下 Vue.use(Vuex); 通过以上3步vuex就可以使用了，接下来就用一个小案例具体实现 在main.js中引入刚新建的store文件 import store from ‘./store/store’ 在实例化Vue对象中加入store对象 new Vue({ el: &apos;#app&apos;, router, store,//使用store template: &apos;&lt;App/&gt;&apos;, components: { App } }) demo介绍 在store.js定义要使用的对象 const state = { count:1 } 在store.js中加入改变state的方法 //提交state的唯一途径（mutations），state对应上边const state中存储的值； const mutations={ add(state){ state.count++; } } actions提交mutations（actions不能直接提交state，只能通过提交mutations改变state） //提交mutations const actions ={ //Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象 addCount(context){ context.commit(&apos;add&apos;) } } getter获取store中的 state 中派生出的一些状态 getters: { counts: state =&gt; { return state.count - 1 } } 在组建中使用 新建count.vue组建具体代码如下 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;addCount&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; //在组件中通过mapState对象赋值 //首先引入mapState对象&apos;; //然后在computed计算属性里获取值并操作： &lt;script&gt; import {mapState} from &apos;vuex&apos;; export default { computed:mapState({ //理解为传入state对象，修改state.count属性； count:state=&gt;state.count }) } &lt;/script&gt; 2、将state,mutations,actions分开管理1.建立相应目录 src文件夹下新建store文件夹 在store文件夹下新建cart文件夹，index.js文件 在cart文件夹下新建state.js, mutations.js, mutation_type, actions.js, getters.js, index.js 在store文件夹下的index.js问价下添加如下代码 import Vue from ‘vue’; import Vuex from ‘vuex’; Vue.use(Vuex); import cart from ‘./cart/‘; export default new Vuex.Store({ modules: { cart } }); 在cart文件夹下的state.js定义要使用的对象 export default { count: 1, isshow: false, params: &apos;hide&apos; } 在mutations.js问价中改变state.js中的状态 import * as types from ‘./mutations_types’ export default { [types.COUNT_LOCAL](state) { state.count += 1 } , [types.REDUCE_LOCAL](state) { state.count -= 1 } , [types.ISSHOW_LOCAl](state,params) { state.isshow = !state.isshow state.params = &apos;hide&apos; ? &apos;show&apos; : &apos;hide&apos; } } 在mutations_type.js中分离mutations.js，便于后期维护 export const COUNT_LOCAL = ‘COUNT_LOCAL’ export const ISSHOW_LOCAl = ‘ISSHOW_LOCAl’ export const REDUCE_LOCAL = ‘REDUCE_LOCAL’ 在action.js中提交mutations import * as types from ‘./mutations_types’ export default { change_count: ({ commit }) =&gt; { commit(types.COUNT_LOCAL); }, change_isshow: ({ commit },{params}) =&gt; { commit(types.ISSHOW_LOCAl,{params}); }, change_reduce: ({ commit }) =&gt; { commit(types.REDUCE_LOCAL) } } 7.在getters.js中获取state中的派生状态 export default { getCount(state) { return state.count; } }; 在caet文件夹下的index.js中导出数据 import state from ‘./state’; import mutations from ‘./mutations’; import getters from ‘./getters’; import actions from ‘./actions’; export default { state, mutations, getters, actions }; 在组件中使用（使用dispatch提交） &lt;div&gt; &lt;h3&gt;&lt;/h3&gt; &lt;button @click=&quot;change()&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&apos;change_reduce&apos;)&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;getmessage()&quot;&gt;get&lt;/button&gt; &lt;input type=&quot;text&quot; :value=&quot;$store.state.cart.count&quot;&gt; &lt;button @click=&quot;changeShow()&quot; ref=&quot;hide&quot;&gt;hide&lt;/button&gt; &lt;input type=&quot;text&quot; v-show=&quot;show&quot; value=&quot;11&quot;&gt; &lt;/div&gt; &lt;script&gt; import { mapState } from &apos;vuex&apos; export default { data () { return { msg: &apos;Hellow Vuex&apos;, show: false } }, methods: { getmessage() { console.log(this.$store.state.cart.count) }, change() { this.$store.dispatch(&apos;change_count&apos;); }, changeShow() { let ishide = this.$store.state.cart.params; if( ishide == &apos;hide&apos;) { ishide = &apos;show&apos; } else { ishide = &apos;hide&apos; } console.log(ishide); this.$store.dispatch(&apos;change_isshow&apos;,&apos;ishide&apos;) this.show = this.$store.state.cart.isshow this.$refs.hide.innerHTML = this.$store.state.cart.params // console.log(this.$store.state.cart.params) } }, computed: { ...mapState({ count: state =&gt; { console.log(state.count) } }) } } &lt;/script&gt; 小结假如你的项目需要数据 和 组件 分离，分别处理，使用 Vuex 是非常合适的，相反，如果不需要分离处理，那么不使用 Vuex 也没关系。","tags":[{"name":"vuex","slug":"vuex","permalink":"https://www.23ybob.club/tags/vuex/"}]},{"title":"从零开始使用github page + hexo搭建个人博客","date":"2018-05-15T11:20:30.000Z","path":"2018/05/15/cjvasuimx000sckvb07t0mnah/","text":"首先附上我使用hexo搭建的博客：https://23ybob.club/github地址: https://github.com/Abriams/Abriams.github.io 简介：个人刚使用hexo+github page搭建完博客，感觉还是很有成就感，所以把自己的一些在搭建过程中遇到的问题总结了一下，并为大家介绍hexo的详细配置，如何将hexo布置到github上，以及最后绑定域名 写在前面：我是一名前端开发人员，经常都会浏览别人的博客，感觉很高大上，一直以后也希望有一个属于自己的博客，虽然以前也搭建过博客，但是做的不是很精细，博客也没有去维护，最近看了别人的文章感触挺深，所以参考一些资料自己完完全全搭建了一个博客，总体来说很简单，如果你是一名程序开发爱好者，刚好你也想搭建自己的博客，你可以认认真真阅读这篇文章，相信对你搭建博客会有很大帮助 废话不多说，直接开始搭建过程 一、安装搭建必须软件1. 安装node.js(直接去node官网下载自己需要的版本即可，这个应该不用多说了吧)2. 安装git（https://git-scm.com/download/win）2.1安装完成后再命令行输入git version查看是否安装成功如果安装成功鼠标右键就会出现Git GUI Here和Git Bash Here两个按钮，然后选择Git Bash Here即可打开git命令行 1. 安装教程：https://git-scm.com/download/win 2. Git入门教程：http://git.oschina.net/progit/ 3. git常用命令 - git clone仓库地址：将远程仓库clone到本地 - git init ：新建仓库 - git pull： 抓取远程仓库所有分支更新并合并到本地 - git add 文件名或者.：添加新文件 - git commit：提交你的修改 - git push：推送本地仓库更新到远程仓库 二、hexo介绍及安装Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.hexo安装在命令行输入 npm install -g hexo-cli 即可安装hexo安装完hexo还需安装将hexo部署到git page的deployer，在命令行输入 npm install hexo-deployer-git –save 2.使用hexo建立建立需要的文件选择自己要存放文件的目录，右键打开点击Git Bash Here，进入命令行执行 hexo init，安装完以后会在指定文件夹的中新建需要的文件，目录结构如下.git├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themeshexo配置参数可在https://hexo.io/zh-cn/docs/setup.html 中参看 3.执行hexohexo根目录中执行hexo generate 以及 hexo server，并且登录localhost:4000，即可看到本地的效果： 三、将博客布置到github Pages上经过以上步骤我们已经使用hexo搭建了一篇博客，但是我们只能通过本地查看，别人是不能看我们的博客的，所以现在我们需要将本地博客发布到服务器上，让别人也可以访问我们的博客，github Pages就可以帮我们实现这件事情，我们都知道github Pages的代码是保存在github上的所以现在我们需要在github上新建一个项目 1.注册github账号访问github官网： https://github.com/ 点击Sign Up注册自己的账号 2.创建项目代码库新用户点击New repository即可创建github Pages（如果已经创建过github Pages，点击github + 弹出新建github Pages主页，示例如下） 在弹出的github Pages主页中填写需要的内容 3.配置SSH密钥Github的SSH密钥可以使本地git项目与远程的github建立联系，这样我们就能将本地代码通过git操作实现与Github库的代码同步，具体操作如下： 1). 查看本机是否已经存在 SSH密钥（keys）打开git命令行（可在任一位置打开）运行 cd ~/. ssh 检查本机用户home目录下是否存在.ssh目录，如果，不存在此目录，则进行2).操作，否则，你本机已经存在ssh公钥和私钥，可以略过2).步，直接进入3).操作 2). 创建SSH密钥（keys）$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;（按照你提供的邮箱地址，创建一对密钥） 直接回车，会将密钥按默认文件进行存储当然了你也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 然后按照提示需要输入密码以及确认密码（一般其实也很安全，不需要密码，直接回车即可） 最后，输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 3). 在github中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。（运行完成后直接右键赋值即可 ） clip &lt; ~/.ssh/id_rsa.pub 3.1 登录github登录github进入Setting，如下图所示 3.2 选择SSH and GPG keys选择SSH and GPG keys，如下图所示 3.2 选择New SSH key点击右上角New SSH key即可添加 3.3 粘贴密钥将密钥粘贴在下方文本框中，如图 3.4 测试密钥输入下方命令，查看是否成功 ssh -T git@github.com 如果是如下所示，输入yes回车即可 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 3.5 设置用户信息现在已经通过SSH链接到了Github，但是git是根据用户的名字和邮箱来提交的，github也是用名字和邮箱处理权限的，为了方便可以使用如下命令设置自己的 邮箱和名字 git config --global user.name &quot;ryanlijianchang&quot;//用户名 git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 此时，SSH key已经配置成功，本机成功连接到github 四. 将hexo更新到github上4.1 打开github pages登录自己的github，选择刚才新建的github pages （Amriams/Amriams.github.io） 4.2 获取SSH类型地址进去页面选择clone or download， 再选择Use SSH，复制SSH密钥 4.3 配置hexo连接SSH打开新建的hexo根目录下的_config.yml文件 4.3 配置SSH在打开的文件里添加配置 deploy: type: git repository: git@github.com:Abriams/Abriams.github.io.git branch: master 如图： 4.4 将本地hexo代码布置到github上执行 hexo g -d 即可 执行时会让你输入github账号以及密码，输入完成后，回车即可在github pages服务器上访问我们的博客了，对应的地址就是username.github.io（我的博客是Abriams.github.io） 如果在上述执行过程中出现 ERROR Deployer not found: git，这个提示是你的deployer没有安装成功，所以需要安装 执行npm install hexo-deployer-git –save， 然后在执行hexo g -d就可将博客部署到github pages 上了 4.5 访问自己的博客访问https://Abriams.github.io就可看到自己的博客啦（https://您的用户名.github.io） 4.6 美化博客进入hexo官网https://hexo.io/themes/选择自己喜欢的主题即可 选择好主题后再打开Hexo文件夹下的themes目录（E:\\hexo\\BIOG\\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 等待下载完成后，打开Hexo文件夹下的配置文件_config.yml，修改参数为：theme: hexo-theme-next 然后依次执行 hexo g ， hexo s，打开浏览器，输入 http://localhost:4000/ 即可看见刚更新的主题啦。 更多hexo配置请在hexo官网https://hexo.io/zh-cn/docs/configuration.html查看详情 4.7部署新内容到github打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 执行完成后访问https://您的用户名.github.io即可 五. 使用hexo写博客首先新建文件 hexo n “文章标题” ，执行完成后会在项目E:\\hexo\\BIOG\\source_posts中生成 文章标题.md文件，当然，也可以直接在\\Hexo\\source_posts中新建一个md文件，然后使用markdown书写文章即可，文章完成后使用执行hexo g（生成）， hexo d（部署），就会将文章部署到github上 六.在hexo中华添加图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，（上传本地图片的插件） 3 等待一段时间后，再运行hexo n “xxxx”来生成md文件时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 七、将独立域名关联到github pages上1. 购买域名选择自己喜欢的域名购买即可，我是在腾讯云购买的一下一腾讯云为例https://cloud.tencent.com/?fromSource=gwzcw.234976.234976.234976 2. 配置域名域名买好后在https://console.qcloud.com/domain/mydomain 中管理自己的域名 进去我的域名页面点击解析，如下图 选择添加记录，添加即可，如下图 然后打开github pages你的项目，选择Settings 下拉到github pages设置添加域名 八.hexo中添加标签选项1 生成“标签页”并添加type属性打开命令行执行如下命令 hexo new page tags 成功后会提示INFO Created: ~/Documents/blog/source/tags/index.md 找到blog/source/tags/index.md的文件并添加type: “tags”如下所示： --- title: 文章分类 date: 2017-05-27 13:47:40 type: &quot;tags&quot; --- 2 给文章添加”tags”属性打开需要添加标签的文章，并添加tags属性，如下（tags后的- vuex就是标签内容） --- title: vuex个人理解 tags: - vuex --- 注意：只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 九.添加微博秀首先获取在微博上获取微博秀 &lt;iframe width=&quot;100%&quot; height=&quot;550&quot; class=&quot;share_self&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1&quot;&gt;&lt;/iframe&gt; 找到BIOG/themes/BlueLake/layout/_widget/weibo.jade文件将src=””里面的内容换成微博秀src=””里面的内容 然后找到跟目录下的_config.yml文件，将widgets:添加- weibo 如下： widgets: - recent_posts - category - tag - archive - weibo - links 注意：如果网站使用的是https协议，需要将微博秀中的http换成https即可； 10.设置百度分享（https）首先下载百度分享的文件 https://themebetter.com/uploads/2017/09/static.zip （解压码：themebetter）；将下载后的文件放到主题文件夹下的source文件夹下 修改百度分享代码：在主题文件夹下的layout/_partial/comment_js.jade 下全局搜索http://bgimg.share.baidu.com并去掉http://bgimg.share.baidu.com即可； window._bd_share_config={&quot;common&quot;:{&quot;bdSnsKey&quot;:{},&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;2&quot;,&quot;bdMiniList&quot;:[&quot;mshare&quot;,&quot;weixin&quot;,&quot;tsina&quot;,&quot;qzone&quot;,&quot;linkedin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;print&quot;,&quot;renren&quot;,&quot;sqq&quot;,&quot;evernotecn&quot;,&quot;bdysc&quot;,&quot;tqq&quot;,&quot;tqf&quot;,&quot;bdxc&quot;,&quot;kaixin001&quot;,&quot;tieba&quot;,&quot;douban&quot;,&quot;bdhome&quot;,&quot;thx&quot;,&quot;ibaidu&quot;,&quot;meilishuo&quot;,&quot;mogujie&quot;,&quot;diandian&quot;,&quot;huaban&quot;,&quot;duitang&quot;,&quot;hx&quot;,&quot;fx&quot;,&quot;youdao&quot;,&quot;sdo&quot;,&quot;qingbiji&quot;,&quot;people&quot;,&quot;xinhua&quot;,&quot;mail&quot;,&quot;isohu&quot;,&quot;yaolan&quot;,&quot;wealink&quot;,&quot;ty&quot;,&quot;iguba&quot;,&quot;h163&quot;,&quot;copy&quot;],&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;1&quot;,&quot;bdSize&quot;:&quot;16&quot;},&quot;share&quot;:{},&quot;image&quot;:{&quot;viewList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;],&quot;viewText&quot;:&quot;分享到：&quot;,&quot;viewSize&quot;:&quot;16&quot;},&quot;selectShare&quot;:{&quot;bdContainerClass&quot;:null,&quot;bdSelectMiniList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;]}};with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||head).appendChild(createElement(&apos;script&apos;)).src=&apos;http://bgimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)] //执行完上面几部发现请求的百度分享地址已经替换成了本地，但是在控制台会报错；这是hexo编译了static文件夹导致的； 最后修改根目录下的—_config.yml文件 找到skip_render并添加static/** ，如下所示 skip_render: static/** //防止hexo编译static文件导致报错； 小结：通过以上操作，一篇博客终于搭建成功了，虽然在搭建的过程中会遇到各种问题，这需要我们耐心解决，当所有问题都完成后，我个人收货到了很大成果，也希望各位小伙伴能有自己的收获，另外，既然博客搭建成功了，那么就一定要坚持下去，不需要每天都写，但是每个月写自己的总结心得，总是不过分的吧","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.23ybob.club/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://www.23ybob.club/tags/github-pages/"}]},{"title":"初识前端","date":"2018-05-06T11:20:30.000Z","path":"2018/05/06/cjvasui1y0001ckvb9r2yuvx0/","text":"个人对前端的理解前端发展1.什么是前端虽然是做前端的，但是具体概念还真不知道，个人感觉就是写页面，渲染数据 2.前端演进史2.1.从静态走向动态大约1994就是前端发展的历史吧，前端都知道1943年10月13日网景公司推出了第一版Navigator；Tim Berners-Lee创建了W3C；Tim的基友发布了CSS。同样在这一年，为动态web网页设计的服务端脚本PHP诞生。 早期网页都是为了方便科学家看文章，传论文而制造的，这也就是为什么Web网页都基于Document，随着网页技术从学术机构走向社会，网页承载的功能已经不足以满足当前需求，因此早期网页的局限性也显示出来了 2.1.1 所有的网页都基于HTML页面，因为没有任何手段可以控制局部内容的显示和隐藏，因此任何局部的变化哪怕只多出一个标点符号，都只能重新下载一个新的页面。2.1.2 计算任务只能在服务端实现。由于网速限制，与服务器通信的过程是非常缓慢的，并且此过程是同步阻塞的，于是会出现这样的场景：用户提交一个表单，然后整个页面消失，浏览器呈现白屏，经过漫长的等待，浏览器渲染出一个和之前一模一样的页面，只不过输入框旁边多了一排红色小字：用户名错误。2.1.3 所有页面都是静态的，这意味着一个电商网站有一千种商品，哪怕页面布局一模一样，也必须写一千个单独的页面。1994年Rasmus Lerdorf为了维护个人网站而创建了PHP，PHP实现了与数据库的交互以及用于生产动态页面的模板引擎，是Web领域中最主流的服务端语言。 1995年网景推出了JavaScript，实现了客户端的计算任务（如表单验证）。 1996年微软推出了iframe标签，实现了异步的局部加载。 1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。 2006年，XMLHttpRequest被W3C正式纳入标准。 至此，早期的Document终于进化为了Web page，早期网页的三个局限都得到了妥善的解决。 2.2从后端走向前端早期网页都是有后端主导的，前端也就只是操作dom，2006年 John Resig发布了jQuery，主要用于操作DOM 起初制约Web开发从后到前的因素很简单，就是前端很多事干不了或干不好，当时的浏览器性能弱，标准化程度低，2008年问世的谷歌V8引擎改变了这一局面，现代浏览器的崛起终结了微软的垄断时代 ECMA也在2009年发布了第五代JavaScript 2009年AngularJS诞生，随后被谷歌收购。 2010年backbone.js诞生。 2011年React和Ember诞生。 2014年Vue.js诞生……前后端分离可谓大势所趋。 参考： Web开发的发展史http://blog.jobbole.com/45169/ https://www.cnblogs.com/leolovexx/p/7249314.html","tags":[{"name":"前端历史","slug":"前端历史","permalink":"https://www.23ybob.club/tags/前端历史/"}]}]