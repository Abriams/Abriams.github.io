[{"title":"javascript设计模式与开发实践六（代理模式）","date":"2019-05-23T03:30:20.000Z","path":"2019/05/23/cjw08yt4u0007kwvbx9zesve0/","text":"代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 代理模式是一种非常有意义的模式，在生活中可以找到很多代理模式的场景。比如，明星都有经纪人作为代理。如果想请明星来办一场商业演出，只能联系他的经纪人。经纪人会把商业演出的细节和报酬都谈好之后，再把合同交给明星签。 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。如图 6-1 和图 6-2 所示。 下面我们通过几个例子来详细说明。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践五（策略模式 ）","date":"2019-05-22T01:53:58.000Z","path":"2019/05/22/cjw08ytb0001nkwvbadarjhtz/","text":"俗话说，条条大路通罗马。在美剧《越狱》中，主角 Michael Scofield 就设计了两条越狱的道路。这两条道路都可以到达靠近监狱外墙的医务室。 同样，在现实中，很多时候也有多种途径到达同一个目的地。比如我们要去某个地方旅游，可以根据具体的实际情况来选择出行的线路。 如果没有时间但是不在乎钱，可以选择坐飞机。 如果没有钱，可以选择坐大巴或者火车。 如果再穷一点，可以选择骑自行车。 一、 使用策略模式计算奖金在程序设计中，我们也常常遇到类似的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。 这些算法灵活多样，而且可以随意互相替换。这种解决方案就是本章将要介绍的策略模式。 策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 策略模式有着广泛的应用。本节我们就以年终奖的计算为例进行介绍。 很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，而绩效为 B 的人年终奖是 2 倍工资。假设财务部要求我们提供一段代码，来方便他们计算员工的年终奖。 1.1 最初的代码实现我们可以编写一个名为 calculateBonus 的函数来计算每个人的奖金数额。很显然，calculateBonus 函数要正确工作，就需要接收两个参数：员工的工资数额和他的绩效考核等级。代码如下： 12345678910111213var calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return salary * 4; &#125; if (performanceLevel === 'A') &#123; return salary * 3; &#125; if (performanceLevel === 'B') &#123; return salary * 2; &#125;&#125;;calculateBonus('B', 20000); // 输出：40000calculateBonus('S', 6000); // 输出：24000 可以发现，这段代码十分简单，但是存在着显而易见的缺点。 calculateBonus 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的逻辑分支。 calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级 C，或者想把绩效 S 的奖金系数改为 5，那我们必须深入 calculateBonus 函数的内部实现，这是违反开放封闭原则的。 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择只有复制和粘贴。 因此，我们需要重构这段代码。 1.2 使用组合函数重构代码一般最容易想到的办法就是使用组合函数来重构代码，我们把各种算法封装到一个个的小函数里面，这些小函数有着良好的命名，可以一目了然地知道它对应着哪种算法，它们也可以被复用在程序的其他地方。代码如下： 123456789101112131415161718192021var performanceS = function (salary) &#123; return salary * 4;&#125;;var performanceA = function (salary) &#123; return salary * 3;&#125;;var performanceB = function (salary) &#123; return salary * 2;&#125;;var calculateBonus = function (performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return performanceS(salary); &#125; if (performanceLevel === 'A') &#123; return performanceA(salary); &#125; if (performanceLevel === 'B') &#123; return performanceB(salary); &#125;&#125;;calculateBonus('A', 10000); // 输出：30000 目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题：calculateBonus 函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。 1.3 使用策略模式重构代码经过思考，我们想到了更好的办法——使用策略模式来重构代码。策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。 在这个例子里，算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数额。而算法的实现是各异和变化的，每种绩效对应着不同的计算规则。 一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用。 现在用策略模式来重构上面的代码。第一个版本是模仿传统面向对象语言中的实现。我们先把每种绩效的计算规则都封装在对应的策略类里面： 1234567891011121314151617181920212223242526var performanceS = function() &#123;&#125;;performanceS.prototype.calculate = function(salary) &#123; return 4 * salary&#125;var performanceA = function ()&#123;&#125;;performanceA.prototype.calculate = function(salary) &#123; return 3 * salary&#125;var performanceB = function () &#123; &#125;;performanceB.prototype.calculate = function(salary) &#123; return 2 * salary&#125;//接下来定义奖金类 Bonus：var Bonus = function()&#123; this.salary = null; // 原始工资 this.strategy = null; // 绩效等级对应的策略对象&#125;;Bonus.prototype.setSalary = function( salary )&#123; this.salary = salary; // 设置员工的原始工资&#125;;Bonus.prototype.setStrategy = function( strategy )&#123; this.strategy = strategy; // 设置员工绩效等级对应的策略对象&#125;;Bonus.prototype.getBonus = function()&#123; // 取得奖金数额 return this.strategy.calculate( this.salary ); // 把计算奖金的操作委托给对应的策略对象&#125;; 在完成最终的代码之前，我们再来回顾一下策略模式的思想： 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换(“并且使它们可以相互替换”，这句话在很大程度上是相对于静态类型语言而言的。因为静态类型语言中有类型检查机制，所以各个策略类需要实现同样的接口。当它们的真正类型被隐藏在接口后面时，它们才能被相互替换。而在 JavaScript 这种“类型模糊”的语言中没有这种困扰，任何对象都可以被替换使用。因此，JavaScript 中的“可以相互替换使用”表现为它们具有相同的目标和意图。)。 这句话如果说得更详细一点，就是：定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对 Context 发起请求的时候，Context 总是把请求委托给这些策略对象中间的某一个进行计算。 现在我们来完成这个例子中剩下的代码。先创建一个 bonus 对象，并且给 bonus 对象设置一些原始的数据，比如员工的原始工资数额。接下来把某个计算奖金的策略对象也传入 bonus 对象内部保存起来。当调用 bonus.getBonus()来计算奖金的时候，bonus 对象本身并没有能力进行计算，而是把请求委托给了之前保存好的策略对象： 123456var bonus = new Bonus();bonus.setSalary(10000);bonus.setStrategy(new performanceS()); // 设置策略对象console.log(bonus.getBonus()); // 输出：40000bonus.setStrategy(new performanceA()); // 设置策略对象console.log(bonus.getBonus()); // 输出：30000 刚刚我们用策略模式重构了这段计算年终奖的代码，可以看到通过策略模式重构之后，代码变得更加清晰，各个类的职责更加鲜明。但这段代码是基于传统面向对象语言的模仿，下一节我们将了解用 JavaScript 实现的策略模式。 二、 JavaScript 版本的策略模式上一节中我们让 strategy 对象从各个策略类中创建而来，这是模拟一些传统面向对象语言的实现。实际上在 JavaScript 语言中，函数也是对象，所以更简单和直接的做法是把 strategy直接定义为函数： 1234567891011var strategies = &#123; \"S\": function( salary )&#123; return salary * 4; &#125;, \"A\": function( salary )&#123; return salary * 3; &#125;, \"B\": function( salary )&#123; return salary * 2; &#125;&#125;; 同样，Context 也没有必要必须用 Bonus 类来表示，我们依然用 calculateBonus 函数充当Context 来接受用户的请求。经过改造，代码的结构变得更加简洁： 12345678910111213141516var strategies = &#123; \"S\": function( salary )&#123; return salary * 4; &#125;, \"A\": function( salary )&#123; return salary * 3; &#125;, \"B\": function( salary )&#123; return salary * 2; &#125;&#125;;var calculateBonus = function( level, salary )&#123; return strategies[ level ]( salary );&#125;;console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000 在接下来的缓动动画和表单验证的例子中，我们用到的都是这种函数形式的策略对象。 三、 多态在策略模式中的体现通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算奖金有关的逻辑不再放在 Context 中，而是分布在各个策略对象中。Context 并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算奖金”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是“它们可以相互替换”的目的。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。 四、 使用策略模式实现缓动动画如果让一些不太了解前端开发的程序员来投票，选出他们眼中 JavaScript 语言在 Web 开发中的两大用途，我想结果很有可能是这样的： 编写一些让 div 飞来飞去的动画 验证表单 虽然这只是一句玩笑话，但从中可以看到动画在 Web 前端开发中的地位。一些别出心裁的动画效果可以让网站增色不少。 如果我们明白了怎样让一个小球运动起来，那么离编写一个完整的游戏就不遥远了，剩下的只是一些把逻辑组织起来的体力活。本节并不会从头到尾地编写一个完整的游戏，我们首先要做的是让一个小球按照不同的算法进行运动。 4.1 实现动画效果的原理用 JavaScript 实现动画效果的原理跟动画片的制作一样，较快的帧数播放，来达到视觉上的动画效果。在 JavaScript 中，可以通过连续改变元素的某个 CSS属性，比如 left、top、background-position 来实现动画效果。图 5-1 就是通过改变节点的background-position，让人物动起来的。 4.2 思路和一些准备工作我们目标是编写一个动画类和一些缓动算法，让小球以各种各样的缓动效果在页面中运动。 现在来分析实现这个程序的思路。在运动开始之前，需要提前记录一些有用的信息，至少包括以下信息： 动画开始时，小球所在的原始位置； 小球移动的目标位置； 动画开始时的准确时间点； 小球运动持续的时间。 随后，我们会用 setInterval 创建一个定时器，定时器每隔 19ms 循环一次。在定时器的每一帧里，我们会把动画已消耗的时间、小球原始位置、小球目标位置和动画持续的总时间等信息传入缓动算法。该算法会通过这几个参数，计算出小球当前应该所在的位置。最后再更新该 div 对应的 CSS 属性，小球就能够顺利地运动起来了。 4.3 让小球运动起来在实现完整的功能之前，我们先了解一些常见的缓动算法，这些算法最初来自 Flash，但可以非常方便地移植到其他语言中。 这些算法都接受 4 个参数，这 4 个参数的含义分别是动画已消耗的时间、小球原始位置、小球目标位置、动画持续的总时间，返回的值则是动画元素应该处在的当前位置。代码如下： 1234567891011121314151617181920var tween = &#123; linear: function (t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function (t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function (t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function (t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125;&#125;; 现在我们开始编写完整的代码，下面代码的思想来自 jQuery 库，由于本节的目标是演示策略模式，而非编写一个完整的动画库，因此我们省去了动画的队列控制等更多完整功能。 现在进入代码实现阶段，首先在页面中放置一个 div： 123&lt;body&gt; &lt;div style=\"position:absolute;background:blue\" id=\"div\"&gt;我是 div&lt;/div&gt;&lt;/body&gt; 接下来定义 Animate 类，Animate 的构造函数接受一个参数：即将运动起来的 dom 节点。Animate类的代码如下： 123456789var Animate = function( dom )&#123; this.dom = dom; // 进行运动的 dom 节点 this.startTime = 0; // 动画开始时间 this.startPos = 0; // 动画开始时，dom 节点的位置，即 dom 的初始位置 this.endPos = 0; // 动画结束时，dom 节点的位置，即 dom 的目标位置 this.propertyName = null; // dom 节点需要被改变的 css 属性名 this.easing = null; // 缓动算法 this.duration = null; // 动画持续时间&#125;; 接下来 Animate.prototype.start 方法负责启动这个动画，在动画被启动的瞬间，要记录一些信息，供缓动算法在以后计算小球当前位置的时候使用。在记录完这些信息之后，此方法还要负责启动定时器。代码如下： 1234567891011121314Animate.prototype.start = function (propertyName, endPos, duration, easing) &#123; this.startTime = +new Date; // 动画启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; // dom 节点初始位置 this.propertyName = propertyName; // dom 节点需要被改变的 CSS 属性名 this.endPos = endPos; // dom 节点目标位置 this.duration = duration; // 动画持续事件 this.easing = tween[easing]; // 缓动算法 var self = this; var timeId = setInterval(function () &#123; // 启动定时器，开始执行动画 if (self.step() === false) &#123; // 如果动画已结束，则清除定时器 clearInterval(timeId); &#125; &#125;, 19);&#125;; Animate.prototype.start 方法接受以下 4 个参数。 propertyName：要改变的 CSS 属性名，比如’left’、’top’，分别表示左右移动和上下移动。 endPos： 小球运动的目标位置。 duration： 动画持续时间。 easing： 缓动算法。 再接下来是 Animate.prototype.step 方法，该方法代表小球运动的每一帧要做的事情。在此处，这个方法负责计算小球的当前位置和调用更新 CSS 属性值的方法 Animate.prototype.update。代码如下： 1234567891011Animate.prototype.step = function () &#123; var t = +new Date; // 取得当前时间 if (t &gt;= this.startTime + this.duration) &#123; // (1) this.update(this.endPos); // 更新小球的 CSS 属性值 return false; &#125; var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration); // pos 为小球当前位置 this.update(pos); // 更新小球的 CSS 属性值&#125;; 在这段代码中，(1)处的意思是，如果当前时间大于动画开始时间加上动画持续时间之和，说明动画已经结束，此时要修正小球的位置。因为在这一帧开始之后，小球的位置已经接近了目标位置，但很可能不完全等于目标位置。此时我们要主动修正小球的当前位置为最终的目标位置。此外让 Animate.prototype.step 方法返回 false，可以通知 Animate.prototype.start 方法清除定时器。 最后是负责更新小球 CSS 属性值的 Animate.prototype.update 方法： 123Animate.prototype.update = function( pos )&#123; this.dom.style[ this.propertyName ] = pos + 'px';&#125;; 如果不嫌麻烦，我们可以进行一些小小的测试： 1234var div = document.getElementById( 'div' );var animate = new Animate( div );animate.start( 'left', 500, 1000, 'strongEaseOut' );// animate.start( 'top', 1500, 500, 'strongEaseIn' ); 通过这段代码，可以看到小球按照我们的期望以各种各样的缓动算法在页面中运动。 本节我们学会了怎样编写一个动画类，利用这个动画类和一些缓动算法就可以让小球运动起来。我们使用策略模式把算法传入动画类中，来达到各种不同的缓动效果，这些算法都可以轻易地被替换为另外一个算法，这是策略模式的经典运用之一。策略模式的实现并不复杂，关键是如何从策略模式的实现背后，找到封装变化、委托和多态性这些思想的价值。 五、 更广义的“算法”策略模式指的是定义一系列的算法，并且把它们封装起来。本章我们介绍的计算奖金和缓动动画的例子都封装了一些算法。 从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。 GoF 在《设计模式》一书中提到了一个利用策略模式来校验用户是否输入了合法数据的例子，但 GoF 未给出具体的实现。刚好在 Web 开发中，表单校验是一个非常常见的话题。下面我们就看一个使用策略模式来完成表单校验的例子。 六、6 表单校验在一个 Web 项目中，注册、登录、修改用户信息等功能的实现都离不开提交表单。 在将用户输入的数据交给后台之前，常常要做一些客户端力所能及的校验工作，比如注册的时候需要校验是否填写了用户名，密码的长度是否符合规定，等等。这样可以避免因为提交不合法数据而带来的不必要网络开销。 假设我们正在编写一个注册的页面，在点击注册按钮之前，有如下几条校验逻辑。 用户名不能为空。 密码长度不能少于 6 位。 手机号码必须符合格式。 6.1 表单校验的第一个版本现在编写表单校验的第一个版本，可以提前透露的是，目前我们还没有引入策略模式。代码如下： 123456789101112131415161718192021222324252627&lt;html&gt;&lt;body&gt; &lt;form action=\"http:// xxx.com/register\" id=\"registerForm\" method=\"post\"&gt; 请输入用户名：&lt;input type=\"text\" name=\"userName\"/ &gt; 请输入密码：&lt;input type=\"text\" name=\"password\"/ &gt; 请输入手机号码：&lt;input type=\"text\" name=\"phoneNumber\"/ &gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; var registerForm = document.getElementById( 'registerForm' ); registerForm.onsubmit = function()&#123; if ( registerForm.userName.value === '' )&#123; alert ( '用户名不能为空' ); return false; &#125; if ( registerForm.password.value.length &lt; 6 )&#123; alert ( '密码长度不能少于 6 位' ); return false; &#125; if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( registerForm.phoneNumber.value ) )&#123; alert ( '手机号码格式不正确' ); return false; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这是一种很常见的代码编写方式，它的缺点跟计算奖金的最初版本一模一样。 registerForm.onsubmit 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的校验规则。 registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的校验规则，或者想把密码的长度校验从 6 改成 8，我们都必须深入 registerForm.onsubmit 函数的内部实现，这是违反开放—封闭原则的。 算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制得漫天遍野。 6.2 用策略模式重构表单校验下面我们将用策略模式来重构表单校验的代码，很显然第一步我们要把这些校验逻辑都封装成策略对象： 1234567891011121314151617var strategies = &#123; isNonEmpty: function (value, errorMsg) &#123; // 不为空 if (value === '') &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; // 限制最小长度 if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function (value, errorMsg) &#123; // 手机号码格式 if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;; 接下来我们准备实现 Validator 类。Validator 类在这里作为 Context，负责接收用户的请求并委托给 strategy 对象。在给出 Validator 类的代码之前，有必要提前了解用户是如何向 Validator类发送请求的，这有助于我们知道如何去编写 Validator 类的代码。代码如下： 1234567891011121314151617181920var Validator = function () &#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function (dom, rule, errorMsg) &#123; var ary = rule.split(':'); // 把 strategy 和参数分开 this.cache.push(function () &#123; // 把校验的步骤用空函数包装起来，并且放入 cache var strategy = ary.shift(); // 用户挑选的 strategy ary.unshift(dom.value); // 把 input 的 value 添加进参数列表 ary.push(errorMsg); // 把 errorMsg 添加进参数列表 return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function () &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;; 从这段代码中可以看到，我们先创建了一个 validator 对象，然后通过 validator.add 方法，往 validator 对象中添加一些校验规则。validator.add 方法接受 3 个参数，以下面这句代码说明： 1validator.add( registerForm.password, 'minLength:6', '密码长度不能少于 6 位' ); registerForm.password 为参与校验的 input 输入框。 ‘minLength:6’是一个以冒号隔开的字符串。冒号前面的minLength代表客户挑选的strategy对象，冒号后面的数字 6 表示在校验过程中所必需的一些参数。’minLength:6’的意思就是校验 registerForm.password 这个文本输入框的 value 最小长度为 6。如果这个字符串中不包含冒号，说明校验过程中不需要额外的参数信息，比如’isNonEmpty’。 第 3 个参数是当校验未通过时返回的错误信息。 当我们往 validator 对象里添加完一系列的校验规则之后，会调用 validator.start()方法来启动校验。如果 validator.start()返回了一个确切的 errorMsg 字符串当作返回值，说明该次校验没有通过，此时需让 registerForm.onsubmit 方法返回 false 来阻止表单的提交。 最后是 Validator 类的实现： 1234567891011121314151617181920212223var Validator = function () &#123; this.cache = []; // 保存校验规则&#125;;Validator.prototype.add = function (dom, rule, errorMsg) &#123; // console.log(dom) // console.log(rule) // console.log(errorMsg) var ary = rule.split(':'); // 把 strategy 和参数分开 this.cache.push(function () &#123; // 把校验的步骤用空函数包装起来，并且放入 cache var strategy = ary.shift(); // 用户挑选的 strategy ary.unshift(dom.value); // 把 input 的 value 添加进参数列表 ary.push(errorMsg); // 把 errorMsg 添加进参数列表 return strategies[strategy].apply(dom, ary); &#125;);&#125;;Validator.prototype.start = function () &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) &#123; // 如果有确切的返回值，说明校验没有通过 return msg; &#125; &#125;&#125;; 使用策略模式重构代码之后，我们仅仅通过“配置”的方式就可以完成一个表单的校验，这些校验规则也可以复用在程序的任何地方，还能作为插件的形式，方便地被移植到其他项目中。 在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想将用户名输入框的校验规则改成用户名不能少于 4 个字符。可以看到，这时候的修改是毫不费力的。代码如下： 123validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空' );// 改成：validator.add( registerForm.userName, 'minLength:10', '用户名长度不能小于 10 位' ); 6.3 给某个文本输入框添加多种校验规则为了让读者把注意力放在策略模式的使用上，目前我们的表单校验实现留有一点小遗憾：一个文本输入框只能对应一种校验规则，比如，用户名输入框只能校验输入是否为空： validator.add( registerForm.userName, ‘isNonEmpty’, ‘用户名不能为空’ ); 如果我们既想校验它是否为空，又想校验它输入文本的长度不小于 10 呢？我们期望以这样的形式进行校验： 12345678910validator.add(registerForm.userName, [ &#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于 10 位' &#125;]); 下面提供的代码可用于一个文本输入框对应多种校验规则： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var strategies = &#123; isNonEmpty: function (value, errorMsg) &#123; if (value === '') &#123; return errorMsg; &#125; &#125;, minLength: function (value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function (value, errorMsg) &#123; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;;/***********************Validator 类**************************/var Validator = function () &#123; this.cache = [];&#125;;Validator.prototype.add = function (dom, rules) &#123; var self = this; for (var i = 0, rule; rule = rules[i++];) &#123; (function (rule) &#123; var strategyAry = rule.strategy.split(':'); var errorMsg = rule.errorMsg; self.cache.push(function () &#123; var strategy = strategyAry.shift(); strategyAry.unshift(dom.value); strategyAry.push(errorMsg); return strategies[strategy].apply(dom, strategyAry); &#125;); &#125;)(rule) &#125;&#125;;Validator.prototype.start = function () &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var errorMsg = validatorFunc(); if (errorMsg) &#123; return errorMsg; &#125; &#125;&#125;;/***********************客户调用代码**************************/var registerForm = document.getElementById('registerForm');var validataFunc = function () &#123; var validator = new Validator(); validator.add(registerForm.userName, [ &#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于 10 位' &#125; ]); validator.add(registerForm.password, [ &#123; strategy: 'minLength:6', errorMsg: '密码长度不能小于 6 位' &#125; ]); validator.add(registerForm.phoneNumber, [ &#123; strategy: 'isMobile', errorMsg: '手机号码格式不正确' &#125; ]); var errorMsg = validator.start(); return errorMsg;&#125;registerForm.onsubmit = function () &#123; var errorMsg = validataFunc(); if (errorMsg) &#123; alert(errorMsg); return false; &#125; &#125;; 七、 策略模式的优缺点策略模式是一种常用且有效的设计模式，本章提供了计算奖金、缓动动画、表单校验这三个例子来加深大家对策略模式的理解。从这三个例子中，我们可以总结出策略模式的一些优点。 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 当然，策略模式也有一些缺点，但这些缺点并不严重。 首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在 Context 中要好。 其次，要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选择飞机、火车、自行车等方案的细节。此时 strategy 要向客户暴露它的所有实现，这是违反最少知识原则的。 八、 一等函数对象与策略模式本章提供的几个策略模式示例，既有模拟传统面向对象语言的版本，也有针对 JavaScript 语言的特有实现。在以类为中心的传统面向对象语言中，不同的算法或者行为被封装在各个策略类中，Context 将请求委托给这些策略对象，这些策略对象会根据请求返回不同的执行结果，这样便能表现出对象的多态性。 Peter Norvig 在他的演讲中曾说过：“在函数作为一等对象的语言中，策略模式是隐形的。strategy 就是值为函数的变量。”在 JavaScript 中，除了使用类来封装算法和行为之外，使用函数当然也是一种选择。这些“算法”可以被封装到函数中并且四处传递，也就是我们常说的“高阶函数”。实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出“调用”的消息时，不同的函数会返回不同的执行结果。在 JavaScript 中，“函数对象的多态性”来得更加简单。 在前面的学习中，为了清楚地表示这是一个策略模式，我们特意使用了 strategies 这个名字。如果去掉 strategies，我们还能认出这是一个策略模式的实现吗？代码如下： 12345678910111213var S = function( salary )&#123; return salary * 4;&#125;;var A = function( salary )&#123; return salary * 3;&#125;;var B = function( salary )&#123; return salary * 2;&#125;;var calculateBonus = function( func, salary )&#123; return func( salary );&#125;;calculateBonus( S, 10000 ); // 输出：40000 九、 小结本章我们既提供了接近传统面向对象语言的策略模式实现，也提供了更适合 JavaScript 语言的策略模式版本。在 JavaScript 语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式。尽管这样，从头到尾地了解策略模式，不仅可以让我们对该模式有更加透彻的了解，也可以使我们明白使用函数的好处。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践四（单例模式）","date":"2019-05-21T08:53:58.000Z","path":"2019/05/21/cjw08yt9c0019kwvbjm8q1167/","text":"单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的 window 对象等。在 JavaScript 开发中，单例模式的用途同样非常广泛。试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。 一、 实现单例模式要实现一个标准的单例模式并不复杂，无非是用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。代码如下： 1234567891011121314151617181920212223242526272829303132333435var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;;Singleton.prototype.getName = function () &#123; alert(this.name);&#125;;Singleton.getInstance = function (name) &#123; console.log(name) if (!this.instance) &#123; this.instance = new Singleton(name); &#125; console.log(this.instance) return this.instance;&#125;;var a = Singleton.getInstance('sven1');var b = Singleton.getInstance('sven2');console.log(a === b); // true //或者var Singleton = function( name )&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; alert ( this.name );&#125;;Singleton.getInstance = (function()&#123; var instance = null; return function( name )&#123; if ( !instance )&#123; instance = new Singleton( name ); &#125; return instance; &#125;&#125;)(); 我们通过 Singleton.getInstance 来获取 Singleton 类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的“不透明性”，Singleton 类的使用者必须知道这是一个单例类，跟以往通过 new XXX 的方式来获取对象不同，这里偏要使用 Singleton.getInstance 来获取对象。 接下来顺便进行一些小测试，来证明这个单例类是可以信赖的： 123var a = Singleton.getInstance( 'sven1' );var b = Singleton.getInstance( 'sven2' );alert ( a === b ); // true 虽然现在已经完成了一个单例模式的编写，但这段单例模式代码的意义并不大。从下一节开始，我们将一步步编写出更好的单例模式。 二、透明的单例模式我们现在的目标是实现一个“透明”的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。在下面的例子中，我们将使用 CreateDiv 单例类，它的作用是负责在页面中创建唯一的 div 节点，代码如下： 虽然现在完成了一个透明的单例类的编写，但它同样有一些缺点 为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的 Singleton 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。 观察现在的 Singleton 构造函数： 12345678var CreateDiv = function( html )&#123; if ( instance )&#123; return instance; &#125; this.html = html; this.init(); return instance = this;&#125;; 在这段代码中，CreateDiv 的构造函数实际上负责了两件事情。第一是创建对象和执行初始化 init 方法，第二是保证只有一个对象。虽然我们目前还没有接触过“单一职责原则”的概念，但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。 假设我们某天需要利用这个类，在页面中创建千千万万的 div，即要让这个类从单例类变成一个普通的可产生多个实例的类，那我们必须得改写 CreateDiv 构造函数，把控制创建唯一对象的那一段去掉，这种修改会给我们带来不必要的烦恼。 三、 用代理实现单例模式现在我们通过引入代理类的方式，来解决上面提到的问题。 我们依然使用 4.2 节中的代码，首先在 CreateDiv 构造函数中，把负责管理单例的代码移除出去，使它成为一个普通的创建 div 的类： 12345678910111213141516171819202122var CreateDiv = function (html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div);&#125;;//接下来引入代理类 proxySingletonCreateDiv：var ProxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)();var a = new ProxySingletonCreateDiv('sven1');var b = new ProxySingletonCreateDiv('sven2');alert(a === b); 通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。这样一来，CreateDiv就变成了一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果。 本例是缓存代理的应用之一，在接下来的学习中，我们将继续了解代理带来的好处。 四、 JavaScript 中的单例模式前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来。在以类为中心的语言中，这是很自然的做法。比如在 Java 中，如果需要某个对象，就必须先定义一个类，对象总是从类中创建而来的。 但 JavaScript 其实是一门无类（class-free）语言，也正因为如此，生搬单例模式的概念并无意义。在 JavaScript 中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢？这无异于穿棉衣洗澡，传统的单例模式实现在 JavaScript 中并不适用。 单例模式的核心是确保只有一个实例，并提供全局访问。 全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当成单例来使用。例如： var a = {}; 当用这种方式创建对象 a 时，对象 a 确实是独一无二的。如果 a 变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样就满足了单例模式的两个条件。 但是全局变量存在很多问题，它很容易造成命名空间污染。在大中型项目中，如果不加以限制和管理，程序中可能存在很多这样的变量。JavaScript 中的变量也很容易被不小心覆盖，相信每个 JavaScript 程序员都曾经历过变量冲突的痛苦，就像上面的对象 var a = {};，随时有可能被别人覆盖。 Douglas Crockford 多次把全局变量称为 JavaScript 中最糟糕的特性。在对 JavaScript 的创造者Brendan Eich 的访谈中， Brendan Eich 本人也承认全局变量是设计上的失误，是在没有足够的时间思考一些东西的情况下导致的结果。 作为普通的开发者，我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染。 4.1 使用命名空间适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量 最简单的方法依然是用对象字面量的方式： 12345678var namespace1 = &#123; a: function()&#123; alert (1); &#125;, b: function()&#123; alert (2); &#125;&#125;; 把 a 和 b 都定义为 namespace1 的属性，这样可以减少变量和全局作用域打交道的机会。另外我们还可以动态地创建命名空间，代码如下（引自 Object-Oriented JavaScrtipt 一书）： 123456789101112131415161718192021var MyApp = &#123;&#125;;MyApp.namespace = function (name) &#123; var parts = name.split('.'); var current = MyApp; for (var i in parts) &#123; if (!current[parts[i]]) &#123; current[parts[i]] = &#123;&#125;; &#125; current = current[parts[i]]; &#125;&#125;;MyApp.namespace('event');MyApp.namespace('dom.style');console.dir(MyApp);// 上述代码等价于：var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;&#125;; 4.2 使用闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信： 123456789var user = (function()&#123; var __name = 'sven', __age = 29; return &#123; getUserInfo: function()&#123; return __name + '-' + __age; &#125; &#125;&#125;)(); 我们用下划线来约定私有变量name 和age，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。 五、 惰性单例前面我们了解了单例模式的一些实现办法，本节我们来了解惰性单例。 惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用，有用的程度可能超出了我们的想象，实际上在本章开头就使用过这种技术，instance 实例对象总是在我们调用 Singleton.getInstance 的时候才被创建，而不是在页面加载好的时候就创建，代码如下： 123456789Singleton.getInstance = (function()&#123; var instance = null; return function( name )&#123; if ( !instance )&#123; instance = new Singleton( name ); &#125; return instance; &#125;&#125;)(); 不过这是基于“类”的单例模式，前面说过，基于“类”的单例模式在 JavaScript 中并不适用，下面我们将以 WebQQ 的登录浮窗为例，介绍与全局变量结合实现惰性的单例。 假设我们是 WebQQ 的开发人员（网址是web.qq.com），当点击左边导航里 QQ 头像时，会弹出一个登录浮窗（如图 4-1 所示），很明显这个浮窗在页面里总是唯一的，不可能出现同时存在两个登录窗口的情况。 第一种解决方案是在页面加载完成的时候便创建好这个 div 浮窗，这个浮窗一开始肯定是隐藏状态的，当用户点击登录按钮的时候，它才开始显示： 1234567891011121314151617&lt;html&gt; &lt;body&gt; &lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt; &lt;/body&gt; &lt;script&gt; var loginLayer = (function()&#123; var div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); return div; &#125;)(); document.getElementById( 'loginBtn' ).onclick = function()&#123; loginLayer.style.display = 'block'; &#125;; &lt;/script&gt;&lt;/html&gt; 这种方式有一个问题，也许我们进入 WebQQ 只是玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录浮窗总是一开始就被创建好，那么很有可能将白白浪费一些 DOM 节点。 现在改写一下代码，使用户点击登录按钮的时候才开始创建该浮窗： 123456789101112131415161718&lt;html&gt;&lt;body&gt; &lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var createLoginLayer = function()&#123; var div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); return div; &#125;; document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block'; &#125;;&lt;/script&gt;&lt;/html&gt; 虽然现在达到了惰性的目的，但失去了单例的效果。当我们每次点击登录按钮的时候，都会创建一个新的登录浮窗 div。虽然我们可以在点击浮窗上的关闭按钮时（此处未实现）把这个浮窗从页面中删除掉，但这样频繁地创建和删除节点明显是不合理的，也是不必要的。 也许读者已经想到了，我们可以用一个变量来判断是否已经创建过登录浮窗，这也是本节第一段代码中的做法： 12345678910111213141516var createLoginLayer = (function()&#123; var div; return function()&#123; if ( !div )&#123; div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); &#125; return div; &#125;&#125;)(); document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;; 六、 通用的惰性单例上一节我们完成了一个可用的惰性单例，但是我们发现它还有如下一些问题。 这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer对象内部。如果我们下次需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就必须得如法炮制，把 createLoginLayer 函数几乎照抄一遍： 1234567891011var createIframe= (function()&#123; var iframe; return function()&#123; if ( !iframe)&#123; iframe= document.createElement( 'iframe' ); iframe.style.display = 'none'; document.body.appendChild( iframe); &#125; return iframe; &#125;&#125;)(); 我们需要把不变的部分隔离出来，先不考虑创建一个 div 和创建一个 iframe 有多少差异，管理单例的逻辑其实是完全可以抽象出来的，这个逻辑始终是一样的：用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象： 1234var obj;if ( !obj )&#123; obj = xxx;&#125; 现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在 getSingle函数内部，创建对象的方法 fn 被当成参数动态传入 getSingle 函数： 123456var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;; 接下来将用于创建登录浮窗的方法用参数 fn 的形式传入 getSingle，我们不仅可以传入createLoginLayer，还能传入 createScript、createIframe、createXhr 等。之后再让 getSingle 返回一个新的函数，并且用一个变量 result 来保存 fn 的计算结果。result 变量因为身在闭包中，它永远不会被销毁。在将来的请求中，如果 result 已经被赋值，那么它将返回这个值。代码如下： 123456789101112var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').onclick = function () &#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;; 下面我们再试试创建唯一的 iframe 用于动态加载第三方页面： 123456789var createSingleIframe = getSingle(function () &#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe;&#125;);document.getElementById('loginBtn').onclick = function () &#123; var loginLayer = createSingleIframe(); loginLayer.src = 'http://baidu.com';&#125;; 在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能，看起来是一件挺奇妙的事情。 这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里追加数据，在使用事件代理的前提下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，如果借助于 jQuery，我们通常选择给节点绑定 one 事件： 123456789101112var bindEvent = function () &#123; $('div').one('click', function () &#123; alert('click'); &#125;);&#125;;var render = function () &#123; console.log('开始渲染列表'); bindEvent();&#125;;render(); render();render(); 如果利用 getSingle 函数，也能达到一样的效果。代码如下： 12345678910111213var bindEvent = getSingle(function () &#123; document.getElementById('div1').onclick = function () &#123; alert('click'); &#125; return true;&#125;);var render = function () &#123; console.log('开始渲染列表'); bindEvent();&#125;;render();render();render(); 可以看到，render 函数和 bindEvent 函数都分别执行了 3 次，但 div 实际上只被绑定了一个事件。 七、 小结单例模式是我们学习的第一个模式，我们先学习了传统的单例模式实现，也了解到因为语言的差异性，有更适合的方法在 JavaScript 中创建单例。这一章还提到了代理模式和单一职责原则，后面的章节会对它们进行更详细的讲解。 在 getSinge 函数中，实际上也提到了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践三（闭包和高阶函数）","date":"2019-05-07T01:53:58.000Z","path":"2019/05/07/cjw08ytbn001qkwvbvfkm13yu/","text":"虽然 JavaScript 是一门完整的面向对象的编程语言，但这门语言同时也拥有许多函数式语言的特性。 函数式语言的鼻祖是 LISP，JavaScript 在设计之初参考了 LISP 两大方言之一的 Scheme，引入了 Lambda 表达式、闭包、高阶函数等特性。使用这些特性，我们经常可以用一些灵活而巧妙的方式来编写 JavaScript 代码。 本章主要挑选了闭包和高阶函数进行讲解。在 JavaScript 版本的设计模式中，许多模式都可以用闭包和高阶函数来实现。 一、 闭包对于 JavaScript 程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。下面我们先简单了解这两个知识点。 1.1 变量的作用域变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。 另外一种情况是用 var 关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。代码如下： 123456var func = function () &#123; var a = 1; alert(a); // 输出: 1&#125;; func();alert(a); // 输出：Uncaught ReferenceError: a is not defined 在 JavaScript 中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的。 下面这段包含了嵌套函数的代码，也许能帮助我们加深对变量搜索过程的理解： 123456789101112var a = 1;var func1 = function () &#123; var b = 2; var func2 = function () &#123; var c = 3; alert(b); // 输出：2 alert(a); // 输出：1 &#125; func2(); alert(c); // 输出：Uncaught ReferenceError: c is not defined&#125;;func1(); 1.2 变量的生存周期除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁： 12345var func = function () &#123; var a = 1; // 退出函数后局部变量 a 将被销毁 alert(a);&#125;;func(); 现在来看看下面这段代码： 123456789101112var func = function () &#123; var a = 1; return function () &#123; a++; alert(a); &#125;&#125;;var f = func();f(); // 输出：2f(); // 输出：3f(); // 输出：4f(); // 输出：5 跟我们之前的推论相反，当退出函数后，局部变量 a 并没有消失，而是似乎一直在某个地方存活着。这是因为当执行 var f = func();时，f 返回了一个匿名函数的引用，它可以访问到 func()被调用时产生的环境，而局部变量 a 一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。 利用闭包我们可以完成许多奇妙的工作，下面介绍一个闭包的经典应用。假设页面上有 5 个div 节点，我们通过循环来给每个 div 绑定 onclick 事件，按照索引顺序，点击第 1 个 div 时弹出0，点击第 2 个 div 时弹出 1，以此类推。代码如下： 1234567891011121314151617&lt;html&gt; &lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; var nodes = document.getElementsByTagName( 'div' ); for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; nodes[ i ].onclick = function()&#123; alert ( i ); &#125; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试这段代码就会发现，无论点击哪个 div，最后弹出的结果都是 5。这是因为 div 节点的onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。 解决方法是在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i，如果有 5 个 div，这里的 i就分别是 0,1,2,3,4： 1234567for ( var i = 0, len = nodes.length; i &lt; len; i++ )&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)( i )&#125;; 根据同样的道理，我们还可以编写如下一段代码： 12345678910var Type = &#123;&#125;;for (var i = 0, type; type = ['String', 'Array', 'Number'][i++];) &#123; (function (type) &#123; Type['is' + type] = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125; &#125;)(type)&#125;;Type.isArray([]); // 输出：trueType.isString(\"str\"); // 输出：true 1.3 闭包的更多作用这一小节我们将通过几个例子，进一步讲解闭包的作用。因为篇幅所限，这里仅例举少量示例。在实际开发中，闭包的运用非常广泛。 1.3.1 封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的简单函数： 1234567var mult = function()&#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ )&#123; a = a * arguments[i]; &#125; return a;&#125;; mult 函数接受一些 number 类型的参数，并返回这些参数的乘积。现在我们觉得对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能： 1234567891011121314var cache = &#123;&#125;;var mult = function () &#123; var args = Array.prototype.join.call(arguments, ','); if (cache[args]) &#123; return cache[args]; &#125; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return cache[args] = a;&#125;;alert(mult(1, 2, 3)); // 输出：6alert(mult(1, 2, 3)); // 输出：6 我们看到 cache 这个变量仅仅在 mult 函数中被使用，与其让 cache 变量跟 mult 函数一起平行地暴露在全局作用域下，不如把它封闭在 mult 函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。代码如下： 1234567891011121314var mult = (function () &#123; var cache = &#123;&#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return cache[args] = a; &#125;&#125;)(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。代码如下： 1234567891011121314151617var mult = (function () &#123; var cache = &#123;&#125;; var calculate = function () &#123; // 封闭 calculate 函数 var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a; &#125;; return function () &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; return cache[args] = calculate.apply(null, arguments); &#125;&#125;)(); 1.3.2 延续局部变量的寿命img 对象经常用于进行数据上报，如下所示： 12345var report = function (src) &#123; var img = new Image(); img.src = src;&#125;;report('http://xxx.com/getUserInfo'); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说，report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后，img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题： 12345678var report = (function () &#123; var imgs = []; return function (src) &#123; var img = new Image(); imgs.push(img); img.src = src; &#125;&#125;)(); 1.4 闭包和面向对象设计过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。在 JavaScript 语言的祖先 Scheme 语言中，甚至都没有提供面向对象的原生设计，但可以使用闭包来实现一个完整的面向对象系统。 下面来看看这段跟闭包相关的代码： 123456789101112131415161718192021222324252627282930313233343536var extent = function () &#123; var value = 0; return &#123; call: function () &#123; value++; console.log(value); &#125; &#125;&#125;;var extent = extent();extent.call(); // 输出：1extent.call(); // 输出：2extent.call(); // 输出：3//如果换成面向对象的写法，就是：var extent = &#123; value: 0, call: function () &#123; this.value++; console.log(this.value); &#125;&#125;;extent.call(); // 输出：1extent.call(); // 输出：2extent.call(); // 输出：3//或者：var Extent = function () &#123; this.value = 0;&#125;;Extent.prototype.call = function () &#123; this.value++; console.log(this.value);&#125;;var extent = new Extent();extent.call();extent.call();extent.call(); 1.5 用闭包实现命令模式在 JavaScript 版本的各种设计模式实现中，闭包的运用非常广泛，在后续的学习过程中，我们将体会到这一点。 在 JavaScript 版本的各种设计模式实现中，闭包的运用非常广泛，在后续的学习过程中，我们将体会到这一点。 在完成闭包实现的命令模式之前，我们先用面向对象的方式来编写一段命令模式的代码。虽然还没有进入设计模式的学习，但这个作为演示作用的命令模式结构非常简单，不会对我们的理解造成困难，代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;body&gt; &lt;button id=\"execute\"&gt;点击我执行命令&lt;/button&gt; &lt;button id=\"undo\"&gt;点击我执行命令&lt;/button&gt; &lt;script&gt; var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125; &#125;; var OpenTvCommand = function( receiver )&#123; this.receiver = receiver; &#125;; OpenTvCommand.prototype.execute = function()&#123; this.receiver.open(); // 执行命令，打开电视机 &#125;; OpenTvCommand.prototype.undo = function()&#123; this.receiver.close(); // 撤销命令，关闭电视机 &#125;; var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125; &#125;; setCommand( new OpenTvCommand( Tv ) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 但在 JavaScript 中，函数作为一等对象，本身就可以四处传递，用函数对象而不是普通对象来封装请求显得更加简单和自然。如果需要往函数对象中预先植入命令的接收者，那么闭包可以完成这个工作。在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来；而在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中，代码如下： 1234567891011121314151617181920212223242526272829var Tv = &#123; open: function()&#123; console.log( '打开电视机' ); &#125;, close: function()&#123; console.log( '关上电视机' ); &#125;&#125;;var createCommand = function( receiver )&#123; var execute = function()&#123; return receiver.open(); // 执行命令，打开电视机 &#125; var undo = function()&#123; return receiver.close(); // 执行命令，关闭电视机 &#125; return &#123; execute: execute, undo: undo &#125;&#125;;var setCommand = function( command )&#123; document.getElementById( 'execute' ).onclick = function()&#123; command.execute(); // 输出：打开电视机 &#125; document.getElementById( 'undo' ).onclick = function()&#123; command.undo(); // 输出：关闭电视机 &#125;&#125;;setCommand( createCommand( Tv ) ); 1.6 闭包与内存管理闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 二、 高级函数高阶函数是指至少满足下列条件之一的函数： 函数可以作为参数被传递；函数可以作为返回值输出。 JavaScript 语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当作参数传递，还是让函数的执行结果返回另外一个函数，这两种情形都有很多应用场景，下面就列举一些高阶函数的应用场景。 2.1 函数作为参数传递把函数当作参数传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。 2.1.1 回调函数在 ajax 异步请求的应用中，回调函数的使用非常频繁。当我们想在 ajax 请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把 callback 函数当作参数传入发起 ajax 请求的方法中，待请求完成之后执行 callback 函数： 12345678910var getUserInfo = function( userId, callback )&#123; $.ajax( 'http://xxx.com/getUserInfo?' + userId, function( data )&#123; if ( typeof callback === 'function' )&#123; callback( data ); &#125; &#125;);&#125;getUserInfo( 13157, function( data )&#123; alert ( data.userName );&#125;); 回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行。 比如，我们想在页面中创建 100 个 div 节点，然后把这些 div 节点都设置为隐藏。下面是一种编写代码的方式： 123456789var appendDiv = function () &#123; for (var i = 0; i &lt; 100; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); div.style.display = 'none'; &#125;&#125;;appendDiv(); 把 div.style.display = ‘none’的逻辑硬编码在 appendDiv 里显然是不合理的，appendDiv 未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。 于是我们把 div.style.display = ‘none’这行代码抽出来，用回调函数的形式传入 appendDiv方法： 12345678910111213var appendDiv = function (callback) &#123; for (var i = 0; i &lt; 100; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); if (typeof callback === 'function') &#123; callback(div); &#125; &#125;&#125;;appendDiv(function (node) &#123; node.style.display = 'none';&#125;); 可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在回调函数中，“委托”给 appendDiv 方法。appendDiv 方法当然知道节点什么时候创建好，所以在节点创建好的时候，appendDiv 会执行之前客户传入的回调函数。 2.1.2 Array.prototype.sortArray.prototype.sort 接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。从Array.prototype.sort 的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入Array.prototype.sort，使 Array.prototype.sort 方法成为了一个非常灵活的方法，代码如下： 12345678910//从小到大排列[1, 4, 3].sort(function (a, b) &#123; return a - b; &#125;);// 输出: [ 1, 3, 4 ]//从大到小排列[1, 4, 3].sort(function (a, b) &#123; return b - a;&#125;);// 输出: [ 4, 3, 1 ] 2.2 函数作为返回值输出相比把函数当作参数传递，函数当作返回值输出的应用场景也许更多，也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。 2.2.1 判断数据的类型我们来看看这个例子，判断一个数据是否是数组，在以往的实现中，可以基于鸭子类型的概念来判断，比如判断这个数据有没有 length 属性，有没有 sort 方法或者 slice 方法等。但更好的方式是用 Object.prototype.toString 来计算。Object.prototype.toString.call( obj )返回一个字符串，比如 Object.prototype.toString.call( [1,2,3] ) 总是返回 “[object Array]” ， 而Object.prototype.toString.call( “str”)总是返回”[object String]”。所以我们可以编写一系列的isType 函数。代码如下： 123456789 var isString = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object String]';&#125;;var isArray = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]';&#125;;var isNumber = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object Number]';&#125;; 我们发现，这些函数的大部分实现都是相同的，不同的只是 Object.prototype.toString.call( obj )返回的字符串。为了避免多余的代码，我们尝试把这些字符串作为参数提前值入 isType函数。代码如下： 1234567891011121314151617181920var isType = function (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125;&#125;; var isString = isType('String');var isArray = isType('Array');var isNumber = isType('Number');console.log(isArray([1, 2, 3])); // 输出：true//我们还可以用循环语句，来批量注册这些 isType 函数：var Type = &#123;&#125;;for (var i = 0, type; type = ['String', 'Array', 'Number'][i++];) &#123; (function (type) &#123; Type['is' + type] = function (obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125; &#125;)(type)&#125;;Type.isArray([]); // 输出：trueType.isString(\"str\"); // 输出：true 2.2.2 getSingle下面是一个单例模式的例子，在第三部分设计模式的学习中，我们将进行更深入的讲解，这里暂且只了解其代码实现： 123456var getSingle = function ( fn ) &#123; var ret; return function () &#123; return ret || ( ret = fn.apply( this, arguments ) ); &#125;;&#125;; 这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数。我们可以看看 getSingle 函数的效果： 12345678910111213var getSingle = function (fn) &#123; var ret; return function () &#123; return ret || (ret = fn.apply(this, arguments)); &#125;;&#125;; var getScript = getSingle(function () &#123; return document.createElement('script');&#125;);var script1 = getScript();var script2 = getScript();alert(script1 === script2); // 输出：true 2.3 高阶函数实现AOPAOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 在 Java 语言中，可以通过反射和动态代理机制来实现 AOP 技术。而在 JavaScript 这种动态语言中，AOP 的实现更加简单，这是 JavaScript 与生俱来的能力。 通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，本节我们通过扩展 Function.prototype 来做到这一点。代码如下： 123456789101112131415161718192021222324Function.prototype.before = function (beforefn) &#123; var __self = this; // 保存原函数的引用 return function () &#123; // 返回包含了原函数和新函数的\"代理\"函数 beforefn.apply(this, arguments); // 执行新函数，修正 this return __self.apply(this, arguments); // 执行原函数 &#125;&#125;;Function.prototype.after = function (afterfn) &#123; var __self = this; return function () &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;;var func = function () &#123; console.log(2);&#125;;func = func.before(function () &#123; console.log(1);&#125;).after(function () &#123; console.log(3);&#125;);func(); //1, 2, 3 我们把负责打印数字 1 和打印数字 3 的两个函数通过 AOP 的方式动态植入 func 函数。通过执行上面的代码，我们看到控制台顺利地返回了执行结果 1、2、3。 这种使用 AOP 的方式来给函数添加职责，也是 JavaScript 语言中一种非常特别和巧妙的装饰者模式实现。这种装饰者模式在实际开发中非常有用。 2.4 高阶函数的其他应用前面我们已经学习过高阶函数，本节我们再挑选一些常见的高阶函数应用进行介绍。 2.4.1 currying首先我们讨论的是函数柯里化（function currying）。currying 的概念最早由俄国数学家 MosesSchönfinkel 发明，而后由著名的数理逻辑学家 Haskell Curry 将其丰富和发展，currying 由此得名。 currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。 从字面上理解 currying 并不太容易，我们来看下面的例子。 假设我们要编写一个计算每月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱。代码如下： 123456789var monthlyCost = 0;var cost = function( money )&#123; monthlyCost += money;&#125;;cost( 100 ); // 第 1 天开销cost( 200 ); // 第 2 天开销cost( 300 ); // 第 3 天开销//cost( 700 ); // 第 30 天开销alert ( monthlyCost ); // 输出：600 通过这段代码可以看到，每天结束后我们都会记录并计算到今天为止花掉的钱。但我们其实并不太关心每天花掉了多少钱，而只想知道到月底的时候会花掉多少钱。也就是说，实际上只需要在月底计算一次。 如果在每个月的前 29 天，我们都只是保存好当天的开销，直到第 30 天才进行求值计算，这样就达到了我们的要求。虽然下面的 cost 函数还不是一个 currying 函数的完整实现，但有助于我们了解其思想： 123456789101112131415161718var cost = (function () &#123;var args = [];return function () &#123; if (arguments.length === 0) &#123; var money = 0; for (var i = 0, l = args.length; i &lt; l; i++) &#123; money += args[i]; &#125; return money; &#125; else &#123; [].push.apply(args, arguments); &#125; &#125;&#125;)();cost(100); // 未真正求值cost(200); // 未真正求值cost(300); // 未真正求值console.log(cost()); // 求值并输出：600 接下来我们编写一个通用的 function currying(){}，function currying(){}接受一个参数，即将要被 currying 的函数。在这个例子里，这个函数的作用遍历本月每天的开销并求出它们的总和。代码如下： 12345678910111213141516171819202122232425var currying = function (fn) &#123; var args = []; return function () &#123; if (arguments.length === 0) &#123; return fn.apply(this, args); &#125; else &#123; [].push.apply(args, arguments); return arguments.callee; &#125; &#125;&#125;;var cost = (function () &#123; var money = 0; return function () &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; money += arguments[i]; &#125; return money; &#125;&#125;)();var cost = currying(cost); // 转化成 currying 函数cost(100); // 未真正求值cost(200); // 未真正求值cost(300); // 未真正求值alert(cost()); // 求值并输出：600 至此，我们完成了一个 currying 函数的编写。当调用 cost()时，如果明确地带上了一些参数，表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让 cost 函数返回另外一个函数。只有当我们以不带参数的形式执行 cost()时，才利用前面保存的所有参数，真正开始进行求值计算。 2.4.2 uncurrying在 JavaScript 中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。 同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？ 答案对于我们来说很简单，call 和 apply 都可以完成这个需求： 123456789var obj1 = &#123; name: 'sven'&#125;;var obj2 = &#123; getName: function()&#123; return this.name; &#125;&#125;;console.log( obj2.getName.call( obj1 ) ); // 输出：sven 我们常常让类数组对象去借用 Array.prototype 的方法，这是 call 和 apply 最常见的应用场景之一： 1234(function()&#123; Array.prototype.push.call( arguments, 4 ); // arguments 借用 Array.prototype.push 方法 console.log( arguments ); // 输出：[1, 2, 3, 4]&#125;)( 1, 2, 3 ); 在我们的预期中，Array.prototype 上的方法原本只能用来操作 array 对象。但用 call 和 apply可以把任意对象当作 this 传入某个方法，这样一来，方法中用到 this 的地方就不再局限于原来规定的对象，而是加以泛化并得到更广的适用性。 那么有没有办法把泛化 this 的过程提取出来呢？本小节讲述的 uncurrying 就是用来解决这个问题的。uncurrying 的话题来自 JavaScript 之父 Brendan Eich 在 2011 年发表的一篇 Twitter。以下代码是 uncurrying 的实现方式之一： 1234567Function.prototype.uncurrying = function () &#123; var self = this; return function () &#123; var obj = Array.prototype.shift.call(arguments); return self.apply(obj, arguments); &#125;;&#125;; 在讲解这段代码的实现原理之前，我们先来瞧瞧它有什么作用。 在类数组对象 arguments 借用 Array.prototype 的方法之前，先把 Array.prototype.push.call这句代码转换为一个通用的 push 函数： 12345var push = Array.prototype.push.uncurrying();(function()&#123; push( arguments, 4 ); console.log( arguments ); // 输出：[1, 2, 3, 4]&#125;)( 1, 2, 3 ); 通过 uncurrying 的方式，Array.prototype.push.call 变成了一个通用的 push 函数。这样一来，push 函数的作用就跟 Array.prototype.push 一样了，同样不仅仅局限于只能操作 array 对象。而对于使用者而言，调用 push 函数的方式也显得更加简洁和意图明了。 我们还可以一次性地把 Array.prototype 上的方法“复制”到 array 对象上，同样这些方法可操作的对象也不仅仅只是 array 对象： 1234567891011121314151617for (var i = 0, fn, ary = ['push', 'shift', 'forEach']; fn = ary[i++];) &#123; Array[fn] = Array.prototype[fn].uncurrying();&#125;;var obj = &#123; \"length\": 3, \"0\": 1, \"1\": 2, \"2\": 3&#125;;Array.push(obj, 4); // 向对象中添加一个元素console.log(obj.length); // 输出：4var first = Array.shift(obj); // 截取第一个元素console.log(first); // 输出：1console.log(obj); // 输出：&#123;0: 2, 1: 3, 2: 4, length: 3&#125;Array.forEach(obj, function (i, n) &#123; console.log(n); // 分别输出：0, 1, 2&#125;); 甚至 Function.prototype.call 和 Function.prototype.apply 本身也可以被 uncurrying，不过这没有实用价值，只是使得对函数的调用看起来更像 JavaScript 语言的前身 Scheme： 12345678910111213141516171819202122232425262728293031323334353637383940var call = Function.prototype.call.uncurrying();var fn = function (name) &#123; console.log(name); &#125;;call(fn, window, 'sven'); // 输出：svenvar apply = Function.prototype.apply.uncurrying();var fn = function (name) &#123; console.log(this.name); // 输出：\"sven\" console.log(arguments); // 输出: [1, 2, 3]&#125;;apply(fn, &#123; name: 'sven' &#125;, [1, 2, 3]);//目前我们已经给出了 Function.prototype.uncurrying 的一种实现。现在来分析调用Array.prototype.push.uncurrying()//这句代码时发生了什么事情：Function.prototype.uncurrying = function () &#123; var self = this; // self 此时是 Array.prototype.push return function () &#123; var obj = Array.prototype.shift.call(arguments); // obj 是&#123; // \"length\": 1, // \"0\": 1 // &#125; // arguments 对象的第一个元素被截去，剩下[2] return self.apply(obj, arguments); // 相当于 Array.prototype.push.apply( obj, 2 ) &#125;;&#125;;var push = Array.prototype.push.uncurrying();var obj = &#123; \"length\": 1, \"0\": 1&#125;;push(obj, 2);console.log(obj); // 输出：&#123;0: 1, 1: 2, length: 2&#125;//除了刚刚提供的代码实现，下面的代码是 uncurrying 的另外一种实现方式：Function.prototype.uncurrying = function () &#123; var self = this; return function () &#123; return Function.prototype.call.apply(self, arguments); &#125;&#125;; 2.4.3 函数节流JavaScript 中的函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则我们一般不会遇到跟性能相关的问题。但在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。下面将列举一些这样的场景。 (1) 函数被频繁调用的场景 window.onresize 事件。我们给 window 对象绑定了 resize 事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果我们在 window.onresize 事件函数里有一些跟 DOM 节点相关的操作，而跟 DOM 节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。mousemove 事件。同样，如果我们给一个 div 节点绑定了拖曳事件（主要是 mousemove），当div 节点被拖动的时候，也会频繁地触发该拖曳事件函数。上传进度。微云的上传功能使用了公司提供的一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知 JavaScript 函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约一秒钟 10 次，很显然我们在页面中不需要如此频繁地去提示用户。 (2) 函数节流的原理 我们整理上面提到的三个场景，发现它们面临的共同问题是函数被触发的频率太高。 比如我们在 window.onresize 事件中要打印当前的浏览器窗口大小，在我们通过拖曳来改变窗口大小的时候，打印窗口大小的工作 1 秒钟进行了 10 次。而我们实际上只需要 2 次或者 3 次。这就需要我们按时间段来忽略掉一些事件请求，比如确保在 500ms 内只打印一次。很显然，我们可以借助 setTimeout 来完成这件事情。 (3) 函数节流的代码实现 关于函数节流的代码实现有许多种，下面的 throttle 函数的原理是，将即将被执行的函数用setTimeout 延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。throttle 函数接受 2 个参数，第一个参数为需要被延迟执行的函数，第二个参数为延迟执行的时间。具体实现代码如下： 1234567891011121314151617181920212223242526var throttle = function (fn, interval) &#123; var __self = fn, // 保存需要被延迟执行的函数引用 timer, // 定时器 firstTime = true; // 是否是第一次调用 return function () &#123; var args = arguments, __me = this; console.log(args); if (firstTime) &#123; // 如果是第一次调用，不需延迟执行 __self.apply(__me, args); return firstTime = false; &#125; if (timer) &#123; // 如果定时器还在，说明前一次延迟执行还没有完成 return false; &#125; timer = setTimeout(function () &#123; // 延迟一段时间执行 clearTimeout(timer); timer = null; __self.apply(__me, args); &#125;, interval || 500); &#125;;&#125;;window.onresize = throttle(function () &#123; console.log(arguments) console.log(1);&#125;, 500); 2.4.4 分时函数在前面关于函数节流的讨论中，我们提供了一种限制函数被频繁调用的解决方案。下面我们将遇到另外一个问题，某些函数确实是用户主动调用的，但因为一些客观的原因，这些函数会严重地影响页面性能。 一个例子是创建 WebQQ 的 QQ 好友列表。列表中通常会有成百上千个好友，如果一个好友用一个节点来表示，当我们在页面中渲染这个列表的时候，可能要一次性往页面中创建成百上千个节点。 在短时间内往页面中大量添加 DOM 节点显然也会让浏览器吃不消，我们看到的结果往往就是浏览器的卡顿甚至假死。代码如下： 123456789101112var ary = [];for (var i = 1; i &lt;= 1000; i++) &#123; ary.push(i); // 假设 ary 装载了 1000 个好友的数据&#125;;var renderFriendList = function (data) &#123; for (var i = 0, l = data.length; i &lt; l; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); &#125;&#125;;renderFriendList(ary); 这个问题的解决方案之一是下面的 timeChunk 函数，timeChunk 函数让创建节点的工作分批进行，比如把 1 秒钟创建 1000 个节点，改为每隔 200 毫秒创建 8 个节点。timeChunk 函数接受 3 个参数，第 1 个参数是创建节点时需要用到的数据，第 2 个参数是封装了创建节点逻辑的函数，第 3 个参数表示每一批创建的节点数量。代码如下： 12345678910111213141516171819202122232425262728293031var timeChunk = function (ary, fn, count) &#123; //ary创建节点时需要用到的数据，fn 封装创建节点逻辑的函数，count每一批创建的节点数量 var obj, t; var len = ary.length; var start = function () &#123; for (var i = 0; i &lt; Math.min(count || 1, ary.length); i++) &#123; var obj = ary.shift(); console.log(obj) fn(obj); &#125; &#125;; return function () &#123; t = setInterval(function () &#123; if (ary.length === 0) &#123; // 如果全部节点都已经被创建好 return clearInterval(t); &#125; start(); &#125;, 200); // 分批执行的时间间隔，也可以用参数的形式传入 &#125;;&#125;; var ary = [];for (var i = 1; i &lt;= 1000; i++) &#123; ary.push(i);&#125;;var renderFriendList = timeChunk(ary, function (n) &#123; var div = document.createElement('div'); div.innerHTML = n; document.body.appendChild(div);&#125;, 8);renderFriendList(); 2.4.5 惰性加载函数Web 开发中，因为浏览器之间的实现差异，一些嗅探工作总是不可避免。比如我们需要一个在各个浏览器中能够通用的事件绑定函数 addEvent，常见的写法如下： 12345678var addEvent = function (elem, type, handler) &#123; if (window.addEventListener) &#123; return elem.addEventListener(type, handler, false); &#125; if (window.attachEvent) &#123; return elem.attachEvent('on' + type, handler); &#125;&#125;; 这个函数的缺点是，当它每次被调用的时候都会执行里面的 if 条件分支，虽然执行这些 if分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行过程。 第二种方案是这样，我们把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，以便让 addEvent 返回一个包裹了正确逻辑的函数。代码如下： 123456789101112var addEvent = (function () &#123; if (window.addEventListener) &#123; return function (elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; if (window.attachEvent) &#123; return function (elem, type, handler) &#123; elem.attachEvent('on' + type, handler); &#125; &#125;&#125;)(); 目前的 addEvent 函数依然有个缺点，也许我们从头到尾都没有使用过 addEvent 函数，这样看来，前一次的浏览器嗅探就是完全多余的操作，而且这也会稍稍延长页面 ready 的时间。 第三种方案即是我们将要讨论的惰性载入函数方案。此时 addEvent 依然被声明为一个普通函数，在函数里依然有一些分支判断。但是在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是我们期望的 addEvent 函数，在下一次进入 addEvent 函数的时候，addEvent函数里不再存在条件分支语句： 1234567891011121314151617181920212223242526&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;点我绑定事件&lt;/div&gt; &lt;script&gt; var addEvent = function( elem, type, handler )&#123; if ( window.addEventListener )&#123; addEvent = function( elem, type, handler )&#123; elem.addEventListener( type, handler, false ); &#125; &#125;else if ( window.attachEvent )&#123; addEvent = function( elem, type, handler )&#123; elem.attachEvent( 'on' + type, handler ); &#125; &#125; addEvent( elem, type, handler ); &#125;; var div = document.getElementById( 'div1' ); addEvent( div, 'click', function()&#123; alert (1); &#125;); addEvent( div, 'click', function()&#123; alert (2); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 三、 小结在进入设计模式的学习之前，本章挑选了闭包和高阶函数来进行讲解。这是因为在 JavaScript开发中，闭包和高阶函数的应用极多。就设计模式而言，因为 JavaScript 这门语言的自身特点，许多设计模式在 JavaScript 之中的实现跟在一些传统面向对象语言中的实现相差很大。在JavaScript 中，很多设计模式都是通过闭包和高阶函数实现的。这并不奇怪，相对于模式的实现过程，我们更关注的是模式可以帮助我们完成什么。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践二（this、call 和 apply）","date":"2019-04-29T03:18:40.000Z","path":"2019/04/29/cjw08yt9a0015kwvbtdvnhcs0/","text":"在 JavaScript 编程中，this 关键字总是让初学者感到迷惑，Function.prototype.call 和Function.prototype.apply 这两个方法也有着广泛的运用。我们有必要在学习设计模式之前先理解这几个概念。 一、 this跟别的语言大相径庭的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 1.1 this的指向除去不常用的 with 和 eval 的情况，具体到实际应用中，this 的指向大致可以分为以下 4 种。 作为对象的方法调用。作为普通函数调用。构造器调用。Function.prototype.call 或 Function.prototype.apply 调用。 下面我们分别进行介绍。 1.1.1 作为对象的方法调用当函数作为对象的方法被调用时，this 指向该对象： 12345678var obj = &#123; a: 1, getA: function () &#123; alert(this === obj); // 输出：true alert(this.a); // 输出: 1 &#125;&#125;;obj.getA(); 1.1.2 作为普通函数调用当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。 12345window.name = 'globalName';var getName = function () &#123; return this.name;&#125;;console.log(getName()); // 输出：globalName 或者： 123456789window.name = 'globalName';var myObject = &#123; name: 'sven', getName: function () &#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log(getName()); // globalName 有时候我们会遇到一些困扰，比如在 div 节点的事件函数内部，有一个局部的 callback 方法，callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向该 div 节点，见如下代码： 123456789101112131415&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;我是一个 div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.id = 'window'; document.getElementById( 'div1' ).onclick = function()&#123; alert ( this.id ); // 输出：'div1' var callback = function()&#123; alert ( this.id ); // 输出：'window' &#125; callback(); &#125;; &lt;/script&gt;&lt;/html&gt; 此时有一种简单的解决方案，可以用一个变量保存 div 节点的引用： 1234567document.getElementById( 'div1' ).onclick = function()&#123; var that = this; // 保存 div 的引用 var callback = function()&#123; alert ( that.id ); // 输出：'div1' &#125; callback();&#125;; 在 ECMAScript 5 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined： 12345function func()&#123; \"use strict\" alert ( this ); // 输出：undefined&#125;func(); 1.1.3 构造器调用JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。 除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码： 12345var MyClass = function()&#123; this.name = 'sven';&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：sven 但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this： 12345678var MyClass = function()&#123; this.name = 'sven'; return &#123; // 显式地返回一个对象 name: 'anne' &#125;&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：anne 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题 123456var MyClass = function()&#123; this.name = 'sven' return 'anne'; // 返回 string 类型&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：sven 1.1.4 Function.prototype.call 或 Function.prototype.apply 调用跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this： 1234567891011var obj1 = &#123; name: 'sven', getName: function()&#123; return this.name; &#125;&#125;;var obj2 = &#123; name: 'anne'&#125;;console.log( obj1.getName() ); // 输出: svenconsole.log( obj1.getName.call( obj2 ) ); // 输出：anne call 和 apply 方法能很好地体现 JavaScript 的函数式语言特性，在 JavaScript 中，几乎每一次编写函数式语言风格的代码，都离不开 call 和 apply。在 JavaScript 诸多版本的设计模式中，也用到了 call 和 apply。在下一节会详细介绍它们。 1.2 丢失的this这是一个经常遇到的问题，我们先看下面的代码： 123456789var obj = &#123; myName: 'sven', getName: function () &#123; return this.myName; &#125;&#125;;console.log(obj.getName()); // 输出：'sven'var getName2 = obj.getName;console.log(getName2()); // 输出：undefined 当调用 obj.getName 时，getName 方法是作为 obj 对象的属性被调用的，根据前面提到的规律，此时的 this 指向 obj 对象，所以 obj.getName()输出’sven’。 当用另外一个变量 getName2 来引用 obj.getName，并且调用 getName2 时，根据前面提到的规律，此时是普通函数调用方式，this 是指向全局 window 的，所以程序的执行结果是undefined。 再看另一个例子，document.getElementById 这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它，如同 prototype.js 等一些框架所做过的事情： 1234var getId = function( id )&#123; return document.getElementById( id );&#125;; getId( 'div1' ); 我们也许思考过为什么不能用下面这种更简单的方式： 12var getId = document.getElementById;getId( 'div1' ); 在浏览器中运行以上代码： 123456789&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;我是一个 div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var getId = document.getElementById; getId( 'div1' ); &lt;/script&gt;&lt;/html&gt; 在 Chrome、Firefox、IE10 中执行过后就会发现，这段代码抛出了一个异常。这是因为许多引擎的 document.getElementById 方法的内部实现中需要用到 this。这个 this 本来被期望指向document，当 getElementById 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指向 document 的。 但当用 getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用，函数内部的 this 指向了 window，而不是原来的 document。 我们可以尝试利用 apply 把 document 当作 this 传入 getId 函数，帮助“修正”this： 12345678document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document, arguments); &#125;&#125;)(document.getElementById);var getId = document.getElementById;var div = getId('div1');alert(div.id); // 输出： div1 二、 call 和 applyECAMScript 3给Function的原型定义了两个方法，它们是Function.prototype.call和Function.prototype.apply。在实际开发中，特别是在一些函数式风格的代码编写中，call和 apply 方法尤为有用。在 JavaScript 版本的设计模式中，这两个方法的应用也非常广泛，能熟练运用这两个方法，是我们真正成为一名 JavaScript 程序员的重要一步。 2.1 call和apply的区别Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。 apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数： 1234var func = function( a, b, c )&#123; alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]&#125;;func.apply( null, [ 1, 2, 3 ] ); 在这段代码中，参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列表中的 a、b、c。 call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数： 1234var func = function (a, b, c) &#123; alert([a, b, c]); // 输出 [ 1, 2, 3 ]&#125;;func.call(null, 1, 2, 3); 当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript 的参数在内部就是用一个数组来表示的。从这个意义上说，apply 比call 的使用率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了。 call 是包装在 apply 上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call 来传送参数。 当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window： 1234var func = function( a, b, c )&#123; alert ( this === window ); // 输出 true &#125;;func.apply( null, [ 1, 2, 3 ] ); 但如果是在严格模式下，函数体内的 this 还是为 null： 12345var func = function( a, b, c )&#123;\"use strict\"; alert ( this === null ); // 输出 true&#125;func.apply( null, [ 1, 2, 3 ] ); 有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象： 1Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输出：5 2.2 call和apply的用途前面说过，能够熟练使用 call 和 apply，是我们真正成为一名 JavaScript 程序员的重要一步，本节我们将详细介绍 call 和 apply 在实际开发中的用途。 2.2.1 改变 this 指向call 和 apply 最常见的用途是改变函数内部的 this 指向，我们来看个例子： 12345678910111213var obj1 = &#123; name: 'sven'&#125;;var obj2 = &#123; name: 'anne'&#125;;window.name = 'window';var getName = function () &#123; alert(this.name);&#125;;getName(); // 输出: windowgetName.call(obj1); // 输出: svengetName.call(obj2); // 输出: anne 当执行 getName.call( obj1 )这句代码时，getName 函数体内的 this 就指向 obj1 对象，所以此处的 123var getName = function()&#123; alert ( this.name );&#125;; 实际上相当于： 123var getName = function()&#123; alert ( obj1.name ); // 输出: sven&#125;; 在实际开发中，经常会遇到 this 指向被不经意改变的场景，比如有一个 div 节点，div 节点的 onclick 事件中的 this 本来是指向这个 div 的： 123document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1&#125;; 假如该事件函数中有一个内部函数 func，在事件内部调用 func 函数时，func 函数体内的 this就指向了 window，而不是我们预期的 div，见如下代码： 1234567document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1 var func = function()&#123; alert ( this.id ); // 输出：undefined &#125; func();&#125;; 这时候我们用 call 来修正 func 函数内的 this，使其依然指向 div： 1234567document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1 var func = function()&#123; alert ( this.id ); // 输出：输出：div1 &#125; func.call(this);&#125;; 使用 call 来修正 this 的场景，我们并非第一次遇到，在前面关于 this 的学习中，我们就曾经修正过 document.getElementById 函数内部“丢失”的 this，代码如下： 12345678document.getElementById = (function( func )&#123; return function()&#123; return func.apply( document, arguments ); &#125;&#125;)( document.getElementById );var getId = document.getElementById;var div = getId( 'div1' );alert ( div.id ); // 输出： div1 2.2.2 Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this指向，即使没有原生的 Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下： 1234567891011121314Function.prototype.bind = function (context) &#123; var self = this; // 保存原函数 return function () &#123; // 返回一个新的函数 return self.apply(context, arguments); // 执行新的函数的时候，会把之前传入的 context // 当作新函数体内的 this &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function () &#123; alert(this.name); // 输出：sven&#125;.bind(obj);func(); 我们通过 Function.prototype.bind 来“包装”func 函数，并且传入一个对象 context 当作参数，这个 context 对象就是我们想修正的 this 对象。 在 Function.prototype.bind 的内部实现中，我们先把 func 函数的引用保存起来，然后返回一个新的函数。当我们在将来执行 func 函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply( context, arguments )这句代码才是执行原来的 func 函数，并且指定 context对象为 func 函数体内的 this。 这是一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一点，使得可以往 func 函数中预先填入一些参数： 123456789101112131415161718Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的 this 上下文 args = [].slice.call(arguments); // 剩余的参数转成数组 return function () &#123; // 返回一个新的函数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this // 并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function (a, b, c, d) &#123; alert(this.name); // 输出：sven alert([a, b, c, d]) // 输出：[ 1, 2, 3, 4 ]&#125;.bind(obj, 1, 2);func(3, 4); 2.2.3 借用其他对象的方法我们知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让它们代为孵化和养育。同样，在 JavaScript 中也存在类似的借用现象。 借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果： 1234567891011var A = function (name) &#123; this.name = name;&#125;;var B = function () &#123; A.apply(this, arguments);&#125;;B.prototype.getName = function () &#123; return this.name;&#125;;var b = new B('sven');console.log(b.getName()); // 输出： 'sven' 借用方法的第二种运用场景跟我们的关系更加密切。 函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用Array.prototype.push： 1234(function () &#123; Array.prototype.push.call(arguments, 3); console.log(arguments); // 输出[1,2,3]&#125;)(1, 2); 在操作 arguments 的时候，我们经常非常频繁地找 Array.prototype 对象借用方法。 想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内部实现原理是什么呢？我们不妨翻开 V8 的引擎源码，以 Array.prototype.push 为例，看看 V8 引擎中的具体实现： 123456789function ArrayPush() &#123; var n = TO_UINT32(this.length); // 被 push 的对象的 length var m = % _ArgumentsLength(); // push 的参数个数 for (var i = 0; i &lt; m; i++) &#123; this[i + n] = % _Arguments(i); // 复制元素 (1) &#125; this.length = n + m; // 修正 length 属性的值 (2) return this.length;&#125;; 通过这段代码可以看到，Array.prototype.push 实际上是一个属性复制的过程，把参数按照下标依次添加到被 push 的对象上面，顺便修改了这个对象的 length 属性。至于被修改的对象是谁，到底是数组还是类数组对象，这一点并不重要。 由此可以推断，我们可以把“任意”对象传入 Array.prototype.push 1234var a = &#123;&#125;;Array.prototype.push.call(a, 'first');alert(a.length); // 输出：1alert(a[0]); // first 这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版本的 IE 浏览器中执行，必须显式地给对象 a 设置 length 属性： 123var a = &#123; length: 0&#125;; 前面我们之所以把“任意”两字加了双引号，是因为可以借用 Array.prototype.push 方法的对象还要满足以下两个条件，从 ArrayPush 函数的(1)处和(2)处也可以猜到，这个对象至少还要满足： 对象本身要可以存取属性；对象的 length 属性可读写。 对于第一个条件，对象本身存取属性并没有问题，但如果借用 Array.prototype.push 方法的不是一个 object 类型的数据，而是一个 number 类型的数据呢? 我们无法在 number 身上存取其他数据，那么从下面的测试代码可以发现，一个 number 类型的数据不可能借用到 Array.prototype.push 方法： 1234var a = 1;Array.prototype.push.call(a, 'first');alert(a.length); // 输出：undefinedalert(a[0]); // 输出：undefined 对于第二个条件，函数的 length 属性就是一个只读的属性，表示形参的个数，我们尝试把一个函数当作 this 传入 Array.prototype.push： 1234var func = function () &#123; &#125;;Array.prototype.push.call(func, 'first');alert(func.length);// 报错：cannot assign to read only property ‘length’ of function()&#123;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript设计模式与开发实践一（面向对象的JavaScript ）","date":"2019-04-18T07:36:40.000Z","path":"2019/04/18/cjw08ytby001skwvb8k1sca5t/","text":"JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript 也没有在语言层面提供对抽象类和接口的支持。正因为存在这些跟传统面向对象语言不一致的地方，我们在用设计模式编写代码的时候，更要跟传统面向对象语言加以区别。所以在正式学习设计模式之前，我们有必要先了解一些 JavaScript 在面向对象方面的知识。 一、 动态类型语言和鸭子类型编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。 静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。 静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。 静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。 动态类型语言的优点是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。 动态类型语言的缺点是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。这好像在商店买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味。 JavaScript 中，当我们对一个变量赋值时，显然不需要考虑它的类型，因此，JavaScript是一门典型的动态类型语言。 动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。 这一切都建立在鸭子类型（duck typing）的概念上，鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。” 我们可以通过一个小故事来更深刻地了解鸭子类型。 从前在 JavaScript 王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个 1000 只鸭子组成的合唱团。大臣们找遍了全国，终于找到 999 只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为了合唱团的最后一员。 这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注 HAS-A, 而不是 IS-A。 下面我们用代码来模拟这个故事。 1234567891011121314151617181920var duck = &#123; duckSinging: function () &#123; console.log('嘎嘎嘎'); &#125;&#125;;var chicken = &#123; duckSinging: function () &#123; console.log('嘎嘎嘎'); &#125;&#125;;var choir = []; // 合唱团var joinChoir = function (animal) &#123; if (animal &amp;&amp; typeof animal.duckSinging === 'function') &#123; choir.push(animal); console.log('恭喜加入合唱团'); console.log('合唱团已有成员数量:' + choir.length); &#125;&#125;;joinChoir(duck); // 恭喜加入合唱团joinChoir(chicken); // 恭喜加入合唱团 我们看到，对于加入合唱团的动物，大臣们根本无需检查它们的类型，而是只需要保证它们拥有 duckSinging 方法。如果下次期望加入合唱团的是一只小狗，而这只小狗刚好也会鸭子叫，我相信这只小狗也能顺利加入。 在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥有 slice 和 splice 等方法），这个对象就可以被当作数组来使用。 在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行向上转型。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类型检查系统的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。 “面向接口编程”是设计模式中最重要的思想，但在 JavaScript 语言中，“面向接口编程”的过程跟主流的静态类型语言不一样，因此，在 JavaScript 中实现设计模式的过程与在一些我们熟悉的语言中实现的过程会大相径庭。 二、 多肽“多态”一词源于希腊文 polymorphism，拆开来看是 poly（复数）+ morph（形态）+ ism，从字面上我们可以理解为复数形态。 多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 从字面上来理解多态不太容易，下面我们来举例说明一下。 主人家里养了两只动物，分别是一只鸭和一只鸡，当主人向它们发出“叫”的命令时，鸭会“嘎嘎嘎”地叫，而鸡会“咯咯咯”地叫。这两只动物都会以自己的方式来发出叫声。它们同样“都是动物，并且可以发出叫声”，但根据主人的指令，它们会各自发出不同的叫声。 其实，其中就蕴含了多态的思想。下面我们通过代码进行具体的介绍。 2.1 一段“多态”的JavaScript代码我们把上面的故事用 JavaScript 代码实现如下： 1234567891011var makeSound = function (animal) &#123; if (animal instanceof Duck) &#123; console.log('嘎嘎嘎'); &#125; else if (animal instanceof Chicken) &#123; console.log('咯咯咯'); &#125;&#125;;var Duck = function () &#123; &#125;;var Chicken = function () &#123; &#125;;makeSound(new Duck()); // 嘎嘎嘎makeSound(new Chicken()); // 咯咯咯 这段代码确实体现了“多态性”，当我们分别向鸭和鸡发出“叫唤”的消息时，它们根据此消息作出了各自不同的反应。但这样的“多态性”是无法令人满意的，如果后来又增加了一只动物，比如狗，显然狗的叫声是“汪汪汪”，此时我们必须得改动 makeSound 函数，才能让狗也发出叫声。修改代码总是危险的，修改的地方越多，程序出错的可能性就越大，而且当动物的种类越来越多时，makeSound 有可能变成一个巨大的函数。 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来是可生长的，也是符合开放—封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。 2.2 对象的多态性下面是改写后的代码，首先我们把不变的部分隔离出来，那就是所有的动物都会发出叫声： 123var makeSound = function( animal )&#123; animal.sound();&#125;; 然后把可变的部分各自封装起来，我们刚才谈到的多态性实际上指的是对象的多态性： 12345678910var Duck = function()&#123;&#125;Duck.prototype.sound = function()&#123; console.log( '嘎嘎嘎' );&#125;;var Chicken = function()&#123;&#125;Chicken.prototype.sound = function()&#123; console.log( '咯咯咯' );&#125;;makeSound( new Duck() ); // 嘎嘎嘎makeSound( new Chicken() ); // 咯咯咯 现在我们向鸭和鸡都发出“叫唤”的消息，它们接到消息后分别作出了不同的反应。如果有一天动物世界里又增加了一只狗，这时候只要简单地追加一些代码就可以了，而不用改动以前的makeSound 函数，如下所示： 12345var Dog = function()&#123;&#125;Dog.prototype.sound = function()&#123; console.log( '汪汪汪' );&#125;;makeSound( new Dog() ); // 汪汪汪 2.3 类型检查和多态类型检查是在表现出对象多态性之前的一个绕不开的话题，但 JavaScript 是一门不必进行类型检查的动态类型语言，为了真正了解多态的目的，我们需要转一个弯，从一门静态类型语言说起。 我们在前面已经说明过静态类型语言在编译时会进行类型匹配检查。以 Java 为例，由于在代码编译时要进行严格的类型检查，所以不能给变量赋予不同类型的值，这种类型检查有时候会让代码显得僵硬，代码如下： 123String str;str = \"abc\"; // 没有问题str = 2; // 报错 现在我们尝试把上面让鸭子和鸡叫唤的例子换成 Java 代码： 12345678910111213141516171819202122public class Duck &#123; // 鸭子类 public void makeSound()&#123; System.out.println( \"嘎嘎嘎\" ); &#125;&#125; public class Chicken &#123; // 鸡类 public void makeSound()&#123; System.out.println( \"咯咯咯\" ); &#125;&#125;public class AnimalSound &#123; public void makeSound( Duck duck )&#123; // (1) duck.makeSound(); &#125;&#125;public class Test &#123; public static void main( String args[] )&#123; AnimalSound animalSound = new AnimalSound(); Duck duck = new Duck(); animalSound.makeSound( duck ); // 输出：嘎嘎嘎 &#125;&#125; 我们已经顺利地让鸭子可以发出叫声，但如果现在想让鸡也叫唤起来，我们发现这是一件不可能实现的事情。因为(1)处 AnimalSound 类的 makeSound 方法，被我们规定为只能接受Duck 类型的参数： 1234567public class Test &#123; public static void main( String args[] )&#123; AnimalSound animalSound = new AnimalSound(); Chicken chicken = new Chicken(); animalSound.makeSound( chicken ); // 报错，只能接受 Duck 类型的参数 &#125;&#125; 某些时候，在享受静态语言类型检查带来的安全性的同时，我们亦会感觉被束缚住了手脚。 为了解决这一问题，静态类型的面向对象语言通常被设计为可以向上转型：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。这就像我们在描述天上的一只麻雀或者一只喜鹊时，通常说“一只麻雀在飞”或者“一只喜鹊在飞”。但如果想忽略它们的具体类型，那么也可以说“一只鸟在飞”。 同理，当 Duck 对象和 Chicken 对象的类型都被隐藏在超类型 Animal 身后，Duck 对象和 Chicken对象就能被交换使用，这是让对象表现出多态性的必经之路，而多态性的表现正是实现众多设计模式的目标。 2.4 使用继承得到多态效果使用继承来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括实现继承和接口继承。接下来我们先讨论实现继承。 我们先创建一个 Animal 抽象类，再分别让 Duck 和 Chicken 都继承自 Animal 抽象类，下述代码中(1)处和(2)处的赋值语句显然是成立的，因为鸭子和鸡也是动物： 123456789101112131415public abstract class Animal &#123; abstract void makeSound(); // 抽象方法&#125;public class Chicken extends Animal&#123; public void makeSound()&#123; System.out.println( \"咯咯咯\" ); &#125;&#125;public class Duck extends Animal&#123; public void makeSound()&#123; System.out.println( \"嘎嘎嘎\" ); &#125;&#125;Animal duck = new Duck(); // (1)Animal chicken = new Chicken(); // (2) 现在剩下的就是让 AnimalSound 类的 makeSound 方法接受 Animal 类型的参数，而不是具体的Duck 类型或者 Chicken 类型： 1234567891011121314public class AnimalSound&#123; public void makeSound( Animal animal )&#123; // 接受 Animal 类型的参数 animal.makeSound(); &#125;&#125;public class Test &#123; public static void main( String args[] )&#123; AnimalSound animalSound= new AnimalSound (); Animal duck = new Duck(); Animal chicken = new Chicken(); animalSound.makeSound( duck ); // 输出嘎嘎嘎 animalSound.makeSound( chicken ); // 输出咯咯咯 &#125;&#125; 2.5 JavaScript的多态从前面的讲解我们得知，多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系。如果类型之间的耦合关系没有被消除，那么我们在 makeSound 方法中指定了发出叫声的对象是某个类型，它就不可能再被替换为另外一个类型。在 Java 中，可以通过向上转型来实现多态。 而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript 对象的多态性是与生俱来的。 这种与生俱来的多态性并不难解释。JavaScript 作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。在前面的代码示例中，我们既可以往 makeSound 函数里传递 duck 对象当作参数，也可以传递 chicken 对象当作参数。 由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是否是某种类型的对象，这里不存在任何程度上的“类型耦合”。这正是我们从上一节的鸭子类型中领悟的道理。在 JavaScript 中，并不需要诸如向上转型之类的技术来取得多态的效果。 2.6 多态在面向对象程序设计中的作用有许多人认为，多态是面向对象编程语言中最重要的技术。但我们目前还很难看出这一点，毕竟大部分人都不关心鸡是怎么叫的，也不想知道鸭是怎么叫的。让鸡和鸭在同一个消息之下发出不同的叫声，这跟程序员有什么关系呢？ Martin Fowler 在《重构：改善既有代码的设计》里写到： 多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。 换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 Martin Fowler 的话可以用下面这个例子很好地诠释： 在电影的拍摄现场，当导演喊出“action”时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前，确认它们的职业分工（类型），然后告诉他们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。 利用对象的多态性，导演在发布消息时，就不必考虑各个对象接到消息后应该做什么。对象应该做什么并不是临时决定的，而是已经事先约定和排练完毕的。每个对象应该做什么，已经成为了该对象的一个方法，被安装在对象的内部，每个对象负责它们自己的行为。所以这些对象可以根据同一个消息，有条不紊地分别进行各自的工作。 将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。 再看一个现实开发中遇到的例子，这个例子的思想和动物叫声的故事非常相似。 假设我们要编写一个地图应用，现在有两家可选的地图 API 提供商供我们接入自己的应用。目前我们选择的是谷歌地图，谷歌地图的 API 中提供了 show 方法，负责在页面上展示整个地图。示例代码如下： 123456789var googleMap = &#123; show: function()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;;var renderMap = function()&#123; googleMap.show();&#125;;renderMap(); // 输出：开始渲染谷歌地图 后来因为某些原因，要把谷歌地图换成百度地图，为了让 renderMap 函数保持一定的弹性，我们用一些条件分支来让 renderMap 函数同时支持谷歌地图和百度地图： 12345678910111213141516171819var googleMap = &#123; show: function()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;;var baiduMap = &#123; show: function()&#123; console.log( '开始渲染百度地图' ); &#125;&#125;;var renderMap = function( type )&#123; if ( type === 'google' )&#123; googleMap.show(); &#125;else if ( type === 'baidu' )&#123; baiduMap.show(); &#125;&#125;;renderMap( 'google' ); // 输出：开始渲染谷歌地图renderMap( 'baidu' ); // 输出：开始渲染百度地图 可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成搜搜地图，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。 我们还是先把程序中相同的部分抽象出来，那就是显示某个地图： 1234567var renderMap = function( map )&#123; if ( map.show instanceof Function )&#123; map.show(); &#125;&#125;;renderMap( googleMap ); // 输出：开始渲染谷歌地图renderMap( baiduMap ); // 输出：开始渲染百度地图 现在来找找这段代码中的多态性。当我们向谷歌地图对象和百度地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。对象的多态性提示我们，“做什么”和“怎么去做”是可以分开的，即使以后增加了搜搜地图，renderMap 函数仍然不需要做任何改变，如下所示： 123456var sosoMap = &#123; show: function()&#123; console.log( '开始渲染搜搜地图' ); &#125;&#125;;renderMap( sosoMap ); // 输出：开始渲染搜搜地图 在这个例子中，我们假设每个地图 API 提供展示地图的方法名都是 show，在实际开发中也许不会如此顺利，这时候可以借助适配器模式来解决问题。 2.7 设计模式与多态GoF 所著的《设计模式》一书的副书名是“可复用面向对象软件的基础”。该书完全是从面向对象设计的角度出发的，通过对封装、继承、多态、组合等技术的反复使用，提炼出一些可重复使用的面向对象设计技巧。而多态在其中又是重中之重，绝大部分设计模式的实现都离不开多态性的思想。 拿命令模式①来说，请求被封装在一些命令对象中，这使得命令的调用者和命令的接收者可以完全解耦开来，当调用命令的 execute 方法时，不同的命令会做不同的事情，从而会产生不同的执行结果。而做这些事情的过程是早已被封装在命令对象内部的，作为调用命令的客户，根本不必去关心命令执行的具体过程。 在组合模式②中，多态性使得客户可以完全忽略组合对象和叶节点对象之前的区别，这正是组合模式最大的作用所在。对组合对象和叶节点对象发出同一个消息的时候，它们会各自做自己应该做的事情，组合对象把消息继续转发给下面的叶节点对象，叶节点对象则会对这些消息作出真实的反馈。 在策略模式③中，Context 并没有执行算法的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算”的消息时，它们会返回各自不同的计算结果。 在 JavaScript 这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在 JavaScript 中可以用高阶函数来代替实现的原因。 三、 封装封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。 3.1 封装数据在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private、public、protected 等关键字来提供不同的访问权限。 但 JavaScript 并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，而且只能模拟出 public 和 private 这两种封装性。 除了 ECMAScript 6 中提供的 let 之外，一般我们通过函数来创建作用域： 12345678910var myObject = (function () &#123; var __name = 'sven'; // 私有（private）变量 return &#123; getName: function () &#123; // 公开（public）方法 return __name; &#125; &#125;&#125;)(); console.log(myObject.getName()); // 输出：svenconsole.log(myObject.__name) // 输出：undefined 另外值得一提的是，在 ECAMScript 6 中，还可以通过 Symbol 创建私有属性。详情可参阅 https://github.com/lukehoban/es6features，二维码如下。 3.2 封装实现上一节描述的封装，指的是数据层面的封装。有时候我们喜欢把封装等同于封装数据，但这是一种比较狭义的定义。 封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是1隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。 从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。 封装实现细节的例子非常之多。拿迭代器来说明，迭代器的作用是在不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。我们编写了一个 each 函数，它的作用就是遍历一个聚合对象，使用这个 each 函数的人不用关心它的内部是怎样实现的，只要它提供的功能正确便可以。即使 each 函数修改了内部源代码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变。 3.3 封装类型封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的①。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。 当然在 JavaScript 中，并没有对抽象类和接口的支持。JavaScript 本身也是一门类型模糊的语言。在封装类型方面，JavaScript 没有能力，也没有必要做得更多。对于 JavaScript 的设计模式实现来说，不区分类型是一种失色，也可以说是一种解脱。在后面的学习中，我们可以慢慢了解这一点。 3.4 封装变化从设计模式的角度出发，封装在更重要的层面体现为封装变化。 《设计模式》一书曾提到如下文字：“考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念，这是许多设计模式的主题。” 这段文字即是《设计模式》提到的“找到变化并封装之”。《设计模式》一书中共归纳总结了 23种设计模式。从意图上区分，这 23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。 拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。 从《设计模式》副标题“可复用面向对象软件的基础”可以知道，这本书理应教我们如何编写可复用的面向对象程序。这本书把大多数笔墨都放在如何封装变化上面，这跟编写可复用的面向对象程序是不矛盾的。当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。 四、 原型模式和基于原型继承的 JavaScript 对象系统在 Brendan Eich 为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。之所以选择基于原型的面向对象系统，并不是因为时间匆忙，它设计起来相对简单，而是因为从一开始 Brendan Eich 就没有打算在 JavaScript 中加入类的概念。 在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。就像电影《第六日》一样，通过克隆可以创造另外一个一模一样的人，而且本体和克隆体看不出任何区别。 原型模式不单是一种设计模式，也被称为一种编程泛型。 本节我们将首先学习第一个设计模式——原型模式。随后会了解基于原型的 Io 语言，借助对 Io 语言的了解，我们对 JavaScript 的面向对象系统也将有更深的认识。在本节的最后，我们将详细了解 JavaScript 语言如何通过原型来构建一个面向对象系统。 4.1 使用克隆的原型模式从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。 既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一模一样的对象，就可以使用原型模式。 假设我们在编写一个飞机大战的网页游戏。某种飞机拥有分身技能，当它使用分身技能的时候，要在页面中创建一些跟它一模一样的飞机。如果不使用原型模式，那么在创建分身之前，无疑必须先保存该飞机的当前血量、炮弹等级、防御等级等信息，随后将这些信息设置到新创建的飞机上面，这样才能得到一架一模一样的新飞机。 如果使用原型模式，我们只需要调用负责克隆的方法，便能完成同样的功能。 原型模式的实现关键，是语言本身是否提供了clone方法。ECMAScript 5提供了Object.create方法，可以用来克隆对象。代码如下： 1234567891011121314151617var Plane = function()&#123; this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1;&#125;;var plane = new Plane();plane.blood = 500;plane.attackLevel = 10;plane.defenseLevel = 7;var clonePlane = Object.create( plane );console.log( clonePlane ); // 输出：Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125;//在不支持 Object.create 方法的浏览器中，则可以使用以下代码：Object.create = Object.create || function( obj )&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125; 4.2 克隆是创建对象的手段通过上一节的代码，我们看到了如何通过原型模式来克隆出一个一模一样的对象。但原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。 在用 Java 等静态类型语言编写程序的时候，类型之间的解耦非常重要。依赖倒置原则提醒我们创建对象的时候要避免依赖具体类型，而用 new XXX 创建对象的方式显得很僵硬。工厂方法模式和抽象工厂模式可以帮助我们解决这个问题，但这两个模式会带来许多跟产品类平行的工厂类层次，也会增加很多额外的代码。 原型模式提供了另外一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类型名字。这就像一个仙女要送给三岁小女孩生日礼物，虽然小女孩可能还不知道飞机或者船怎么说，但她可以指着商店橱柜里的飞机模型说“我要这个”。 当然在 JavaScript 这种类型模糊的语言中，创建对象非常容易，也不存在类型耦合的问题。从设计模式的角度来讲，原型模式的意义并不算大 。但 JavaScript 本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型也许更合适。 4.3 体验Io语言前面说过，原型模式不仅仅是一种设计模式，也是一种编程范型。JavaScript 就是使用原型模式来搭建整个面向对象系统的。在 JavaScript 语言中不存在类的概念，对象也并非从类中创建出来的，所有的 JavaScript 对象都是从某个对象上克隆而来的。 对于习惯了以类为中心语言的人来说，也许一时不容易理解这种基于原型的语言。即使是对于 JavaScript 语言的熟练使用者而言，也可能会有一种“不识庐山真面目，只缘身在此山中”的感觉。事实上，使用原型模式来构造面向对象系统的语言远非仅有 JavaScript 一家。 JavaScript 基于原型的面向对象系统参考了 Self 语言和 Smalltalk 语言，为了搞清 JavaScript中的原型，我们本该寻根溯源去瞧瞧这两门语言。但由于这两门语言距离现在实在太遥远，我们不妨转而了解一下另外一种轻巧又基于原型的语言——Io 语言。 Io 语言在 2002 年由 Steve Dekorte 发明。可以从http://iolanguage.com 下载到 Io 语言的解释器，安装好之后打开 Io 解释器，输入经典的“Hello World”程序。解释器打印出了 Hello World 的字符串，这说明我们已经可以使用 Io 语言来编写一些小程序了，如图 1-1 所示。 作为一门基于原型的语言，Io 中同样没有类的概念，每一个对象都是基于另外一个对象的克隆。 就像吸血鬼的故事里必然有一个吸血鬼祖先一样，既然每个对象都是由其他对象克隆而来的，那么我们猜测 Io 语言本身至少要提供一个根对象，其他对象都发源于这个根对象。这个猜测是正确的，在 Io 中，根对象名为 Object。 这一节我们依然拿动物世界的例子来讲解 Io 语言。在下面的代码中，通过克隆根对象 Object，就可以得到另外一个对象 Animal。虽然 Animal 是以大写开头的，但是记住 Io 中没有类，Animal跟所有的数据一样都是对象。 Animal := Object clone // 克隆动物对象 现在通过克隆根对象 Object 得到了一个新的 Animal 对象，所以 Object 就被称为 Animal 的原型。目前 Animal 对象和它的原型 Object 对象一模一样，还没有任何属于它自己的方法和能力。我们假设在 Io 的世界里，所有的动物都会发出叫声，那么现在就给 Animal 对象添加 makeSound 方法吧。代码如下： Animal makeSound := method( “animal makeSound “ print ); 好了，现在所有的动物都能够发出叫声了，那么再来继续创建一个 Dog 对象。显而易见，Animal对象可以作为 Dog 对象的原型，Dog 对象从 Animal 对象克隆而来： Dog := Animal clone 可以确定，Dog 一定懂得怎么吃食物，所以接下来给 Dog 对象添加 eat 方法： Dog eat := method( “dog eat “ print ); 现在已经完成了整个动物世界的构建，通过一次次克隆，Io 的对象世界里不再只有形单影只的根对象 Object，而是多了两个新的对象：Animal 对象和 Dog 对象。其中 Dog 的原型是Animal，Animal 对象的原型是 Object。最后我们来测试 Animal 对象和 Dog 对象的功能。 先尝试调用 Animal 的 makeSound 方法，可以看到，动物顺利发出了叫声： Animal makeSound // 输出：animal makeSound 然后再调用 Dog 的 eat 方法，同样我们也看到了预期的结果： Dog eat // 输出：dog eat 4.4 原型编程范型的一些规则从上一节的讲解中，我们看到了如何在 Io 语言中从无到有地创建一些对象。跟使用“类”的语言不一样的地方是，Io 语言中最初只有一个根对象 Object，其他所有的对象都克隆自另外一个对象。如果 A 对象是从 B 对象克隆而来的，那么 B 对象就是 A 对象的原型。 在上一小节的例子中，Object 是 Animal 的原型，而 Animal 是 Dog 的原型，它们之间形成了一条原型链。这个原型链是很有用处的，当我们尝试调用 Dog 对象的某个方法时，而它本身却没有这个方法，那么 Dog 对象会把这个请求委托给它的原型 Animal 对象，如果 Animal 对象也没有这个属性，那么请求会顺着原型链继续被委托给 Animal 对象的原型Object 对象，这样一来便能得到继承的效果，看起来就像 Animal 是 Dog 的“父类”，Object 是 Animal 的“父类”。 这个机制并不复杂，却非常强大，Io 和 JavaScript 一样，基于原型链的委托机制就是原型继承的本质。 我们来进行一些测试。在 Io 的解释器中执行 Dog makeSound 时，Dog 对象并没有 makeSound 方法，于是把请求委托给了它的原型 Animal 对象 ，而 Animal 对象是有makeSound 方法的，所以该条语句可以顺利得到输出，如图 1-2 所示。 现在我们明白了原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委托给它自己的原型。 最后整理一下本节的描述，我们可以发现原型编程范型至少包括以下基本规则。 所有的数据都是对象。要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。对象会记住它的原型。如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 4.5 JavaScript中的原型继承刚刚我们已经体验过同样是基于原型编程的 Io 语言，也已经了解了在 Io 语言中如何通过原型链来实现对象之间的继承关系。在原型继承方面，JavaScript 的实现原理和 Io 语言非常相似，JavaScript 也同样遵守这些原型编程的基本规则。 所有的数据都是对象。要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。对象会记住它的原型。如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 下面我们来分别讨论 JavaScript 是如何在这些规则的基础上来构建它的对象系统的。 4.5.1 所有的数据都是对象JavaScript 在设计的时候，模仿 Java 引入了两套类型机制：基本类型和对象类型。基本类型包括 undefined、number、boolean、string、function、object。从现在看来，这并不是一个好的想法。 按照 JavaScript 设计者的本意，除了 undefined 之外，一切都应是对象。为了实现这一目标，number、boolean、string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。 我们不能说在 JavaScript 中所有的数据都是对象，但可以说绝大部分数据都是对象。那么相信在 JavaScript 中也一定会有一个根对象存在，这些对象追根溯源都来源于这个根对象。 事实上，JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的原型。比如下面的 obj1 对象和 obj2 对象： 12var obj1 = new Object();var obj2 = &#123;&#125;; 可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型： 12console.log( Object.getPrototypeOf( obj1 ) === Object.prototype ); // 输出：trueconsole.log( Object.getPrototypeOf( obj2 ) === Object.prototype ); // 输出：true 4.5.2 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它在Io 语言中，克隆一个对象的动作非常明显，我们可以在代码中清晰地看到 clone 的过程。 比如以下代码： Dog := Animal clone 但在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。我们所需要做的只是显式地调用 var obj1 = new Object()或者 var obj2 = {}。此时，引擎内部会从Object.prototype 上面克隆一个对象出来，我们最终得到的就是这个对象。 再来看看如何用 new 运算符从构造器中得到一个对象，下面的代码我们再熟悉不过了： 12345678910function Person( name )&#123; this.name = name;&#125;;Person.prototype.getName = function()&#123; return this.name;&#125;;var a = new Person( 'sven' )console.log( a.name ); // 输出：svenconsole.log( a.getName() ); // 输出：svenconsole.log( Object.getPrototypeOf( a ) === Person.prototype ); // 输出：true 在 JavaScript 中没有类的概念，这句话我们已经重复过很多次了。但刚才不是明明调用了 newPerson()吗？ 在这里 Person 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。 在 Chrome 和 Firefox 等向外暴露了对象proto属性的浏览器下，我们可以通过下面这段代码来理解 new 运算的过程： 1234567891011121314151617function Person( name )&#123; this.name = name;&#125;;Person.prototype.getName = function()&#123; return this.name;&#125;;var objectFactory = function()&#123; var obj = new Object(), // 从 Object.prototype 上克隆一个空的对象 Constructor = [].shift.call( arguments ); // 取得外部传入的构造器，此例是 Person obj.__proto__ = Constructor.prototype; // 指向正确的原型 var ret = Constructor.apply( obj, arguments ); // 借用外部传入的构造器给 obj 设置属性 return typeof ret === 'object' ? ret : obj; // 确保构造器总是会返回一个对象&#125;;var a = objectFactory( Person, 'sven' );console.log( a.name ); // 输出：svenconsole.log( a.getName() ); // 输出：svenconsole.log( Object.getPrototypeOf( a ) === Person.prototype ); // 输出：true 我们看到，分别调用下面两句代码产生了一样的结果： 12var a = objectFactory( A, 'sven' );var a = new A( 'sven' ); 4.5.3 对象会记住它的原型如果请求可以在一个链条中依次往后传递，那么每个节点都必须知道它的下一个节点。同理，要完成 Io语言或者 JavaScript语言中的原型链查找机制，每个对象至少应该先记住它自己的原型。 目前我们一直在讨论“对象的原型”，就 JavaScript 的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型。那么对象如何把请求顺利地转交给它的构造器的原型呢？ JavaScript 给对象提供了一个名为proto的隐藏属性，某个对象的proto属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。在一些浏览器中，proto被公开出来，我们可以在 Chrome 或者 Firefox 上用这段代码来验证： 12var a = new Object();console.log ( a.__proto__=== Object.prototype ); // 输出：true 实际上，proto就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过proto属性来记住它的构造器的原型，所以我们用上一节的 objectFactory 函数来模拟用 new创建对象时， 需要手动给 obj 对象设置正确的proto指向。 1obj.__proto__ = Constructor.prototype; 通过这句代码，我们让 obj.proto 指向 Person.prototype，而不是原来的 Object.prototype。 4.5.4 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型这条规则即是原型继承的精髓所在。从对 Io 语言的学习中，我们已经了解到，当一个对象无法响应某个请求的时候，它会顺着原型链把请求传递下去，直到遇到一个可以处理该请求的对象为止。 JavaScript 的克隆跟 Io 语言还有点不一样，Io 中每个对象都可以作为原型被克隆，当 Animal对象克隆自 Object 对象，Dog 对象又克隆自 Animal 对象时，便形成了一条天然的原型链，如图1-3 所示。 而在 JavaScript 中，每个对象都是从 Object.prototype 对象克隆而来的，如果是这样的话，我们只能得到单一的继承关系，即每个对象都继承自 Object.prototype 对象，这样的对象系统显然是非常受限的。 实际上，虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的效果。下面的代码是我们最常用的原型继承方式： 12345var obj = &#123; name: 'sven' &#125;;var A = function()&#123;&#125;;A.prototype = obj;var a = new A();console.log( a.name ); // 输出：sven 我们来看看执行这段代码的时候，引擎做了哪些事情。 首先，尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.proto 记录着并且指向 A.prototype，而 A.prototype 被设置为对象 obj。在对象 obj 中找到了 name 属性，并返回它的值。 当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现： 123456var A = function()&#123;&#125;;A.prototype = &#123; name: 'sven' &#125;;var B = function()&#123;&#125;;B.prototype = new A();var b = new B();console.log( b.name ); // 输出：sven 再看这段代码执行的时候，引擎做了什么事情。 首先，尝试遍历对象 b 中的所有属性，但没有找到 name 这个属性。查找 name 属性的请求被委托给对象 b 的构造器的原型，它被 b.proto 记录着并且指向B.prototype，而 B.prototype 被设置为一个通过 new A()创建出来的对象。在该对象中依然没有找到 name 属性，于是请求被继续委托给这个对象构造器的原型A.prototype。在 A.prototype 中找到了 name 属性，并返回它的值。 和把 B.prototype 直接指向一个字面量对象相比，通过 B.prototype = new A()形成的原型链比之前多了一层。但二者之间没有本质上的区别，都是将对象构造器的原型指向另外一个对象，继承总是发生在对象和对象之间。 最后还要留意一点，原型链并不是无限长的。现在我们尝试访问对象 a 的 address 属性。而对象 b 和它构造器的原型上都没有 address 属性，那么这个请求会被最终传递到哪里呢？ 实际上，当请求达到 A.prototype，并且在 A.prototype 中也没有找到 address 属性的时候，请求会被传递给 A.prototype 的构造器原型 Object.prototype，显然Object.prototype 中也没有address 属性，但 Object.prototype 的原型是 null，说明这时候原型链的后面已经没有别的节点了。所以该次请求就到此打住，a.address 返回 undefined。 a.address // 输出：undefined 4.5.5 原型继承的未来设计模式在很多时候其实都体现了语言的不足之处。Peter Norvig 曾说，设计模式是对语言不足的补充，如果要使用设计模式，不如去找一门更好的语言。这句话非常正确。不过，作为Web 前端开发者，相信 JavaScript 在未来很长一段时间内都是唯一的选择。虽然我们没有办法换一门语言，但语言本身也在发展，说不定哪天某个模式在 JavaScript 中就已经是天然的存在，不再需要拐弯抹角来实现。比如 Object.create 就是原型模式的天然实现。使用 Object.create 来完成原型继承看起来更能体现原型模式的精髓。目前大多数主流浏览器都供了 Object.create 方法。 但美中不足是在当前的 JavaScript 引擎下，通过 Object.create 来创建对象的效率并不高，通常比通过构造函数创建对象要慢。此外还有一些值得注意的地方，比如通过设置构造器的prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个原型。而通过 Object.create( null )可以创建出没有原型的对象。 另外，ECMAScript 6 带来了新的 Class 语法。这让 JavaScript 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。通过 Class 创建对象的一段简单示例代码①如下所示 ： 123456789101112131415161718class Animal &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name); &#125; speak() &#123; return \"woof\"; &#125;&#125;var dog = new Dog(\"Scamp\");console.log(dog.getName() + ' says ' + dog.speak());","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法十二（算法复杂度）","date":"2019-04-12T01:53:40.000Z","path":"2019/04/12/cjw08yt6c000rkwvbpllj5hi9/","text":"一、 大 O 表示法大O表示法用于描述算法的性能和复杂程度 分析算法时，时常遇到以下几类函数： 符 号 名 称 O(1) 常数的 O(log(n)) 对数的 O((log(n))c) 对数多项式的 O(n) 线性的 O(n^2) 二次的 O(n^c) 多项式的 O(c^n) 指数的 1.1 理解大 O 表示法如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。 让我们试着用一些例子来理解大O表示法的规则。 1.1.1 O(1)考虑以下函数： 123function increment(num)&#123; return ++num;&#125; 假设运行increment(1)函数，执行时间等于X。如果再用不同的参数（例如2）运行一次increment函数，执行时间依然是X。和参数无关，increment函数的性能都一样。因此，我们说上述函数的复杂度是O(1)（常数）。 1.1.2 O(n)现在以前面实现的顺序搜索算法为例： 12345678function sequentialSearch(array, item)&#123; for (var i=0; i&lt;array.length; i++)&#123; if (item === array[i])&#123; //&#123;1&#125; return i; &#125; &#125; return -1;&#125; 如果将含10个元素的数组（[1, …, 10]）传递给该函数，假如搜索1这个元素，那么，第一次判断时就能找到想要搜索的元素。在这里我们假设每执行一次行{1} ，开销是 1。 现在，假如要搜索元素11。行{1}会执行10次（遍历数组中所有的值，并且找不到要搜索的元素，因而结果返回 -1）。如果行{1}的开销是1，那么它执行10次的开销就是10，10倍于第一种假设。 现在，假如该数组有1000个元素（[1, …, 1000]）。搜索1001的结果是行{1}执行了1000次（然后返回-1）。 注意，sequentialSearch函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，行{1}会执行几次呢？如果查找的是数组中不存在的值，那么行{1}就会执行和数组大小一样多次，这就是通常所说的最坏情况。 最坏情况下，如果数组大小是10，开销就是10；如果数组大小是1000，开销就是1000。可以得出sequentialSearch函数的时间复杂度是O(n)，n是（输入）数组的大小。 回到之前的例子，修改一下算法的实现，使之计算开销： 123456789101112function sequentialSearch(array, item) &#123; var cost = 0; for (var i = 0; i &lt; array.length; i++) &#123; cost++; if (item === array[i]) &#123; //&#123;1&#125; return i; &#125; &#125; console.log('cost for sequentialSearch with input size ' + array.length + ' is ' + cost); return -1;&#125; sequentialSearch([1,2,3,4,5,6,7,8,9], 19) // cost for sequentialSearch with input size 9 is 9 1.1.3 O(n^2)用冒泡排序做O(n^2)的例子： 123456789101112131415function swap(array, index1, index2) &#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;&#125;function bubbleSort(array) &#123; var length = array.length; for (var i = 0; i &lt; length; i++) &#123; //&#123;1&#125; for (var j = 0; j &lt; length - 1; j++) &#123; //&#123;2&#125; if (array[j] &gt; array[j + 1]) &#123; swap(array, j, j + 1); &#125; &#125; &#125;&#125; 假设行{1}和行{2}的开销分别是1。修改算法的实现使之计算开销： 1234567891011121314function bubbleSort(array) &#123; var length = array.length; var cost = 0; for (var i = 0; i &lt; length; i++) &#123; //&#123;1&#125; cost++; for (var j = 0; j &lt; length - 1; j++) &#123; //&#123;2&#125; cost++; if (array[j] &gt; array[j + 1]) &#123; swap(array, j, j + 1); &#125; &#125; &#125; console.log('cost for bubbleSort with input size ' + length + 'is ' + cost);&#125; 如果用大小为10的数组执行bubbleSort，开销是 100（102）。如果用大小为100的数组执行bubbleSort，开销就是 10 000（1002）。需要注意，我们每次增加输入的大小，执行都会越来越久。 时间复杂度O(n)的代码只有一层循环，而O(n2)的代码有双层嵌套循环。如果算法有三层遍历数组的嵌套循环，它的时间复杂度很可能就是O(n3)。 1.2 时间复杂度比较 下图比较了前述各个大O符号表示的时间复杂度： 这个图表是用JavaScript绘制的哦！在本书示例代码中，你可以到Chapter12下的bigOChart目录中找到绘制本图表的源代码。 在接下来的部分，你可以找到本书实现的所有算法的时间复杂度的速查表。 1.2.1 数据结构下表是常用数据结构的时间复杂度： 数据结构一般情况最差情况插入删除搜索插入删除搜索数组/栈/队列O(1)O(1)O(n)O(1)O(1)O(n)链表O(1)O(1)O(n)O(1)O(1)O(n)双向链表O(1)O(1)O(n)O(1)O(1)O(n)散列表O(1)O(1)O(1)O(n)O(n)O(n)二分搜索树O(log(n))O(log(n))O(log(n))O(n)O(n)O(n)AVL树O(log(n))O(log(n))O(log(n))O(log(n))O(log(n))O(log(n)) 1.2.2 图下表是图的时间复杂度： 节点/边的管理方式存储空间增加顶点增加边删除顶点删除边轮 询邻接表O(|V|+|E|) O(1) O(1)O(|V|+|E|)O(|E|)O(|V|)邻接矩阵O(|V|^2)O(|V|^2)O(1)O(|V|^2O(1)O(1) 1.2.3 排序算法下表是排序算法的时间复杂度： 数据结构时间复杂度最好情况一般情况 最差情况冒泡排序O(n)O(n^2)O(n^2)选择排序O(n^2)O(n^2)O(n^2)插入排序O(n)O(n^2)O(n^2)归并排序O(nlog(n))O(nlog(n))O(nlog(n))快速排序O(nlog(n))O(log(n)) O(n^2)堆排序O(nlog(n))O(nlog(n))O(nlog(n))桶排序O(n+k)O(n+k)O(n^2)基数排序O(nk)O(nk)O(nk) 1.2.4 搜索算法下表是搜索算法的时间复杂度： 算 法数据结构最差情况顺序搜索数组O(n)二分搜索已排序的数组O(log(n))深度优先搜索（DPS）顶点数为|V|，边数为|E|的图O(|V|+|E|)广度优先搜索（BFS）顶点数为|V|，边数为|E|的图 O(|V|+|E|) 1.3 NP 完全理论概述一般来说，如果一个算法的复杂度为O(nk)，其中k是常数，我们就认为这个算法是高效的，这就是多项式算法。 对于给定的问题，如果存在多项式算法，则计为P（polynomial，多项式）。 还有一类NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为NP。 如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的P都是NP。然而，P = NP是否成立，仍然不得而知。 NP问题中最难的是NP完全问题，它满足以下两个条件： (1) 是NP问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；(2) 所有的NP问题都能在多项式时间内归约为它。 为了理解问题的归约，考虑两个决策问题L和M。假设算法A可以解决问题L，算法B可以验证输入y是否为M的解。目标是找到一个把L转化为M的方法，使得算法B可以用于构造算法A。 还有一类问题，只需满足NP完全问题的第二个条件，称为NP困难问题。因此，NP完全问题也是NP困难问题的子集。 P = NP是否成立，是计算机科学中最重要的难题之一。如果能找到答案，对密码学、算法研究、人工智能等诸多领域都会产生重大影响。 下面是满足P &lt; &gt; NP时，P、NP、NP完全和NP困难问题的欧拉图： 非NP完全的NP困难问题的例子有停机问题和布尔可满足性问题（SAT） NP完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。 不可解问题与启发式算法 我们提到的有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。 启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。详情请查阅http://goo.gl/gxIu9w。 二、 用算法娱乐身心我们学习算法并不单单是因为它是大学必修课，也不单单是因为我们想成为开发者。通过用在本书中学到的算法来解决问题，我们可以提高解决问题的能力，进而成为更棒的专业人士。 增长（解题）知识的最好方式是练习，而练习不一定是枯燥的。本节将展示一些网站，你可以访问它们并尝试从算法中获到快乐（甚至小赚一笔）。 这里列出一些有用的网站（有些不支持用JavaScript提交解答，但是我们依然可以将从本书中所学到的逻辑应用到其他语言上）。 UVa Online Judge（http://uva.onlinejudge.org/）：这个网站包含了世界各大赛事的题目，包括 由IBM赞助的ACM国际大学生程序竞赛（ICPC。若你依然在校，应尽量参与这项赛事，如果团队获胜，则有可能免费享受一次国际旅行）。这个网站包括了成百上千的题目，可以应用本书所学的算法。Sphere Online Judge（http://www.spoj.com/）： 这个网站和UVa Online Judge差不多，但支持用更多语言解题（包括JavaScript）。Coder Byte（http://coderbyte.com/）：这个网站包含了74个可以用JavaScript解答的题目（简单、中等难度和非常困难）。Project Euler（https://projecteuler.net/）：这个网站包含了一系列数学/计算机的编程题目。你所要做的就是输入那些题目的答案，不过我们可以用算法来找到正确的解答。Hacker Rank（https://www.hackerrank.com）：这个网站包含了263个挑战，分为16个类别（可以应用本书中的算法和更多其他算法）。它也支持JavaScript和其他语言。Code Chef（http://www.codechef.com/）：这个网站包含一些题目，并会举办在线比赛。Top Coder（http://www.topcoder.com/）：此网站会举办算法联赛，这些联赛通常由NASA、Google、Yahoo!、Amazon和Facebook这样的公司赞助。参加其中一些赛事，你可以获得到赞助公司工作的机会，而参与另一些赛事会赢得奖金。这个网站也提供很棒的解题和算法教程。 以上网站的另一个好处是，它们通常给出的是真实世界中的问题，而我们需要鉴别用哪一个算法解决它。通过这样的方式也能让我们明白本书中的算法并非局限于学术，而是能应用到现实问题上。 如果你想从事技术工作，强烈推荐你创建一个免费的GitHub（https://github.com） 账号，你可以将上述网站的解答代码提交上去。如果你没有任何专业经验，GitHub可以帮助你建立一个作品集，还会对你找到第一份工作有帮助！ 三、延 展 阅 读","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法十一（算法模式）","date":"2019-03-30T07:49:40.000Z","path":"2019/03/30/cjw08ytay001lkwvbhujupyqc/","text":"一、递归递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。 递归函数是像下面这样能够直接调用自身的方法或函数： 123function recursiveFunction(someParam)&#123; recursiveFunction(someParam);&#125;; 能够像下面这样间接调用自身的函数，也是递归函数： 123456function recursiveFunction1(someParam)&#123; recursiveFunction2(someParam);&#125;;function recursiveFunction2(someParam)&#123; recursiveFunction1(someParam);&#125;; 假设现在必须要执行recursiveFunction，结果是什么？单单就上述情况而言，它会一直执行下去。因此，每个递归函数都必须要有边界条件，即一个不再递归调用的条件（停止点），以防止无限递归。 1.1 JavaScript 调用栈大小的限制如果忘记加上用以停止函数递归调用的边界条件，会发生什么呢？递归并不会无限地执行下去；浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）。 每个浏览器都有自己的上限，可用以下代码测试： 12345678910var i = 0;function recursiveFn () &#123; i++; recursiveFn(); //&#123;1&#125;&#125;try &#123; recursiveFn();&#125; catch (ex) &#123; alert('i = ' + i + ' error: ' + ex);&#125; 在Chrome v37中，这个函数执行了20 955次，而后浏览器抛出错误RangeError: Maximumcall stack size exceeded（超限错误：超过最大调用栈大小）。在Firefox v27中，函数执行了343 429次，然后浏览器抛出错误 InternalError: too much recursion（内部错误：递归次数过多）。 ECMAScript 6有尾调用优化（tail call optimization）。如果函数内最后一个操作是调用函数（就像示例中{1}的那行），会通过“跳转指令”（jump） 而不是“子程序调用”（subroutine call）来控制。也就是说，在ECMAScript 6中，这里的代码可以一直执行下去。所以，具有停止递归的边界条件非常重要。 1.2 斐波那契数列斐波那契数列的定义如下： 1和2的斐波那契数是 1；n（n&gt;2）的斐波那契数是(n-1)的斐波那契数加上(n-2)的斐波那契数。 那么，让我们开始实现斐波那契函数： 12345function fibonacci(num)&#123; if (num === 1 || num === 2)&#123; //&#123;1&#125; return 1; &#125;&#125; 边界条件是已知的，1和2的斐波那契数（行{1}）是1。现在，让我们完成斐波那契函数的实现： 123456function fibonacci(num)&#123; if (num === 1 || num === 2)&#123; return 1; &#125; return fibonacci(num - 1) + fibonacci(num - 2);&#125; 我们已经知道，当n大于2时，Fibonacci(n)等于Fibonacci(n-1)+Fibonacci(n-2)。 现在，斐波那契函数实现完毕。让我们试着找出6的斐波那契数，其会产生如下函数调用 我们也可以用非递归的方式实现斐波那契函数： 1234567891011function fib(num)&#123; var n1 = 1, n2 = 1, n = 1; for (var i = 3; i&lt;=num; i++)&#123; n = n1 + n2; n1 = n2; n2 = n; &#125; return n;&#125; 为何用递归呢？更快吗？递归并不比普通版本更快，反倒更慢。但要知道，递归更容易理解，并且它所需的代码量更少。 在ECMAScript 6中，因为尾调用优化的缘故，递归并不会更慢。但是在其他语言中，递归通常更慢。 所以，我们用递归，通常是因为它更容易解决问题。 二、动态规划动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。 之前提到过几次动态规划技术。用动态规划解决的一个问题就是深度优先搜索。 要注意动态规划和分而治之（归并排序和快速排序算法中用到的那种）是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。 另一个例子是上一节解决的斐波那契问题。我们将斐波那契问题分解成如该节图示的小问题。 用动态规划解决问题时，要遵循三个重要步骤： (1) 定义子问题；(2) 实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；(3) 识别并求解出边界条件。 能用动态规划解决的一些著名的问题如下。 背包问题：给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。硬币找零：给出面额为d1…dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。图的全源最短路径：对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。我们在前面已经学习过这个问题的Floyd-Warshall算法。 2.1 最少硬币找零问题最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找到所需的最少的硬币个数。 例如，美国有以下面额（硬币）：d1=1，d2=5，d3=10，d4=25。 如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（1美分）。 如何将这个解答转化成算法？ 最少硬币找零的解决方案是找到n所需的最小硬币数。但要做到这一点，首先得找到对每个x&lt;n的解。然后，我们将解建立在更小的值的解的基础上。 来看看算法： 123456789101112131415161718192021222324252627282930function MinCoinChange(coins) &#123; var coins = coins; //&#123;1&#125; var cache = &#123;&#125;; //&#123;2&#125; this.makeChange = function (amount) &#123; var me = this; if (!amount) &#123; //&#123;3&#125; return []; &#125; if (cache[amount]) &#123; //&#123;4&#125; return cache[amount]; &#125; var min = [], newMin, newAmount; for (var i = 0; i &lt; coins.length; i++) &#123; //&#123;5&#125; var coin = coins[i]; newAmount = amount - coin; //&#123;6&#125; if (newAmount &gt;= 0) &#123; newMin = me.makeChange(newAmount); //&#123;7&#125; &#125; if ( newAmount &gt;= 0 &amp;&amp; //&#123;8&#125; (newMin.length &lt; min.length - 1 || !min.length)//&#123;9&#125; &amp;&amp; (newMin.length || !newAmount)) //&#123;10&#125;) &#123; min = [coin].concat(newMin); //&#123;11&#125; console.log('new Min ' + min + ' for ' + amount); &#125; &#125; return (cache[amount] = min); //&#123;12&#125; &#125;;&#125; 为了更有条理，我们创建了一个类，解决给定面额的最少硬币找零问题。让我们一步步解读这个算法。 MinCoinChange类接收coins参数（行{1}），该参数代表问题中的面额。对美国的硬币系统而言，它是[1, 5, 10, 25]。我们可以随心所欲传递任何面额。此外，为了更加高效且不重复计算值，我们使用了cache（行{2}）。 接下来是makeChange方法，它也是一个递归函数，找零问题由它解决。首先，若amount不为正（&lt; 0），就返回空数组（行{3}）；方法执行结束后，会返回一个数组，包含用来找零的各个面额的硬币数量（最少硬币数）。接着，检查cache缓存。若结果已缓存（行{4}），则直接返回结果；否则，执行算法。 我们基于coins参数（面额）解决问题。因此，对每个面额（行{5}），我们都计算newAmount（行{6}）的值，它的值会一直减小，直到能找零的最小钱数（别忘了本算法对所有的x &lt; amount都会计算makeChange结果）。若newAmount是合理的值（正值），我们也会计算它的找零结果（行{7}）。 最后，我们判断newAmount是否有效，minValue（最少硬币数）是否是最优解，与此同时minValue和newAmount是否是合理的值（{行10}）。若以上判断都成立，意味着有一个比之前更优的答案（行{11}。以5美分为例，可以给5便士或者1个5美分镍币，1个5美分镍币是最优解）。最后，返回最终结果（行{12}）。 测试一下这个算法： 12var minCoinChange = new MinCoinChange([1, 5, 10, 25]);console.log(minCoinChange.makeChange(36)); 要知道，如果我们检查cache变量，会发现它存储了从1到36美分的所有结果。以上代码的结果是[1, 10, 25]。 本节的源码中会有几行多余的代码，输出算法的步骤。例如，使用面额[1, 3, 4]，并对钱数6执行算法，会产生以下输出： 12345678910new Min 1 for 1new Min 1,1 for 2new Min 1,1,1 for 3new Min 3 for 3new Min 1,3 for 4new Min 4 for 4 new Min 1,4 for 5new Min 1,1,4 for 6new Min 3,3 for 6[3, 3] 所以，找零钱数为6时，最佳答案是两枚价值为3的硬币。 2.2 背包问题背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重W的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大。 下面是一个例子： 物 品# 重 量 价 值 1 2 3 2 3 4 3 4 5 考虑背包能够携带的重量只有5。对于这个例子，我们可以说最佳解决方案是往背包里装入物品1和物品2，这样，总重量为5，总价值为7。 这个问题有两个版本。0-1版本只能往背包里装完整的物品，而分数背包问题则允许装入分数物品。在这个例子里，我们将处理该问题的0-1版本。动态规划对分数版本无能为力，但稍后要学习的贪心算法可以解决它。 我们来看看下面这个背包算法： 1234567891011121314151617181920function knapSack(capacity, weights, values, n) &#123; var i, w, a, b, kS = []; for (i = 0; i &lt;= n; i++) &#123; //&#123;1&#125; kS[i] = []; &#125; for (i = 0; i &lt;= n; i++) &#123; for (w = 0; w &lt;= capacity; w++) &#123; if (i == 0 || w == 0) &#123; //&#123;2&#125; kS[i][w] = 0; &#125; else if (weights[i - 1] &lt;= w) &#123; //&#123;3&#125; a = values[i - 1] + kS[i - 1][w - weights[i - 1]]; b = kS[i - 1][w]; kS[i][w] = (a &gt; b) ? a : b; //&#123;4&#125; max(a,b) &#125; else &#123; kS[i][w] = kS[i - 1][w]; //&#123;5&#125; &#125; &#125; &#125; return kS[n][capacity]; //&#123;6&#125;&#125; 我们来看看这个算法是如何工作的。 行{1}：首先，初始化将用于寻找解决方案的矩阵ks[n+1][capacity+1]。 行{2}：忽略矩阵的第一列和第一行，只处理索引不为0的列和行。 行{3}：物品i的重量必须小于约束（capacity）才有可能成为解决方案的一部分；否则，总重量就会超出背包能够携带的重量，这是不可能发生的。发生这种情况时，只要忽略它，用之前的值就可以了（行{5}）。 行{4}：当找到可以构成解决方案的物品时，选择价值最大的那个。 行{6}：最后，问题的解决方案就在这个二维表格右下角的最后一个格子里。 我们可以用开头的例子来测试这个算法： 下图举例说明了例子中kS矩阵的构造： 请注意，这个算法只输出背包携带物品价值的最大值，而不列出实际的物品。我们可以增加下面的附加函数来找出构成解决方案的物品： 12345678910111213function findValues(n, capacity, kS, weights, values) &#123; var i = n, k = capacity; console.log('解决方案包含以下物品：'); while (i &gt; 0 &amp;&amp; k &gt; 0) &#123; if (kS[i][k] !== kS[i - 1][k]) &#123; console.log('物品' + i + '，重量：' + weights[i - 1] + '，价值：' + values[i - 1]); i--; k = k - kS[i][k]; &#125; else &#123; i--; &#125; &#125;&#125; 我们可以在knapsack函数的行{6}之前调用这个函数。执行完整的算法，会得到如下输出： 1234解决方案包含以下物品：88 物品2，重量：3，价值：488 物品1，重量：2，价值：37 2.3 最长公共子序列另一个经常被当作编程挑战问题的动态规划问题是最长公共子序列（LCS）：找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。 考虑如下例子： 再看看下面这个算法： 12345678910111213141516171819202122232425262728293031function lcs(wordX, wordY) &#123; var m = wordX.length, n = wordY.length, l = [], i, j, a, b; for (i = 0; i &lt;= m; ++i) &#123; l[i] = []; //&#123;1&#125; for (j = 0; j &lt;= n; ++j) &#123; l[i][j] = 0; //&#123;2&#125; &#125; &#125; for (i = 0; i &lt;= m; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) &#123; l[i][j] = 0; &#125; else if (wordX[i - 1] == wordY[j - 1]) &#123; l[i][j] = l[i - 1][j - 1] + 1; //&#123;3&#125; &#125; else &#123; a = l[i - 1][j]; b = l[i][j - 1]; l[i][j] = (a &gt; b) ? a : b; //max(a, b) //&#123;4&#125; &#125; &#125; &#125; //&#123;5&#125; return l[m][n];&#125; 比较背包问题和LCS算法，我们会发现两者非常相似。这项从顶部开始构建解决方案的技术被称为记忆，而解决方案就在表格或矩阵的右下角。 像背包问题算法一样，这种方法只输出LCS的长度，而不包含LCS的实际结果。要提取这个信息，需要对算法稍作修改，声明一个新的solution矩阵。如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function lcs(wordX, wordY) &#123; var m = wordX.length, n = wordY.length, l = [], i, j, a, b; for (i = 0; i &lt;= m; ++i) &#123; l[i] = []; solution[i] = [];//&#123;1&#125; for (j = 0; j &lt;= n; ++j) &#123; l[i][j] = 0; solution[i][j] = '0';//&#123;2&#125; &#125; &#125; for (i = 0; i &lt;= m; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; if (i == 0 || j == 0) &#123; l[i][j] = 0; &#125; else if (wordX[i - 1] == wordY[j - 1]) &#123; l[i][j] = l[i - 1][j - 1] + 1; solution[i][j] = 'diagonal';//&#123;3&#125; &#125; else &#123; a = l[i - 1][j]; b = l[i][j - 1]; l[i][j] = (a &gt; b) ? a : b; //max(a, b) solution[i][j]=(l[i][j] == l[i-1][j]) ? 'top' : 'left';//&#123;4&#125; &#125; &#125; &#125; printSolution(solution, l, wordX, wordY, m, n);//&#123;5&#125; return l[m][n];&#125; //printSolution函数如下：function printSolution(solution, l, wordX, wordY, m, n) &#123; var a = m, b = n, i, j, x = solution[a][b], answer = ''; while (x !== '0') &#123; if (solution[a][b] === 'diagonal') &#123; answer = wordX[a - 1] + answer; a--; b--; &#125; else if (solution[a][b] === 'left') &#123; b--; &#125; else if (solution[a][b] === 'top') &#123; a--; &#125; x = solution[a][b]; &#125; console.log('lcs: ' + answer);&#125; 当解矩阵的方向为对角线时，我们可以将字符添加到答案中。 如果用’acbaed’和’abcadf’两个字符串执行上面的算法，我们将得到输出4。用于构建结果的矩阵l看起来像下面这样。我们也可以用附加的算法来跟踪LCS的值（如下图高亮所示）。 通过上面的矩阵，我们知道LCS算法的结果是长度为4的acad。 2.4 矩阵链相乘矩阵链相乘是另一个可以用动态规划解决的著名问题。这个问题是要找出一组矩阵相乘的最佳方式（顺序）。 让我们试着更好地理解这个问题。n行m列的矩阵A和m行p列的矩阵B相乘，结果是n行p列的矩阵C。 考虑我们想做ABC*D的乘法。因为乘法满足结合律，所以我们可以让这些矩阵以任意顺序相乘。因此，考虑如下情况： A是一个10行100列的矩阵B是一个100行5列的矩阵C是一个5行50列的矩阵D是一个50行1列的矩阵 ABC*D的结果是一个10行1列的矩阵 在这个例子里，相乘的方式有五种。 (1) (A(B(CD)))：乘法运算的次数是1750次。(2) ((AB)(CD))：乘法运算的次数是5300次。(3) (((AB)C)D)：乘法运算的次数是8000次。(4) ((A(BC))D)：乘法运算的次数是75 500次。(5) (A((BC)D))：乘法运算的次数是31 000次。 相乘的顺序不一样，要进行的乘法运算总数也有很大差异。那么，要如何构建一个算法，求出最少的乘法运算操作次数？矩阵链相乘的算法如下： 12345678910111213141516171819202122function matrixChainOrder(p, n) &#123; var i, j, k, l, q, m = []; for (i = 1; i &lt;= n; i++) &#123; m[i] = []; m[i][i] = 0; &#125; for (l = 2; l &lt; n; l++) &#123; for (i = 1; i &lt;= n - l + 1; i++) &#123; j = i + l - 1; m[i][j] = Number.MAX_SAFE_INTEGER; for (k = i; k &lt;= j - 1; k++) &#123; q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; //&#123;1&#125; if (q &lt; m[i][j]) &#123; m[i][j] = q; //&#123;2&#125; &#125; &#125; &#125; &#125; //&#123;3&#125; return m[1][n - 1];&#125; 整个算法中最重要的是行{1}，神奇之处全都在这一行。它计算了给定括号顺序的乘法运算次数，并将值保存在辅助矩阵m中。 对开头的例子执行上面的算法，会得到结果7500；正如我们前面提到的，这是最少的操作次数。看看这个： 123var p = [10, 100, 5, 50, 1],n = p.length;console.log(matrixChainOrder(p, n)); //1750 然而，这个算法也不会给出最优解的括号顺序。为了得到这些信息，我们可以对代码做一些改动。 123456789101112131415161718192021222324252627282930313233343536373839404142function matrixChainOrder(p, n) &#123; var i, j, k, l, q, m = []; var s = []; for (i = 0; i &lt;= n; i++) &#123; s[i] = []; for (j = 0; j &lt;= n; j++) &#123; s[i][j] = 0; &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; m[i] = []; m[i][i] = 0; &#125; for (l = 2; l &lt; n; l++) &#123; for (i = 1; i &lt;= n - l + 1; i++) &#123; j = i + l - 1; m[i][j] = Number.MAX_SAFE_INTEGER; for (k = i; k &lt;= j - 1; k++) &#123; q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; //&#123;1&#125; if (q &lt; m[i][j]) &#123; m[i][j] = q; s[i][j] = k; //&#123;2&#125; &#125; &#125; &#125; &#125; printOptimalParenthesis(s, 1, n - 1); //&#123;3&#125; return m[1][n - 1];&#125; function printOptimalParenthesis(s, i, j) &#123; if (i == j) &#123; console.log(\"A[\" + i + \"]\"); &#125; else &#123; console.log(\"(\"); printOptimalParenthesis(s, i, s[i][j]); printOptimalParenthesis(s, s[i][j] + 1, j); console.log(\")\"); &#125;&#125; var p = [10, 100, 5, 50, 1],n = p.length;console.log(matrixChainOrder(p, n)); 执行修改后的算法，也能得到括号的最佳顺序(A1))，并可以转化为(A(B(CD)))。 三、 贪心算法贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。 我们来看看如何用贪心算法解决前面的最少硬币找零问题和背包问题。（我们已经介绍了一些其他的贪心算法，比如Dijkstra算法、Prim算法和Kruskal算法。） 3.1 最少硬币找零问题最少硬币找零问题也能用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。 来看看算法： 123456789101112131415function MinCoinChange(coins) &#123; var coins = coins; //&#123;1&#125; this.makeChange = function (amount) &#123; var change = [], total = 0; for (var i = coins.length; i &gt;= 0; i--) &#123; //&#123;2&#125; var coin = coins[i]; while (total + coin &lt;= amount) &#123; //&#123;3&#125; change.push(coin); //&#123;4&#125; total += coin; //&#123;5&#125; &#125; &#125; return change; &#125;;&#125; 不得不说贪心版本的MinCoinChange比动态规划版本的简单多了。和动态规划方法相似，我们传递面额参数，实例化MinCoinChange（行{1}）。 对每个面额（行{2}——从大到小），把它的值和total相加后，total需要小于amount（行{3}）。我们会将当前面额coin添加到结果中（行{4}），也会将它和total相加（行{5}）。 如你所见，这个解法很简单。从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。 用和DP方法同样的测试代码测试： 12var minCoinChange = new MinCoinChange([1, 5, 10, 25]);console.log(minCoinChange.makeChange(36)); 结果依然是[25, 10, 1]，和用DP得到的一样。下图阐释了算法的执行过程： 然而，如果用[1, 3, 4]面额执行贪心算法，会得到结果[4, 1, 1]。如果用动态规划的解法，会得到最优的结果[3, 3]。 比起动态规划算法而言，贪心算法更简单、更快。然而，如我们所见，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。 3.2 分数背包问题求解分数背包问题的算法与动态规划版本稍有不同。在0-1背包问题中，只能向背包里装入完整的物品，而在分数背包问题中，我们可以装入分数的物品。我们用前面用过的例子来比较两者的差异，如下所示： 物 品# 重 量 价 值 1 2 3 2 3 4 3 4 5 在动态规划的例子里，我们考虑背包能够携带的重量只有5。而在这个例子里，我们可以说最佳解决方案是往背包里装入物品1和物品2，总重量为5，总价值为7。 如果在分数背包问题中考虑相同的容量，得到的结果是一样的。因此，我们考虑容量为6的情况。 在这种情况下，解决方案是装入物品1和物品2，还有25%的物品3。这样，重量为6的物品总价值为8.25。 我们来看看下面这个算法： 123456789101112131415function knapSack(capacity, values, weights) &#123; var n = values.length, load = 0, i = 0, val = 0; for (i = 0; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123; //&#123;1&#125; if (weights[i] &lt;= (capacity - load)) &#123; //&#123;2&#125; val += values[i]; load += weights[i]; &#125; else &#123; var r = (capacity - load) / weights[i]; //&#123;3&#125; val += r * values[i]; load += weights[i]; &#125; &#125; return val;&#125; 下面是对算法的解释。 行{1}：总重量少于背包容量，继续迭代，装入物品。行{2}：如果物品可以完整地装入背包，就将其价值和重量分别计入背包已装入物品的总价值（val）和总重量（load）。行{3}：如果物品不能完整地装入背包，计算能够装入部分的比例（r）。 如果在0-1背包问题中考虑同样的容量6，我们就会看到，物品1和物品3组成了解决方案。在这种情况下，对同一个问题应用不同的解决方法，会得到两种不同的结果。 测试以上代码： 12345var values = [3, 4, 5], weights = [2, 3, 4], capacity = 5, n = values.length;console.log(knapSack(capacity, values, weights)) //7 四、 函数式编程简介到目前为止，我们在本书中所用的编程范式都是命令式编程。在命令式编程中，我们按部就班地编写程序代码，详细描述要完成的事情以及完成的顺序。 在本节中，我们会介绍一种新的范式，叫作函数式编程。函数式编程是一种曾经主要用于学术领域的范式，多亏了Python和Ruby等现代语言，它才开始在行业开发者中流行起来。值得欣慰的是，借助ES6的能力，JavaScript也能够进行函数式编程。 4.1 函数式编程与命令式编程以函数式范式进行开发并不简单；关键在于习惯这种范式的机制。我们编写一个例子来说明差异。 假设我们想打印一个数组中所有的元素。我们可以用命令式编程，声明的函数如下： 123456var printArray = function (array) &#123; for (var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]); &#125;&#125;;printArray([1, 2, 3, 4, 5]); 在上面的代码中，我们迭代数组，打印每一项。 现在，我们试着把这个例子转换成函数式编程。在函数式编程中，函数就是摇滚明星。我们关注的重点是需要描述什么，而不是如何描述。回到这一句：“我们迭代数组，打印每一项”。那么，我们首先要关注的是迭代数据，然后进行操作，即打印数组项。下面的函数负责迭代数组： 12345var forEach = function (array, action) &#123; for (var i = 0; i &lt; array.length; i++) &#123; action(array[i]); &#125;&#125;; 接下来，我们要创建另一个负责把数组元素打印到控制台的函数（考虑为回调函数），如下： 123var logItem = function (item) &#123; console.log(item);&#125;; 最后，像下面这样使用声明的函数： 1forEach([1, 2, 3, 4, 5], logItem); 只需要上面这一行代码，我们就能描述我们要把数组的每一项打印到控制台。这是我们的第一个函数式编程的例子！ 有几点要注意： 主要目标是描述数据，以及要对数据应用的转换；程序执行顺序的重要性很低，而在命令式编程中，步骤和顺序是非常重要的；函数和数据集合是函数式编程的核心；在函数式编程中，我们可以使用和滥用函数和递归，而在命令式编程中，则使用循环、赋值、条件和函数。 4.2 ES2015 和函数式编程有了ES2015的新功能，用JavaScript进行函数式编程变得更加容易了。我们来看一个例子。 考虑我们要找出数组中最小的值。要用命令式编程完成这个任务，只要迭代数组，检查当前的最小值是否大于数组元素；如果是，就更新最小值，代码如下： 12345678910var findMinArray = function (array) &#123; var minValue = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; if (minValue &gt; array[i]) &#123; minValue = array[i]; &#125; &#125; return minValue;&#125;;console.log(findMinArray([8, 6, 4, 5, 9])); //输出4 用函数式编程完成相同的任务，可以使用Math.min函数，传入所有要比较的数组元素。我们可以像下面的例子里这样，使用ES2015的解构操作符（…），把数组转换成单个的元素： 1234const min_ = function (array) &#123; return Math.min(...array)&#125;;console.log(min_([8, 6, 4, 5, 9])); //输出4 使用ES2015的箭头函数，我们可以进一步简化上面的代码： 12const min = arr =&gt; Math.min(...arr);console.log(min([8, 6, 4, 5, 9])); 4.3 JavaScript 函数式工具箱—— map、filter 和 reducemap、filter和reduce函数是函数式编程的基础。 我们可以使用map函数，把一个数据集合转换或映射成另一个数据集合。先看一个命令式编程的例子： 123456789var daysOfWeek = [ &#123;name: 'Monday', value: 1&#125;, &#123;name: 'Tuesday', value: 2&#125;, &#123;name: 'Wednesday', value: 7&#125;];var daysOfWeekValues_ = [];for (var i = 0; i &lt; daysOfWeek.length; i++) &#123; daysOfWeekValues_.push(daysOfWeek[i].value);&#125; 再以函数式编程来考虑同样的例子，代码如下： 1234var daysOfWeekValues = daysOfWeek.map(function(day) &#123; return day.value;&#125;);console.log(daysOfWeekValues); 我们可以使用filter函数过滤一个集合的值。来看一个例子： 12345678910var positiveNumbers_ = function (array) &#123; var positive = []; for (var i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt;= 0) &#123; positive.push(array[i]); &#125; &#125; return positive;&#125;console.log(positiveNumbers_([-1, 1, 2, -2])); 我们可以把同样的代码写成函数式的，如下： 123456var positiveNumbers = function(array) &#123; return array.filter(function(num) &#123; return num &gt;= 0; &#125;)&#125;;console.log(positiveNumbers([-1, 1, 2, -2])); 我们也可以使用reduce函数，把一个集合归约成一个特定的值。比如，对一个数组中的值求和： 12345678var sumValues = function (array) &#123; var total = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; total += array[i]; &#125; return total;&#125;;console.log(sumValues([1, 2, 3, 4, 5])); 上面的代码也可以写成这样： 123456var sum_ = function (array) &#123; return array.reduce(function (a, b) &#123; return a + b; &#125;)&#125;;console.log(sum_([1, 2, 3, 4, 5])); 我们还可以把这些函数与ES2015的功能结合起来，比如解构操作符和箭头函数，代码如下： 12const sum = arr =&gt; arr.reduce((a, b) =&gt; a + b);console.log(sum([1, 2, 3, 4, 5])); 我们再看另一个例子。考虑我们需要写一个函数，把几个数组连接起来。为此，可以创建另一个数组，用于存放其他数组的元素。我们可以执行以下命令式的代码： 123456789101112 var mergeArrays_ = function (arrays) &#123; var count = arrays.length, newArray = [], k = 0; for (var i = 0; i &lt; count; i++) &#123; for (var j = 0; j &lt; arrays[i].length; j++) &#123; newArray[k++] = arrays[i][j]; &#125; &#125; return newArray;&#125;;console.log(mergeArrays_([[1, 2, 3], [4, 5], [6]])); 注意，在这个例子中，我们声明了变量，还使用了循环。现在，我们用JavaScript函数式编程把上面的代码重写如下： 123456var mergeArraysConcat = function (arrays) &#123; return arrays.reduce(function (p, n) &#123; return p.concat(n); &#125;);&#125;;console.log(mergeArraysConcat([[1, 2, 3], [4, 5], [6]])); 上面的代码完成了同样的任务，但它是面向函数的。我们也可以用ES2015使代码更加精简，如下所示： 123 const mergeArrays = (...arrays) =&gt; [].concat(...arrays); console.log(mergeArrays([1, 2, 3], [4, 5], [6])); ` 4.4 JavaScript 函数式类库和数据结构有一些很棒的JavaScript类库借助工具函数和函数式数据结构，对函数式编程提供支持。通过下面的列表，你可以找到一些最有名的JavaScript函数式类库。 Underscode.js：http://underscorejs.org/Bilby.js：http://bilby.brianmckenna.org/Lazy.js：http://danieltao.com/lazy.js/Bacon.js：https://baconjs.github.io/Fn.js：http://eliperelman.com/fn.js/Functional.js：http://functionaljs.com/Ramda.js：http://ramdajs.com/0.20.1/index.htmlMori：http://swannodette.github.io/mori/","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法十（排序和搜索算法）","date":"2019-03-18T02:51:50.000Z","path":"2019/03/18/cjw08ytaj001fkwvbqxfxz5wc/","text":"一、排序算法在开始排序算法之前，我们先创建一个数组（列表）来表示待排序和搜索的数据结构。 123456789function ArrayList() &#123; var array = []; //&#123;1&#125; this.insert = function (item) &#123; //&#123;2&#125; array.push(item); &#125;; this.toString = function () &#123; //&#123;3&#125; return array.join(); &#125;;&#125; 如你所见，ArrayList是一个简单的数据结构，它将项存储在数组中（行{1}）。我们只需要一个插入方法来向数据结构中添加元素（行{2}），用JavaScript Array类原生的push方法即可。最后，为了帮助我们验证结果，toString方法使用JavaScript原生Array类的join方法，来拼接数组中的所有元素至一个单一的字符串，这样我们就可以轻松地在浏览器的控制台输出结果了。 注意ArrayList类并没有任何方法来移除数据或插入数据到特定位置。我们刻意保持简单是为了能够专注于排序和搜索算法。所有的排序和搜索算法会添加至这个类中。 1.1 冒泡排序在开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 让我们来实现一下冒泡排序： 12345678910this.bubbleSort = function () &#123; var length = array.length; //&#123;1&#125; for (var i = 0; i &lt; length; i++) &#123; //&#123;2&#125; for (var j = 0; j &lt; length - 1; j++) &#123; //&#123;3&#125; if (array[j] &gt; array[j + 1]) &#123; //&#123;4&#125; swap(array, j, j + 1); //&#123;5&#125; &#125; &#125; &#125;&#125;; 首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。 现在我们得声明swap函数（一个私有函数，只能用在ArrayList类的内部代码中）： 12345var swap = function (array, index1, index2) &#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux;&#125;; 交换时，我们用一个中间值来存储某一交换项的值。其他排序法也会用到这个方法，因此我们声明一个方法放置这段交换代码以便重用。 如果使用在第1章学过的ES6（ECMAScript 2015）增强的对象属性，这个函数可以写成下面这样： 1[array[index1], array[index2]] = [array[index2], array[index1]]; 下面这个示意图展示了冒泡排序的工作过程： 该示意图中每一小段表示外循环的一轮（行{2}），而相邻两项的比较则是在内循环中进行的（行{3}）。 我们将使用下面这段代码来测试冒泡排序算法，看结果是否和示意图所示一致： 1234567891011function createNonSortedArray(size) &#123; //&#123;6&#125; var array = new ArrayList(); for (var i = size; i &gt; 0; i--) &#123; array.insert(i); &#125; return array;&#125;var array = createNonSortedArray(5); //&#123;7&#125;console.log(array.toString()); //&#123;8&#125;array.bubbleSort(); //&#123;9&#125;console.log(array.toString()); //&#123;10&#125; 为了辅助测试本章将要学习的排序算法，我们将创建一个函数来自动地创建一个未排序的数组，数组的长度由函数参数指定（行{6}）。如果传递5作为参数，该函数会创建如下数组：[5, 4 ,3, 2, 1]。调用这个函数并将返回值存储在一个变量中，该变量将包含这个以某些数字来初始化的ArrayList类实例（行{7}）。我们在控制台上输出这个数组内容，确保这是一个未排序数组（行{8}），接着我们调用冒泡排序方法（行{9}）并再次在控制台上输出数组内容以验证数组已被排序了（行{10}）。 注意当算法执行外循环的第二轮的时候，数字4和5已经是正确排序的了。尽管如此，在后续比较中，它们还一直在进行着比较，即使这是不必要的。因此，我们可以稍稍改进一下冒泡排序算法。 改进后的冒泡排序 如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较（行{1}）。 12345678910this.modifiedBubbleSort = function()&#123; var length = array.length; for (var i=0; i&lt;length; i++)&#123; for (var j=0; j&lt;length-1-i; j++ )&#123; //&#123;1&#125; if (array[j] &gt; array[j+1])&#123; swap(j, j+1); &#125; &#125; &#125;&#125;; 下面这个示意图展示了改进后的冒泡排序算法是如何执行的： 1.2 选择排序选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。 下面是选择排序算法的源代码： 123456789101112131415this.selectionSort = function () &#123; var length = array.length, //&#123;1&#125; indexMin; for (var i = 0; i &lt; length - 1; i++) &#123; //&#123;2&#125; indexMin = i; //&#123;3&#125; for (var j = i; j &lt; length; j++) &#123; //&#123;4&#125; if (array[indexMin] &gt; array[j]) &#123; //&#123;5&#125; indexMin = j; //&#123;6&#125; &#125; &#125; if (i !== indexMin) &#123; //&#123;7&#125; swap(array, i, indexMin); &#125; &#125;&#125;; 首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。 用以下代码段来测试选择排序算法： 1234array = createNonSortedArray(5);console.log(array.toString()); //[5, 4, 3, 2, 1]array.selectionSort(); console.log(array.toString()); //[1, 2, 3, 4, 5] 下面的示意图展示了选择排序算法，此例基于之前代码中所用的数组。 数组底部的箭头指示出当前迭代轮寻找最小值的数组范围（内循环{4}），示意图中的每一步则表示外循环。 选择排序同样也是一个复杂度为O(n2)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。然而，接下来要学的插入排序比选择排序性能要好。 1.3 插入排序插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。 下面这段代码表示插入排序算法： 照例，算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。 下面的示意图展示了一个插入排序的实例： 举个例子，假定待排序数组是[3, 5, 1, 4, 2]。这些值将被插入排序算法按照下面形容的步骤进行排序。 (1) 3已被排序，所以我们从数组第二个值5开始。3比5小，所以5待在原位（数组的第二位）。3和5排序完毕。(2) 下一个待排序和插到正确位置上去的值是1（目前在数组的第三位）。5比1大，所以5被移至第三位去了。我们得分析1是否应该被插入到第二位——1比3大吗？不，所以3被移到第二位去了。接着，我们得证明1应该插入到数组的第一位上。因为0是第一个位置且没有负数位，所以1必须被插入到第一位。1、3、5三个数字已经排序。(3) 4应该在当前位置（索引3）还是要移动到索引较低的位置上呢？4比5小，所以5移动到索引3位置上去。那么应该把4插到索引2的位置上去吗？4要比3大，所以4插入到数组的位置3上。 下一个待插入的数字是2（数组的位置4）。5比2大，所以5移动至索引4。4比2大，所以4也得移动（位置3）。3也比2大，所以3还得移动。1比2小，所以2插入到数组的第二位置上。至此，数组已排序完成。 排序小型数组时，此算法比选择排序和冒泡排序性能要好。 1.4 归并排序归并排序是第一个可以被实际使用的排序算法。前面学到的三个排序算法性能不好，但归并排序性能不错，其复杂度为O(nlogn)。 JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。 归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 由于是分治法，归并排序也是递归的： 123this.mergeSort = function()&#123; array = mergeSortRec(array);&#125;; 像之前的章节一样，每当要实现一个递归函数，我们都会实现一个实际被执行的辅助函数。对归并排序我们也会这么做。我们将声明mergeSort方法以供随后使用，而mergeSort方法将会调用mergeSortRec，该函数是一个递归函数： 12345678910var mergeSortRec = function(array)&#123; var length = array.length; if(length === 1) &#123; //&#123;1&#125; return array; //&#123;2&#125; &#125; var mid = Math.floor(length / 2), //&#123;3&#125; left = array.slice(0, mid), //&#123;4&#125; right = array.slice(mid, length); //&#123;5&#125; return merge(mergeSortRec(left), mergeSortRec(right)); //&#123;6&#125;&#125;; 归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。 如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。 下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。 12345678910111213141516171819var merge = function (left, right) &#123; var result = [], // &#123;7&#125; il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; // &#123;8&#125; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); // &#123;9&#125; &#125; else &#123; result.push(right[ir++]); // &#123;10&#125; &#125; &#125; while (il &lt; left.length) &#123; // &#123;11&#125; result.push(left[il++]); &#125; while (ir &lt; right.length) &#123; // &#123;12&#125; result.push(right[ir++]); &#125; return result; // &#123;13&#125;&#125;; merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。 接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。 如果执行mergeSort函数，下图是具体的执行过程： 可以看到，算法首先将原始数组分割直至只有一个元素的子数组，然后开始归并。归并过程也会完成排序，直至原始数组完全合并并完成排序。 1.5 快速排序快速排序也许是最常用的排序算法了。它的复杂度为O(nlogn)，且它的性能通常比其他的复杂度为O(nlogn)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。 快速排序比到目前为止你学过的其他排序算法要复杂一些。让我们一步步地来学习。 (1) 首先，从数组中选择中间一项作为主元。(2) 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。 让我们开始快速排序的实现吧： 123this.quickSort = function()&#123; quick(array, 0, array.length - 1);&#125;; 就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数。 123456789101112var quick = function (array, left, right) &#123; var index; //&#123;1&#125; if (array.length &gt; 1) &#123; //&#123;2&#125; index = partition(array, left, right); //&#123;3&#125; if (left &lt; index - 1) &#123; //&#123;4&#125; quick(array, left, index - 1); //&#123;5&#125; &#125; if (index &lt; right) &#123; //&#123;6&#125; quick(array, index, right); //&#123;7&#125; &#125; &#125;&#125;; 首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。 如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。 1.5.1 划分过程第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。 现在，让我们看看划分过程： 12345678910111213141516171819var partition = function (array, left, right) &#123; var pivot = array[Math.floor((right + left) / 2)], //&#123;8&#125; i = left, //&#123;9&#125; j = right; //&#123;10&#125; while (i &lt;= j) &#123; //&#123;11&#125; while (array[i] &lt; pivot) &#123; //&#123;12&#125; i++; &#125; while (array[j] &gt; pivot) &#123; //&#123;13&#125; j--; &#125; if (i &lt;= j) &#123; //&#123;14&#125; swap(array, i, j); //&#123;15&#125; i++; j--; &#125; &#125; return i; //&#123;16&#125;&#125;; 在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。 只要left和right指针没有相互交错（行{11}），就执行划分操作。首先，移动left指针直到找到一个元素比主元大（行{12}）。对right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。 在划分操作结束后，返回左指针的索引，用来在行{3}处创建子数组。 swap函数和我们在本章开始为冒泡排序算法实现的相同。我们也可以将此函数替换为以下ES6代码。 1[array[index1], array[index2]] = [array[index2], array[index1]]; 1.5.2 快速排序实战让我们来一步步地看一个快速排序的实际例子： 给定数组[3, 5, 1, 6, 4, 7, 2]，前面的示意图展示了划分操作的第一次执行。 下面的示意图展示了对有较小值的子数组执行的划分操作（注意7和6不包含在子数组之内）： 接着，我们继续创建子数组，请看下图，但是这次操作是针对上图中有较大值的子数组（有1的那个较小子数组不用再划分了，因为它仅含有一个项）。 子数组（[2, 3, 5, 4]）中的较小子数组（[2, 3]）继续进行划分（算法代码中的行{5}）： 然后子数组（[2, 3, 5, 4]）中的较大子数组（[5, 4]）也继续进行划分（算法中的行{7}），示意图如下： 最终，较大子数组[6, 7]也会进行划分（partition）操作，快速排序算法的操作执行完成。 1.6 堆排序堆排序也是一种很高效的算法，因其把数组当作二叉树来排序而得名。这个算法会根据以下信息，把数组当作二叉树来管理。 索引0是树的根节点；除根节点外，任意节点N的父节点是N/2；节点L的左子节点是2L；节点R的右子节点是2R+1。 举例来说，可以将数组[3, 5, 1, 6, 4, 7, 2]想象成下面的树： 堆排序算法实现如下： 123456789this.heapSort = function () &#123; var heapSize = array.length; buildHeap(array); //&#123;1&#125; while (heapSize &gt; 1) &#123; heapSize--; swap(array, 0, heapSize); //&#123;2&#125; heapify(array, heapSize, 0); //&#123;3&#125; &#125;&#125;; 第一步，构造一个满足array[parent(i)] ≥ array[i]的堆结构（行{1}）。 第二步，交换堆里第一个元素（数组中较大的值）和最后一个元素的位置（行{2}）。这样，最大的值就会出现在它已排序的位置。 第二步可能会丢掉堆的属性。因此，我们还需要执行一个heapify函数，再次将数组转换成堆，也就是说，它会找到当前堆的根节点（较小的值），重新放到树的底部。 buildHeap函数实现如下： 123456var buildHeap = function(array)&#123; var heapSize = array.length; for (var i = Math.floor(array.length / 2); i &gt;= 0; i--) &#123; heapify(array, heapSize, i); &#125;&#125;; 如果对数组[3, 5, 1, 6, 4, 7, 2]调用buildHeap函数，堆的构建过程如下： 最后，heapify函数实现如下： 123456789101112131415var heapify = function (array, heapSize, i) &#123; var left = i * 2 + 1, right = i * 2 + 2, largest = i; if (left &lt; heapSize &amp;&amp; array[left] &gt; array[largest]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123; largest = right; &#125; if (largest !== i) &#123; swap(array, i, largest); heapify(array, heapSize, largest); &#125;&#125;; 堆构造好之后，就可以应用堆排序的算法了，也就是行{2}和行{3} 二、搜索算法现在，让我们来谈谈搜索算法。回顾一下之前章节所实现的算法，我们会发现BinarySearchTree类的search方法（第8章），以及LinkedList类的indexOf方法（第5章）等，都是搜索算法，当然，它们每一个都是根据其各自的数据结构来实现的。所以，我们已经熟悉两个搜索算法了，只是还不知道它们“正式”的名称而已。 2.1 顺序搜索顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。 以下是其实现： 1234567this.sequentialSearch = function (item) &#123; for (var i = 0; i &lt; array.length; i++) &#123; //&#123;1&#125; if (item === array[i]) //&#123;2&#125; return i; //&#123;3&#125; &#125; return -1; //&#123;4&#125;&#125;; 顺序搜索迭代整个数组（行{1}），并将每个数组元素和搜索项作比较（行{2}）。如果搜索到了，算法将用返回值来标示搜索成功。返回值可以是该搜索项本身，或是true，又或是搜索项的索引（行{3}）。如果没有找到该项，则返回-1（行{4}），表示该索引不存在；也可以考虑返回false或者null。 假定有数组[5, 4, 3, 2, 1]和待搜索值3，下图展示了顺序搜索的示意图： 2.2 二分搜索二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。 这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。 (1) 选择数组的中间值。 (2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。 (3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。 (4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。 以下是其实现： 123456789101112131415161718this.binarySearch = function (item) &#123; this.quickSort(); //&#123;1&#125; var low = 0, //&#123;2&#125; high = array.length - 1, //&#123;3&#125; mid, element; while (low &lt;= high) &#123; //&#123;4&#125; mid = Math.floor((low + high) / 2); //&#123;5&#125; element = array[mid]; //&#123;6&#125; if (element &lt; item) &#123; //&#123;7&#125; low = mid + 1; //&#123;8&#125; &#125; else if (element &gt; item) &#123; //&#123;9&#125; high = mid - 1; //&#123;10&#125; &#125; else &#123; return mid; //&#123;11&#125; &#125; &#125; return -1; //&#123;12&#125;&#125; 开始前需要先将数组排序，我们可以选择任何一个在10.1节中实现的排序算法。这里我们选择了快速排序。在数组排序之后，我们设置low（行{2}）和high（行{3}）指针（它们是边界）。 当low比high小时（行{4}），我们计算得到中间项索引并取得中间项的值，此处如果low比high大，则意思是该待搜索值不存在并返回-1（行{12}）。接着，我们比较选中项的值和搜索值（行{7}）。如果小了，则选择数组低半边并重新开始。如果选中项的值比搜索值大了，则选择数组高半边并重新开始。若两者都是不是，则意味着选中项的值和搜索值相等，因此，直接返回该索引（行{11}）。 给定下图所示数组，让我们试试看搜索2。这些是算法将会执行的步骤：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法九（图）","date":"2019-03-08T01:45:50.000Z","path":"2019/03/08/cjw08ytaw001jkwvbs7bpqs7n/","text":"一、图的相关术语图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。 任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。 我们还可以使用图来表示道路、航班以及通信状态，如下图所示： 让我们来学习一下图在数学及技术上的概念。 一个图G = (V, E)由以下元素组成。 V：一组顶点E：一组边，连接V中的顶点 下图表示一个图： 在着手实现算法之前，让我们先了解一下图的一些术语。 由一条边连接在一起的顶点称为相邻顶点。比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。 一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3；E和其他两个顶点相连，因此，E的度为2。 路径是顶点v1, v2,…,vk的一个连续序列，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。 简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如A D C A（最后一个顶点重新回到A）。 如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。 1.1 有向图和无向图图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向： 如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的，而A和B不是强连通的。 图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值： 我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。 二、 图的表示从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。 2.1 邻接矩阵图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0，如下图所示： 不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而2维数组不太灵活。 2.2 邻接表我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。 尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质（例如，要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。在本书的示例中，我们将会使用邻接表表示法。 2.3 关联矩阵我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。 关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。 三、创建Graph类照例，我们声明类的骨架： 1234function Graph() &#123; var vertices = []; //&#123;1&#125; var adjList = new Dictionary(); //&#123;2&#125;&#125; 我们使用一个数组来存储图中所有顶点的名字（行{1}），以及一个字典（在第7章中已经实现）来存储邻接表（行{2}）。字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和adjList字典两者都是我们Graph类的私有属性。 接着，我们将实现两个方法：一个用来向图中添加一个新的顶点（因为图实例化后是空的），另外一个方法用来添加顶点之间的边。我们先实现addVertex方法： 1234this.addVertex = function(v)&#123; vertices.push(v); //&#123;3&#125; adjList.set(v, []); //&#123;4&#125;&#125;; 这个方法接受顶点v作为参数。我们将该顶点添加到顶点列表中（行{3}），并且在邻接表中，设置顶点v作为键对应的字典值为一个空数组（行{4}）。 现在，我们来实现addEdge方法： 1234this.addEdge = function(v, w)&#123; adjList.get(v).push(w); //&#123;5&#125; adjList.get(w).push(v); //&#123;6&#125;&#125;; 这个方法接受两个顶点作为参数。首先，通过将w加入到v的邻接表中，我们添加了一条自顶点v到顶点w的边。如果你想实现一个有向图，则行{5}就足够了。由于本章中大多数的例子都是基于无向图的，我们需要添加一条自w向v的边（行{6}）。 为了更方便一些，让我们来实现一下Graph类的toString方法，以便于在控制台输出图。 123456789101112this.toString = function()&#123; var s = ''; for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;10&#125; s += vertices[i] + ' -&gt; '; var neighbors = adjList.get(vertices[i]); //&#123;11&#125; for (var j=0; j&lt;neighbors.length; j++)&#123; //&#123;12&#125; s += neighbors[j] + ' '; &#125; s += '\\n'; //&#123;13&#125; &#125; return s;&#125;; 我们为邻接表表示法构建了一个字符串。首先，迭代vertices数组列表（行{10}），将顶点的名字加入字符串中。接着，取得该顶点的邻接表（行{11}），同样也迭代该邻接表（行{12}），将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符（行{13}），这样就可以在控制台看到一个漂亮的输出了。运行如下代码： 测试以上代码： 12345678910111213141516var graph = new Graph();var myVertices = ['A','B','C','D','E','F','G','H','I']; //&#123;7&#125;for (var i=0; i&lt;myVertices.length; i++)&#123; //&#123;8&#125; graph.addVertex(myVertices[i]);&#125;graph.addEdge('A', 'B'); //&#123;9&#125;graph.addEdge('A', 'C');graph.addEdge('A', 'D');graph.addEdge('C', 'D');graph.addEdge('C', 'G');graph.addEdge('D', 'G');graph.addEdge('D', 'H');graph.addEdge('B', 'E');graph.addEdge('B', 'F');graph.addEdge('E', 'I');console.log(graph.toString()); 为方便起见，我们创建了一个数组，包含所有我们想添加到图中的顶点（行{7}）。接下来，我们只要遍历vertices数组并将其中的值逐一添加到我们的图中（行{8}）。最后，我们添加想要的边（行{9}）。这段代码将会创建一个图，也就是到目前为止本章的示意图所使用的。 输出如下： 123456789A -&gt; B C DB -&gt; A E FC -&gt; A D GD -&gt; A C G HE -&gt; B IF -&gt; BG -&gt; C DH -&gt; DI -&gt; E 一个漂亮的邻接表！从该输出中，我们知道顶点A有这几个相邻顶点：B、C和D。 四、图的遍历和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。 在实现算法之前，让我们来更好地理解一下图遍历的思想方法。 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。 完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。 为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。 广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。 算 法 数据结构 描述 深度优先搜索 栈 通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 广度优先搜索 队列 通过将顶点存入队列中，最先入队列的顶点先被探索 当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。 白色：表示该顶点还没有被访问。灰色：表示该顶点被访问过，但并未被探索过。黑色：表示该顶点被访问过且被完全探索过。 这就是之前提到的务必访问每个顶点最多两次的原因。 4.1 广度优先搜索广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示： 以下是从顶点v开始的广度优先搜索算法所遵循的步骤。 (1) 创建一个队列Q。(2) 将v标注为被发现的（灰色），并将v入队列Q。(3) 如果Q非空，则运行以下步骤： (a) 将u从Q中出队列； (b) 将标注u为被发现的（灰色）； (c) 将u所有未被访问过的邻点（白色）入队列； (d) 将u标注为已被探索的（黑色）。 让我们来实现广度优先搜索算法： 12345678910111213141516171819202122232425262728var initializeColor = function () &#123; var color = []; for (var i = 0; i &lt; vertices.length; i++) &#123; color[vertices[i]] = 'white'; //&#123;1&#125; &#125; return color;&#125;; this.bfs = function (v, callback) &#123; var color = initializeColor(), //&#123;2&#125; queue = new Queue(); //&#123;3&#125; queue.enqueue(v); //&#123;4&#125; while (!queue.isEmpty()) &#123; //&#123;5&#125; var u = queue.dequeue(), //&#123;6&#125; neighbors = adjList.get(u); //&#123;7&#125; color[u] = 'grey'; // &#123;8&#125; for (var i = 0; i &lt; neighbors.length; i++) &#123; // &#123;9&#125; var w = neighbors[i]; // &#123;10&#125; if (color[w] === 'white') &#123; // &#123;11&#125; color[w] = 'grey'; // &#123;12&#125; queue.enqueue(w); // &#123;13&#125; &#125; &#125; color[u] = 'black'; // &#123;14&#125; if (callback) &#123; // &#123;15&#125; callback(u); &#125; &#125;&#125;; 广度优先搜索和深度优先搜索都需要标注被访问过的顶点。为此，我们将使用一个辅助数组color。由于当算法开始执行时，所有的顶点颜色都是白色（行{1}），所以我们可以创建一个辅助函数initializeColor，为这两个算法执行此初始化操作。 让我们深入学习广度优先搜索方法的实现。我们要做的第一件事情是用initializeColor函数来将color数组初始化为white（行{2}）。我们还需要声明和创建一个Queue实例（行{3}），它将会存储待访问和待探索的顶点。 照着本章开头解释过的步骤，bfs方法接受一个顶点作为算法的起始点。起始顶点是必要的，我们将此顶点入队列（行{4}）。 如果队列非空（行{5}），我们将通过出队列（行{6}）操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表（行{7}）。该顶点将被标注为grey（行{8}），表示我们发现了它（但还未完成对其的探索）。 对于u（行{9}）的每个邻点，我们取得其值（该顶点的名字——行{10}），如果它还未被访问过（颜色为white——行{11}），则将其标注为我们已经发现了它（颜色设置为grey——行{12}），并将这个顶点加入队列中（行{13}），这样当其从队列中出列的时候，我们可以完成对其的探索。 当完成探索该顶点和其相邻顶点后，我们将该顶点标注为已探索过的（颜色设置为black——行{14}）。 我们实现的这个bfs方法也接受一个回调（我们在第8章中遍历树时使用了一个相似的方法）。这个参数是可选的，如果我们传递了回调函数（行{15}），会用到它。 让我们执行下面这段代码来测试一下这个算法： 1234function printNode(value)&#123; //&#123;16&#125; console.log('Visited vertex: ' + value); //&#123;17&#125;&#125;graph.bfs(myVertices[0], printNode); //&#123;18&#125; 首先，我们声明了一个回调函数（行{16}），它仅仅在浏览器控制台上输出已经被完全探索过的顶点的名字。接着，我们会调用bfs方法，给它传递第一个顶点（A——从本章开头声明的myVertices数组）和回调函数。当我们执行这段代码时，该算法会在浏览器控制台输出下示的结果： Visited vertex: AVisited vertex: BVisited vertex: CVisited vertex: DVisited vertex: EVisited vertex: FVisited vertex: GVisited vertex: HVisited vertex: I 顶点被访问的顺序和本节开头的示意图中所展示的一致。 4.1.1 使用BFS寻找最短路径到目前为止，我们只展示了BFS算法的工作原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面这个问题。 给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。 对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改bfs方法以返回给我们一些信息： 从v到u的距离d[u]； 前溯点pred[u]，用来推导出从v到其他每个顶点u的最短路径。 123456789101112131415161718192021222324252627282930this.BFS = function (v) &#123; var color = initializeColor(), queue = new Queue(), d = [], //&#123;1&#125; pred = []; //&#123;2&#125; queue.enqueue(v); for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;3&#125; d[vertices[i]] = 0; //&#123;4&#125; pred[vertices[i]] = null; //&#123;5&#125; &#125; while (!queue.isEmpty()) &#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; color[w] = 'grey'; d[w] = d[u] + 1; //&#123;6&#125; pred[w] = u; //&#123;7&#125; queue.enqueue(w); &#125; &#125; color[u] = 'black'; &#125; return &#123; //&#123;8&#125; distances: d, predecessors: pred &#125;;&#125;; 让我们来看看改进过的广度优先方法的实现： 我们还需要声明数组d（行{1}）来表示距离，以及pred数组来表示前溯点。下一步则是对图中的每一个顶点，用0来初始化数组d（行{4}），用null来初始化数组pred。 当我们发现顶点u的邻点w时，则设置w的前溯点值为u（行{7}）。我们还通过给d[u]加1来设置v和w之间的距离（u是w的前溯点，d[u]的值已经有了）。 方法最后返回了一个包含d和pred的对象（行{8}）。 现在，我们可以再次执行BFS方法，并将其返回值存在一个变量中： 12var shortestPathA = graph.BFS(myVertices[0]);console.log(shortestPathA); 对顶点A执行BFS方法，以下将会是输出： 12distances: [A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3],predecessors: [A: null, B: \"A\", C: \"A\", D: \"A\", E: \"B\", F: \"B\", G: \"C\", H: \"D\", I: \"E\"] 这意味着顶点A与顶点B、C和D的距离为1；与顶点E、F、G和H的距离为2；与顶点I的距离为3。 通过前溯点数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径： 1234567891011121314var fromVertex = myVertices[0]; //&#123;9&#125;for (var i = 1; i &lt; myVertices.length; i++) &#123; //&#123;10&#125; var toVertex = myVertices[i], //&#123;11&#125; path = new Stack(); //&#123;12&#125; for (var v = toVertex; v !== fromVertex;v = shortestPathA.predecessors[v]) &#123; //&#123;13&#125; path.push(v); //&#123;14&#125; &#125; path.push(fromVertex); //&#123;15&#125; var s = path.pop(); //&#123;16&#125; while (!path.isEmpty()) &#123; //&#123;17&#125; s += ' - ' + path.pop(); //&#123;18&#125; &#125; console.log(s); //&#123;19&#125;&#125; 我们用顶点A作为源顶点（行{9}）。对于每个其他顶点（除了顶点A——行{10}），我们会计算顶点A到它的路径。我们从顶点数组得到toVertex（行{11}），然后会创建一个栈来存储路径值（行{12}）。 接着，我们追溯toVertex到fromVertex的路径（行{13}）。变量v被赋值为其前溯点的值，这样我们能够反向追溯这条路径。将变量v添加到栈中（行{14}）。最后，源顶点也会被添加到栈中，以得到完整路径。 这之后，我们创建了一个s字符串，并将源顶点赋值给它（它是最后一个加入栈中的，所以它是第一个被弹出的项 ——行{16}）。当栈是非空的，我们就从栈中移出一个项并将其拼接到字符串s的后面（行{18}）。最后（行{19}）在控制台上输出路径。 执行该代码段，我们会得到如下输出： A - BA - CA - DA - B - EA - B - FA - C - GA - D - HA - B - E - I 这里，我们得到了从顶点A到图中其他顶点的最短路径（衡量标准是边的数量）。 4.1.2 深入学习最短路径算法本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法），广度优先搜索未必合适。 举些例子，Dijkstra算法解决了单源最短路径问题。Bellman-Ford算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。Floyd-Warshall算法解决了求所有顶点对间的最短路径这一问题。 如文章开头提到的，图是一个广泛的主题，对最短路径问题及其变种问题，我们有很多的解决方案。但在开始学习这些其他解决方案前，我们需要掌握好图的基本概念，这是本章涵盖的内容。而这些其他解决方案则不会在本章讲述，但你可以自行探索图的奇妙世界 4.2深度优先搜索深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示： 深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。 要访问顶点v，照如下步骤做。 (1) 标注v为被发现的（灰色）。(2) 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。 如你所见，深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。 让我们来实现一下深度优先算法 12345678910111213141516171819202122this.dfs = function (callback) &#123; var color = initializeColor(); //&#123;1&#125; for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;2&#125; if (color[vertices[i]] === 'white') &#123; //&#123;3&#125; dfsVisit(vertices[i], color, callback); //&#123;4&#125; &#125; &#125;&#125;;var dfsVisit = function (u, color, callback) &#123; color[u] = 'grey'; //&#123;5&#125; if (callback) &#123; //&#123;6&#125; callback(u); &#125; var neighbors = adjList.get(u); //&#123;7&#125; for (var i = 0; i &lt; neighbors.length; i++) &#123; //&#123;8&#125; var w = neighbors[i]; //&#123;9&#125; if (color[w] === 'white') &#123; //&#123;10&#125; dfsVisit(w, color, callback); //&#123;11&#125; &#125; &#125; color[u] = 'black'; //&#123;12&#125;&#125;; 首先，我们创建颜色数组（行{1}），并用值white为图中的每个顶点对其做初始化，广度优先搜索也这么做的。接着，对于图实例中每一个未被访问过的顶点（行{2}和{3}），我们调用私有的递归函数dfsVisit，传递的参数为顶点、颜色数组以及回调函数（行{4}）。 当访问u顶点时，我们标注其为被发现的（grey——行{5}）。如果有callback函数的话（行{6}），则执行该函数输出已访问过的顶点。接下来一步是取得包含顶点u所有邻点的列表（行{7}）。对于顶点u的每一个未被访问过（颜色为white——行{10}和行{8}）的邻点w（行{9}），我们将调用dfsVisit函数，传递w和其他参数（行{11}——添加顶点w入栈，这样接下来就能访问它）。最后，在该顶点和邻点按深度访问之后，我们回退，意思是该顶点已被完全探索，并将其标注为black（行{12}）。 让我们执行下面的代码段来测试一下dfs方法： 输出如下： Visited vertex: AVisited vertex: BVisited vertex: EVisited vertex: IVisited vertex: FVisited vertex: CVisited vertex: DVisited vertex: GVisited vertex: H 这个顺序和本节开头处示意图所展示的一致。下面这个示意图展示了该算法每一步的执行过程： 在我们示例所用的图中，行{4}只会被执行一次，因为所有其他的顶点都有路径到第一个调用dfsVisit函数的顶点（顶点A）。如果顶点B第一个调用函数，则行{4}将会为其他顶点再执行一次（比如顶点A）。 4.2.1 深度优先搜索到目前为止，我们只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事情，而不只是输出被访问顶点的顺序。 对于给定的图G，我们希望深度优先搜索算法遍历图G的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。我们可以修改dfs方法来返回给我们一些信息： 顶点u的发现时间d[u]；当顶点u被标注为黑色时，u的完成探索时间f[u]；顶点u的前溯点p[u]。 让我们来看看改进了的DFS方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839var time = 0; //&#123;1&#125;this.DFS = function () &#123; var color = initializeColor(), //&#123;2&#125; d = [], f = [], p = []; time = 0; for (var i = 0; i &lt; vertices.length; i++) &#123; //&#123;3&#125; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for (i = 0; i &lt; vertices.length; i++) &#123; if (color[vertices[i]] === 'white') &#123; DFSVisit(vertices[i], color, d, f, p); &#125; &#125; return &#123; //&#123;4&#125; discovery: d, finished: f, predecessors: p &#125;;&#125;;var DFSVisit = function (u, color, d, f, p) &#123; console.log('discovered ' + u); color[u] = 'grey'; d[u] = ++time; //&#123;5&#125; var neighbors = adjList.get(u); for (var i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; p[w] = u; // &#123;6&#125; DFSVisit(w, color, d, f, p); &#125; &#125; color[u] = 'black'; f[u] = ++time; //&#123;7&#125; console.log('explored ' + u);&#125;; 我们需要一个变量来要追踪发现时间和完成探索时间（行{1}）。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他JavaScript方法（将变量作为引用传递的意思是如果该变量在其他方法内部被修改，新值会在原始变量中反映出来）。接下来，我们声明数组d、f和p（行{2}）。我们需要为图的每一个顶点来初始化这些数组（行{3}）。在这个方法结尾处返回这些值（行{4}），之后我们要用到它们。 当一个顶点第一次被发现时，我们追踪其发现时间（行{5}）。当它是由引自顶点u的边而被发现的，我们追踪它的前溯点（行{6}）。最后，当这个顶点被完全探索后，我们追踪其完成时间（行{7}）。 深度优先算法背后的思想是什么？边是从最近发现的顶点u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法回退到u被发现的地方去探索其他的边。这个过程持续到我们发现了所有从原始顶点能够触及的顶点。如果还留有任何其他未被发现的顶点，我们对新源顶点重复这个过程。重复该算法，直到图中所有的顶点都被探索了。 对于改进过的深度优先搜索，有两点需要我们注意： 时间（time）变量值的范围只可能在图顶点数量的一倍到两倍之间；对于所有的顶点u，d[u]&lt;f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）。 在这两个假设下，我们有如下的规则： 1 ≤ d [u] &lt; f [u] ≤ 2|V| 如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间： 4.2.2 拓扑排序——使用深度优先搜索给定下图，假定每个顶点都是一个我们需要去执行的任务： 这是一个有向图，意味着任务的执行是有顺序的。例如，任务F不能在任务A之前执行。注意这个图没有环，意味着这是一个无环图。所以，我们可以说该图是一个有向无环图（DAG）。 当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting，英文亦写作topsort或是toposort）。在日常生活中，这个问题在不同情形下都会出现。例如，当我们开始学习一门计算机科学课程，在学习某些知识之前得按顺序完成一些知识储备（你不可以在上算法I前先上算法II）。当我们在开发一个项目时，需要按顺序执行一些步骤，例如，首先我们得从客户那里得到需求，接着开发客户要求的东西，最后交付项目。你不能先交付项目再去收集需求。 拓扑排序只能应用于DAG。那么，如何使用深度优先搜索来实现拓扑排序呢？让我们在本节开头的示意图上执行一下深度优先搜索。 123456789101112graph = new Graph();myVertices = ['A','B','C','D','E','F'];for (i=0; i&lt;myVertices.length; i++)&#123;graph.addVertex(myVertices[i]);&#125;graph.addEdge('A', 'C');graph.addEdge('A', 'D');graph.addEdge('B', 'D');graph.addEdge('B', 'E');graph.addEdge('C', 'F');graph.addEdge('F', 'E');var result = graph.DFS(); 这段代码将创建图，添加边，执行改进版本的深度优先搜索算法，并将结果保存到result变量。下图展示了深度优先搜索算法执行后，该图的发现和完成时间 现在要做的仅仅是以倒序来排序完成时间数组，这便得出了该图的拓扑排序： B - A - D - C - F - E 注意之前的拓扑排序结果仅是多种可能性之一。如果我们稍微修改一下算法，就会有不同的结果，比如下面这个结果也是众多其他可能性中的一个： A - B - C - D - F - E 五、 最短路径算法设想你要从街道地图上的A点，通过可能的最短路径到达B点。举例来说，从洛杉矶的圣莫尼卡大道到好莱坞大道，如下图所示： 这种问题在生活中非常常见，我们（特别是生活在大城市的人们）会求助于苹果地图、谷歌地图、Waze等应用程序。当然，我们也有其他的考虑，如时间或路况，但根本的问题仍然是：从A到B的最短路径是什么？ 我们可以用图来解决这个问题，相应的算法被称为最短路径。本节我们将介绍两种非常著名的算法，即Dijkstra算法和Floyd-Warshall算法。 5.1 Dijkstra 算法Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。 考虑下图： 我们来看看如何找到顶点A和其余顶点之间的最短路径。但首先，我们需要声明表示上图的邻接矩阵，如下所示： 123456var graph = [[0, 2, 4, 0, 0, 0], [0, 0, 1, 4, 2, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 2], [0, 0, 0, 3, 0, 2], [0, 0, 0, 0, 0, 0]]; 现在，通过下面的代码来看看Dijkstra算法是如何工作的： 1234567891011121314151617181920this.dijkstra = function (src) &#123; var dist = [], visited = [], length = this.graph.length; for (var i = 0; i &lt; length; i++) &#123; //&#123;1&#125; dist[i] = Number.MAX_SAFE_INTEGER; visited[i] = false; &#125; dist[src] = 0; //&#123;2&#125; for (var i = 0; i &lt; length - 1; i++) &#123; //&#123;3&#125; var u = minDistance(dist, visited); //&#123;4&#125; visited[u] = true; //&#123;5&#125; for (var v = 0; v &lt; length; v++) &#123; if (!visited[v] &amp;&amp; this.graph[u][v] != 0 &amp;&amp; dist[u] != Number.MAX_SAFE_INTEGER &amp;&amp; dist[u] + this.graph[u][v] &lt; dist[v]) &#123; //&#123;6&#125; dist[v] = dist[u] + this.graph[u][v]; //&#123;7&#125; &#125; &#125; &#125; return dist; //&#123;8&#125;&#125;; 下面是对算法过程的描述。 行{1}：首先，把所有的距离（dist）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），将visited[]初始化为false。行{2}：然后，把源顶点到自己的距离设为0。行{3}：接下来，要找出到其余顶点的最短路径。行{4}：为此，我们需要从尚未处理的顶点中选出距离最近的顶点。行{5}：把选出的顶点标为visited，以免重复计算。行{6}：如果找到更短的路径，则更新最短路径的值（行{7}）。行{8}：处理完所有顶点后，返回从源顶点（src）到图中其他顶点最短路径的结果。 要计算顶点间的minDistance，就要搜索dist数组中的最小值，返回它在数组中的索引： 12345678910var minDistance = function(dist, visited) &#123; var min = INF, minIndex = -1; for (var v = 0; v &lt; dist.length; v++) &#123; if (visited[v] == false &amp;&amp; dist[v] &lt;= min) &#123; min = dist[v]; minIndex = v; &#125; &#125; return minIndex;&#125;; 对本节开始的图执行以上算法，会得到如下输出： 1234560 01 22 33 64 45 6 5.2 Floyd-Warshall 算法Floyd-Warshall算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。 Floyd-Warshall算法实现如下： 1234567891011121314151617181920212223242526272829303132333435363738 this.floydWarshall = function() &#123; var dist = [], length = this.graph.length, i, j, k; for (i = 0; i &lt; length; i++) &#123; //&#123;1&#125; dist[i] = []; for (j = 0; j &lt; length; j++) &#123; dist[i][j] = this.graph[i][j]; &#125; &#125; for (k = 0; k &lt; length; k++) &#123; //&#123;2&#125; for (i = 0; i &lt; length; i++) &#123; for (j = 0; j &lt; length; j++) &#123; if (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; //&#123;3&#125; dist[i][j] = dist[i][k] + dist[k][j]; //&#123;4&#125; &#125; &#125; &#125; &#125; return dist; &#125;; 下面是对算法过程的描述:&gt; 行&#123;1&#125;：首先，把dist数组初始化为每个顶点之间的权值，因为i到j可能的最短距离就是这些顶点间的权值。&gt; 行&#123;2&#125;：通过k，得到i途径顶点0至k，到达j的最短路径。&gt; 行&#123;3&#125;：判断i经过顶点k到达j的路径是否比已有的最短路径更短。&gt; 行&#123;4&#125;：如果是更短的路径，则更新最短路径的值。行&#123;3&#125;是Floyd-Warshall算法的核心。对本节开始的图执行以上算法，会得到如下输出：```javascript 0 2 3 6 4 6 INF 0 1 4 2 4 INF INF 0 6 3 5 INF INF INF 0 INF 2 INF INF INF 3 0 2 INF INF INF INF INF 0 其中，INF代表顶点i到j的最短路径不存在。 对图中每一个顶点执行Dijkstra算法，也可以得到相同的结果。 六、 最小生成树最小生成树（MST）问题是网络设计中常见的问题。想象一下，你的公司有几间办公室，要以最低的成本实现办公室电话线路相互连通，以节省资金，最好的办法是什么？ 这也可以应用于岛桥问题。设想你要在n个岛屿之间建造桥梁，想用最低的成本实现所有岛屿相互连通。 这两个问题都可以用MST算法来解决，其中的办公室或者岛屿可以表示为图中的一个顶点，边代表成本。这里我们有一个图的例子，其中较粗的边是一个MST的解决方案。 6.1 Prim 算法Prim算法是一种求解加权无向连通图的MST问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。 现在，通过下面的代码来看看Prim算法是如何工作的： 123456789101112131415161718192021222324this.prim = function() &#123; var parent = [], key = [], visited = []; length = this.graph.length, i; for (i = 0; i &lt; length; i++) &#123; //&#123;1&#125; key[i] = INF; visited[i] = false; &#125; key[0] = 0; //&#123;2&#125; parent[0] = -1; for (i = 0; i &lt; length-1; i++) &#123; //&#123;3&#125; var u = minKey(key, visited); //&#123;4&#125; visited[u] = true; //&#123;5&#125; for (var v = 0; v &lt; length; v++) &#123; if (this.graph[u][v] &amp;&amp; visited[v] == false &amp;&amp; this.graph[u][v] &lt; key[v]) &#123; //&#123;6&#125; parent[v] = u; //&#123;7&#125; key[v] = this.graph[u][v]; //&#123;8&#125; &#125; &#125; &#125; return parent; //&#123;9&#125;&#125;; 下面是对算法过程的描述。 行{1}：首先，把所有顶点（key）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），visited[]初始化为false。行{2}：其次，选择第一个key作为第一个顶点，同时，因为第一个顶点总是MST的根节点，所以parent[0] = -1。行{3}：然后，对所有顶点求MST。行{4}：从未处理的顶点集合中选出key值最小的顶点（与Dijkstra算法中使用的函数一样，只是名字不同）。行{5}：把选出的顶点标为visited，以免重复计算。行{6}：如果得到更小的权值，则保存MST路径（parent，行{7}）并更新其权值（行{8}）。行{9}：处理完所有顶点后，返回包含MST的结果。 比较Prim算法和Dijkstra算法，我们会发现除了行{7}和行{8}之外，两者非常相似。行{7}用parent数组保存MST的结果。行{8}用key数组保存权值最小的边，而在Dijkstra算法中，用dist数组保存距离。我们可以修改Dijkstra算法，加入parent数组。这样，就可以在求出距离的同时得到路径。 对如下的图执行以上算法： 123456var graph = [[0, 2, 4, 0, 0, 0], [2, 0, 2, 4, 2, 0], [4, 2, 0, 0, 3, 0], [0, 4, 0, 0, 3, 2], [0, 2, 3, 3, 0, 2], [0, 0, 0, 2, 2, 0]]; 我们会得到如下输出： 123456Edge Weight0 - 1 21 - 2 25 - 3 21 - 4 24 - 5 2 6.1 Kruskal 算法和Prim算法类似，Kruskal算法也是一种求加权无向连通图的MST的贪心算法。 现在，通过下面的代码来看看Kruskal算法是如何工作的： 123456789101112131415161718192021222324this.kruskal = function() &#123; var length = this.graph.length, parent = [], cost, ne = 0, a, b, u, v, i, j, min; cost = initializeCost(); //&#123;1&#125; while (ne &lt; length-1) &#123; //&#123;2&#125; for (i = 0, min = INF; i &lt; length; i++) &#123; //&#123;3&#125; for (j = 0; j &lt; length; j++) &#123; if (cost[i][j] &lt; min) &#123; min = cost[i][j]; u = i; v = j; &#125; &#125; &#125; u = find(u, parent); //&#123;4&#125; v = find(v, parent); //&#123;5&#125; if (union(u, v, parent)) &#123; //&#123;6&#125; ne++; &#125; cost[u][v] = cost[v][u] = INF; //&#123;7&#125; &#125; return parent;&#125; 下面是对算法过程的描述。 行{1}：首先，把邻接矩阵的值复制到cost数组，以方便修改且可以保留原始值行{7}。行{2}：当MST的边数小于顶点总数减1时。行{3}：找出权值最小的边。行{4}和行{5}：检查MST中是否已存在这条边，以避免环路。行{6}：如果u和v是不同的边，则将其加入MST。行{7}：从列表中移除这些边，以免重复计算。行{8}：返回MST。 下面是find函数的定义。它能防止MST出现环路： 123456var find = function(i, parent) &#123; while (parent[i]) &#123; i = parent[i]; &#125; return i;&#125;; union函数的定义如下: 1234567var union = function(i, j, parent) &#123; if (i != j) &#123; parent[j] = i; return true; &#125; return false;&#125;; 这个算法有几种变体。这取决于对边的权值排序时所使用的数据结构（如优先队列），以及图是如何表示的。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法八（树）","date":"2019-02-28T08:08:07.000Z","path":"2019/02/28/cjw08ytav001ikwvbwre69mos/","text":"到目前为止，我们学习了一些顺序数据结构，学习的第一个非顺序数据结构是散列表。在节章，我们将要学习另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用。 一、 树数据结构树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图，如下图所示： 二、 树的相关术语一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点： 位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。 一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）。 三、 二叉树和二叉搜索树二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。 二叉搜索树将是我们在本章中要研究的数据结构。 3.1 创建 BinarySearchTree 类让我们开始创建自己的BinarySearchTree类。首先，声明它的结构： 12345678function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125;&#125; 下图展现了二叉搜索树数据结构的组织方式： 和链表一样，将通过指针来表示节点之间的关系（术语称其为边）。在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树，使用同样的方式（也使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。因此，将声明一个Node类来表示树中的每个节点（行{1}）。值得注意的一个小细节是，不同于在之前的章节中将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼。 我们将会遵循和LinkedList类中相同的模式，这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是根元素（行{2}） 然后，我们需要实现一些方法。下面是将要在树类中实现的方法。 insert(key)：向树中插入一个新的键。 search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。 inOrderTraverse：通过中序遍历方式遍历所有节点。 preOrderTraverse：通过先序遍历方式遍历所有节点。 postOrderTraverse：通过后序遍历方式遍历所有节点。 min：返回树中最小的值/键。 max：返回树中最大的值/键。 remove(key)：从树中移除某个键。 3.1.1 向树中插入一个键下面的代码是用来向树插入一个新键的算法的第一部分： 12345678this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125;&#125;; 要向树中插入一个新的节点（或项），要经历三个步骤。 第一步是创建用来表示新节点的Node类实例（行{1}）。只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针的值会由构造函数自动设置为null。 第二步要验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点（行{2}）。如果是，就将根节点指向新节点 第三步是将节点加在非根节点的其他位置。这种情况下，需要一个私有的辅助函数（行{3}），函数定义如下： 123456789101112131415var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125;&#125;; 如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入树的根节点和要插入的节点。 如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}），那么需要检查当前节点的左侧子节点。如果它没有左侧子节点（行{5}），就在那里插入新的节点。 如果有左侧子节点，需要通过递归调用insertNode方法（行{7}）继续找到树的下一层。在这里，下次将要比较的节点将会是当前节点的左侧子节点。 如果节点的键比当前节点的键大，同时当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。如果有右侧子节点，同样需要递归调用insertNode方法，但是要用来和新节点比较的节点将会是右侧子节点。 让我们通过一个例子来更好地理解这个过程。 考虑下面的情景：我们有一个新的树，并且想要向它插入第一个值。 12var tree = new BinarySearchTree();tree.insert(11); 这种情况下，树中有一个单独的节点，根指针将会指向它。源代码的行{2}将会执行。 现在，来考虑下图所示树结构的情况： 创建上图所示的树的代码如下，它们接着上面一段代码（插入了键为11的节点）之后输入执行： 12345678910111213tree.insert(7);tree.insert(15);tree.insert(5);tree.insert(3);tree.insert(9);tree.insert(8);tree.insert(10);tree.insert(13);tree.insert(12);tree.insert(14);tree.insert(20);tree.insert(18);tree.insert(25); 同时我们想要插入一个值为6的键，执行下面的代码： tree.insert(6); 下面的步骤将会被执行。 树不是空的，行{3}的代码将会执行。insertNode方法将会被调用（root, key[6]）。 算法将会检测行{4}（key[6] &lt; root[11]为真），并继续检测行{5}（node.left[7]不是null），然后将到达行{7}并调用insertNode（node.left[7], key[6]）。 将再次进入insertNode方法内部，但是使用了不同的参数。它会再次检测行{4}（key[6]&lt; node[7]为真），然后再检测行{5}（node.left[5]不是null），接着到达行{7}，调用insertNode（node.left[5], key[6]）。 将再一次进入insertNode方法内部。它会再次检测行{4}（key[6] &lt; node[5]为假），然后到达行{8}（node.right是null 然后，方法调用会依次出栈，代码执行过程结束 这是插入键6后的结果： 四、树的遍历遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做呢？应该从树的顶端还是底端开始呢？从左开始还是从右开始呢？访问树的所有节点有三种方式：中序、先序和后序。 4.1 中序遍历中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。我们来看它的实现： 123this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback); //&#123;1&#125;&#125;; inOrderTraverse方法接收一个回调函数作为参数。回调函数用来定义我们对遍历到的每个节点进行的操作（这也叫作访问者模式，要了解更多关于访问者模式的信息，请参考http://en.wikipedia.org/wiki/Visitor_pattern）。由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）。 1234567var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125;&#125;; 要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为null（这就是停止递归继续执行的判断条件——行{2}——递归算法的基本条件）。 然后，递归调用相同的函数来访问左侧子节点（行{3}）。接着对这个节点进行一些操作（callback），然后再访问右侧子节点（行{5}）。 我们试着在之前展示的树上执行下面的方法： 1234function printNode(value)&#123; //&#123;6&#125; console.log(value);&#125;tree.inOrderTraverse(printNode); //&#123;7&#125; 但首先，需要创建一个回调函数（行{6}）。我们要做的，是在浏览器的控制台上输出节点的值。然后，调用inOrderTraverse方法并将回调函数作为参数传入（行{7}）。当执行上面的代码后，下面的结果将会在控制台上输出（每个数字将会输出在不同的行）： 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25 完整案例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//创建 BinarySearchTree 类function BinarySearchTree() &#123; var Node = function (key) &#123; //&#123;1&#125; this.key = key; this.left = null; this.right = null; &#125;; var root = null; //&#123;2&#125; //私有的辅助函数 var insertNode = function (node, newNode) &#123; if (newNode.key &lt; node.key) &#123; //&#123;4&#125; if (node.left === null) &#123; //&#123;5&#125; node.left = newNode; //&#123;6&#125; &#125; else &#123; insertNode(node.left, newNode); //&#123;7&#125; &#125; &#125; else &#123; if (node.right === null) &#123; //&#123;8&#125; node.right = newNode; //&#123;9&#125; &#125; else &#123; insertNode(node.right, newNode); //&#123;10&#125; &#125; &#125; &#125;; //insert向树中插入一个键 this.insert = function (key) &#123; var newNode = new Node(key); //&#123;1&#125; if (root === null) &#123; //&#123;2&#125; root = newNode; &#125; else &#123; insertNode(root, newNode); //&#123;3&#125; &#125; &#125;; //inOrderTraverse中序遍历 this.inOrderTraverse = function (callback) &#123; // console.log(callback) inOrderTraverseNode(root, callback); //&#123;1&#125; &#125;; var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; //&#123;2&#125; inOrderTraverseNode(node.left, callback); //&#123;3&#125; callback(node.key); //&#123;4&#125; inOrderTraverseNode(node.right, callback); //&#123;5&#125; &#125; &#125;; // tree.inOrderTraverse(printNode); //&#123;7&#125; &#125; let binarySearchTree = new BinarySearchTree();function printNode(value) &#123; //&#123;6&#125; console.log(value);&#125;binarySearchTree.insert(7);binarySearchTree.insert(15);binarySearchTree.insert(5);binarySearchTree.insert(3);binarySearchTree.insert(9);binarySearchTree.insert(8);binarySearchTree.insert(10);binarySearchTree.insert(13);binarySearchTree.insert(12);binarySearchTree.insert(14);binarySearchTree.insert(20);binarySearchTree.insert(18);binarySearchTree.insert(25); binarySearchTree.insert(6); binarySearchTree.inOrderTraverse(printNode) 下面的图描绘了inOrderTraverse方法的访问路径： 4.2 先序遍历先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。 我们来看实现: 1234567891011this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback);&#125;; //preOrderTraverseNode方法的实现如下：var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key); //&#123;1&#125; preOrderTraverseNode(node.left, callback); //&#123;2&#125; preOrderTraverseNode(node.right, callback); //&#123;3&#125; &#125;&#125;; 先序遍历和中序遍历的不同点是，先序遍历会先访问节点本身（行{1}），然后再访问它的左侧子节点（行{2}），最后是右侧子节点（行{3}），而中序遍历的执行顺序是：{2}、{1}和{3}。 下面是控制台上的输出结果（每个数字将会输出在不同的行）： 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25 下面的图描绘了preOrderTraverse方法的访问路径： 4.3 后序遍历后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。 我们来看它的实现： 1234567891011this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback);&#125;;//postOrderTraverseNode方法的实现如下：var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); //&#123;1&#125; postOrderTraverseNode(node.right, callback); //&#123;2&#125; callback(node.key); //&#123;3&#125; &#125;&#125;; 这个例子中，后序遍历会先访问左侧子节点（行{1}），然后是右侧子节点（行{2}），最后是父节点本身（行{3}）。 你会发现，中序、先序和后序遍历的实现方式是很相似的，唯一不同的是行{1}、{2}和{3}的执行顺序。 下面是控制台的输出结果（每个数字将会输出在不同行）： 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11 下面的图描绘了postOrderTraverse方法的访问路径： 五、搜索树中的值在树中，有三种经常执行的搜索类型： 搜索最小值搜索最大值搜索特定的值 5.1 搜索最小值和最大值我们使用下面的树作为示例： 只用眼睛看这张图，你能一下找到树中的最小值和最大值吗？ 如果你看一眼树最后一层最左侧的节点，会发现它的值为3，这是这棵树中最小的键。如果你再看一眼树最右端的节点（同样是树的最后一层），会发现它的值为25，这是这棵树中最大的键。这条信息在我们实现搜索树节点的最小值和最大值的方法时能给予我们很大的帮助。 首先，我们来看寻找树的最小键的方法： 123this.min = function() &#123; return minNode(root);&#125; min方法将会暴露给用户。这个方法调用了minNode方法（行{1}）： 123456789var minNode = function(node) &#123; if(node) &#123; while(node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node.key; &#125; return null;&#125; minNode方法允许我们从树中任意一个节点开始寻找最小的键。我们可以使用它来找到一棵树或它的子树中最小的键。因此，我们在调用minNode方法的时候传入树的根节点（行{1}），因为我们想要找到整棵树的最小键。 在minNode内部，我们会遍历树的左边（行{2}和行{3}）直到找到树的最下层（最左端）。 以相似的方式，可以实现max方法： 1234567891011121314this.max = function() &#123; return maxNode(root);&#125;//maxNode方法实现var maxNode = function(node) &#123; if(node) &#123; while(node &amp;&amp; node.right !== null) &#123; node = node.right; &#125; return node.key; &#125; return null;&#125; 要找到最大的键，我们要沿着树的右边进行遍历（行{5}）直到找到最右端的节点。 因此，对于寻找最小值，总是沿着树的左边；而对于寻找最大值，总是沿着树的右边。 5.2 搜索一个特定的值在之前的学习中，我们同样实现了find、search或get方法来查找数据结构中的一个特定的值（和之前实现的has方法相似）。我们将同样在BST中实现搜索的方法，来看它的实现： 123456789101112131415this.search = function (key) &#123; return searchNode(root, key); //&#123;1&#125;&#125;;var searchNode = function (node, key) &#123; if (node === null) &#123; //&#123;2&#125; return false; &#125; if (key &lt; node.key) &#123; //&#123;3&#125; return searchNode(node.left, key); //&#123;4&#125; &#125; else if (key &gt; node.key) &#123; //&#123;5&#125; return searchNode(node.right, key); //&#123;6&#125; &#125; else &#123; return true; //&#123;7&#125; &#125;&#125;; 我们要做的第一件事，是声明search方法。和BST中声明的其他方法的模式相同，我们将会使用一个辅助函数（行{1}）。 searchNode方法可以用来寻找一棵树或它的任意子树中的一个特定的值。这也是为什么在行{1}中调用它的时候传入树的根节点作为参数。 在开始算法之前，先要验证作为参数传入的node是否合法（不是null）。如果是null的话，说明要找的键没有找到，返回false。 如果传入的节点不是null，需要继续验证。如果要找的键比当前的节点小（行{3}），那么继续在左侧的子树上搜索（行{4}）。如果要找的键比当前的节点大，那么就从右侧子节点开始继续搜索（行{6}），否则就说明要找的键和当前节点的键相等，就返回true来表示找到了这个键（行{7}）。 可以通过下面的代码来测试这个方法： console.log(binarySearchTree.search(1) ? ‘Key 1 found.’ : ‘Key 1 not found.’);console.log(binarySearchTree.search(8) ? ‘Key 8 found.’ : ‘Key 8 not found.’); 输出结果如下： Value 1 not found.Value 8 found. 让我们详细展示查找1这个键的时候方法是如何执行的。 (1) 调用searchNode方法，传入根节点作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们执行到行{3}。(2) （key[1] &lt; node[11]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[7], key[1]）作为参数。(3) （node[7]）不是null（{2}），因此继续执行行{3}。(4) （key[1] &lt; node[7]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[5], key[1]）作为参数。(5) （node[5]）不是null（行{2}），因此继续执行行{3}。(6) （key[1] &lt; node[5]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[3], key[1]）作为参数。(7) （node[3]）不是null（行{2}），因此来到行{3}。(8) （key[1] &lt; node[3]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（null, key[1]）作为参数。null被作为参数传入是因为node[3]是一个叶节点（它没有子节点，所以它的左侧子节点的值为null）。(9) 节点（null）的值为null（行{2}，这时要搜索的节点为null），因此返回false。(10) 然后，方法调用会依次出栈，代码执行过程结束。 让我们再来查找值为8的节点。 (1) 调用searchNode方法，传入root作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们来到行{3}。(2) （key[8] &lt; node[11]）为真（行{3}），因此执行到行{4}并再次调用searchNode方法，传入（node[7], key[8]）作为参数。(3) （node[7]）不是null，因此来到行{3}。(4) （key[8] &lt; node[7]）为假（行{3}），因此来到行{5}。(5) （key[8] &gt; node[7]）为真（行{5}），因此来到行{6}并再次调用searchNode方法，传入（node[9], key[8]）作为参数。(6) （node[9]）不是null（行{2}），因此来到行{3}。(7) （key[8] &lt; node[9]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[8], key[8]）作为参数。(8) （node[8]）不是null（行{2}），因此来到行{3}。(9) （key[8] &lt; node[8]）为假（行{3}），因此来到行{5}。(10)（key[8] &gt; node[8]）为假（行{5}），因此来到行{7}并返回true，因为node[8]就是要找的键。(11) 然后，方法调用会依次出栈，代码执行过程结束。 5.3 移除一个节点我们要为BST实现的下一个、也是最后一个方法是remove方法。这是我们在本书中要实现的最复杂的方法。我们先创建这个方法，使它能够在树的实例上被调用： 123this.remove = function(key)&#123; root = removeNode(root, key); //&#123;1&#125; &#125;; 这个方法接收要移除的键并且它调用了removeNode方法，传入root和要移除的键作为参数（行{1}）。我要提醒大家的一件非常重要的事情是，root被赋值为removeNode方法的返回值。我们稍后会明白其中的原因。 removeNode方法的复杂之处在于我们要处理不同的运行场景，当然也包括它同样是通过递归来实现的。 我们来看removeNode方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940this.remove = function (key) &#123; root = removeNode(root, key); //&#123;1&#125; &#125;; var removeNode = function (node, key) &#123; if (node === null) &#123; //&#123;2&#125; return null; &#125; if (key &lt; node.key) &#123; //&#123;3&#125; node.left = removeNode(node.left, key); //&#123;4&#125; return node; //&#123;5&#125; &#125; else if (key &gt; node.key) &#123; //&#123;6&#125; node.right = removeNode(node.right, key); //&#123;7&#125; return node; //&#123;8&#125; &#125; else &#123; //键等于node.key //第一种情况——一个叶节点 if (node.left === null &amp;&amp; node.right === null) &#123; //&#123;9&#125; node = null; //&#123;10&#125; return node; //&#123;11&#125; &#125; //第二种情况——一个只有一个子节点的节点 if (node.left === null) &#123; //&#123;12&#125; node = node.right; //&#123;13&#125; return node; //&#123;14&#125; &#125; else if (node.right === null) &#123; //&#123;15&#125; node = node.left; //&#123;16&#125; return node; //&#123;17&#125; &#125; //第三种情况——一个有两个子节点的节点 var aux = findMinNode(node.right); //&#123;18&#125; node.key = aux.key; //&#123;19&#125; node.right = removeNode(node.right, aux.key); //&#123;20&#125; return node; //&#123;21&#125; &#125; var findMinNode = function (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node; &#125;; &#125;; 我们来看行{2}，如果正在检测的节点是null，那么说明键不存在于树中，所以返回null。 然后，我们要做的第一件事，就是在树中找到要移除的节点。因此，如果要找的键比当前节点的值小（行{3}），就沿着树的左边找到下一个节点（行{4}）。如果要找的键比当前节点的值大（行{6}），那么就沿着树的右边找到下一个节点（行{7}）。 如果我们找到了要找的键（键和node.key相等），就需要处理三种不同的情况。 5.3.1第一种情况是该节点是一个没有左侧或右侧子节点的叶节点——行{9}。在这种情况下，我们要做的就是给这个节点赋予null值来移除它（行{9}）。但是当学习了链表的实现之后，我们知道仅仅赋一个null值是不够的，还需要处理指针。在这里，这个节点没有任何子节点，但是它有一个父节点，需要通过返回null来将对应的父节点指针赋予null值（行{11}）。 现在节点的值已经是null了，父节点指向它的指针也会接收到这个值，这也是我们要在函数中返回节点的值的原因。父节点总是会接收到函数的返回值。另一种可行的办法是将父节点和节点本身都作为参数传入方法内部。 如果回头来看方法的第一行代码，会发现我们在行{4}和行{7}更新了节点左右指针的值，同样也在行{5}和行{8}返回了更新后的节点。 下图展现了移除一个叶节点的过程： 5.3.2 移除有一个左侧或右侧子节点的节点现在我们来看第二种情况，移除有一个左侧子节点或右侧子节点的节点。这种情况下，需要跳过这个节点，直接将父节点指向它的指针指向子节点。如果这个节点没有左侧子节点（行{12}），也就是说它有一个右侧子节点。因此我们把对它的引用改为对它右侧子节点的引用（行{13}）并返回更新后的节点（行{14}）。如果这个节点没有右侧子节点，也是一样——把对它的引用改为对它左侧子节点的引用（行{16}）并返回更新后的值（行{17}）。 下图展现了移除只有一个左侧子节点或右侧子节点的节点的过程： 5.3.3 移除有两个子节点的节点现在是第三种情况，也是最复杂的情况，那就是要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。 (1) 当找到了需要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们改变了这个节点的键，也就是说它被移除了。(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。 findMinNode方法的实现和min方法的实现方式是一样的。唯一不同之处在于，在min方法中只返回键，而在findMinNode中返回了节点。 下图展现了移除有两个子节点的节点的过程： 六、 自平衡树BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层，如下图所示： 这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作Adelson-Velskii-Landi树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树。 6.1 Adelson-Velskii-Landi 树（AVL 树）AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1。添加或移除节点时，AVL树会尽可能尝试转换为完全树。 6.1.1 在AVL树中插入节点在AVL树中插入或移除节点和BST完全相同。然而，AVL树的不同之处在于我们需要检验它的平衡因子，如果有需要，则将其逻辑应用于树的自平衡。 下面的代码是向AVL树插入新节点的例子： 12345678910111213141516var insertNode = function(node, element) &#123; if (node === null) &#123; node = new Node(element); &#125; else if (element &lt; node.key) &#123; node.left = insertNode(node.left, element); if (node.left !== null) &#123; // 确认是否需要平衡 &#123;1&#125; &#125; &#125; else if (element &gt; node.key) &#123; node.right = insertNode(node.right, element); if (node.right !== null) &#123; // 确认是否需要平衡 &#123;2&#125; &#125; &#125; return node;&#125;; 然而，插入新节点时，还要检查是否需要平衡树（行{1}和行{2}） 计算平衡因子 在AVL树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）的差值，该值（hr－hl）应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。这就是平衡因子的概念。 下图举例说明了一些树的平衡因子（所有的树都是平衡的）： 计算节点高度的代码如下： 1234567var heightNode = function(node) &#123; if (node === null) &#123; return -1; &#125; else &#123; return Math.max(heightNode(node.left),heightNode(node.right)) + 1; &#125;&#125;; 因此，向左子树插入新节点时，需要计算其高度；如果高度大于1（即不为-1、0和1之一），就需要平衡左子树。代码如下： 12345678910// 替换insertNode方法的行&#123;1&#125;if ((heightNode(node.left) - heightNode(node.right)) &gt; 1) &#123; // 旋转 &#123;3&#125;&#125;//向右子树插入新节点时，应用同样的逻辑，代码如下：// 替换insertNode方法的行&#123;2&#125;if ((heightNode(node.right) - heightNode(node.left)) &gt; 1) &#123; // 旋转 &#123;4&#125;&#125; AVL旋转 向AVL树插入节点时，可以执行单旋转或双旋转两种平衡操作，分别对应四种场景。 右-右（RR）：向左的单旋转左-左（LL）：向右的单旋转左-右（LR）：向右的双旋转右-左（RL）：向左的双旋转 我们依次看看它们是如何工作的。 右-右（RR）：向左的单旋转 如下图所示： 假设向AVL树插入节点90，这会造成树失衡（节点50-Y高度为-2），因此需要恢复树的平衡。下面是我们执行的操作： 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为-2）所在的位置（行{1}）；节点X的右子树保持不变；将节点Y的右子节点置为节点X的左子节点Z（行{2}）；将节点X的左子节点置为节点Y（行{3}）。 下面的代码举例说明了整个过程： 123456var rotationRR = function(node) &#123; var tmp = node.right; // &#123;1&#125; node.right = tmp.left; // &#123;2&#125; tmp.left = node; // &#123;3&#125; return tmp;&#125;; 左-左（LL）：向右的单旋转 如下图所示： 假设向AVL树插入节点5，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作： 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为+2）所在的位置（行{1}）；节点X的左子树保持不变；将节点Y的左子节点置为节点X的右子节点Z（行{2}）；将节点X的右子节点置为节点Y（行{3}）。 下面的代码举例说明了整个过程： 123456var rotationLL = function(node) &#123; var tmp = node.left; // &#123;1&#125; node.left = tmp.right; // &#123;2&#125; tmp.right = node; // &#123;3&#125; return tmp;&#125;; 左-右（LR）：向右的双旋转 如下图所示： 假设向AVL树插入节点35，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作： 将节点X置于节点Y（平衡因子为+2）所在的位置；将节点Y的左子节点置为节点X的右子节点；将节点Z的右子节点置为节点X的左子节点；将节点X的右子节点置为节点Y；将节点X的左子节点置为节点Z。 基本上，就是先做一次RR旋转，再做一次LL旋转 下面的代码举例说明了整个过程： 1234var rotationLR = function(node) &#123; node.left = rotationRR(node.left); return rotationLL(node);&#125;; 右-左（RL）：向左的双旋转 如下图所示： 假设向AVL树插入节点75，这会造成树失衡（节点70-Y高度为-2），需要恢复树的平衡。下面是我们执行的操作： 将节点X置于节点Y（平衡因子为-2）所在的位置；将节点Z的左子节点置为节点X的右子节点；将节点Y的右子节点置为节点X的左子节点；将节点X的左子节点置为节点Y；将节点X的右子节点置为节点Z。 基本上，就是先做一次LL旋转，再做一次RR旋转 下面的代码举例说明了整个过程： 1234var rotationRL = function(node) &#123; node.right = rotationLL(node.right); return rotationRR(node);&#125;; 完成insertNode方法 确认树需要平衡后，就需要对每种情况分别应用正确的旋转。 向左子树插入新节点，且节点的值小于其左子节点时，应进行LL旋转。否则，进行LR旋转。该过程的代码如下： 123456789// 替换insertNode方法的行&#123;1&#125;if ((heightNode(node.left) - heightNode(node.right)) &gt; 1)&#123; // 旋转 &#123;3&#125; if (element &lt; node.left.key)&#123; node = rotationLL(node); &#125; else &#123; node = rotationLR(node); &#125;&#125; 向右子树插入新节点，且节点的值大于其右子节点时，应进行RR旋转。否则，进行RL旋转。该过程的代码如下： 123456789// 替换insertNode方法的行&#123;2&#125;if ((heightNode(node.right) - heightNode(node.left)) &gt; 1)&#123; // 旋转 &#123;4&#125; if (element &gt; node.right.key)&#123; node = rotationRR(node); &#125; else &#123; node = rotationRL(node); &#125;&#125; 七、 小结在本节中，我们学习了在计算机科学中被广泛使用的基本树数据结构——二叉搜索树中添加、搜索和移除项的算法。我们同样介绍了访问树中每个节点的三种遍历方式。此外还学习了如何开发名叫AVL的自平衡树。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法七（字典和散列表）","date":"2019-01-18T11:40:59.000Z","path":"2019/01/18/cjw08ytag001ckwvba3d2jg2x/","text":"字典和散也是用来存储唯一值（不重复的值）的数据结构。 集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。 一、 字典前面已经学习过，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。 1.1 创建字典首先创建Dictionary类的骨架： 123function Dictionary() &#123; var items = &#123;&#125;;&#125; 与Set类类似，我们将在一个Object的实例而不是数组中存储元素。然后，我们需要声明一些映射/字典所能使用的方法。 set(key,value)：向字典中添加新元素。delete(key)：通过使用键值来从字典中移除键值对应的数据值。has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。get(key)：通过键值查找特定的数值并返回。clear()：将这个字典中的所有元素全部删除。size()：返回字典所包含元素的数量。与数组的length属性类似。keys()：将字典所包含的所有键名以数组形式返回。values()：将字典所包含的所有数值以数组形式返回。 1.1.1 has 和 set 方法我们首先来实现has(key)方法。之所以要先实现这个方法，是因为它会被set和remove等其他方法调用。我们可以通过如下代码来实现： 123this.has = function(key) &#123; return key in items;&#125;; 这个方法的实现和我们之前在Set类中的实现是一样的。我们使用JavaScript中的in操作符来验证一个key是否是items对象的一个属性。 然后是set方法的实现： 123this.set = function(key, value) &#123; items[key] = value; //&#123;1&#125;&#125;; 该方法接受一个key和一个value作为参数。我们直接将value设为items对象的key属性的值。它可以用来给字典添加一个新的值，或者用来更新一个已有的值。 1.1.2 delete方法接下来，我们实现delete方法。它和Set类中的delete方法很相似，唯一的不同点在于我们将先搜索key（而不是value）： 1234567this.delete= function(key) &#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false;&#125;; 然后我们可以使用JavaScript的delete操作符来从items对象中移除key属性。 1.1.3 get和values方法如果我们想在字典中查找一个特定的项，并检索它的值，可以使用下面的方法： 123this.get = function(key) &#123; return this.has(key) ? items[key] : undefined;&#125;; get方法首先会验证我们想要检索的值是否存在（通过查找key值），如果存在，将返回该值，反之将返回一个undefined值（请记住undefined值和null值是不一样的 下一个是values方法。这个方法以数组的形式返回字典中所有values实例的值： 123456789this.values = function() &#123; let values = []; for(var key in items) &#123; //&#123;1&#125; if(this.has(key)) &#123; values.push(items[key]) //&#123;2&#125; &#125; &#125; return values&#125; 首先，我们遍历items对象的所有属性值（行{1}）。为了确定值存在，我们使用has函数来验证key确实存在，然后将它的值加入values数组（行{2}）。最后，我们就能返回所有找到的值。 我们不能仅仅使用for-in语句来遍历items对象的所有属性，还需要使用hasOwnProperty方法（验证items对象是否包含某个属性），因为对象的原型也会包含对象的其他属性（JavaScript基本的Object类中的属性将会被继承，并存在于当前对象中，而对于这个数据结构来说，我们并不需要它们）。 1.1.4 clear、size、keys和getItems方法clear和size 方法与前面介绍的Set类中对应的方法是完全一样的。 keys方法返回在Dictionary类中所有用于标识值的键名。要取出一个JavaScript对象中所有的键名，可以把这个对象作为参数传入Object类的keys方法（到目前为止，书中创建的类，包括Dictionary在内，都是JavaScript对象），如下： 123this.keys = function() &#123; return object.keys(items)&#125; 最后，我们来验证items属性的输出值。我们可以实现一个返回items变量的方法，叫作getItems： 123this.getItems = function() &#123; return items;&#125; 1.1.5 使用Dictionary首先，我们来创建一个Dictionary类的实例，然后给它添加三条电子邮件地址。我们将会使用这个dictionary实例来实现一个电子邮件地址簿。 使用我们创建的类来执行如下代码： 1234var dictionary = new Dictionary();dictionary.set('Gandalf', 'gandalf@email.com');dictionary.set('John', 'johnsnow@email.com');dictionary.set('Tyrion', 'tyrion@email.com'); 如果执行了如下代码，输出结果将会是true： console.log(dictionary.has(‘Gandalf’)); 下面的代码将会输出3，因为我们向字典实例中添加了三个元素： console.log(dictionary.size()); 现在，执行下面的几行代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.get(‘Tyrion’)); 输出结果分别如下所示： [“Gandalf”, “John”, “Tyrion”][“gandalf@email.com“, “johnsnow@email.com“, “tyrion@email.com“]tyrion@email.com 最后，再执行几行代码： dictionary.delete(‘John’); 再执行下面的代码： console.log(dictionary.keys());console.log(dictionary.values());console.log(dictionary.getItems()); 输出结果如下所示： [“Gandalf”, “Tyrion”][“gandalf@email.com“, “tyrion@email.com“]Object {Gandalf: “gandalf@email.com“, Tyrion:”tyrion@email.com“} 移除了一个元素后，现在的dictionary实例中只包含两个元素了。 二、 散列表接下来我们会学到HashTable类，也叫HashMap类，它是Dictionary类的一种散列表实现方式。 散列算法的作用是尽可能快地在数据结构中找到一个值。在前面我们已经知道如果要在数据结构中获得一个值（使用get方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址 举个例子，我们继续使用字典中的案例使用电子邮件地址簿。我们将要使用最常见的散列函数——“lose lose”散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。 2.1 创建散列表我们将使用数组来表示我们的数据结构，该数据结构的图表（“lose lose”）所用的非常相似。 和之前一样，我们从搭建类的骨架开始： 123function HashTable() &#123; var table = [];&#125; 然后，给类添加一些方法。我们给每个类实现三个基本方法 put(key,value)：向散列表增加一个新的项（也能更新散列表）。remove(key)：根据键值从散列表中移除值。get(key)：返回根据键值检索到的特定的值。 在实现这三个方法之前，要实现的第一个方法是散列函数，它是HashTable类中的一个私有方法： 1234567var loseloseHashCode = function (key) &#123; var hash = 0; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash += key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 37; //&#123;4&#125;&#125;; 给定一个key参数，我们就能根据组成key的每个字符的ASCII码值的和得到一个数字。所以，首先需要一个变量来存储这个总和（行{1}）。然后，遍历key（行{2}）并将从ASCII表中查到的每个字符对应的ASCII值加到hash变量中（可以使用JavaScript的String类中的charCodeAt方法——行{3}）。最后，返回hash值。为了得到比较小的数值，我们会使用hash值和一个任意数做除法的余数（mod）。 现在，有了散列函数，我们就可以实现put方法了： 12345this.put = function (key, value) &#123; var position = loseloseHashCode(key); //&#123;5&#125; console.log(position + ' - ' + key); //&#123;6&#125; table[position] = value; //&#123;7&#125;&#125;; 首先，根据给定的key，我们需要根据所创建的散列函数计算出它在表中的位置（行{5}）。为了便于展示信息，我们将计算出的位置输出至控制台（行{6}）。由于它不是必需的，我们也可以将这行代码移除。然后要做的，是将value参数添加到用散列函数计算出的对应的位置上。（行{7}）。 从HashTable实例中查找一个值也很简单。为此，我们将会实现一个get方法： 123this.get = function (key) &#123; return table[loseloseHashCode(key)];&#125;; 首先，我们会使用所创建的散列函数来求出给定key所对应的位置。这个函数会返回值的位置，因此我们所要做的就是根据这个位置从数组table中获得这个值。 我们要实现的最后一个方法是remove方法： 123this.remove = function(key) &#123; table[loseloseHashCode(key)] = undefined;&#125;; 要从HashTable实例中移除一个元素，只需要求出元素的位置（可以使用散列函数来获取）并赋值为undefined。 对于HashTable类来说，我们不需要像ArrayList类一样从table数组中将位置也移除。由于元素分布于整个数组范围内，一些位置会没有任何元素占据，并默认为undefined值。我们也不能将位置本身从数组中移除（这会改变其他元素的位置），否则，当下次需要获得或移除一个元素的时候，这个元素会不在我们用散列函数求出的位置上。 2.2 使用 HashTable 类让我们执行一些代码来测试HashTable类: var hash = new HashTable();hash.put(‘Gandalf’, &#39;gandalf@email.com‘);hash.put(‘John’, &#39;johnsnow@email.com‘);hash.put(‘Tyrion’, &#39;tyrion@email.com‘); 执行上述代码，会在控制台中获得如下输出： 19 - Gandalf29 - John16 - Tyrion 下面的图表展现了包含这三个元素的HashTable数据结构： 现在来测试get方法： console.log(hash.get(‘Gandalf’));console.log(hash.get(‘Loiane’)); 获得如下的输出： gandalf@email.comundefined 由于Gandalf是一个在散列表中存在的键，get方法将会返回它的值。而由于Loiane是一个不存在的键，当我们试图在数组中根据位置获取值的时候（一个由散列函数生成的位置），返回值将会是undefined（即不存在）。 然后，我们试试从散列表中移除Gandalf： hash.remove(‘Gandalf’);console.log(hash.get(‘Gandalf’)); 由于Gandalf不再存在于表中，hash.get(‘Gandalf’)方法将会在控制台上给出undefined的输出结果。 2.3 散列表和散列集合散列表和散列映射是一样的，我们学习过这种数据结构了。 在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是散列函数。我们可以重用本章实现HashTable的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。 2.4 处理散列表中的冲突有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。例如，我们看看下面的代码会得到怎样的输出结果： 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 注意，Tyrion和Aaron有相同的散列值（16）。Donnie和Ana有相同的散列值（13），Jonathan、Jamie和Sue有相同的散列值（5），Mindy和Paul也有相同的散列值（32）。 那HashTable实例会怎样呢？执行之前的代码后散列表中会有哪些值呢？ 为了获得结果，我们来实现一个叫作print的辅助方法，它会在控制台上输出HashTable中的值： 1234567this.print = function () &#123; for (var i = 0; i &lt; table.length; ++i) &#123; //&#123;1&#125; if (table[i] !== undefined) &#123; //&#123;2&#125; console.log(i + \": \" + table[i]);//&#123;3&#125; &#125; &#125;&#125;; 现在来使用这个方法： hash.print(); 在控制台上得到如下的输出结果： 12345675: sue @email.com10: nathan@email.com13: ana@email.com16: aaron@email.com19: gandalf@email.com29: johnsnow@email.com32: paul@email.com Jonathan、Jamie和Sue有相同的散列值，也就是5。由于Sue是最后一个被添加的，Sue将是在HashTable实例中占据位置5的元素。首先，Jonathan会占据这个位置，然后Jamie会覆盖它，然后Sue会再次覆盖。这对于其他发生冲突的元素来说也是一样的。 使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接、线性探查和双散列法。在本节中，我们会介绍前两种方法。 2.4.1 分离链接分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。 例如，我们在之前的测试代码中使用分离链接的话，输出结果将会是这样： 在位置5上，将会有包含三个元素的LinkedList实例；在位置13、16和32上，将会有包含两个元素的LinkedList实例；在位置10、19和29上，将会有包含单个元素的LinkedList实例。 对于分离链接和线性探查来说，只需要重写三个方法：put、get和remove。这三个方法在每种技术实现中都是不同的。 为了实现一个使用了分离链接的HashTable实例，我们需要一个新的辅助类来表示将要加入LinkedList实例的元素。我们管它叫ValuePair类（在HashTable类内部定义）： 1234567var ValuePair = function (key, value) &#123; this.key = key; this.value = value; this.toString = function () &#123; return '[' + this.key + ' - ' + this.value + ']'; &#125;&#125;; 这个类只会将key和value存储在一个Object实例中。我们也重写了toString方法，以便之后在浏览器控制台中输出结果。 put方法 我们来实现第一个方法，put方法，代码如下： 1234567this.put = function (key, value) &#123; var position = loseloseHashCode(key); if (table[position] == undefined) &#123; //&#123;1&#125; table[position] = new LinkedList(); &#125; table[position].append(new ValuePair(key, value)); //&#123;2&#125;&#125;; 在这个方法中，将验证要加入新元素的位置是否已经被占据（行{1}）。如果这个位置是第一次被加入元素，我们会在这个位置上初始化一个LinkedList类的实例（你已经在第5章中学习过）。然后，使用第5章中实现的append方法向LinkedList实例中添加一个ValuePair实例（键和值）（行{2}）。 (2) get方法 然后，我们实现用来获取特定值的get方法： 123456789101112131415161718this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;3&#125; //遍历链表来寻找键/值 var current = table[position].getHead(); //&#123;4&#125; while (current.next) &#123; //&#123;5&#125; if (current.element.key === key) &#123; //&#123;6&#125; return current.element.value; //&#123;7&#125; &#125; current = current.next; //&#123;8&#125; &#125; //检查元素在链表第一个或最后一个节点的情况 if (current.element.key === key) &#123; //&#123;9&#125; return current.element.value; &#125; &#125; return undefined; //&#123;10&#125;&#125;; 我们要做的第一个验证，是确定在特定的位置上是否有元素存在（行{3}）。如果没有，则返回一个undefined表示在HashTable实例中没有找到这个值（行{10}）。如果在这个位置上有值存在，我们知道这是一个LinkedList实例。现在要做的是遍历这个链表来寻找我们需要的元素。在遍历之前先要获取链表表头的引用（行{4}），然后就可以从链表的头部遍历到尾部（行{5}，current.next将会是null）。 Node链表包含next指针和element属性。而element属性又是ValuePair的实例，所以它又有value和key属性。可以通过current.element.key来获得Node链表的key属性，并通过比较它来确定它是否就是我们要找的键（行{6}）。（这就是要使用ValuePair这个辅助类来存储元素的原因。我们不能简单地存储值本身，这样就不能确定哪个值对应着特定的键。）如果key值相同，就返回Node的值（行{7}）；如果不相同，就继续遍历链表，访问下一个节点（行{8}）。 如果要找的元素是链表的第一个或最后一个节点，那么就不会进入while循环的内部。因此，需要在行{9}处理这种特殊的情况 remove方法 使用分离链接法从HashTable实例中移除一个元素和之前在本章实现的remove方法有一些不同。现在使用的是链表，我们需要从链表中移除一个元素。来看看remove方法的实现： 12345678910111213141516171819202122232425this.remove = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; var current = table[position].getHead(); while (current.next) &#123; if (current.element.key === key) &#123; //&#123;11&#125; table[position].remove(current.element); //&#123;12&#125; if (table[position].isEmpty()) &#123; //&#123;13&#125; table[position] = undefined; //&#123;14&#125; &#125; return true; //&#123;15&#125; &#125; current = current.next; &#125; // 检查是否为第一个或最后一个元素 if (current.element.key === key) &#123; //&#123;16&#125; table[position].remove(current.element); if (table[position].isEmpty()) &#123; table[position] = undefined; &#125; return true; &#125; &#125; return false; //&#123;17&#125;&#125;; 在remove方法中，我们使用和get方法一样的步骤找到要找的元素。遍历LinkedList实例时，如果链表中的current元素就是要找的元素（行{11}），使用remove方法将其从链表中移除。然后进行一步额外的验证：如果链表为空了（行{13}——链表中不再有任何元素了），就将散列表这个位置的值设为undefined（行{14}），这样搜索一个元素或打印它的内容的时候，就可以跳过这个位置了。最后，返回true表示这个元素已经被移除（行{15}）或者在最后返回false表示这个元素在散列表中不存在（行{17}）。同样，需要和get方法一样，处理元素在第一个或最后一个的情况（行{16}）。 重写了这三个方法后，我们就拥有了一个使用了分离链接法来处理冲突的HashMap实例。 2.4.1 线性探查另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推 然后重写put、get、remove方法 put方法 123456789101112this.put = function (key, value) &#123; var position = loseloseHashCode(key); // &#123;1&#125; if (table[position] == undefined) &#123; // &#123;2&#125; table[position] = new ValuePair(key, value); // &#123;3&#125; &#125; else &#123; var index = ++position; // &#123;4&#125; while (table[index] != undefined) &#123; // &#123;5&#125; index++; // &#123;6&#125; &#125; table[index] = new ValuePair(key, value); // &#123;7&#125; &#125;&#125;; 和之前一样，先获得由散列函数生成的位置（行{1}），然后验证这个位置是否有元素存在（如果这个位置被占据了，将会通过行{2}的验证）。如果没有元素存在，就在这个位置加入新元素（行{3}——一个ValuePair的实例）。 如果这个位置已经被占据了，需要找到下一个没有被占据的位置（position的值是undefined），因此我们声明一个index变量并赋值为position+1（行{4}——在变量名前使用自增运算符++会先递增变量值然后再将其赋值给index）。然后验证这个位置是否被占据（行{5}），如果被占据了，继续将index递增（行{6}），直到找到一个没有被占据的位置。然后要做的，就是将值分配到这个位置（行{7}）。 如果再次执行插入数据的代码: 12345678910111213var hash = new HashTable();hash.put('Gandalf', 'gandalf@email.com');hash.put('John', 'johnsnow@email.com');hash.put('Tyrion', 'tyrion@email.com');hash.put('Aaron', 'aaron@email.com');hash.put('Donnie', 'donnie@email.com');hash.put('Ana', 'ana@email.com');hash.put('Jonathan', 'jonathan@email.com');hash.put('Jamie', 'jamie@email.com');hash.put('Sue', 'sue@email.com');hash.put('Mindy', 'mindy@email.com');hash.put('Paul', 'paul@email.com');hash.put('Nathan', 'nathan@email.com'); 下图展示使用了线性探查的散列表的最终结果： 让我们来模拟一下散列表中的插入操作。 (1) 试着插入Gandalf。它的散列值是19，由于散列表刚刚被创建，位置19还是空的——可以在这里插入数据。(2) 试着在位置29插入John。它也是空的，所以可以插入这个姓名。(3) 试着在位置16插入Tyrion。它是空的，所以可以插入这个姓名。(4) 试着插入Aaron，它的散列值也是16。位置16已经被Tyrion占据了，所以需要检查索引值为position+1的位置（16+1）。位置17是空的，所以可以在位置17插入Aaron。(5) 接着，试着在位置13插入Donnie。它是空的，所以可以插入这个姓名。(6) 想在位置13插入Ana，但是这个位置被占据了。因此在位置14进行尝试，它是空的，所以可以在这里插入姓名。(7) 然后，在位置5插入Jonathan，这个位置是空的，所以可以插入这个姓名。(8) 试着在位置5插入Jamie，但是这个位置被占了。所以跳至位置6，这个位置是空的，因此可以在这个位置插入姓名。(9) 试着在位置5插入Sue，但是位置被占据了。所以跳至位置6，但也被占了。接着跳至位置7，这里是空的，所以可以在这里插入姓名。以此类推。 get方法 现在插入了所有的元素，让我们实现get方法来获取它们的值吧： 1234567891011121314151617this.get = function (key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; //&#123;8&#125; if (table[position].key === key) &#123; //&#123;9&#125; return table[position].value; //&#123;10&#125; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key) &#123; //&#123;11&#125; index++; &#125; if (table[index].key === key) &#123; //&#123;12&#125; return table[index].value; //&#123;13&#125; &#125; &#125; &#125; return undefined; //&#123;14&#125; &#125;; 要获得一个键对应的值，先要确定这个键存在（行{8}）。如果这个键不存在，说明要查找的值不在散列表中，因此可以返回undefined（行{14}）。如果这个键存在，需要检查我们要找的值是否就是这个位置上的值（行{9}）。如果是，就返回这个值（行{10}）。 如果不是，就在散列表中的下一个位置继续查找，直到找到一个键值与我们要找的键值相同的元素（行{11}）。然后，验证一下当前项就是我们要找的项（行{12}——只是为了确认一下）并且将它的值返回（行{13}）。 我们无法确定要找的元素实际上在哪个位置，这就是使用ValuePair来表示HashTable元素的原因。 remove方法 remove方法和get方法基本相同，不同之处在于行{10}和{13}，它们将会由下面的代码代替： table[index] = undefined; 要移除一个元素，只需要给其赋值为undefined，来表示这个位置不再被占据并且可以在必要时接受一个新元素。 2.5 创建更好的散列函数我们实现的“lose lose”散列函数并不是一个表现良好的散列函数，因为它会产生太多的冲突。如果我们使用这个函数的话，会产生各种各样的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。我们可以在网上找到一些不同的实现方法，或者也可以实现自己的散列函数。 另一个可以实现的比“lose lose”更好的散列函数是djb2： 1234567var djb2HashCode = function (key) &#123; var hash = 5381; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 1013; //&#123;4&#125;&#125;; 它包括初始化一个hash变量并赋值为一个质数（行{1}——大多数实现都使用5381），然后迭代参数key（行{2}），将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加（行{3}）。 最后，我们将使用相加的和与另一个随机质数（比我们认为的散列表的大小要大——在本例中，我们认为散列表的大小为1000）相除的余数。 如果再次执行插入数据的代码，这将是使用djb2HashCode代替loseloseHashCode的最终结果： 123456789101112798 - Gandalf838 - John624 - Tyrion215 - Aaron278 - Donnie925 - Ana288 - Jonathan962 - Jamie502 - Sue804 - Mindy54 - Paul223 - Nathan 这并不是最好的散列函数，但这是最受社区推崇的散列函数之一。 三、es6——Map类我们看看原生的Map类怎么用。 还是用我们原来测试Dictionary类的例子： 123456789var map = new Map();map.set('Gandalf', 'gandalf@email.com');map.set('John', 'johnsnow@email.com');map.set('Tyrion', 'tyrion@email.com');console.log(map.has('Gandalf')); //输出trueconsole.log(map.size); //输出3console.log(map.keys()); //输出[\"Gandalf\", \"John\", \"Tyrion\"]console.log(map.values()); //输出[\"gandalf@email.com\", s\"johnsnow@email.com\", \"tyrion@email.com\"]console.log(map.get('Tyrion')); //输出tyrion@email.com 和我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator（第2章提到过），而不是值或键构成的数组。另一个区别是，我们实现的size方法返回字典中存储的值的个数，而ES6的Map类则有一个size属性。 删除map中的元素可以用delete方法： map.delete(‘John’); clear方法会重置map数据结构，这跟我们在Dictionary类里实现的一样。 四、ES6——WeakMap 类和 WeakSet 类除了Set和Map这两种新的数据结构，ES6还增加了它们的弱化版本，WeakSet和WeakMap。 基本上，Map和Set与其弱化版本之间仅有的区别是： WeakSet或WeakMap类没有entries、keys和values等方法； 只能用对象作为键。 创建和使用这两个类主要是为了性能。WeakSet和WeakMap是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。 另一个优点是，必须用键才可以取出值。这些类没有entries、keys和values等迭代器方法，因此，除非你知道键，否则没有办法取出值。这印证了我们在前面的做法，即使用WeakMap类封装ES6类的私有属性。 使用WeakMap类的例子如下： 12345678910var map = new WeakMap();var ob1 = &#123;name:'Gandalf'&#125;, //&#123;1&#125;ob2 = &#123;name:'John'&#125;,ob3 = &#123;name:'Tyrion'&#125;;map.set(ob1, 'gandalf@email.com'); //&#123;2&#125;map.set(ob2, 'johnsnow@email.com');map.set(ob3, 'tyrion@email.com');console.log(map.has(ob1)); //&#123;3&#125; 输出trueconsole.log(map.get(ob3)); //&#123;4&#125; 输出tyrion@email.commap.delete(ob2); //&#123;5&#125; WeakMap类也可以用set方法，但不能使用数字、字符串、布尔值等基本数据类型，需要将名字转换为对象（行{1}和行{2}）。搜索（行{3}）、读取（行{4}）和删除值（行{5}），也要传入作为键的对象。同样的逻辑也适用于WeakSet类。 五、小结在本节中，我们学习了字典的相关知识，了解了如何添加、移除和获取元素以及其他的一些方法。我们还了解了字典和集合的不同之处。 我们也学习了散列运算，怎样创建一个散列表（或者说散列映射）数据结构，如何添加、移除和获取元素，以及如何创建散列函数。我们学习了怎样使用两种不同的方法解决散列表中的冲突问题。 我们还介绍了如何使用ES6的Map、WeakMap和WeakSet类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法六（集合）","date":"2018-12-28T08:10:32.000Z","path":"2018/12/28/cjw08yt9b0017kwvboccmg44q/","text":"一、构建数据集合集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。 在深入学习集合的计算机科学实现之前，我们先看看它的数学概念。在数学中，集合是一组不同的对象（的集）。 比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6, …}。集合中的对象列表用“{}”（大括号）包围。 还有一个概念叫空集。空集就是不包含任何元素的集合。比如24和29之间的素数集合。由于24和29之间没有素数（除了1和自身，没有其他正因数的大于1的自然数），这个集合就是空集。空集用“{ }”表示。 你也可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。 在数学中，集合也有并集、交集、差集等基本操作。在本片文章中我们也会介绍这些操作 二、创建集合首先创建set类，Set类的骨架如下： 123function Set() &#123; let items = &#123;&#125;;&#125; 有一个非常重要的细节，我们使用对象而不是数组来表示集合（items）。但也可以用数组实现。在这里我们用对象来实现，稍微有点儿不一样，也学习一下实现相似数据结构的新方法。同时，JavaScript的对象不允许一个键指向两个不同的属性，也保证了集合里的元素都是唯一的。 接下来，需要声明一些集合可用的方法（我们会尝试模拟与ECMAScript 6实现相同的Set类）。 add(value)：向集合添加一个新的项。delete(value)：从集合移除一个值。has(value)：如果值在集合中，返回true，否则返回false。clear()：移除集合中的所有项。size()：返回集合所包含元素的数量。与数组的length属性类似。values()：返回一个包含集合中所有值的数组。 2.1 has(value)方法首先要实现的是has(value)方法。这是因为它会被add、remove等其他方法调用。下面看看它的实现： 123this.has = function(value)&#123; return value in items;&#125;; 既然我们使用对象来存储集合的值，就可以用JavaScript的in操作符来验证给定的值是否是items对象的属性。 但这个方法还有更好的实现方式，如下： 123this.has = function(value)&#123; return items.hasOwnProperty(value);&#125;; 所有JavaScript对象都有hasOwnProperty方法。这个方法返回一个表明对象是否具有特定属性的布尔值。 2.2 add方法接下来要实现add方法： 1234567this.add = function(value)&#123; if (!this.has(value))&#123; items[value] = value; //&#123;1&#125; return true; &#125; return false;&#125;; 对于给定的value，可以检查它是否存在于集合中。如果不存在，就把value添加到集合中（行{1}），返回true，表示添加了这个值。如果集合中已经有这个值，就返回false，表示没有添加它。 添加一个值的时候，把它同时作为键和值保存，因为这样有利于查找这个值。 2.3 remove 和 clear 方法下面要实现remove方法： 1234567this.remove = function(value)&#123;if (this.has(value))&#123; delete items[value]; //&#123;2&#125; return true;&#125;return false;&#125;; 在remove方法中，我们会验证给定的value是否存在于集合中。如果存在，就从集合中移除value（行{2}），返回true，表示值被移除；否则返回false。 既然用对象来存储集合的items对象，就可以简单地使用delete操作符从items对象中移除属性（行{2}）。 使用Set类的示例代码如下： 123let set = new Set();set.add(1); //trueset.add(2); //true 如果想移除集合中的所有值，可以用clear方法： 123this.clear = function()&#123; items = &#123;&#125;; // &#123;3&#125;&#125;; 要重置items对象，需要做的只是把一个空对象重新赋值给它（行{3}）。我们也可以迭代集合，用remove方法依次移除所有的值，但既然有更简单的方法，那样做就太麻烦了 2.4 size 方法下一个要实现的是size方法（返回集合中有多少项）。这个方法有三种实现方式。 第一种方法是使用一个length变量，每当使用add或remove方法时控制它，就像在上一章中使用LinkedList类一样。 第二种方法，使用JavaScript内建的Object类的一个内建函数（ECMAScript 5以上版本）： 123this.size = function()&#123; return Object.keys(items).length; //&#123;4&#125;&#125;; JavaScript的Object类有一个keys方法，它返回一个包含给定对象所有属性的数组。在这种情况下，可以使用这个数组的length属性（行{4}）来返回items对象的属性个数。以上代码只能在现代浏览器中运行（比如IE9以上版本、Firefox 4以上版本、Chrome 5以上版本、Opera 12以上版本、Safari 5以上版本，等等）。 第三种方法是手动提取items对象的每一个属性，记录属性的个数并返回这个数字。这个方法可以在任何浏览器上运行，和之前的代码是等价的： 12345678this.sizeLegacy = function()&#123; let count = 0; for(let key in items) &#123; //&#123;5&#125; if(items.hasOwnProperty(key)) //&#123;6&#125; ++count; //&#123;7&#125; &#125; return count;&#125;; 遍历items对象的所有属性（行{5}），检查它们是否是对象自身的属性（避免重复计数——行{6}）。如果是，就递增count变量的值（行{7}），最后在方法结束时返回这个数字。 不能简单地使用for-in语句遍历items对象的属性，并递增count变量的值。还需要使用hasOwnProperty方法（以验证items对象具有该属性），因为对象的原型包含了额外的属性（属性既有继承自JavaScript的Object类的，也有属于对象自身，未用于数据结构的）。 2.5 values 方法values方法也应用了相同的逻辑，提取items对象的所有属性，以数组的形式返回： 123456789this.values = function () &#123; let values = []; for (let key in items) &#123; //&#123;7&#125; if (items.hasOwnProperty(key)) &#123; //&#123;8&#125; values.push(items[key]); &#125; &#125; return values; &#125; 首先遍历items对象的所有属性（行{7}），把它们添加一个数组中（行{8}），并返回这个数组。该方法类似于我们开发的sizeLegacy方法，但我们添加一个数组，而不是计算属性个数。 2.6 使用 Set 类现在数据结构已经完成了，执行Set类的方法，测试我们的Set类： 12345678910111213let set = new Set();set.add(1);console.log(set.values()); //输出[\"1\"]console.log(set.has(1)); //输出trueconsole.log(set.size()); //输出1 set.add(2);console.log(set.values()); //输出[\"1\", \"2\"]console.log(set.has(2)); //trueconsole.log(set.size()); //2set.remove(1);console.log(set.values()); //输出[\"2\"]set.remove(2);console.log(set.values()); //输出[] 三、 集合操作对集合可以进行如下操作。 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。子集：验证一个给定集合是否是另一集合的子集。 3.1 并集并集的数学概念是集合A和集合B的并集，表示为： A∪B 该集合定义如下： A∪B = { x | x ∈ A∨x ∈ B } 意思是x（元素）存在于A中，或x存在于B中。下图展示了并集操作： 现在来实现Set类的union方法： 12345678910111213//union 方法this.union = function (otherSet) &#123; let unionSet = new Set(); //&#123;1&#125; let values = this.values(); //&#123;2&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); //&#123;3&#125; for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet;&#125;; 首先需要创建一个新的集合，代表两个集合的并集（行{1}）。接下来，获取第一个集合（当前的Set类实例）所有的值（values），遍历并全部添加到代表并集的集合中（行{2}）。然后对第二个集合做同样的事（行{3}）。最后返回结果。 测试一下上面的代码： 1234567891011let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(3);setB.add(4);setB.add(5);setB.add(6);let unionAB = setA.union(setB);console.log(unionAB.values()); //[1, 2, 3, 4, 5, 6] 输出为[“1”, “2”, “3”, “4”, “5”, “6”]。注意元素3同时存在于A和B中，它在结果的集合中只出现一次。 3.2 交集交集的数学概念是集合A和集合B的交集，表示为： A∩B 该集合定义如下： A∩B = { x | x ∈ A∧x ∈ B } 意思是x（元素）存在于A中，且x存在于B中。下图展示了交集操作： 现在来实现Set类的intersection方法： 12345678910this.intersection = function(otherSet)&#123; let intersectionSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; //&#123;2&#125; if (otherSet.has(values[i]))&#123; //&#123;3&#125; intersectionSet.add(values[i]); //&#123;4&#125; &#125; &#125; return intersectionSet;&#125; intersection方法需要找到当前Set实例中，所有也存在于给定Set实例中的元素。首先创建一个新的Set实例，这样就能用它返回共有的元素（行{1}）。接下来，遍历当前Set实例所有的值（行{2}），验证它们是否也存在于otherSet实例（行{3}）之中。可以用前面实现的has方法来验证元素是否存在于Set实例中。然后，如果这个值也存在于另一个Set实例中，就将其添加到创建的intersectionSet变量中（行{4}），最后返回它。 测试一下intersection方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let intersectionAB = setA.intersection(setB);console.log(intersectionAB.values()); 输出为[“2”, “3”]，因为2和3同时存在于两个集合中。 3.3 差集差集的数学概念是集合A和集合B的差集，表示为：AB，定义如下图： 意思是x（元素）存在于A中，且x不存在于B中。下图展示了集合A和B的差集操作： 现在来实现Set类的difference方法： 12345678910this.difference = function (otherSet) &#123; let differenceSet = new Set(); //&#123;1&#125; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; differenceSet.add(values[i]); //&#123;4&#125; &#125; &#125; return differenceSet;&#125;; intersection方法会得到所有同时存在于两个集合中的值。而difference方法会得到所有存在于集合A但不存在于B的值。因此这两个方法在实现上唯一的区别就是行{3}。只获取不存在于otherSet实例中的值，而不是也存在于其中的值。行{1}、{2}和{4}是完全相同的。 测试difference方法 12345678910let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4);let differenceAB = setA.difference(setB);console.log(differenceAB.values()); 输出为[“1”]，因为1是唯一一个仅存在于setA的元素。 3.4 子集子集的数学概念是集合A是集合B的子集（或集合B包含了A），表示为 A⊆B 该集合定义如下： ∀x { x ∈ A → x ∈ B } 意思是集合A中的每一个x（元素），也需要存在于B中。下图展示了集合A是集合B的子集： 现在来实现Set类的subset方法： 12345678910111213this.subset = function (otherSet) &#123; if (this.size() &gt; otherSet.size()) &#123; //&#123;1&#125; return false; &#125; else &#123; let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; //&#123;2&#125; if (!otherSet.has(values[i])) &#123; //&#123;3&#125; return false; //&#123;4&#125; &#125; &#125; return true; //&#123;5&#125; &#125;&#125;; 首先需要验证的是当前Set实例的大小。如果当前实例中的元素比otherSet实例更多，它就不是一个子集（行{1}）。子集的元素个数需要小于或等于要比较的集合。 接下来要遍历集合中的所有元素（行{2}），验证这些元素也存在于otherSet中（行{3}）。如果有任何元素不存在于otherSet中，就意味着它不是一个子集，返回false（行{4}）。如果所有元素都存在于otherSet中，行{4}就不会被执行，那么就返回true（行{5}）。 检验一下上面的代码效果如何： 12345678910111213let setA = new Set();setA.add(1); setA.add(2);let setB = new Set();setB.add(1);setB.add(2);setB.add(3);let setC = new Set();setC.add(2);setC.add(3);setC.add(4);console.log(setA.subset(setB));console.log(setA.subset(setC)); 我们有三个集合：setA是setB的子集（因此输出为true），然而setA不是setC的子集（setC只包含了setA中的2，而不包含1），因此输出为false。 四、 ES6——Set 类我们先看看原生的Set类怎么用。 还是用我们原来测试Set类的例子： 12345let set = new Set();set.add(1);console.log(set.values()); // 输出@Iteratorconsole.log(set.has(1)); // 输出trueconsole.log(set.size); // 输出1 和我们的Set不同，ES6的Set的values方法返回Iterator（第2章提到过），而不是值构成的数组。另一个区别是，我们实现的size方法返回set中存储的值的个数，而ES6的Set则有一个size属性。 可以用delete方法删除set中的元素： set.delete(1); clear方法会重置set数据结构，这跟我们实现的功能一样 4.1 ES6 Set 类的操作我们的Set类实现了并集、交集、差集、子集等数学操作，然而ES6原生的Set并没有这些功能。不过，有需要的话，我们也可以模拟。 我们的例子会用到下面两个集合 12345678let setA = new Set();setA.add(1);setA.add(2);setA.add(3);let setB = new Set();setB.add(2);setB.add(3);setB.add(4); 4.1.1 模拟并集操作我们可以创建一个新的集合，用来添加两个集合中所有的元素（行{1}）。迭代这两个集合（行{2}、行{3}），把所有元素都添加到并集的集合中。代码如下： 123let unionAb = new Set(); //&#123;1&#125;for (let x of setA) unionAb.add(x); //&#123;2&#125;for (let x of setB) unionAb.add(x); //&#123;3&#125; 4.1.2 模拟交集操作模拟交集操作需要创建一个辅助函数，来生成包含setA和setB都有的元素的新集合（行{1}）。代码如下： 12345678910let intersection = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if (setB.has(x)) &#123; //&#123;1&#125; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125;;let intersectionAB = intersection(setA, setB); 交集可以用更简单的语法实现，代码如下： intersectionAb = new Set([x for (x of setA) if (setB.has(x))]); 这和intersection函数的效果完全一样。 4.1.3 模拟差集操作交集操作创建的集合包含setA和setB都有的元素，差集操作创建的集合包含的则是setA有而setB没有的元素。看下面的代码： 12345678910let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; //&#123;1&#125; differenceSet.add(x); &#125; &#125; return differenceSet;&#125;;let differenceAB = difference(setA, setB); intersection函数和difference函数只有行{1}不同，因为差集中只添加setA有而setB没有的元素。 差集也可以用更简单的语法实现，代码如下： differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); 目前只有Firefox支持简化的语法，但在所有支持ES6的现代浏览器中都可以执行difference函数 五、小结在这片文章中，我们学习了如何从头实现一个与ECMAScript 6中定义的类似的Set类。我们还介绍了在其他编程语言的集合数据结构的实现中不常见的一些方法，比如并集、交集、差集和子集。因此，相比于其他编程语言目前的Set实现，我们实现了一个非常完备的Set类。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法五（链表）","date":"2018-11-18T11:41:53.000Z","path":"2018/11/18/cjw08ytai001dkwvb35pr69ar/","text":"一、链表数据结构要存储多个元素，数组（或列表）可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管JavaScript的array类方法做这些事，但背后的情况同样是这样）。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展示了一个链表的结构： 相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。 另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法，就是从起点（第一条线索）顺着列表寻找。 还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或移除它。下图演示了一列火车。每节车皮都是列表的元素，车皮间的连接就是指针： 二、创建链表理解了链表是什么之后，现在就要开始实现我们的数据结构了，以下是我们的LinkedList类的骨架： 123456789101112131415161718function LinkedList() &#123; let Node = function (element) &#123; // &#123;1&#125; this.element = element; this.next = null; &#125;; let length = 0; // &#123;2&#125; let head = null; // &#123;3&#125; this.append = function (element) &#123; &#125;; this.insert = function (position, element) &#123; &#125;; this.removeAt = function (position) &#123; &#125;; this.remove = function (element) &#123; &#125;; this.indexOf = function (element) &#123; &#125;; this.isEmpty = function () &#123; &#125;; this.size = function () &#123; &#125;; this.getHead = function () &#123; &#125;; this.toString = function () &#123; &#125;; this.print = function () &#123; &#125;;&#125; LinkedList数据结构还需要一个Node辅助类（行{1}）。Node类表示要加入列表的项。它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。 LinkedList类也有存储列表项的数量的length属性（内部/私有变量）（行{2}）。 另一个重要的点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在一个称为head的变量中（行{3}） 然后就是LinkedList类的方法。在实现这些方法之前，先来看看它们的职责。 append(element)：向列表尾部添加一个新的项。 insert(position, element)：向列表的特定位置插入一个新的项。 remove(element)：从列表中移除一项。 indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。 removeAt(position)：从列表的特定位置移除一项。 isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。 size()：返回链表包含的元素个数。与数组的length属性类似。 toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 2.1 向链表尾部追加元素向LinkedList对象尾部添加一个元素时，可能有两种场景：列表为空，添加的是第一个元素，或者列表不为空，向其追加元素。 下面是我们实现的append方法： 1234567891011121314151617181920212223242526// LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; // this.element = element; this.next = null; &#125;; let length = 0; // let head = null; // //实现LinkedList类的append方法 this.append = function (element) &#123; let node = new Node(element), //&#123;1&#125; current; //&#123;2&#125; if (head === null) &#123; //列表中第一个节点 //&#123;3&#125; head = node; &#125; else &#123; current = head; //&#123;4&#125; //循环列表，直到找到最后一项 while (current.next) &#123; current = current.next; &#125; //找到最后一项，将其next赋为node，建立链接 current.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 //&#123;6&#125; &#125;;&#125; 首先需要做的是把element作为值传入，创建Node项（行{1}）。 先来实现第一个场景：向为空的列表添加一个元素。当我们创建一个LinkedList对象时，head会指向null： 如果head元素为null（列表为空——行{3}），就意味着在向列表添加第一个元素。因此要做的就是让head元素指向node元素。下一个node元素将会自动成为null。 列表最后一个节点的下一个元素始终是null。 再来看看第二个场景，也就是向一个不为空的列表尾部添加元素。 要向列表的尾部添加一个元素，首先需要找到最后一个元素。记住，我们只有第一个元素的引用（行{4}），因此需要循环访问列表，直到找到最后一项。为此，我们需要一个指向列表中current项的变量（行{2}）。 循环访问列表时，当current.next元素为null时，我们就知道已经到达列表尾部了。然后要做的就是让当前（也就是最后一个）元素的next指针指向想要添加到列表的节点（行{5}）。下图展示了这个行为： 而当一个Node元素被创建时，它的next指针总是null。这没问题，因为我们知道它会是列表的最后一项。 当然，别忘了递增列表的长度，这样就能控制它，轻松地得到列表的长度（行{6}）。 我们可以通过以下代码来使用和测试目前创建的数据结构： let list = new LinkedList();list.append(15);list.append(10); 2.2 从链表中移除元素现在，让我们看看如何从LinkedList对象中移除元素。移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种remove方法：第一种是从特定位置移除一个元素，第二种是根据元素的值移除元素。 123456789101112131415161718192021222324252627282930313233//LinkedList类的骨架function LinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; &#125;; let length = 0; let head = null; //实现LinkedList类的append方法 this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; // &#123;1&#125; let current = head, // &#123;2&#125; previous, // &#123;3&#125; index = 0; // &#123;4&#125; //移除第一项 if (position === 0) &#123; // &#123;5&#125; head = current.next; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;6&#125; previous = current; // &#123;7&#125; current = current.next; // &#123;8&#125; &#125; //将previous与current的下一项链接起来：跳过current，从而移除它 previous.next = current.next; // &#123;9&#125; &#125; length--; // &#123;10&#125; return current.element; &#125; else &#123; return null; // &#123;11&#125; &#125; &#125;; &#125; 一步一步来看这段代码。该方法要得到需要移除的元素的位置，就需要验证这个位置是有效的（行{1}）。从0（包括0）到列表的长度（size – 1，因为索引是从零开始的）都是有效的位置。如果不是有效的位置，就返回null（意即没有从列表中移除元素）。 首先为第一种场景编写代码：我们要从列表中移除第一个元素（position === 0——行{5}）。下图展示了这个过程： 因此，如果想移除第一个元素，要做的就是让head指向列表的第二个元素。我们将用current变量创建一个对列表中第一个元素的引用（行{2}——我们还会用它来迭代列表，但稍等一下再说）。这样current变量就是对列表中第一个元素的引用。如果把head赋为current.next，就会移除第一个元素 现在，假设我们要移除列表的最后一项或者中间某一项。为此，需要依靠一个细节来迭代列表，直到到达目标位置（行{6}——我们会使用一个用于内部控制和递增的index变量）：current变量总是为对所循环列表的当前元素的引用（行{8}）。我们还需要一个对当前元素的前一个元素的引用（行{7}）；它被命名为previous（行{3}）。 因此，要从列表中移除当前元素，要做的就是将previous.next和current.next链接起来（行{9}）。这样，当前元素就会被丢弃在计算机内存中，等着被垃圾回收器清除。 我们试着通过一些图表来更好地理解。首先考虑移除最后一个元素： 对于最后一个元素，当我们在行{6}跳出循环时，current变量将是对列表中最后一个元素的引用（要移除的元素）。current.next的值将是null（因为它是最后一个元素）。由于还保留了对previous元素的引用（当前元素的前一个元素），previous.next就指向了current。那么要移除current，要做的就是把previous.next的值改变为current.next。 现在来看看，对于列表中间的元素是否可以应用相同的逻辑： current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。那么要移除current元素，需要做的就是将previous.next与current.next链接起来。因此，我们的逻辑对这两种情况都管用。 2.3 在任意位置插入元素接下来，我们要实现insert方法。使用这个方法可以在任意位置插入一个元素。我们来看一看它的实现： 123456789101112131415161718192021222324this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; //&#123;1&#125; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 node.next = current; //&#123;2&#125; head = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;3&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;4&#125; previous.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; //&#123;6&#125; &#125;&#125;; 由于我们处理的是位置，就需要检查越界值（行{1}，跟removeAt方法类似）。如果越界了，就返回false值，表示没有添加项到列表中（行{6}）。 现在我们要处理不同的场景。第一种场景，需要在列表的起点添加一个元素，也就是第一个位置。下图展示了这种场景： current变量是对列表中第一个元素的引用。我们需要做的是把node.next的值设为current（列表中第一个元素）。现在head和node.next都指向了current。接下来要做的就是把head的引用改为node（行{2}），这样列表中就有了一个新元素。 现在来处理第二种场景：在列表中间或尾部添加一个元素。首先，我们需要循环访问列表，找到目标位置（行{3}）。当跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用，而previous将是对想要插入新元素的位置之前一个元素的引用。在这种情况下，我们要在previous和current之间添加新项。因此，首先需要把新项（node）和当前项链接起来（行{4}），然后需要改变previous和current之间的链接。我们还需要让previous.next指向node（行{5}）。 我们通过一张图表来看看代码所做的事： 如果我们试图向最后一个位置添加一个新元素，previous将是对列表最后一项的引用，而current将是null。在这种情况下，node.next将指向current，而previous.next将指向node，这样列表中就有了一个新的项。 现在来看看如何向列表中间添加一个新元素： 在这种情况下，我们试图将新的项（node）插入到previous和current元素之间。首先，我们需要把node.next的值指向current。然后把previous.next的值设为node。这样列表中就有了一个新的项。 使用变量引用我们需要控制的节点非常重要，这样就不会丢失节点之间的链接。我们可以只使用一个变量（previous），但那样会很难控制节点之间的链接。由于这个原因，最好是声明一个额外的变量来帮助我们处理这些引用。 2.4 实现链表的其他方法2.4.1 toString方法toString方法会把LinkedList对象转换成一个字符串。下面是toString方法的实现： 123456789this.toString = function () &#123; let current = head, //&#123;1&#125; string = ''; //&#123;2&#125; while (current) &#123; //&#123;3&#125; string += current.element + (current.next ? 'n' : '');//&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return string; //&#123;6&#125;&#125;; 首先，要循环访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引（行{1}），控制循环访问列表。我们还需要初始化用于拼接元素值的变量（行{2}）。 接下来就是循环访问列表中的每个元素（行{3}）。我们要用current来检查元素是否存在（如果列表为空，或是到达列表中最后一个元素的下一位（null），while循环中的代码就不会执行）。然后我们就得到了元素的内容，将其拼接到字符串中（行{4}）。最后，继续迭代下一个元素（行{5}）。最后，返回列表内容的字符串（行{6}）。 2.4.2 indexOf方法indexOf方法接收一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回-1。 123456789101112this.indexOf = function(element)&#123; let current = head, //&#123;1&#125; index = -1; while (current) &#123; //&#123;2&#125; if (element === current.element) &#123; return index; //&#123;3&#125; &#125; index++; //&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return -1;&#125;; 一如既往，我们需要一个变量来帮助我们循环访问列表，这个变量是current，它的初始值是head（列表的第一个元素——我们还需要一个index变量来计算位置数（行{1}））。然后循环访问元素（行{2}），检查当前元素是否是我们要找的。如果是，就返回它的位置（行{3}）；如果不是，就继续计数（行{4}），检查列表中下一个节点（行{5}）。 如果列表为空，或是到达列表的尾部（current = current.next将是null），循环就不会执行。如果没有找到值，就返回-1。 2.4.3 remove方法实现了indexOf方法就可以实现remove方法了 1234this.remove = function(element)&#123; let index = this.indexOf(element); return this.removeAt(index);&#125;; 我们已经有一个移除给定位置的一个元素的removeAt方法了。现在有了indexOf方法，如果传入元素的值，就能找到它的位置，然后调用removeAt方法并传入找到的位置。这样非常简单，如果需要更改removeAt方法的代码，这样也更容易——两个方法都会被更改（这就是重用代码的妙处）。这样，我们就不需要维护两个从列表中移除一项的方法，只需要一个！同时，removeAt方法将会检查边界约束。 2.4.4 isEmpty、size和getHead方法isEmpty方法检查链表是否为空、size获取链表长度，这两个方法与队列中的isEmpty方法、size方法类似，如下实现： 123this.isEmpty = function() &#123; return length === 0;&#125;; 如果列表中没有元素，isEmpty方法就返回true，否则返回false。 123this.size = function() &#123; return length;&#125;; size方法返回列表的length。和已经实现的Queue类、Stack类有所不同，列表的length是内部控制的，因为LinkedList是从头构建的。 最后还有getHead方法： 123this.getHead = function()&#123; return head;&#125;; head变量是LinkedList类的私有变量（这意味着它不能在LinkedList实例外部被访问和更改，只有通过LinkedList实例才可以）。但是，如果我们需要在类的外部循环访问列表，就需要提供一种获取类的第一个元素的方法。 三、双向链表双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素，如下图所示 先从实现DoublyLinkedList类所需的变动开始 123456789101112//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法&#125; 在代码中可以看到，LinkedList类和DoublyLinkedList类之间的区别标为新增的。在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一项的引用的tail属性。 双向链表提供了两种迭代列表的方法：从头到尾，或者反过来。我们也可以访问一个特定节点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。 3.1 在任意位置插入新元素向双向链表中插入一个新项跟（单向）链表非常类似。区别在于，链表只要控制一个next指针，而双向链表则要同时控制next和prev（previous，前一个）这两个指针。 这是向任意位置插入一个新元素的算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//DoublyLinkedList类function DoublyLinkedList() &#123; let Node = function (element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; let length = 0; let head = null; let tail = null; //新增的 //这里是方法 this.insert = function (position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; let node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 if (!head) &#123; //新增的 &#123;1&#125; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; //新增的 &#123;2&#125; head = node; &#125; &#125; else if (position === length) &#123; //最后一项 //新增的 current = tail; // &#123;3&#125; current.next = node; node.prev = current; tail = node; &#125; else &#123; while (index++ &lt; position) &#123; //&#123;4&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;5&#125; previous.next = node; current.prev = node; //新增的 node.prev = previous; //新增的 &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; &#125; &#125;;&#125; 我们来分析第一种场景：在列表的第一个位置（列表的起点）插入一个新元素。如果列表为空（行{1}），只需要把head和tail都指向这个新节点。如果不为空，current变量将是对列表中第一个元素的引用。就像我们在链表中所做的，把node.next设为current，而head将指向node（它将成为列表中的第一个元素）。不同之处在于，我们还需要为指向上一个元素的指针设一个值。current.prev指针将由指向null变为指向新元素（node——行{2}）。node.prev指针已经是null，因此不需要再更新任何东西。下图演示了这个过程： 现在来分析一下，假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current变量将引用最后一个元素（行{3}）。然后开始建立第一个链接：node.prev将引用current。current.next指针（指向null）将指向node（由于构造函数，node.next已经指向了null）。然后只剩一件事了，就是更新tail，它将由指向current变为指向node。下图展示了这些行为： 然后还有第三种场景：在列表中间插入一个新元素。就像我们在之前的方法中所做的，迭代列表，直到到达要找的位置（行{4}）。我们将在current和previous元素之间插入新元素。首先，node.next将指向current（行{5}），而previous.next将指向node，这样就不会丢失节点之间的链接。然后需要处理所有的链接：current.prev将指向node，而node.prev将指向previous。下图展示了这一过程： 3.2 从任意位置移除元素从双向链表中移除元素跟链表非常类似。唯一的区别就是还需要设置前一个位置的指针。我们来看一下它的实现： 12345678910111213141516171819202122232425262728293031323334this.removeAt = function (position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; let current = head, previous, index = 0; //移除第一项 if (position === 0) &#123; head = current.next; // &#123;1&#125; //如果只有一项，更新tail //新增的 if (length === 1) &#123; // &#123;2&#125; tail = null; &#125; else &#123; head.prev = null; // &#123;3&#125; &#125; &#125; else if (position === length - 1) &#123; //最后一项 //新增的 current = tail; // &#123;4&#125; tail = current.prev; tail.next = null; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;5&#125; previous = current; current = current.next; &#125; //将previous与current的下一项链接起来——跳过current previous.next = current.next; // &#123;6&#125; current.next.prev = previous; //新增的 &#125; length--; return current.element; &#125; else &#123; return null; &#125;&#125;; 我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。 我们来看看如何移除第一个元素。current变量是对列表中第一个元素的引用，也就是我们想移除的元素。需要做的就是改变 head 的引用，将其从 current 改为下一个元素（current.next——行{1}）。但我们还需要更新current.next指向上一个元素的指针（因为第一个元素的prev指针是null）。因此，把head.prev的引用改为null（行{3}——因为head也指向列表中新的第一个元素，或者也可以用current.next.prev）。由于还需要控制tail的引用，我们可以检查要移除的元素是否是第一个元素，如果是，只需要把tail也设为null（行{2}）。 下图勾画了从双向链表移除第一个元素的过程： 下一种场景是从最后一个位置移除元素。既然已经有了对最后一个元素的引用（tail），我们就不需要为找到它而迭代列表。这样我们也就可以把tail的引用赋给current变量（行{4}）。接下来，需要把tail的引用更新为列表中倒数第二个元素（current.prev，或者tail.prev也可以）。既然tail指向了倒数第二个元素，我们就只需要把next指针更新为null（tail.next= null）。下图演示了这一行为： 第三种也是最后一种场景：从列表中间移除一个元素。首先需要迭代列表，直到到达要找的位置（行{5}）。current变量所引用的就是要移除的元素。那么要移除它，我们可以通过更新previous.next和current.next.prev的引用，在列表中跳过它。因此，previous.next将指向current.next，而current.next.prev将指向previous，如下图所示： 3.3 循环列表循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用null，而是指向第一个元素（head），如下图所示。 双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev。 四、小结本篇文章主要介绍链表这种数据结构，及其变体双向链表和循环链表。我们学习了如何在任意位置添加和移除元素，以及如何循环访问链表。还学习了链表相比数组最重要的优点，那就是无需移动链表中的元素，就能轻松地添加和移除元素。因此，当我们需要添加和移除很多元素时，最好的选择就是链表，而非数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法四（队列）","date":"2018-10-12T11:31:39.000Z","path":"2018/10/12/cjw08yt6g000xkwvbjcwwslhh/","text":"一、队列数据结构队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 在现实中，最常见的队列的例子就是排队： 1.1 创建队列首先需要创建自己的类表示队列，先从最基本的声明开始： 123function quene() &#123; //这里是属性和方法&#125; 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像在Stack类中那样使用（你会发现Queue类和Stack类非常类似，只是添加和移除元素的原则不同）： let items = []; 接下来需要声明一些队列可用的方法: 123456789enqueue(element(s))：向队列尾部添加一个（或多个）新的项。dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。front()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）。isEmpty()：如果队列中不包含任何元素，返回true，否则返回false。size()：返回队列包含的元素个数，与数组的length属性类似。 1.2 向队列添加元素首先要实现的是enqueue方法。这个方法负责向队列添加新元素。这里有一个非常重要的细节，新的项只能添加到队列末尾： 123this.enqueue = function(element)&#123; items.push(element);&#125;; 1.2 从队列移除元素接下来要实现dequeue方法。这个方法负责从队列移除项。由于队列遵循先进先出原则，最先添加的项也是最先被移除的。 123this.dequeue = function()&#123; return items.shift();&#125;; 只有enqueue方法和dequeue方法可以添加和移除元素，这样就确保了Queue类遵循先进先出原则。 1.3 查看队列头元素现在来为我们的类实现一些额外的辅助方法。如果想知道队列最前面的项是什么，可以用front方法。这个方法会返回队列最前面的项（数组的索引为0）： 123this.front = function()&#123; return items[0];&#125;; 1.4 检查队列是否为空下一个是isEmpty方法。如果队列为空，它会返回true，否则返回false（注意这个方法和Stack类里的一样）： 123this.isEmpty = function() &#123; return items.length == 0&#125; 对于isEmpty方法，可以简单地验证内部数组的length是否为0。 我们也可以为Queue类实现类似于array类的length属性的方法。size方法也跟Stack类里的一样： 123this.size = function()&#123; return items.length;&#125;; 1.5 打印队列元素我们的Queue类已经实现好了。为了方便也可以像Stack类一样增加一个print方法： 123this.print = function()&#123; console.log(items.toString());&#125;; 1.6 使用quene类首先要做的是实例化我们刚刚创建的Queue类，然后就可以验证它为空（输出为true，因为我们还没有向队列添加任何元素）： 1234567891011121314151617181920212223242526let items = [];function Queue() &#123; this.enqueue = function(element) &#123; return items.push(element); &#125; this.dequeue = function() &#123; return items.shift(); &#125; this.front = function() &#123; return items[0]; &#125; this.isEmpty = function() &#123; return items.length == 0; &#125; this.size = function() &#123; return items.length; &#125; this.print = function() &#123; return console.log(items.toString()); &#125;&#125;let queue = new Queue();console.log(queue.isEmpty()); //输出true 接下来，添加一些元素（添加”John”和”Jack”两个元素——你可以向队列添加任何类型的元素）： queue.enqueue(“John”); queue.enqueue(“Jack”); 添加另一个元素： queue.enqueue(&quot;Camila&quot;); 再执行一些其他的命令： 1234567891011queue.print(); //[\"John\", \"Jack\", \"Camila\"]console.log(queue.size()); //输出3console.log(queue.isEmpty()); //输出falsequeue.dequeue(); //\"John\"queue.dequeue(); //\"Jack\"queue.print(); //[\"Camila\"] 如果打印队列的内容，就会得到John、Jack和Camila这三个元素。因为我们向队列添加了三个元素，所以队列的大小为3（当然也就不为空了）。 下图展示了目前为止执行的所有入列操作，以及队列当前的状态： 然后，出列两个元素（执行两次dequeue方法）。下图展示了dequeue方法的执行过程： 最后，再次打印队列内容时，就只剩Camila一个元素了。前两个入列的元素出列了，最后入列的元素也将是最后出列的。也就是说，我们遵循了先进先出原则。 二、用ECMAscript6语法实现的Queue类和Stack类一样，我们也可以用ECMAScript 6语法编写Queue类。在这种方法中，我们要用一个WeakMap来保存私有属性items，并用外层函数（闭包）来封装Queue类。 123456789101112131415161718192021let Queue = (function() &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; items.get(this).push(element) return items.get(this); &#125; dequeue() &#123; items.get(this).shift(); return items.get(this) &#125; &#125; return Queue&#125;)();let queue = new Queue();console.log(queue.enqueue(10)); //[10]console.log(queue.enqueue(11)); //[10,11]console.log(queue.dequeue()); //[11] 三、优先队列队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和妇（或带小孩的妇女）登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的（急诊科）候诊室。医生会优先处理病情比较严重的患者。通常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此可以对它们使用默认的出列操作： 12345678910111213141516171819202122232425262728293031323334function PriorityQueue() &#123; let items = []; function QueueElement(element, priority) &#123; // &#123;1&#125; this.element = element; this.priority = priority; &#125; this.enqueue = function (element, priority) &#123; console.log(items) let queueElement = new QueueElement(element, priority); let added = false; for (let i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; // &#123;2&#125; items.splice(i, 0, queueElement); // &#123;3&#125; added = true; break; // &#123;4&#125; &#125; &#125; if (!added) &#123; items.push(queueElement); //&#123;5&#125; &#125; &#125;; this.print = function () &#123; for (let i = 0; i &lt; items.length; i++) &#123; console.log(`$&#123;items[i].element&#125; - $&#123;items[i].priority&#125;`); &#125; &#125;; //其他方法和默认的Queue实现相同&#125; let priorityQueue = new PriorityQueue();priorityQueue.enqueue(\"John\", 2);priorityQueue.enqueue(\"Jack\", 1);priorityQueue.enqueue(\"Camila\", 1);priorityQueue.print(); 默认的Queue类和PriorityQueue类实现上的区别是，要向PriorityQueue添加元素，需要创建一个特殊的元素（行{1}）。这个元素包含了要添加到队列的元素（它可以是任意类型）及其在队列中的优先级。 如果队列为空，可以直接将元素入列（行{2}）。否则，就需要比较该元素与其他元素的优先级。当找到一个比要添加的元素的priority值更大（优先级更低）的项时，就把新元素插入到它之前（根据这个逻辑，对于其他优先级相同，但是先添加到队列的元素，我们同样遵循先进先出的原则）。要做到这一点，我们可以用第2章学习过的JavaScript的array类的splice方法。一旦找到priority值更大的元素，就插入新元素（行{3}）并终止队列循环（行{4}）。这样，队列也就根据优先级排序了。 如果要添加元素的priority值大于任何已有的元素，把它添加到队列的末尾就行了（行{5}）: let priorityQueue = new PriorityQueue();priorityQueue.enqueue(“John”, 2);priorityQueue.enqueue(“Jack”, 1);priorityQueue.enqueue(“Camila”, 1);priorityQueue.print(); 以上代码是一个使用PriorityQueue类的示例。在下图中可以看到每条命令的结果（以上代码的结果） 第一个被添加的元素是优先级为2的John。因为此前队列为空，所以它是队列中唯一的元素。接下来，添加了优先级为1的Jack。由于Jack的优先级高于John，它就成了队列中的第一个元素。然后，添加了优先级也为1的Camila。Camila的优先级和Jack相同，所以它会被插入到Jack之后（因为Jack先被插入队列）；Camila的优先级高于John，所以它会被插入到John之前。 我们在这里实现的优先队列称为最小优先队列，因为优先级的值较小的元素被放置在队列最前面（1代表更高的优先级）。最大优先队列则与之相反，把优先级的值较大的元素放置在队列最前面。 四、循环队列——击鼓传花还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏（HotPotato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子（胜者）。 在下面这个示例中，我们要实现一个模拟的击鼓传花游戏： 123456789101112131415161718192021222324252627282930313233343536373839404142let Queue = (function () &#123; const items = new WeakMap(); class Queue &#123; constructor() &#123; items.set(this, []); &#125; enqueue(element) &#123; return items.get(this).push(element) // return items.get(this); &#125; dequeue() &#123; return items.get(this).shift(); // return items.get(this); &#125; size() &#123; return items.get(this).length; &#125; print() &#123; console.log(items.get(this).toString()); &#125; &#125; return Queue&#125;)();function hotPotato(nameList, num) &#123; let queue = new Queue(); // &#123;1&#125; for (let i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); // &#123;2&#125; &#125; let eliminated = ''; while (queue.size() &gt; 1) &#123; for (let i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); // &#123;3&#125; John queue.print() &#125; eliminated = queue.dequeue();// &#123;4&#125; // console.log(eliminated + '在击鼓传花游戏中被淘汰。'); //Camila,Jack,Carl,Ingrid &#125; return queue.dequeue();// &#123;5&#125;&#125;let names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl']; let winner = hotPotato(names, 7); console.log('The winner is: ' + winner); //The winner is: John 实现一个模拟的击鼓传花游戏，要用到实现的Queue类（行{1}）。我们会得到一份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被淘汰的威胁立刻就解除了）。一旦传递次数达到给定的数字，拿着花的那个人就被淘汰了（从队列中移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）。 以上算法的输出如下： Camila在击鼓传花游戏中被淘汰。Jack在击鼓传花游戏中被淘汰。Carl在击鼓传花游戏中被淘汰。Ingrid在击鼓传花游戏中被淘汰。胜利者：John 下图模拟了这个输出过程：","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法三（栈）","date":"2018-09-28T09:58:31.000Z","path":"2018/09/28/cjw08yt6a000qkwvb4otwqg0l/","text":"一、栈数据结构栈是一种遵从后进先出(LIFO)原则的有序数据集合。新添加的或者待删除的元素保存在栈的同一端称为栈顶，另一端称为栈底。在栈里新添加的元素都靠近栈顶，旧添加的元素都接近栈底 1.1 创建栈先创建一个类表示栈，先声明一个类： function Stack() { //各种属性和方法的声明 } 首先，我们需要一种数据结构来保存栈里的元素。可以选择数组： let items = []; 接下来，要为我们的栈声明一些方法。 push(element(s))：添加一个（或几个）新元素到栈顶。 pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。 isEmpty()：如果栈里没有任何元素就返回true，否则返回false。 clear()：移除栈里的所有元素。 size()：返回栈里的元素个数。这个方法和数组的length属性很类似。 1.2 像栈中添加元素我们要实现的第一个方法是push。这个方法负责往栈里添加新元素，有一点很重要：该方法只添加元素到栈顶，也就是栈的末尾。push方法可以这样写： this.push = function(element){ items.push(element); }; 1.3 从栈中移除元素接着，我们来实现pop方法。这个方法主要用来移除栈里的元素。栈遵从LIFO原则，因此移出的是最后添加进去的元素。因此，我们可以用数组的pop方法。栈的pop方法可以这样写： this.pop = function(){ return items.pop(); }; 1.4 查看栈顶元素现在，为我们的类实现一些额外的辅助方法。如果想知道栈里最后添加的元素是什么，可以用peek方法。这个方法将返回栈顶的元素： this.peek = function(){ return items[items.length-1]; }; 1.5 检测栈是否为空下一个要实现的方法是 isEmpty，如果栈为空的话将返回true，否则就返回false： this.isEmpty = function(){ return items.length == 0; }; 使用isEmpty方法，我们能简单地判断内部数组的长度是否为0。 类似于数组的length属性，我们也能实现栈的length。对于集合，最好用size代替length。因为栈的内部使用数组保存元素，所以能简单地返回栈的长度： this.size = function(){ return items.length; }; 1.6 清空和打印栈元素最后，我们来实现clear方法。clear方法用来移除栈里所有的元素，把栈清空。实现这个方法最简单的方式是： this.clear = function(){ items = []; }; 另外也可以多次调用pop方法，把数组中的元素全部移除，这样也能实现clear方法。 如下案例，为了检查栈里的内容，实现一个辅助方法print。它会把栈里的元素都输出到控制台： this.print = function(){ console.log(items.toString()); }; 1.7 使用Stack类首先，我们需要初始化Stack类。然后，验证一下栈是否为空（输出是true，因为还没有往栈里添加元素）。 1234567891011121314151617181920212223242526function Stack()&#123; this.push = function (element) &#123; return items.push(element) &#125; this.pop = function () &#123; return items.pop(); &#125;; this.peek = function () &#123; return items[items.length - 1]; &#125;; this.isEmpty = function () &#123; return items.length == 0; &#125;; this.size = function () &#123; return items.length; &#125;; this.clear = function()&#123; items = []; &#125;; this.print = function()&#123; console.log(items.toString()); &#125;; &#125;let items = [];let stack = new Stack();console.log(stack.isEmpty()); //true 接下来，往栈里添加一些元素（这里我们添加数字5和8；你可以添加任意类型的元素）: Stack.push(5); Stack.push(8); 如果调用peek方法，将会输出8，因为它是往栈里添加的最后一个元素： console.log(stack.peek()); //输出8 再添加一个元素： stack.push(11); console.log(stack.size()); //输出3 console.log(stack.isEmpty()); //输出false 我们往栈里添加了11。如果调用size方法，输出为3，因为栈里有三个元素（5、8和11）。如果我们调用isEmpty方法，会看到输出了false（因为栈里有三个元素，不是空栈）。最后，我们再添加一个元素： stack.push(15); 下图描绘了目前为止我们对栈的操作，以及栈的当前状态： 然后，调用两次pop方法从栈里移除2个元素： stack.pop(); stack.pop(); console.log(stack.size()); //输出2 stack.print(); //输出[5, 8] 在两次调用pop方法前，我们的栈里有四个元素。调用两次后，现在栈里仅剩下5和8了。下图描绘这个过程的执行： 二、ECMAScript 6 和 Stack 类2.1 用 ES6 语法声明 Stack 类class Stack { constructor () { this.items = []; //{1} } push(element){ this.items.push(element); } //其他方法 } 我们只是用ES6的简化语法把Stack函数转换成Stack类。这种方法不能像其他语言（Java、C++、C#）一样直接在类里面声明变量，只能在类的构造函数constructor里声明（行{1}，在类的其他函数里用this.nameofVariable就可以引用这个变量。 尽管代码看起来更简洁、更漂亮，变量items却是公共的。ES6的类是基于原型的。虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性（变量）或方法。而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法。否则，就有可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。 2.1.1 用ES6的限定作用域Symbol实现类ES6新增了一种叫作Symbol的基本类型，它是不可变的，可以用作对象的属性。 let _items = Symbol(); //{1} class Stack { constructor () { this[_items] = []; //{2} } //Stack方法 } 在上面的代码中，我们声明了Symbol类型的变量_items（行{1}），在类的constructor函数中初始化它的值（行{2}）。要访问_items，只需把所有的this.items都换成this[_items]。 这种方法创建了一个假的私有属性，因为ES6新增的Object.getOwnPropertySymbols方法能够取到类里面声明的所有Symbols属性。下面是一个破坏Stack类的例子： let _items = Symbol(); class Stack { constructor() { this[_items] = []; } push(element) { return this[_items].push(element); }; print() { console.log(this[_items].toString()); }; } let stack = new Stack(); stack.push(5); stack.push(8); let objectSymbols = Object.getOwnPropertySymbols(stack); console.log(objectSymbols.length); // 1 console.log(objectSymbols); // [Symbol()] console.log(objectSymbols[0]); // Symbol() stack[objectSymbols[0]].push(1); stack.print(); //输出 5, 8, 1 从以上代码可以看到，访问stack[objectSymbols[0]]是可以得到_items的。并且，_items属性是一个数组，可以进行任意的数组操作，比如从中间删除或添加元素。我们操作的是栈，不应该出现这种行为。 2.1.2 用ES6的WeakMap实现类有一种数据类型可以确保属性是私有的，这就是WeakMap。WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。 如果用WeakMap来存储items变量，Stack类就是这样的： const items = new WeakMap(); //{1} class Stack { constructor () { items.set(this, []); //{2} } push(element) { let s = items.get(this); //{3} s.push(element); } pop() { let s = items.get(this); let r = s.pop(); return r; } //其他方法 } //行{1}，声明一个WeakMap类型的变量items。 //行{2}，在constructor中，以this（Stack类自己的引用）为键，把代表栈的数组存入items。 //行{3}，从WeakMap中取出值，即以this为键（行{2}设置的）从items中取值。 现在我们知道，items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap： let Stack = (function () { const items = new WeakMap(); class Stack { constructor () { items.set(this, []); } //其他方法 } return Stack; //{5} })(); //当Stack函数里的构造函数被调用时，会返回Stack类的一个实例（行{5}）。 现在，Stack类有一个名为items的私有属性。虽然它很丑陋，但毕竟实现了私有属性。然而，用这种方法的话，扩展类无法继承私有属性。鱼与熊掌不可兼得！ 把上面的代码跟本章最初实现的Stack类做个比较，我们会发现有一些相似之处： function Stack() { let items = []; //其他方法 } 事实上，尽管ES6引入了类的语法，我们仍然不能像在其他编程语言中一样声明私有属性或方法。有很多种方法都可以达到相同的效果，但无论是语法还是性能，这些方法都有各自的优点和缺点 哪种方法更好？这取决于你在实际项目中如何使用本书中这些算法，要处理的数据量，要创建的实例个数，以及其他约束条件。最终，还是取决于你。 2.2 用栈解决问题栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后续再讨论图和回溯问题时，我们会学习如何应用这个例子）。Java和C#用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 2.2.1 从十进制到二进制现实生活中，我们主要使用十进制。但在计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的（0和1）。没有十进制和二进制相互转化的能力，与计算机交流就很困难。 要把十进制转化成二进制，我们可以将该十进制数字和2整除（二进制是满二进一），直到结果是0为止。举个例子，把十进制的数字10转化成二进制的数字，过程大概是这样： 大学的计算机课一般都会先教这个进制转换。下面是对应的算法描述： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop(); } isEmpty() { return items.get(this).length == 0; }; } return Stack; })(); function divideBy2(decNumber) { var remStack = new Stack(), rem, binaryString = &apos;&apos;; while (decNumber &gt; 0) { //{1} rem = Math.floor(decNumber % 2); //{2} remStack.push(rem); //{3} decNumber = Math.floor(decNumber / 2); //{4} } while (!remStack.isEmpty()) { binaryString += remStack.pop().toString(); //{5} } return binaryString; } console.log(divideBy2(13)); //1101 在这段代码里，当结果满足和2做整除的条件时（行{2}），我们会获得当前结果和2的余数，放到栈里（行{2}、{3}）。然后让结果和2做整除（行{4}）。另外请注意：JavaScript有数字类型，但是它不会区分究竟是整数还是浮点数。因此，要使用Math.floor函数让除法的操作仅返回整数部分。最后，用pop方法把栈中的元素都移除，把出栈的元素变成连接成字符串（行{5}）。 2.2.2 进制转换算法我们很容易修改之前的算法，使之能把十进制转换成任何进制。除了让十进制数字和2整除转成二进制数，还可以传入其他任意进制的基数为参数，就像下面算法这样： let Stack = (function () { const items = new WeakMap(); class Stack { constructor() { items.set(this, []); } push(element) { items.get(this).push(element); } pop() { return items.get(this).pop() } isEmpty() { return items.get(this).length == 0; }; } return Stack; //{5} })(); function baseConverter(decNumber, base) { var remStack = new Stack(), rem, baseString = &apos;&apos;, digits = &apos;0123456789ABCDEF&apos;; //{6} while (decNumber &gt; 0) { rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); } while (!remStack.isEmpty()) { baseString += digits[remStack.pop()]; //{7} } return baseString; } console.log(baseConverter(13,2)); //1101 console.log(baseConverter(13,8)); //15 我们只需要改变一个地方。在将十进制转成二进制时，余数是0或1；在将十进制转成八进制时，余数是0到7之间的数；但是将十进制转成16进制时，余数是0到9之间的数字加上A、B、C、D、E和F（对应10、11、12、13、14和15）。因此，我们需要对栈中的数字做个转化才可以（行{6}和行{7}）。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法二（数组的使用）","date":"2018-09-10T11:24:31.000Z","path":"2018/09/10/cjw08yt990014kwvbyczyrg8v/","text":"一、创建和初始化数组1.1 创建数组用JavaScript声明、创建和初始化数组有两种方式 //使用new创建数组 var daysOfWeek = new Array(); //{1} var daysOfWeek = new Array(7); //{2} var daysOfWeek = new Array(&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;); //{3} 使用new关键字，就能简单地声明并初始化一个数组（行{1}）。用这种方式，还可以创建一 个指定长度的数组（行{2}）。另外，也可以直接将数组元素作为参数传递给它的构造器（行{3}）。 //使用[]创建数组 var daysOfWeek = []; 也可使用一些元素初始化数组，如下： var daysOfWeek = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; 使用数组的length属性获取数组的长度 console.log(daysOfWeek.length); //7 1.2 访问元素和迭代数组要访问数组里特定位置的元素，可以用中括号传递数值位置，得到想知道的值或者赋新的值。如下： for (var i=0; i&lt;daysOfWeek.length; i++){ console.log(daysOfWeek[i]); } 我们来看另一个例子：求斐波那契数列的前20个数字。已知斐波那契数列中第一个数字是1，第二个是2，从第三项开始，每一项都等于前两项之和： var fibonacci = []; //{1} fibonacci[1] = 1; //{2} fibonacci[2] = 2; //{3} for(var i = 3; i &lt; 20; i++){ fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]; ////{4} } for(var i = 1; i&lt;fibonacci.length; i++){ //{5} console.log(fibonacci[i]); //{6} } 在行{1}处，我们声明并创建了一个数组。 在行{2}和行{3}，把斐波那契数列中的前两个数字分别赋给了数组的第二和第三位（在JavaScript中，数组的第一位是0，这里我们略过，从第二位开始分别保存斐波那契数列中对应位置的元素）。 然后，我们需要做的就是想办法得到斐波那契数列的第三到第二十位的数字（前两个值我们已经初始化过了）。我们可以用循环来处理，把数组中前两位上的元素相加，结果赋给当前位置上的元素（行{4}——从数组中的索引3到索引19）。 最后，看看输出（行{6}），我们只需要循环遍历数组的各个元素（行{5}）。 1.3 添加元素1.3.1 使用数组索引直接添加var numbers = [0,1,2,3,4,5,6,7,8,9]; 如果想要给数组添加一个元素（比如10），只要把值赋给数组中最后一个空位上的元素即可。 numbers[numbers.length] = 10; 1.3.2 使用push方法push方法，能把元素添加到数组的末尾 numbers.push(11); numbers.push(12, 13); 1.3.3 插入元素到数组首位现在，我们希望在数组中插入一个值，不像之前那样插入到最后，而是放到数组的首位。为了实现这个需求，首先我们要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位+1（长度）开始，将其对应的前一个元素的值赋给它，依次处理，最后把我们想要的值赋给第一个位置（-1）上。 for (var i=numbers.length; i&gt;=0; i--){ numbers[i] = numbers[i-1]; } numbers[0] = -1; 下面这张图描述了我们刚才的操作过程： ; 也可以使用unshift方法 numbers.unshift(-2); numbers.unshift(-4, -3); 1.4 删除元素1.4.1 删除数组里最靠后的元素删除数组里最靠后的元素使用pop方法： numbers.pop(); 1.4.2 从数组首位删除元素如果要移除数组里的第一个元素，可以用下面的代码： for (var i = 0; i &lt; numbers.length; i++){ numbers[i] = numbers[i+1]; } 下面这张图呈现了这段代码的执行过程： 我们把数组里所有的元素都左移了一位。但数组的长度依然是17，这意味着数组中有额外的 一个元素（值是undefined）。在最后一次循环里，i + 1引用了一个数组里还未初始化的位置。 在Java、C/C+或C#等一些语言里，这样写可能就会抛出异常了，因此不得不在 numbers.length - 1处停止循环。 可以看到，我们只是把数组第一位的值用第二位覆盖了，并没有删除元素（因为数组的长度 和之前还是一样的，并且了多一个未定义元素）。 使用unshift()方法 numbers.shift(); //通过shift和unshift方法，就能用数组模拟基本的队列数据结构， 1.4.3 在任意位置添加或删除元素使用splice方法，简单地通过指定位置/索引，就可以删除相应位置和数量的元素： //如下 numbers.splice(5,3); //这行代码删除了从数组索引5开始的3个元素。这就意味着numbers[5]、numbers[6]和numbers[7]从数组中删除了。 splice方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除元素的个数（这个例子里，我们的目的不是删除元素，所以传入0）。第三个参数往后，就是要添加到数组里的值（元素2、3、4）。输出会发现值又变成了从3到12。 numbers.splice(5,3,2,3,4);//我们从索引5开始删除了3个元素，但也从索引5开始添加了元素2、3、4 对于JavaScript数组和对象，我们还可以用delete操作符删除数组中的元素，例如delete numbers[0]。然而，数组位置0的值会变成undefined，也就是说，以上操作等同于numbers[0] = undefined。因此，我们应该始终使用splice、pop或shift（马上就会学到）方法来删除数组元素。 二、 二维和多维数组JavaScript只支持一维数组，并不支持矩阵(二维数组)。但是，我们可以用数组套数组，实现矩阵或任一多维数组。代码也可以写成这样： var averageTemp = []; averageTemp[0] = []; averageTemp[0][0] = 72; averageTemp[0][1] = 75; averageTemp[0][2] = 79; averageTemp[0][3] = 79; averageTemp[0][4] = 81; averageTemp[0][5] = 81; //day 2 averageTemp[1] = []; averageTemp[1][0] = 81; averageTemp[1][1] = 79; averageTemp[1][2] = 75; averageTemp[1][3] = 75; averageTemp[1][4] = 73; averageTemp[1][5] = 72; 上面的代码里，我们分别指定了每天和每小时的数据。数组中的内容如下图所示： 每行就是每天的数据，每列是当天不同时段的气温 2.1 迭代二维数组的元素如果想看矩阵的输出，我们可以创建一个通用函数，专门输出其中的值： function printMatrix(myMatrix) { for (var i=0; i&lt;myMatrix.length; i++){ for (var j=0; j&lt;myMatrix[i].length; j++){ console.log(myMatrix[i][j]); } } } 需要遍历所有的行和列。因此，我们需要使用一个嵌套的for循环来处理，其中变量i为行，变量j为列。 使用以下代码查看矩阵averageTemp的输出： printMatrix(averageTemp); 2.2 多维数组我们也可以用这种方式来处理多维数组。假如我们要创建一个3×3×3的矩阵，每一格里包含矩阵的i（行）、j（列）及z（深度）之和： var matrix3x3x3 = []; for (var i=0; i&lt;3; i++){ matrix3x3x3[i] = []; for (var j=0; j&lt;3; j++){ matrix3x3x3[i][j] = []; for (var z=0; z&lt;3; z++){ matrix3x3x3[i][j][z] = i+j+z; } } } 数据结构中有几个维度都没关系，我们都可以用循环遍历每个维度来访问所有格子。3×3×3的矩阵也可用立体图表示如下： 可以用以下代码输出这个矩阵的内容： for (var i=0; i&lt;matrix3x3x3.length; i++){ for (var j=0; j&lt;matrix3x3x3[i].length; j++){ for (var z=0; z&lt;matrix3x3x3[i][j].length; z++){ console.log(matrix3x3x3[i][j][z]); } } } 如果是一个3×3×3×3的矩阵，代码中就会用四层嵌套的for语句，以此类推。 2.3 JavaScript 的数组方法参考 方法名 语法 concat 连接数组（一个或多个），返回连接后的结果 every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach 遍历数组 join 将所有的数组元素连接成一个字符串 indexOf 从数组开始查找数组元素在数组中的的位置，并返回，没有找到则返回-1 lastIndexOf 从数组结尾查找数组元素在数组中的的位置，并返回，没有找到则返回-1 map 遍历数组元素，并返回 reverse 颠倒数组中元素的顺序 slice 截取数组中的元素 some 对数组中的每一项运行给定函数，如果任一项返回true，则返回true sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 toString 将数组作为字符串返回 valueOf 和toString类似，将数组作为字符串返回 2.3.1 数组合并concat方法可以向一个数组传递数组、对象或是元素。数组会按照该方法传入的参数顺序连接指定数组。如下： var zero = 0; var positiveNumbers = [1,2,3]; var negativeNumbers = [-3,-2,-1]; var numbers = negativeNumbers.concat(zero, positiveNumbers); //[3,2,1,0,1,2,3] 2.3.1 迭代器函数迭代数组中的元素可以使用for循环，同样JavaScript内置了许多数组可用的迭代方法 解决如下案例： 假如有一个数组，它值是从1到15，如果数组里的元素可以被2整除（偶数），函数就返回true，否则返回false： var isEven = function (x) { // 如果x是2的倍数，就返回true console.log(x); return (x % 2 == 0) ? true : false; }; var numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; 用every方法迭代 numbers.every(isEven); //false //数组numbers的第一个元素是1，它不是2的倍数（1是奇数），因此isEven 函数返回false，然后every执行结束。 用some方法迭代 some方法会迭代数组的每个元素，直到函数返回true： numbers.some(isEven); //numbers数组中第一个偶数是2（第二个元素）。第一个被迭代的元素是1， isEven会返回false。第二个被迭代的元素是2，isEven返回true——迭代结束。 用forEach方法迭代 numbers.forEach(function(x){ console.log((x % 2 == 0)); }); 使用map和filter方法 var myMap = numbers.map(isEven); //[false, true, false, true, false, true, false, true,false, true, false, true, false, true, false]。 filter方法返回新数组由使函数返回true的元素组成： var evenNumbers = numbers.filter(isEven); //[2, 4, 6, 8, 10, 12, 14] 使用reduce方法 reduce方法接收一个函数作为参数，这个函数有四个参数：previousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器 numbers.reduce(function(previous, current, index){ return previous + current; //120 }); 2.4 ECMAScript 6 和数组的新功能下标展示了一些ES6和ES7新增的数组方法 方法 描述 @@iterator 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对 copyWithin 复制数组中一系列元素到同一数组指定的起始位置 entries 返回包含数组所有键值对的@@iterator includes 如果数组中存在某个元素则返回true，否则返回false。ES7新增 find 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素 findIndex 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引-1 fill 用静态值填充数组-1 from 根据已有数组创建一个新数组 keys 返回包含数组所有索引的@@iterator of 根据传入的参数创建一个新数组 values 返回包含数组中所有值的@@iterator sort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数 除了这些新的方法，还有一种用for…of循环来迭代数组的新做法，以及可以从数组实例得到的迭代器对象 2.4.1 使用forEach和箭头函数迭代箭头函数可以简化使用forEach迭代数组元素的做法，如下 numbers.forEach(function (x) { console.log(x % 2 == 0); }); //这段代码可以简化如下： numbers.forEach(x =&gt; { console.log((x % 2 == 0)); }); 2.4.2 使用for…of循环迭代for (let n of numbers) { console.log((n % 2 == 0) ? &apos;even&apos; : &apos;odd&apos;); } 2.4.3 ES6新的迭代器（@@iterator）ES6还为Array类增加了一个@@iterator属性，需要通过Symbol.iterator来访问。代码如下: let iterator = numbers[Symbol.iterator](); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3 console.log(iterator.next().value); // 4 console.log(iterator.next().value); // 5 然后，不断调用迭代器的next方法，就能依次得到数组中的值,数组中所有值都迭代完之后，iterator.next().value会返回undefined。 2.4.4 数组的entries、keys和values方法 entries: 返回包含键值对的@@iterator，如下案例： let numbers = [1,2,3] let aEntries = numbers.entries(); // 得到键值对的迭代器,key是数组中的位置，value是保存在数组索引的值。 console.log(aEntries.next().value); // [0, 1] - 位置0的值为1 console.log(aEntries.next().value); // [1, 2] - 位置1的值为2 console.log(aEntries.next().value); // [2, 3] - 位置2的值为3 entries方法会返回numbers数组位置以及对应的值，如果没有可迭代的值则返回undefined。 entries：方法返回包含数组索引的@@iterator，如下案例： let numbers = [1,2,3] let aKeys = numbers.keys(); // 得到数组索引的迭代器 console.log(aKeys.next()); // {value: 0, done: false } console.log(aKeys.next()); // {value: 1, done: false } console.log(aKeys.next()); // {value: 2, done: false } console.log(aKeys.next()); // {value: undefined, done: true } keys方法会返回numbers数组的索引。一旦没有可迭代的值，aKeys.next()就会返回一个value属性为undefined，done属性为true的对象。如果done属性的值为false，就意味着还有可迭代的值。 values：方法返回的@@iterator则包含数组的值 let numbers = [1,2,3] let aValues = numbers.values(); console.log(aValues.next()); // {value: 1, done: false } console.log(aValues.next()); // {value: 2, done: false } console.log(aValues.next()); // {value: 3, done: false } console.log(aValues.next()); // {value: undefined, done: true } 2.4.5 from方法Array.from方法根据已有的数组创建一个新数组，参数为过滤Array中元素的函数 let evens = Array.from(numbers, x =&gt; (x % 2 == 0)); 2.4.6 用Array.of方法Array.of方法根据传入的参数创建一个新数组 let numbers4 = Array.of(1, 2, 3, 4, 5, 6); //[1,2,3,4,5,6] 也可以用这个方法复制已有的数组 let numbersCopy = Array.of(...numbers4); //[1,2,3,4,5,6] 2.4.7 使用fill方法fill方法用静态值填充数组,参数为要添加的位置范围 let numbersCopy = Array.of(1, 2, 3, 4, 5, 6); numbersCopy.fill(0); //（[0, 0, 0, 0, 0, 0] numbersCopy.fill(1, 3, 5); //[0, 0, 0, 1, 1, 0] 创建数组并初始化值的时候，fill方法非常方便，如下： let ones = Array(6).fill(1); //[1, 1, 1, 1, 1, 1] 2.4.8 copyWithin方法copyWithin方法复制数组中的一系列元素到同一数组指定的起始位置 let copyArray = [1, 2, 3, 4, 5, 6]; copyArray.copyWithin(0, 3); // [4, 5, 6, 4, 5, 6] copyArray.copyWithin(1, 3, 5); //[4,4,5,4,5,6] 2.4.9 排序元素 反转数组reverse： let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. 15]; numbers.reverse(); //[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]; 对数组进行排序sort： numbers.sort(); //[1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9] //sort方法在对数组做排序时，把元素默认成字符串进行相互比较。 //所以在使用的时候传入自己写的比较函数 numbers.sort(function(a, b){ return a-b; }); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 自定义排序 我们可以对任何对象类型的数组排序，也可以创建compareFunction来比较元素。例如，对象Person有名字和年龄属性，我们希望根据年龄排序，就可以这么写： var friends = [ {name: &apos;John&apos;, age: 30}, {name: &apos;Ana&apos;, age: 20}, {name: &apos;Chris&apos;, age: 25} ]; function comparePerson(a, b){ if (a.age &lt; b.age){ return -1 } if (a.age &gt; b.age){ return 1 } return 0; } console.log(friends.sort(comparePerson)); //在这个例子里，最后会输出Ana(20), Chris(25), John(30)。 字符串排序 JavaScript在做字符比较的时候，是根据字符对应的ASCII值来比较的。 如下案例： var names =[&apos;Ana&apos;, &apos;ana&apos;, &apos;john&apos;, &apos;John&apos;]; console.log(names.sort()); //[&quot;Ana&quot;, &quot;John&quot;, &quot;ana&quot;, &quot;john&quot;] //因为A、J、a、j对应的ASCII值分别是65、75、97、106。 现在，如果给sort传入一个忽略大小写的比较函数，将会输出[“Ana”, “ana”, “John”,”john”]： names.sort(function(a, b){ if (a.toLowerCase() &lt; b.toLowerCase()){ return -1 } if (a.toLowerCase() &gt; b.toLowerCase()){ return 1 } return 0; }); 假如对带有重音符号的字符做排序的话，我们可以用localeCompare来实现： var names2 = [&apos;Maève&apos;, &apos;Maeve&apos;]; console.log(names2.sort(function(a, b){ return a.localeCompare(b); })); //[&quot;Maeve&quot;, &quot;Maève&quot;] 搜索（indexOf/lastIndexOf） 搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引,如果没有匹配的元素则返回-1。 console.log(numbers.indexOf(10)); //9 console.log(numbers.indexOf(100)); //-1 搜索（ECMAScript 6——find和findIndex方法） find和findIndex方法接收一个回调函数，搜索一个满足回调函数条件的值。 let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; function multipleOf13(element, index, array) { return (element % 13 == 0) ? true : false; } console.log(numbers.find(multipleOf13)); //13 console.log(numbers.findIndex(multipleOf13)); //12 //find和findIndex的不同之处在于，find方法返回第一个满足条件的值。 //findIndex方法则返回这个值在数组里的索引。 //如果没有满足条件的值，find会返回undefined，而findIndex返回-1。 搜索（ECMAScript 7——使用includes方法） 如果数组里存在某个元素，includes方法会返回true，否则返回false。 console.log(numbers.includes(15)); //true console.log(numbers.includes(20)); //false 如果给includes方法传入一个起始索引，搜索会从索引指定的位置开始： let numbers2 = [7, 6, 5, 4, 3, 2, 1]; console.log(numbers2.includes(4, 5)); //false 2.4.10 输出数组为字符串 toString 把数组里所有元素输出为一个字符串 let numbers = [1, 2, 3, 4] console.log(numbers.toString()); //1,2,3,4 如果想用一个不同的分隔符（比如-）把元素隔开，可以用join方法： var numbersString = numbers.join(&apos;-&apos;); console.log(numbersString); //1-2-3-4 三、 类型数组JavaScript数组不是强类型的，因此它可以存储任意类型的数据。而类型数组则用于存储单一类型的数据。它的语法是let myArray = new TypedArray(length)，其中TypedArray需替换为下表所列之一。 类型数组 数据类型 Int8Array 8位二进制补码整数 Uint8Array 8位无符号整数 Uint8ClampedArray 8位无符号整数 Int16Array 16位二进制补码整数 Uint16Array 16位无符号整数 Int32Array 32位二进制补码整数 Uint32Array 32位无符号整数 Float32Array 32位IEEE浮点数 Float64Array 64位IEEE浮点数 代码示例如下： let length = 5; let int16 = new Int16Array(length); for (let i=0; i&lt;length; i++){ int16[i] = i+1; } console.log(int16); //[1, 2, 3, 4, 5] 使用WebGL API、进行位操作、处理文件和图像时，类型数组都可以大展拳脚。它用起来和普通数组也毫无二致，本章所学的数组方法和功能都可以用于类型数组。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"javascript数据结构与算法一（javascript基础）","date":"2018-08-16T11:20:30.000Z","path":"2018/08/16/cjw08yt4q0005kwvbso6149d5/","text":"一、相等操作符（==和===）1.相等操作符（==）在使用==时，不同类型的值也可以被看作相等下面表格展示了不同类型的值用相等操作符比较后的结果。 类型（x） 类型（y） 结 果 null undefined true undefined null true 数字 字符串 x == toNumber(y) 字符串 数字 toNumber(x) == y 布尔值 任意类型 toNumber(x) == y 任意类型 布尔值 x == toNumber(y) 字符串或数字 对象 x == toPrimitive(y) 对象 字符串或数字 toPrimitive(x) == y 如果x和y是相同类型，JavaScript会比较它们的值或对象值。其他没有列在这个表格中的情况都会返回false。toNumber和toPrimitive方法是内部的，并根据以下表格对其进行估值。toNumber方法对不同类型返回的结果如下： 值类型 结 果 undefined NAN null +0 布尔值 如果是true，返回1；如果是false，返回+0 数字 数字对应的值 字符串 将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字 对象 Number(toPrimitive(vale)) toPrimitive方法对不同类型返回的结果如下： 值类型 结 果 对象 如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误 例：console.log(&apos;packt&apos; == true); //输出false 首先，布尔值会被toNumber方法转成数字，因此得到packt == 1。 其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式就变成了NaN == 1，结果就是false。 1.相等操作符（===）如果比较的两个值或者类型不同则返回false，如果比较的两个值类型相同，结果会根据下表判断。 类型（x） 类型（y） 结 果 数字 x和y数值相同（但不是NaN） true 字符串 x和y是相同的字符 true 布尔值 x和y都是true或false true 对象 x和y引用同一个对象 true 例：console.log(&apos;packt&apos; === true); //false console.log(&apos;packt&apos; === &apos;packt&apos;); //true 二、声明展开和剩余参数2.1展开操作符在es5中使用apply()函数将数组转化为参数，在es6中使用展开操作符(…); 例： var params = [1, 3, 5] function sum(a=1, b=3, c=4) { return a+b+c } console.log(sum(...params)); //es6使用扩展符传入数组 console.log(sum.apply(null, params)); //es5使用apply传入数组 在函数中也可以使用展开操作符(…)代替arguments，当做剩余参数使用，如下案例： function restParamaterFunction (x, y, ...a) { return (x + y) * a.length; } console.log(restParamaterFunction(1, 2, &quot;hello&quot;, true, 7)); //输出9; es5中实现 function restParamaterFunction(x, y) { var a = Array.prototype.slice.call(arguments, 2); console.log(a) return (x + y) * a.length; }; 2.2数组解构es6引入数组解构的概念，可以一次初始化多个变量，如下： var [x, y] = [&apos;a&apos;, &apos;b&apos;]; 等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; 数组解构也可以用来进行值的互换，而不需要创建临时变量，如下： [x, y] = [y, x]; //等同于 var temp = x, x = y, y = temp; 对象也可以解构，如下： //属性简写的功能， var [x, y] = [&apos;a&apos;, &apos;b&apos;]; var obj = { x, y }; console.log(obj); // { x: &quot;a&quot;, y: &quot;b&quot; } //等同于 var x = &apos;a&apos;; var y = &apos;b&apos;; var obj2 = { x: x, y: y }; console.log(obj2); // { x: &quot;a&quot;, y: &quot;b&quot; } //方法属性 var hello = { name : &apos;abcdef&apos;, printHello() { console.log(&apos;Hello&apos;); } } console.log(hello.printHello()); //等同于 var hello = { name: &apos;abcdef&apos;, printHello: function printHello() { console.log(&apos;Hello&apos;); } }; 三、使用类进行面向对象编程声明一个book类的方式 function Book(title, pages, isbn){ //{1} this.title = title; this.pages = pages; this.isbn = isbn; } Book.prototype.printTitle = function(){ console.log(this.title); }; 使用es6可以简化为一下语法 只需要使用class关键字声明一个constructor函数和其他函数 class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } //以上两种声明据用相同的效果和输出 let book = new Book(&apos;title&apos;, &apos;pag&apos;, &apos;isbn&apos;); console.log(book.title); //输出图书标题 book.title = &apos;new title&apos;; //更新图书标题 console.log(book.title); //输出图书标题 3.1继承es6简化声明类的方式 如下： class Book { //{2} constructor (title, pages, isbn) { this.title = title; this.pages = pages; this.isbn = isbn; } printIsbn(){ console.log(this.isbn); } } class ITBook extends Book { //{扩展book并继承其行为 constructor (title, pages, isbn, technology) { super(title, pages, isbn); //引用父类的构造函数 this.technology = technology; } printTechnology(){ console.log(this.technology); } } let jsBook = new ITBook(&apos;学习JS算法&apos;, &apos;200&apos;, &apos;1234567890&apos;, &apos;JavaScript&apos;); console.log(jsBook.title); console.log(jsBook.printTechnology()); //我们可以使用extends关键字扩展一个类并继承它的行为。在构造函数中，也可以通过super关键字引用父类的构造函数。 3.2使用属性存取器使用新的类语法也可以为属性创建存取器函数。如下： class Person { constructor(name) { this._name = name; //{1} } get name() { //{2} return this._name; } set name(value) { //{3} this._name = value; } } let lotrChar = new Person(&apos;Frodo&apos;); console.log(lotrChar.name); //Frodo lotrChar.name = &apos;Gandalf&apos;; console.log(lotrChar.name); //Gandalf lotrChar._name = &apos;Sam&apos;; console.log(lotrChar.name); //Sam //要声明get和set函数，只需要在我们要暴露和使用的函数名前面加上get或set关键字。可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的。 然后，只要像普通的属性一样，引用它们的名字，就可以执行get和set函数。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"认识es6","date":"2018-08-05T11:02:07.000Z","path":"2018/08/05/cjw08yt6e000tkwvb89gdzz9y/","text":"es6常用api介绍一、let和const命令介绍及区别1. let命令：1）、基本用法： es5只有两种方式声明变量var以及function，es6新增了四种let、const、import、class； let声明的变量的方式与var相似，但是声明的变量，只在let命令所在的代码块中生效; { let a = 1; var b = 2; } console.log(a);//Error in created hook: &quot;ReferenceError: a is not defined&quot; console.log(b);//2 上面在代码块中使用let，var分别声明了连个变量，然后再代码块外面调用，let声明的变量会报错，var声明的 返回值正常，表明let只在它所在的代码块中生效； 2）、let不存在变量提升问题 我们知道使用var声明的变量会存在变量提升问题，但是在let中不存在这种现象 console.log(a);//undefined var a = 1; console.log(b);//报错 let b = 2; 上述代码中，使用let声明了变量b，在声明之前使用会报错，而使用var声明的变量，在使用前值是undefined； 3）、暂时性死区在es6中规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，在声明前使用这些变量就会报错； var a = 1; { a = 3; console.log(a);//报错 let a; } 4）、不允许重复声明let不允许在相同作用域内重复声明同一个变量 // 报错 function fn1() { let a = 1; var a = 2; } // 报错 function fn2() { let a = 1; let a = 2; } function fn3(argements) { let argements; // 也会报错 } es6规定暂时性死区，以及let，const语句不提升变量，主要是为了减少运行时错误，防止在变量声明前就是用这个变量。从而导致意料之外的行为； 1. const命令：const声明一个常量，一旦声明，常量的值就不能改变了，所以const在声明是必须立即初始化，不能留到以后赋值，如果修改它的值会报错 const index = 1; console.log(index)//1 index = 3;// 报错 const num;报错 const声明的常量也不存在变量提升，同样的也是有暂时性死区，也不能重复声明变量 二、块级作用域1、块级作用域的用处在es5中只有全局作用域以及函数作用域，在许多情况下使用很不方便 var num = 1; function f() { console.log(num); if (false) { var num = 2; } } f(); // undefined //在上述代码中在函数内部声明的变量覆盖了外层声明的变量； var index = &apos;hello&apos;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 //在for循环中的计数变量会泄露到全局 2、es6中的块级作用域function fn1() { let i = 5; if (true) { let i = 10; } console.log(n); // 5 } //上述代码中存在两个代码块，都声明了变量i，在运行后输出5，说明function声明的代码块不受if(){}代码块的影响 { { {let i = 5}； console.log(i)//报错 } } //let只在当前代码块中生效,其他代码块中是无法使用的，在es6中允许使用作用域的任意嵌套 {{{ let i = 1; {let i = 2};//不报错，不同的作用域中可以声明同一个变量 }}} 3、块级作用域域函数作用域在es5中函数只能在顶层作用域中以及函数作用域中声明，不能再块级作用域中声明，而es6中则可以在块级作用域中声明函数，在块级作用域中声明的函数只在当前作用域中生效，对其他作用域不会造成影响；另外，es6的块级作用域内声明函数必须使用大括号，如果没有会报错 // 不报错 if (true) { function f() {} } // 报错 if (true) function f() {} 三、变量的解构赋值1、数组的解构赋值在es6以前为变量赋值只能指定值 let a = 1; let b = 2; let c = 3; 上述代码在es6中可以住这样写 let [a, b, c] = [1, 2, 3];//a=1,b=2,c=3 //只要等号两边的模式相同，左边的变量就会被赋值对应的值 { let [x, y] = [1, 2, 3] //x=1,y=2 }; { let [x, ,y] = [1, 2, 3] //x=1,y=3 }; { let [x, [y], [z]] = [1, [2], [3]] //x=1,y=2,z=3 }; { let [x, ...y] = [1, 2, 3, 4] //x=1,y=[2,3,4] }; { let [x, y, ...z] = [1] //x=1,y=undefined,z=[] }; 如果结构不成功就会返回undefined { let x = []; //x = undefined; } { let [x, y] = [1] //y =undefined; } 如果等号左边的变量只能匹配等号右边变量的一部分值，这种情况就是不完全解构，但是解构依然会成功； { let [x, y] = [1, 2, 3] //x=1,y=2; } { let [x, [y], z] = [1, [2, 4], 3] //x=1,y=2,z=3; } 如果等号右边不是数组（不可遍历的结构）就会报错 { let [x] = 1; let [y] = false; let [z] = NaN; let [a] = undefined; let [b] = null; let [c] = {}; } 结构赋值允许指定默认值 { let [x = 1] = [];//x = 1 let [i, n = 2] = [1];//i=1,n=2 let [a = 1, b = 2] = [3]//a=3,b=2 } 在es6内部使用严格相等运算符（===），来判断一个位置是否有值，所以只有一个数组成员严格等于undefined默认值才会生效 { let [x = 1] = [undefined] //x=1 let [y = 2] = [null] //y=null,以为null===undefined不成立； } 如果默认是一个表达式，那么这个表达式只有在用到的时候才会求值 { function fn() { console.log(111); } let [x = f()] = [1];//fn不会执行,因为x能取到值1 } 默认值也可以使用解构赋值的其他变量，但是该变量必须先声明 { let [x = 1, y = x] = [] //x= 1;y =2 } { let [x = 1, y = x] = [2] //x=2,y=2 } { let [x = y, y = 1] = [] //报错 y is not defined，因为y还没有声明 } 2、对象的解构赋值对象的结构和数组类似，但是数组的解构按数组的顺序一次取值，而对象是没有顺序的，变量名必须与属性名一直才能取到正确的值； { let {bar, foo} = {foo: 1, bar: 2} //foo:1,bar:2; let {bar1} = {foo1: 1, bar2: 2} //bar1的值为undefined； } 如果变量名与属性名不一致，必须要写成如下形式 { let {foo: foo1} = {foo: 1} //foo1:1 let foo2 = {num1: 10, num2: 20 }; let {num1: f1, num2: f2} = foo2; //f1:10, f2:20; } 变量结构的机制是先找到同名的属性，然后在赋值给对应的变量，如下： { let {bar: foo1} = {bar: 10, bar1: 20} //foo1:10; bar: error: bar is not defined //bar 只是匹配的模式，foo1才是变量，真正被赋值的是变量foo1而不是模式bar } 与数组解构一样对象的解构也可以嵌套 { let foo = { index: [ 10, { y: 20 } ] } let {index:[x, {y}]} = foo;//x:10,y:20 } 对象结构中要注意赋值的是变量，而不是模式，模式只是用来匹配变量的 { let obj = { foo: { index: { num: 1, col: 2 } } } let {foo:{index: {num,col}}} = obj; //num:1, col:2 } 对象的解构也可以指定默认值 { let {x=1} = {} //x=3 } { let {x: y= 1} = {} // y = 3; } { let {x: y= 1} = {null} // y:null; } //和数组一样默认值生效的条件也是严格等于undefined 如果解构失败，变量的值是undefined { let {foo} = {bar: 1} //foo:undefined } 如果解构模式是嵌套的对象，如果子对象所在的父对象不存在，则会报错 { let {foo: {bar}} = {x: 1} //报错 } 解构赋值允许等号左边的模式中，不放置任何变量名，因此如下写法是可以执行的 { ({} = [1, 2]) ({} = &apos;abc) ({} = []) } 也可以对数组进行对象属性的解构 { let arr = [1, 2, 3]; let {0: f1, [arr.length-1]: f2} = arr //f1:1, f2:3 } 2、字符串的解构赋值字符串在解构的时候会被转换成一个类似数组的对象 { let [A, B, C, D] = &apos;abcd&apos;; //A:a,B:b,C:c,D:d; } 3、数值和布尔值的解构赋值数值和布尔值的解构赋值会先转成对象（隐式调用toString方法） { let {toString: s} = 123;//true s === Number.prototype.toString(隐式调用) } { let {toString: s} = true;//true s === Boolean.prototype.toString } { let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError //undefined,null无法转成对象 } 4、函数参数的解构赋值{ function fn([x, y]) { return x + y; } fn([1, 2]);//3 } 函数参数的结解构也可以指定默认值 { function fn({x=3, y=4} = {}) { return [x, y] } fn({x:10, y:20});// [10, 20] fn(); // [3, 4] } 四、圆括号的使用es6对于圆括号的规则是可能导致解构发生歧义，就不能使用圆括号 1、不能使用圆括号的场景(1). 变量的声明赋值 { let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; //上面6个语句都会报错，因为它们都是变量声明语句，模式中不能使用圆括号 } (2). 函数参数 { function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } // 报错 //函数参数也属于变量声明，因此不能带有圆括号。 } (3). 赋值语句的模式 { ({ p: a }) = { p: 42 }; //报错 ([a]) = [5];//报错 } 1、能使用圆括号的场景(1). 赋值语句的非模式部分，可以使用圆括号。 { [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 } 五、函数1、箭头函数的使用在es6中允许使用“箭头”（=&gt;）定义函数 { var f = fn =&gt; v //以上代码等同于 var f = function fn(v) { return v } } 基本语法 { 用法一：参数1（单一参数） =&gt; {函数声明} //一个参数，多个执行语句 用法二：（参数1）（单一参数） =&gt; 表达式（只有一条语句）//单个参数一条执行语句 用法三：(参数1，参数2，... , 参数n) =&gt; {函数声明} //多个参数，多个执行语句 用法四：(参数1，参数2，... , 参数n) =&gt; 表达式（只有一条语句）//相当于(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }//多个参数，一条语句 用法五： () =&gt; {函数声明} //没有参数时使用()代替 } 其他使用 { var f = bar =&gt; ({foo: bar}) console.log(f(1)); //{foo: 1} //箭头函数如果想直接返回一个对象必须在对象外面加()，不然会报错 } { (参数1, 参数2, ...rest) =&gt; {函数声明} (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明} //可以使用默认参数以及剩余参数 } { let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6 //也可以使用解构 } 如果箭头函数不需要参数或者需要多个参数，则使用一个()代表参数部分 { var f1 = () =&gt; x //等同于 var f1 = function() {return x} } { var f1 = (index1, index2) =&gt; index1 + index2; //等同于var f1 = function(index1, index2) {return index1+index2} } 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 { var f1 = (index1, index2) =&gt; { return index1 + index2; } } 2、箭头函数注意点（1）、箭头函数内部的this是固定的，就是定义时所在的对象，而不是使用时调用的对象；（2）、不能当做构造函数使用，如果和new一起使用会抛出错误；（3）、箭头函数内部不存在arguments对象，但是可以用rest参数代替arguments对象；（4）、call 或 apply 调用在箭头函数中不能修改this指针，他们的第一个参数会被忽略（5）、箭头函数没有prototype属性。（6）、箭头函数在参数和箭头之间不能换行。","tags":[{"name":"es6","slug":"es6","permalink":"https://www.23ybob.club/tags/es6/"}]},{"title":"drafting","date":"2018-07-21T06:46:21.000Z","path":"2018/07/21/cjw08yt4d0000kwvbkg8wzej2/","text":"实现目标div在另一个div中的拖拽效果最近项目中遇到的一个小功能，总结了一下，感觉还不错.github地址： https://github.com/Abriams/js-drafting 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #draft_big &#123; border: 1px solid #FF3300; width: 300px; height: 300px; position: relative; margin-left: 400px; margin-top: 400px; &#125; #draft_small &#123; background: #99CC00; width: 50px; height: 50px; position: absolute; cursor: pointer; right: -80px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"draft_big\"&gt; &lt;div id=\"draft_small\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=\"javascript\"&gt; window.onload = function () &#123; var draftBig = document.getElementById(\"draft_big\"); var draftSmall = document.getElementById(\"draft_small\"); draftSmall.onmousedown = function (event) &#123; var e = e || window.event; //记录并保存可拖拽div（id为draftSmall的盒子）拖拽前的坐标 var startX = e.clientX - draftSmall.offsetLeft; var startY = e.clientY - draftSmall.offsetTop; // offsetHeight,包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话）; // offsetLeft,目标元素距离最近定位的父级元素左边的距离； // offsetTop,目标元素距离最近定位的父级元素上边的距离； // clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。 // clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的垂直坐标。 /*鼠标的移动事件*/ document.onmousemove = function(e) &#123; //判断被拖拽的盒子（id为draftSmall的盒子）必须拖拽到目标盒子（id为draftBig盒子中）才能移动； if(e.clientX - 400 &lt; draftBig.offsetHeight &amp;&amp; e.clientX &gt; 400) &#123; if(e.clientY -400 &lt; draftBig.offsetWidth &amp;&amp; e.clientY &gt; 400) &#123; var e = e || window.event; //计算当前拖拽的盒子（id为draftSmall的盒子）在目标盒子（id为draftBig盒子）中的坐标； draftSmall.style.left = e.clientX - startX + \"px\"; draftSmall.style.top = e.clientY - startY + \"px\"; /*判断拖拽边界（id为draftSmall的盒子四个边界的判断）*/ if (e.clientX - startX &lt;= 0) &#123; draftSmall.style.left = 0 + \"px\"; &#125; if (e.clientY - startX &lt;= 0) &#123; draftSmall.style.top = 0 + \"px\"; &#125; if (e.clientX - startX &gt;= 250) &#123; draftSmall.style.left = 250 + \"px\"; &#125; if (e.clientY - startX &gt;= 250) &#123; draftSmall.style.top = 250 + \"px\"; &#125; &#125; &#125; &#125;; /*鼠标的抬起事件,终止拖动*/ document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; &#125;; &#125;; &#125;; &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"js实现拖拽","slug":"js实现拖拽","permalink":"https://www.23ybob.club/tags/js实现拖拽/"}]},{"title":"vue slot使用小结","date":"2018-07-14T11:20:30.000Z","path":"2018/07/14/cjw08yt4w000akwvbqjrltvb5/","text":"一、slot简介在vue实际项目开发当中，我们经常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在Vue中被称为内容分发。在Vue中，slot也分多种，从Vue的官网中可以获知，其主要分为：单个插槽、具名插槽和作用域插槽三种。下面就逐一介绍这三种插槽的用法： 二、slot插槽具体用法2.1单个插槽的使用从官网中（https://cn.vuejs.org/）我们知道，如果子组件template中没有包含任何一个时，就算父组件分发再多的内容也将会被丢弃。如下案例： 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; 父组件slotdemo组件 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图：上图所示在中添加内容并不会显示 只有子组件模板只中拥有一个没有属性的slot（可以有多个带属性的slot，后面的内容会介绍），父组件传入的整个内容片段才会被插入到slot所在的位置，并将替换掉slot本身，如果传入的内容为空则会显示slot的默认内容。如下案例： 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div&gt;为子组件添加新内容&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 当派发的内容为空时，会默认显示slot的内容 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;/main&gt; &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里 &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.2具名插槽的使用可以用一个特殊的属性name来配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将根据name属性匹配内容片段中有对应slot属性的元素。 父组件slotdemo &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;div slot=&quot;header&quot;&gt;新的slotchildrenheader&lt;/div&gt; &lt;div slot=&quot;main&quot;&gt;新的内容&lt;/div&gt; &lt;div&gt;没有name&lt;/div&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 子组件slotChildren组件， &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt;//如果匹配不到内容显示在这 &lt;/header&gt; &lt;main&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;这是子组件的内容&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;&lt;/script&gt; 页面渲染结果如下图： 2.3作用域插槽的使用作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将prop传递给组件一样： &lt;template&gt; &lt;div&gt; &lt;header&gt;slotchildrenheader&lt;/header&gt; &lt;main&gt;这是子组件的内容&lt;slot :text=&quot;msg&quot;&gt;&lt;/slot&gt;&lt;/main&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;&apos;, data() { return { msg: &quot;slot分发内容&quot;, } }, } &lt;/script&gt; 在父组件中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。 &lt;template&gt; &lt;div class=&quot;Slotdemo&quot;&gt; &lt;slotChildren&gt; &lt;template slot-scope=&quot;props&quot;&gt;//作用域模板插槽必须存在 &lt;div&gt;新的slotchildrenheader&lt;/div&gt; &lt;div&gt;新的内容&lt;div&gt;{{props.text}}&lt;/div&gt;&lt;/div&gt; &lt;/template&gt; &lt;/slotChildren&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import slotChildren from &apos;./slotChildren.vue&apos; export default { name: &quot;Slotdemo&quot;, components: { slotChildren } } &lt;/script&gt; 页面渲染结果如下图： 三、小结这篇文章主要介绍vue中的插槽的使用方法。只是一个空壳子，他的显示以及如何显示手父组件的控制，插槽显示的位置由子组件自身决定。父组件传过来的模板显示组件的template。使用slot可以帮助我们更容易，灵活的使用组件，同时也提高了组件的复用性。","tags":[{"name":"slot","slug":"slot","permalink":"https://www.23ybob.club/tags/slot/"},{"name":"vue","slug":"vue","permalink":"https://www.23ybob.club/tags/vue/"}]},{"title":"工作中遇到的问题总结","date":"2018-07-04T11:20:30.000Z","path":"2018/07/04/cjw08yt52000dkwvbx745ugkw/","text":"一、element ui 的使用总结1.1. 自定义验证规则的使用在自定义验证规则的时候每一个判断里（if()else()或者if()else if() else()）都要有callback,否则表单在执行this.$refs[formName].validate((valid) =&gt; {}) 的时候，内部代码是不会执行的； &lt;el-form :model=&quot;ruleForm2&quot; status-icon :rules=&quot;rules2&quot; ref=&quot;ruleForm2&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt; &lt;el-input v-model.number=&quot;ruleForm2.age&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm2&apos;)&quot;&gt;提交&lt;/el-button&gt; &lt;el-button @click=&quot;resetForm(&apos;ruleForm2&apos;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;script&gt; export default { data() { var checkAge = (rule, value, callback) =&gt; { if (!value) { return callback(new Error(&apos;年龄不能为空&apos;)); } setTimeout(() =&gt; { if (!Number.isInteger(value)) { callback(new Error(&apos;请输入数字值&apos;)); } else { if (value &lt; 18) { callback(new Error(&apos;必须年满18岁&apos;)); } else { callback();//不能省略，不然无法执行 } } }, 1000); }; var validatePass = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请输入密码&apos;)); } else { if (this.ruleForm2.checkPass !== &apos;&apos;) { this.$refs.ruleForm2.validateField(&apos;checkPass&apos;); } callback(); } }; var validatePass2 = (rule, value, callback) =&gt; { if (value === &apos;&apos;) { callback(new Error(&apos;请再次输入密码&apos;)); } else if (value !== this.ruleForm2.pass) { callback(new Error(&apos;两次输入密码不一致!&apos;)); } else { callback(); } }; return { ruleForm2: { pass: &apos;&apos;, checkPass: &apos;&apos;, age: &apos;&apos; }, rules2: { pass: [ { validator: validatePass, trigger: &apos;blur&apos; } ], checkPass: [ { validator: validatePass2, trigger: &apos;blur&apos; } ], age: [ { validator: checkAge, trigger: &apos;blur&apos; } ] } }; }, methods: { submitForm(formName) { this.$refs[formName].validate((valid) =&gt; { if (valid) { alert(&apos;submit!&apos;); } else { console.log(&apos;error submit!!&apos;); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); } } } &lt;/script&gt; 1.2移动端ios以及andriod兼容问题1.2.1 ios以及andriod使用overflow: scroll;遇到的问题；页面滚动时使用overflow：scroll;在ios端会出现滑动不流畅问题。 为了解决这个问题，首先我使用了-webkit-overflow-scrolling : touch;这个属性，发现使用这个属性以后，ios页面在滑动到底部或者顶部会出现页面卡死问题，在网上找了好多方法参考这篇文章https://hk.saowen.com/a/ba965995919b5f04ed8bcb7ccc5b4af1e95792e9769fd92a8d36881d1fad8683个人觉得这篇文章写得很好，试了一下这些方法，发现最后还是没有解决，最后发现不要用原生的滚动也就是overflow：scroll;并且阻止ios的默认滑动效果，改为使用better-scroll这个滚动插件完美解决了以上的问题；参考如下案例： &lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;contain-img wrapper&quot; ref=&quot;menuWrapper&quot; v-show=&quot;Show&quot; id=&quot;contain-img&quot;&gt; &lt;ul class=&quot;content&quot; id=&quot;content&quot; ref=&quot;content&quot;&gt; //合同图片显示 &lt;div class=&quot;img01&quot; id=&quot;img01&quot;&gt;&lt;img src=&quot;../../static/img/demo-detail01.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img02&quot;&gt; &lt;img id=&quot;img01&quot; src=&quot;../../static/img/demo-detail02.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;pact-sign&quot; v-show=&quot;isSubmit&quot; @click=&quot;sign()&quot;&gt;提交&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import BScroll from &apos;better-scroll&apos; export default { data() { return { contractImg: &apos;&apos;, isSubmit: true, Show: true } }, created() { this.$nextTick(()=&gt;{ //异步执行 setTimeout(() =&gt; { let containImg = document.getElementById(&quot;img01&quot;).offsetHeight; let bodyHeight = document.body.clientHeight; let distance = bodyHeight-containImg; let scrollHeight = containImg-distance; this.meunScroll=new BScroll(this.$refs.menuWrapper,{});//初始化better-scroll插件 this.meunScroll.scrollTo(0,-scrollHeight); //页面加载完滚动到某个位置 }, 100) }); this.$nextTick(function(){ document.getElementsByTagName(&quot;img&quot;)[0].onload =function() { document.body.addEventListener(&apos;touchmove&apos;, function (e) { e.preventDefault() // 阻止默认的处理方式(阻止下拉滑动的效果) }, {passive: false}) // passive 参数不能省略，用来兼容ios和android } }); }, beforeCreate() { document.title = &apos;签署确认&apos;; }, } &lt;/script&gt; &lt;style scoped&gt; *{ margin: 0; padding: 0; } body, html { height: 100%; width: 100%; background-color: #fff; } .container { width: 100%; height: 100%; } .contain-img { width: 100%; height: 100%; position: absolute; /* overflow: scroll; -webkit-overflow-scrolling : touch; */ } .container img { width: 100%; height: 100%; } .pact-sign { width: 40px; height: 40px; line-height: 40px; position: fixed; bottom: 40px; right: 20px; border-radius: 50%; background-color: #409EFF; text-align: center; color: #ffffff; z-index: 10; } .img01, .img02 { position: relative; overflow: hidden; } &lt;/style&gt; 1.3 prop以及attr的使用使用attr获取checked属性、disabled属性、select属性，如果这些属性默认选中可以取到值，如果未选中值返回undefined，使用prop则可以解决这些问题 官方文档建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()； 1.4 npm打包卡死问题修改为淘宝源：（npm config set registry http://registry.cnpmjs.org）；","tags":[]},{"title":"javascript权威指南理解片一","date":"2018-06-24T09:38:29.000Z","path":"2018/06/24/cjw08yt4s0006kwvbit3ctvcu/","text":"eval函数eval函数执行另一段javascript代码; eval(&quot;function f() {return x + 1}&quot;); //eval函数只有一个参数，如果参数不是字符串则直接返回这个函数 console.log(eval(11)); //11 //如果参数是字符串则会将字符串当做javascript代码进行编译执行 //并且返回最后一个表达式或语句得值，如果最后一个表达式或语句没有值则返回undefined； //eval使用的作用域是调用他的作用域；如果eval调用了全局函数，则返回的是全局变量的值，如果eval调用了局部函数，他会返回局部变量的值； var geval = eval; var x = &quot;global&quot;, y = &quot;global&quot;; function f() { var x = &quot;local &quot;; eval(&quot;x += &apos;changed&apos;;&quot;) //改变局部变量x的值 return x; } function g() { var y = &quot;local&quot;; geval(&quot;y += &apos; changed&apos;;&quot;); //改变全局变量y的值 return y; } console.log(f(), x); //local changed global console.log(g(), y); //local global changed 三元运算符x &gt; 0 ? x : -x 条件运算符的操作数可以是任意类型，第一个操作符如果是真值，那么返回第二个操作符的结果，如果第一个操作符是假值，则返回第三个操作符的结果； typeof 运算符","tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.23ybob.club/tags/javascript/"}]},{"title":"vuex个人理解","date":"2018-06-14T11:20:30.000Z","path":"2018/06/14/cjw08yt50000bkwvbpa6a9h1y/","text":"什么是vuex及其作用vuex是一个转为vue.js开发的状态管理模式（如同redux是为react提供的状态管理模式），采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 什么是”状态管理模式”在我看来就是在vue中把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中，以供其他任意组件使用； vuex核心vuex核心就是store仓库，也就是一个容器，在这个容器中存储着vuex应用的状态（state） vuex特点 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 在vuex中你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 vuex案例实现1、将state,mutations,actions写在一起 安装vuex，在命令行执行如下命令（注意点：要加上–save，因为这个包在生产环境中是要使用的） npm install vuex –save 新建store文件夹（名称不唯一），并在store文件夹中新家store.js文件，然后引入vue,以及vuex；代码实现如下 import Vue from ‘vue’; import Vuex from ‘vuex’; 使用vuex，代码如下 Vue.use(Vuex); 通过以上3步vuex就可以使用了，接下来就用一个小案例具体实现 在main.js中引入刚新建的store文件 import store from ‘./store/store’ 在实例化Vue对象中加入store对象 new Vue({ el: &apos;#app&apos;, router, store,//使用store template: &apos;&lt;App/&gt;&apos;, components: { App } }) demo介绍 在store.js定义要使用的对象 const state = { count:1 } 在store.js中加入改变state的方法 //提交state的唯一途径（mutations），state对应上边const state中存储的值； const mutations={ add(state){ state.count++; } } actions提交mutations（actions不能直接提交state，只能通过提交mutations改变state） //提交mutations const actions ={ //Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象 addCount(context){ context.commit(&apos;add&apos;) } } getter获取store中的 state 中派生出的一些状态 getters: { counts: state =&gt; { return state.count - 1 } } 在组建中使用 新建count.vue组建具体代码如下 &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;addCount&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; //在组件中通过mapState对象赋值 //首先引入mapState对象&apos;; //然后在computed计算属性里获取值并操作： &lt;script&gt; import {mapState} from &apos;vuex&apos;; export default { computed:mapState({ //理解为传入state对象，修改state.count属性； count:state=&gt;state.count }) } &lt;/script&gt; 2、将state,mutations,actions分开管理1.建立相应目录 src文件夹下新建store文件夹 在store文件夹下新建cart文件夹，index.js文件 在cart文件夹下新建state.js, mutations.js, mutation_type, actions.js, getters.js, index.js 在store文件夹下的index.js问价下添加如下代码 import Vue from ‘vue’; import Vuex from ‘vuex’; Vue.use(Vuex); import cart from ‘./cart/‘; export default new Vuex.Store({ modules: { cart } }); 在cart文件夹下的state.js定义要使用的对象 export default { count: 1, isshow: false, params: &apos;hide&apos; } 在mutations.js问价中改变state.js中的状态 import * as types from ‘./mutations_types’ export default { [types.COUNT_LOCAL](state) { state.count += 1 } , [types.REDUCE_LOCAL](state) { state.count -= 1 } , [types.ISSHOW_LOCAl](state,params) { state.isshow = !state.isshow state.params = &apos;hide&apos; ? &apos;show&apos; : &apos;hide&apos; } } 在mutations_type.js中分离mutations.js，便于后期维护 export const COUNT_LOCAL = ‘COUNT_LOCAL’ export const ISSHOW_LOCAl = ‘ISSHOW_LOCAl’ export const REDUCE_LOCAL = ‘REDUCE_LOCAL’ 在action.js中提交mutations import * as types from ‘./mutations_types’ export default { change_count: ({ commit }) =&gt; { commit(types.COUNT_LOCAL); }, change_isshow: ({ commit },{params}) =&gt; { commit(types.ISSHOW_LOCAl,{params}); }, change_reduce: ({ commit }) =&gt; { commit(types.REDUCE_LOCAL) } } 7.在getters.js中获取state中的派生状态 export default { getCount(state) { return state.count; } }; 在caet文件夹下的index.js中导出数据 import state from ‘./state’; import mutations from ‘./mutations’; import getters from ‘./getters’; import actions from ‘./actions’; export default { state, mutations, getters, actions }; 在组件中使用（使用dispatch提交） &lt;div&gt; &lt;h3&gt;&lt;/h3&gt; &lt;button @click=&quot;change()&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&apos;change_reduce&apos;)&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;getmessage()&quot;&gt;get&lt;/button&gt; &lt;input type=&quot;text&quot; :value=&quot;$store.state.cart.count&quot;&gt; &lt;button @click=&quot;changeShow()&quot; ref=&quot;hide&quot;&gt;hide&lt;/button&gt; &lt;input type=&quot;text&quot; v-show=&quot;show&quot; value=&quot;11&quot;&gt; &lt;/div&gt; &lt;script&gt; import { mapState } from &apos;vuex&apos; export default { data () { return { msg: &apos;Hellow Vuex&apos;, show: false } }, methods: { getmessage() { console.log(this.$store.state.cart.count) }, change() { this.$store.dispatch(&apos;change_count&apos;); }, changeShow() { let ishide = this.$store.state.cart.params; if( ishide == &apos;hide&apos;) { ishide = &apos;show&apos; } else { ishide = &apos;hide&apos; } console.log(ishide); this.$store.dispatch(&apos;change_isshow&apos;,&apos;ishide&apos;) this.show = this.$store.state.cart.isshow this.$refs.hide.innerHTML = this.$store.state.cart.params // console.log(this.$store.state.cart.params) } }, computed: { ...mapState({ count: state =&gt; { console.log(state.count) } }) } } &lt;/script&gt; 小结假如你的项目需要数据 和 组件 分离，分别处理，使用 Vuex 是非常合适的，相反，如果不需要分离处理，那么不使用 Vuex 也没关系。","tags":[{"name":"vuex","slug":"vuex","permalink":"https://www.23ybob.club/tags/vuex/"}]},{"title":"从零开始使用github page + hexo搭建个人博客","date":"2018-05-15T11:20:30.000Z","path":"2018/05/15/cjw08yt6f000vkwvb8wp5gei8/","text":"首先附上我使用hexo搭建的博客：https://23ybob.club/github地址: https://github.com/Abriams/Abriams.github.io 简介：个人刚使用hexo+github page搭建完博客，感觉还是很有成就感，所以把自己的一些在搭建过程中遇到的问题总结了一下，并为大家介绍hexo的详细配置，如何将hexo布置到github上，以及最后绑定域名 写在前面：我是一名前端开发人员，经常都会浏览别人的博客，感觉很高大上，一直以后也希望有一个属于自己的博客，虽然以前也搭建过博客，但是做的不是很精细，博客也没有去维护，最近看了别人的文章感触挺深，所以参考一些资料自己完完全全搭建了一个博客，总体来说很简单，如果你是一名程序开发爱好者，刚好你也想搭建自己的博客，你可以认认真真阅读这篇文章，相信对你搭建博客会有很大帮助 废话不多说，直接开始搭建过程 一、安装搭建必须软件1. 安装node.js(直接去node官网下载自己需要的版本即可，这个应该不用多说了吧)2. 安装git（https://git-scm.com/download/win）2.1安装完成后再命令行输入git version查看是否安装成功如果安装成功鼠标右键就会出现Git GUI Here和Git Bash Here两个按钮，然后选择Git Bash Here即可打开git命令行 1. 安装教程：https://git-scm.com/download/win 2. Git入门教程：http://git.oschina.net/progit/ 3. git常用命令 - git clone仓库地址：将远程仓库clone到本地 - git init ：新建仓库 - git pull： 抓取远程仓库所有分支更新并合并到本地 - git add 文件名或者.：添加新文件 - git commit：提交你的修改 - git push：推送本地仓库更新到远程仓库 二、hexo介绍及安装Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.hexo安装在命令行输入 npm install -g hexo-cli 即可安装hexo安装完hexo还需安装将hexo部署到git page的deployer，在命令行输入 npm install hexo-deployer-git –save 2.使用hexo建立建立需要的文件选择自己要存放文件的目录，右键打开点击Git Bash Here，进入命令行执行 hexo init，安装完以后会在指定文件夹的中新建需要的文件，目录结构如下.git├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themeshexo配置参数可在https://hexo.io/zh-cn/docs/setup.html 中参看 3.执行hexohexo根目录中执行hexo generate 以及 hexo server，并且登录localhost:4000，即可看到本地的效果： 三、将博客布置到github Pages上经过以上步骤我们已经使用hexo搭建了一篇博客，但是我们只能通过本地查看，别人是不能看我们的博客的，所以现在我们需要将本地博客发布到服务器上，让别人也可以访问我们的博客，github Pages就可以帮我们实现这件事情，我们都知道github Pages的代码是保存在github上的所以现在我们需要在github上新建一个项目 1.注册github账号访问github官网： https://github.com/ 点击Sign Up注册自己的账号 2.创建项目代码库新用户点击New repository即可创建github Pages（如果已经创建过github Pages，点击github + 弹出新建github Pages主页，示例如下） 在弹出的github Pages主页中填写需要的内容 3.配置SSH密钥Github的SSH密钥可以使本地git项目与远程的github建立联系，这样我们就能将本地代码通过git操作实现与Github库的代码同步，具体操作如下： 1). 查看本机是否已经存在 SSH密钥（keys）打开git命令行（可在任一位置打开）运行 cd ~/. ssh 检查本机用户home目录下是否存在.ssh目录，如果，不存在此目录，则进行2).操作，否则，你本机已经存在ssh公钥和私钥，可以略过2).步，直接进入3).操作 2). 创建SSH密钥（keys）$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;（按照你提供的邮箱地址，创建一对密钥） 直接回车，会将密钥按默认文件进行存储当然了你也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 然后按照提示需要输入密码以及确认密码（一般其实也很安全，不需要密码，直接回车即可） 最后，输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 3). 在github中添加你的公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。（运行完成后直接右键赋值即可 ） clip &lt; ~/.ssh/id_rsa.pub 3.1 登录github登录github进入Setting，如下图所示 3.2 选择SSH and GPG keys选择SSH and GPG keys，如下图所示 3.2 选择New SSH key点击右上角New SSH key即可添加 3.3 粘贴密钥将密钥粘贴在下方文本框中，如图 3.4 测试密钥输入下方命令，查看是否成功 ssh -T git@github.com 如果是如下所示，输入yes回车即可 The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 3.5 设置用户信息现在已经通过SSH链接到了Github，但是git是根据用户的名字和邮箱来提交的，github也是用名字和邮箱处理权限的，为了方便可以使用如下命令设置自己的 邮箱和名字 git config --global user.name &quot;ryanlijianchang&quot;//用户名 git config --global user.email &quot;liji.anchang@163.com&quot;//填写自己的邮箱 此时，SSH key已经配置成功，本机成功连接到github 四. 将hexo更新到github上4.1 打开github pages登录自己的github，选择刚才新建的github pages （Amriams/Amriams.github.io） 4.2 获取SSH类型地址进去页面选择clone or download， 再选择Use SSH，复制SSH密钥 4.3 配置hexo连接SSH打开新建的hexo根目录下的_config.yml文件 4.3 配置SSH在打开的文件里添加配置 deploy: type: git repository: git@github.com:Abriams/Abriams.github.io.git branch: master 如图： 4.4 将本地hexo代码布置到github上执行 hexo g -d 即可 执行时会让你输入github账号以及密码，输入完成后，回车即可在github pages服务器上访问我们的博客了，对应的地址就是username.github.io（我的博客是Abriams.github.io） 如果在上述执行过程中出现 ERROR Deployer not found: git，这个提示是你的deployer没有安装成功，所以需要安装 执行npm install hexo-deployer-git –save， 然后在执行hexo g -d就可将博客部署到github pages 上了 4.5 访问自己的博客访问https://Abriams.github.io就可看到自己的博客啦（https://您的用户名.github.io） 4.6 美化博客进入hexo官网https://hexo.io/themes/选择自己喜欢的主题即可 选择好主题后再打开Hexo文件夹下的themes目录（E:\\hexo\\BIOG\\themes），右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 等待下载完成后，打开Hexo文件夹下的配置文件_config.yml，修改参数为：theme: hexo-theme-next 然后依次执行 hexo g ， hexo s，打开浏览器，输入 http://localhost:4000/ 即可看见刚更新的主题啦。 更多hexo配置请在hexo官网https://hexo.io/zh-cn/docs/configuration.html查看详情 4.7部署新内容到github打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 执行完成后访问https://您的用户名.github.io即可 五. 使用hexo写博客首先新建文件 hexo n “文章标题” ，执行完成后会在项目E:\\hexo\\BIOG\\source_posts中生成 文章标题.md文件，当然，也可以直接在\\Hexo\\source_posts中新建一个md文件，然后使用markdown书写文章即可，文章完成后使用执行hexo g（生成）， hexo d（部署），就会将文章部署到github上 六.在hexo中华添加图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，（上传本地图片的插件） 3 等待一段时间后，再运行hexo n “xxxx”来生成md文件时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 七、将独立域名关联到github pages上1. 购买域名选择自己喜欢的域名购买即可，我是在腾讯云购买的一下一腾讯云为例https://cloud.tencent.com/?fromSource=gwzcw.234976.234976.234976 2. 配置域名域名买好后在https://console.qcloud.com/domain/mydomain 中管理自己的域名 进去我的域名页面点击解析，如下图 选择添加记录，添加即可，如下图 然后打开github pages你的项目，选择Settings 下拉到github pages设置添加域名 八.hexo中添加标签选项1 生成“标签页”并添加type属性打开命令行执行如下命令 hexo new page tags 成功后会提示INFO Created: ~/Documents/blog/source/tags/index.md 找到blog/source/tags/index.md的文件并添加type: “tags”如下所示： --- title: 文章分类 date: 2017-05-27 13:47:40 type: &quot;tags&quot; --- 2 给文章添加”tags”属性打开需要添加标签的文章，并添加tags属性，如下（tags后的- vuex就是标签内容） --- title: vuex个人理解 tags: - vuex --- 注意：只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 九.添加微博秀首先获取在微博上获取微博秀 &lt;iframe width=&quot;100%&quot; height=&quot;550&quot; class=&quot;share_self&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1&quot;&gt;&lt;/iframe&gt; 找到BIOG/themes/BlueLake/layout/_widget/weibo.jade文件将src=””里面的内容换成微博秀src=””里面的内容 然后找到跟目录下的_config.yml文件，将widgets:添加- weibo 如下： widgets: - recent_posts - category - tag - archive - weibo - links 注意：如果网站使用的是https协议，需要将微博秀中的http换成https即可； 10.设置百度分享（https）首先下载百度分享的文件 https://themebetter.com/uploads/2017/09/static.zip （解压码：themebetter）；将下载后的文件放到主题文件夹下的source文件夹下 修改百度分享代码：在主题文件夹下的layout/_partial/comment_js.jade 下全局搜索http://bgimg.share.baidu.com并去掉http://bgimg.share.baidu.com即可； window._bd_share_config={&quot;common&quot;:{&quot;bdSnsKey&quot;:{},&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;2&quot;,&quot;bdMiniList&quot;:[&quot;mshare&quot;,&quot;weixin&quot;,&quot;tsina&quot;,&quot;qzone&quot;,&quot;linkedin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;print&quot;,&quot;renren&quot;,&quot;sqq&quot;,&quot;evernotecn&quot;,&quot;bdysc&quot;,&quot;tqq&quot;,&quot;tqf&quot;,&quot;bdxc&quot;,&quot;kaixin001&quot;,&quot;tieba&quot;,&quot;douban&quot;,&quot;bdhome&quot;,&quot;thx&quot;,&quot;ibaidu&quot;,&quot;meilishuo&quot;,&quot;mogujie&quot;,&quot;diandian&quot;,&quot;huaban&quot;,&quot;duitang&quot;,&quot;hx&quot;,&quot;fx&quot;,&quot;youdao&quot;,&quot;sdo&quot;,&quot;qingbiji&quot;,&quot;people&quot;,&quot;xinhua&quot;,&quot;mail&quot;,&quot;isohu&quot;,&quot;yaolan&quot;,&quot;wealink&quot;,&quot;ty&quot;,&quot;iguba&quot;,&quot;h163&quot;,&quot;copy&quot;],&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;1&quot;,&quot;bdSize&quot;:&quot;16&quot;},&quot;share&quot;:{},&quot;image&quot;:{&quot;viewList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;],&quot;viewText&quot;:&quot;分享到：&quot;,&quot;viewSize&quot;:&quot;16&quot;},&quot;selectShare&quot;:{&quot;bdContainerClass&quot;:null,&quot;bdSelectMiniList&quot;:[&quot;tsina&quot;,&quot;qzone&quot;,&quot;weixin&quot;,&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;youdao&quot;,&quot;evernotecn&quot;,&quot;mshare&quot;]}};with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||head).appendChild(createElement(&apos;script&apos;)).src=&apos;http://bgimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)] //执行完上面几部发现请求的百度分享地址已经替换成了本地，但是在控制台会报错；这是hexo编译了static文件夹导致的； 最后修改根目录下的—_config.yml文件 找到skip_render并添加static/** ，如下所示 skip_render: static/** //防止hexo编译static文件导致报错； 小结：通过以上操作，一篇博客终于搭建成功了，虽然在搭建的过程中会遇到各种问题，这需要我们耐心解决，当所有问题都完成后，我个人收货到了很大成果，也希望各位小伙伴能有自己的收获，另外，既然博客搭建成功了，那么就一定要坚持下去，不需要每天都写，但是每个月写自己的总结心得，总是不过分的吧","tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.23ybob.club/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://www.23ybob.club/tags/github-pages/"}]},{"title":"初识前端","date":"2018-05-06T11:20:30.000Z","path":"2018/05/06/cjw08yt4l0002kwvb1c2oj0wn/","text":"个人对前端的理解前端发展1.什么是前端虽然是做前端的，但是具体概念还真不知道，个人感觉就是写页面，渲染数据 2.前端演进史2.1.从静态走向动态大约1994就是前端发展的历史吧，前端都知道1943年10月13日网景公司推出了第一版Navigator；Tim Berners-Lee创建了W3C；Tim的基友发布了CSS。同样在这一年，为动态web网页设计的服务端脚本PHP诞生。 早期网页都是为了方便科学家看文章，传论文而制造的，这也就是为什么Web网页都基于Document，随着网页技术从学术机构走向社会，网页承载的功能已经不足以满足当前需求，因此早期网页的局限性也显示出来了 2.1.1 所有的网页都基于HTML页面，因为没有任何手段可以控制局部内容的显示和隐藏，因此任何局部的变化哪怕只多出一个标点符号，都只能重新下载一个新的页面。2.1.2 计算任务只能在服务端实现。由于网速限制，与服务器通信的过程是非常缓慢的，并且此过程是同步阻塞的，于是会出现这样的场景：用户提交一个表单，然后整个页面消失，浏览器呈现白屏，经过漫长的等待，浏览器渲染出一个和之前一模一样的页面，只不过输入框旁边多了一排红色小字：用户名错误。2.1.3 所有页面都是静态的，这意味着一个电商网站有一千种商品，哪怕页面布局一模一样，也必须写一千个单独的页面。1994年Rasmus Lerdorf为了维护个人网站而创建了PHP，PHP实现了与数据库的交互以及用于生产动态页面的模板引擎，是Web领域中最主流的服务端语言。 1995年网景推出了JavaScript，实现了客户端的计算任务（如表单验证）。 1996年微软推出了iframe标签，实现了异步的局部加载。 1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。 2006年，XMLHttpRequest被W3C正式纳入标准。 至此，早期的Document终于进化为了Web page，早期网页的三个局限都得到了妥善的解决。 2.2从后端走向前端早期网页都是有后端主导的，前端也就只是操作dom，2006年 John Resig发布了jQuery，主要用于操作DOM 起初制约Web开发从后到前的因素很简单，就是前端很多事干不了或干不好，当时的浏览器性能弱，标准化程度低，2008年问世的谷歌V8引擎改变了这一局面，现代浏览器的崛起终结了微软的垄断时代 ECMA也在2009年发布了第五代JavaScript 2009年AngularJS诞生，随后被谷歌收购。 2010年backbone.js诞生。 2011年React和Ember诞生。 2014年Vue.js诞生……前后端分离可谓大势所趋。 参考： Web开发的发展史http://blog.jobbole.com/45169/ https://www.cnblogs.com/leolovexx/p/7249314.html","tags":[{"name":"前端历史","slug":"前端历史","permalink":"https://www.23ybob.club/tags/前端历史/"}]}]