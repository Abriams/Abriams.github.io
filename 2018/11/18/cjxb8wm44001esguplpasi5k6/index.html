<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Abriams blog"><meta name="keywords" content="前端， 移动互联网, vue"><title>javascript数据结构与算法五（链表） | 淡笑忘、祈一世凡恋</title><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript数据结构与算法五（链表）</h1><a id="logo" href="/.">淡笑忘、祈一世凡恋</a><p class="description">进步的源泉来源于坚持不懈</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">javascript数据结构与算法五（链表）</h1><div class="post-meta"><a href="/2018/11/18/cjxb8wm44001esguplpasi5k6/#comments" class="comment-count"></a><p><span class="date">Nov 18, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、链表数据结构"><a href="#一、链表数据结构" class="headerlink" title="一、链表数据结构"></a>一、链表数据结构</h2><p>要存储多个元素，数组（或列表）可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管JavaScript的array类方法做这些事，但背后的情况同样是这样）。</p>
<p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展示了一个链表的结构：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-01.png" alt="链表数据结构"></p>
<p>相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。</p>
<p>现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。</p>
<p>另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法，就是从起点（第一条线索）顺着列表寻找。</p>
<p>还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或移除它。下图演示了一列火车。每节车皮都是列表的元素，车皮间的连接就是指针：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-02.png" alt="链表数据结构"></p>
<h2 id="二、创建链表"><a href="#二、创建链表" class="headerlink" title="二、创建链表"></a>二、创建链表</h2><p>理解了链表是什么之后，现在就要开始实现我们的数据结构了，以下是我们的LinkedList类的骨架：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123; &#125;; </span><br><span class="line">    <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedList数据结构还需要一个Node辅助类（行{1}）。Node类表示要加入列表的项。它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。</p>
<p>LinkedList类也有存储列表项的数量的length属性（内部/私有变量）（行{2}）。</p>
<p>另一个重要的点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在一个称为head的变量中（行{3}）</p>
<p>然后就是LinkedList类的方法。在实现这些方法之前，先来看看它们的职责。</p>
<ul>
<li>append(element)：向列表尾部添加一个新的项。</li>
<li>insert(position, element)：向列表的特定位置插入一个新的项。</li>
<li>remove(element)：从列表中移除一项。</li>
<li>indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。</li>
<li>removeAt(position)：从列表的特定位置移除一项。</li>
<li>isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。</li>
<li>size()：返回链表包含的元素个数。与数组的length属性类似。</li>
<li>toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。</li>
</ul>
<h3 id="2-1-向链表尾部追加元素"><a href="#2-1-向链表尾部追加元素" class="headerlink" title="2.1 向链表尾部追加元素"></a>2.1 向链表尾部追加元素</h3><p>向LinkedList对象尾部添加一个元素时，可能有两种场景：列表为空，添加的是第一个元素，或者列表不为空，向其追加元素。</p>
<p>下面是我们实现的append方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedList类的骨架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>; <span class="comment">// </span></span><br><span class="line">    <span class="comment">//实现LinkedList类的append方法</span></span><br><span class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element), <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            current; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123; <span class="comment">//列表中第一个节点 //&#123;3&#125;</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = head; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            <span class="comment">//循环列表，直到找到最后一项</span></span><br><span class="line">            <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到最后一项，将其next赋为node，建立链接</span></span><br><span class="line">            current.next = node; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        length++; <span class="comment">//更新列表的长度 //&#123;6&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要做的是把element作为值传入，创建Node项（行{1}）。</p>
<p>先来实现第一个场景：向为空的列表添加一个元素。当我们创建一个LinkedList对象时，head会指向null：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-03.png" alt="链表数据结构"></p>
<p>如果head元素为null（列表为空——行{3}），就意味着在向列表添加第一个元素。因此要做的就是让head元素指向node元素。下一个node元素将会自动成为null。</p>
<p>列表最后一个节点的下一个元素始终是null。</p>
<p>再来看看第二个场景，也就是向一个不为空的列表尾部添加元素。</p>
<p>要向列表的尾部添加一个元素，首先需要找到最后一个元素。记住，我们只有第一个元素的引用（行{4}），因此需要循环访问列表，直到找到最后一项。为此，我们需要一个指向列表中current项的变量（行{2}）。</p>
<p>循环访问列表时，当current.next元素为null时，我们就知道已经到达列表尾部了。然后要做的就是让当前（也就是最后一个）元素的next指针指向想要添加到列表的节点（行{5}）。下图展示了这个行为：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-04.png" alt="链表数据结构"></p>
<p>而当一个Node元素被创建时，它的next指针总是null。这没问题，因为我们知道它会是列表的最后一项。</p>
<p>当然，别忘了递增列表的长度，这样就能控制它，轻松地得到列表的长度（行{6}）。</p>
<p>我们可以通过以下代码来使用和测试目前创建的数据结构：</p>
<blockquote>
<p>let list = new LinkedList();<br>list.append(15);<br>list.append(10); </p>
</blockquote>
<h3 id="2-2-从链表中移除元素"><a href="#2-2-从链表中移除元素" class="headerlink" title="2.2 从链表中移除元素"></a>2.2 从链表中移除元素</h3><p>现在，让我们看看如何从LinkedList对象中移除元素。移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种remove方法：第一种是从特定位置移除一个元素，第二种是根据元素的值移除元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedList类的骨架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//实现LinkedList类的append方法</span></span><br><span class="line">    <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//检查越界值</span></span><br><span class="line">        <span class="keyword">if</span> (position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">            <span class="keyword">let</span> current = head, <span class="comment">// &#123;2&#125;</span></span><br><span class="line">                previous, <span class="comment">// &#123;3&#125;</span></span><br><span class="line">                index = <span class="number">0</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">            <span class="comment">//移除第一项</span></span><br><span class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">                head = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (index++ &lt; position) &#123; // &#123;6&#125;</span><br><span class="line">                    previous = current; // &#123;7&#125;</span><br><span class="line">                    current = current.next; // &#123;8&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //将previous与current的下一项链接起来：跳过current，从而移除它</span><br><span class="line">                previous.next = current.next; // &#123;9&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            length--; // &#123;10&#125;</span><br><span class="line">            return current.element;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null; // &#123;11&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一步一步来看这段代码。该方法要得到需要移除的元素的位置，就需要验证这个位置是有效的（行{1}）。从0（包括0）到列表的长度（size – 1，因为索引是从零开始的）都是有效的位置。如果不是有效的位置，就返回null（意即没有从列表中移除元素）。</p>
<p>首先为第一种场景编写代码：我们要从列表中移除第一个元素（position === 0——行{5}）。下图展示了这个过程：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-05.png" alt="链表数据结构"></p>
<p>因此，如果想移除第一个元素，要做的就是让head指向列表的第二个元素。我们将用current变量创建一个对列表中第一个元素的引用（行{2}——我们还会用它来迭代列表，但稍等一下再说）。这样current变量就是对列表中第一个元素的引用。如果把head赋为current.next，就会移除第一个元素</p>
<p>现在，假设我们要移除列表的最后一项或者中间某一项。为此，需要依靠一个细节来迭代列表，直到到达目标位置（行{6}——我们会使用一个用于内部控制和递增的index变量）：current变量总是为对所循环列表的当前元素的引用（行{8}）。我们还需要一个对当前元素的前一个元素的引用（行{7}）；它被命名为previous（行{3}）。</p>
<p>因此，要从列表中移除当前元素，要做的就是将previous.next和current.next链接起来（行{9}）。这样，当前元素就会被丢弃在计算机内存中，等着被垃圾回收器清除。</p>
<p>我们试着通过一些图表来更好地理解。首先考虑移除最后一个元素：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-06.png" alt="链表数据结构"></p>
<p>对于最后一个元素，当我们在行{6}跳出循环时，current变量将是对列表中最后一个元素的引用（要移除的元素）。current.next的值将是null（因为它是最后一个元素）。由于还保留了对previous元素的引用（当前元素的前一个元素），previous.next就指向了current。那么要移除current，要做的就是把previous.next的值改变为current.next。</p>
<p>现在来看看，对于列表中间的元素是否可以应用相同的逻辑：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-06.png" alt="链表数据结构"></p>
<p>current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。那么要移除current元素，需要做的就是将previous.next与current.next链接起来。因此，我们的逻辑对这两种情况都管用。</p>
<h3 id="2-3-在任意位置插入元素"><a href="#2-3-在任意位置插入元素" class="headerlink" title="2.3 在任意位置插入元素"></a>2.3 在任意位置插入元素</h3><p>接下来，我们要实现insert方法。使用这个方法可以在任意位置插入一个元素。我们来看一看它的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</span><br><span class="line">            current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">//在第一个位置添加</span></span><br><span class="line">            node.next = current; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (index++ &lt; position) &#123; //&#123;3&#125;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = current; //&#123;4&#125;</span><br><span class="line">            previous.next = node; //&#123;5&#125; </span><br><span class="line">        &#125;</span><br><span class="line">        length++; //更新列表的长度</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false; //&#123;6&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于我们处理的是位置，就需要检查越界值（行{1}，跟removeAt方法类似）。如果越界了，就返回false值，表示没有添加项到列表中（行{6}）。</p>
<p>现在我们要处理不同的场景。第一种场景，需要在列表的起点添加一个元素，也就是第一个位置。下图展示了这种场景：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-08.png" alt="insert图示"></p>
<p>current变量是对列表中第一个元素的引用。我们需要做的是把node.next的值设为current（列表中第一个元素）。现在head和node.next都指向了current。接下来要做的就是把head的引用改为node（行{2}），这样列表中就有了一个新元素。</p>
<p>现在来处理第二种场景：在列表中间或尾部添加一个元素。首先，我们需要循环访问列表，找到目标位置（行{3}）。当跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用，而previous将是对想要插入新元素的位置之前一个元素的引用。在这种情况下，我们要在previous和current之间添加新项。因此，首先需要把新项（node）和当前项链接起来（行{4}），然后需要改变previous和current之间的链接。我们还需要让previous.next指向node（行{5}）。</p>
<p>我们通过一张图表来看看代码所做的事：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-09.png" alt="insert图示"></p>
<p>如果我们试图向最后一个位置添加一个新元素，previous将是对列表最后一项的引用，而current将是null。在这种情况下，node.next将指向current，而previous.next将指向node，这样列表中就有了一个新的项。</p>
<p>现在来看看如何向列表中间添加一个新元素：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-10.png" alt="insert图示"></p>
<p>在这种情况下，我们试图将新的项（node）插入到previous和current元素之间。首先，我们需要把node.next的值指向current。然后把previous.next的值设为node。这样列表中就有了一个新的项。</p>
<p>使用变量引用我们需要控制的节点非常重要，这样就不会丢失节点之间的链接。我们可以只使用一个变量（previous），但那样会很难控制节点之间的链接。由于这个原因，最好是声明一个额外的变量来帮助我们处理这些引用。</p>
<h3 id="2-4-实现链表的其他方法"><a href="#2-4-实现链表的其他方法" class="headerlink" title="2.4 实现链表的其他方法"></a>2.4 实现链表的其他方法</h3><h4 id="2-4-1-toString方法"><a href="#2-4-1-toString方法" class="headerlink" title="2.4.1 toString方法"></a>2.4.1 toString方法</h4><p>toString方法会把LinkedList对象转换成一个字符串。下面是toString方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head, <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        string = <span class="string">''</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        string += current.element + (current.next ? <span class="string">'n'</span> : <span class="string">''</span>);<span class="comment">//&#123;4&#125;</span></span><br><span class="line">        current = current.next; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，要循环访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引（行{1}），控制循环访问列表。我们还需要初始化用于拼接元素值的变量（行{2}）。</p>
<p>接下来就是循环访问列表中的每个元素（行{3}）。我们要用current来检查元素是否存在（如果列表为空，或是到达列表中最后一个元素的下一位（null），while循环中的代码就不会执行）。然后我们就得到了元素的内容，将其拼接到字符串中（行{4}）。最后，继续迭代下一个元素（行{5}）。最后，返回列表内容的字符串（行{6}）。</p>
<h4 id="2-4-2-indexOf方法"><a href="#2-4-2-indexOf方法" class="headerlink" title="2.4.2 indexOf方法"></a>2.4.2 indexOf方法</h4><p>indexOf方法接收一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回-1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head, <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">            <span class="keyword">return</span> index; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        index++; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        current = current.next; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一如既往，我们需要一个变量来帮助我们循环访问列表，这个变量是current，它的初始值是head（列表的第一个元素——我们还需要一个index变量来计算位置数（行{1}））。然后循环访问元素（行{2}），检查当前元素是否是我们要找的。如果是，就返回它的位置（行{3}）；如果不是，就继续计数（行{4}），检查列表中下一个节点（行{5}）。</p>
<p>如果列表为空，或是到达列表的尾部（current = current.next将是null），循环就不会执行。如果没有找到值，就返回-1。</p>
<h4 id="2-4-3-remove方法"><a href="#2-4-3-remove方法" class="headerlink" title="2.4.3 remove方法"></a>2.4.3 remove方法</h4><p>实现了indexOf方法就可以实现remove方法了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们已经有一个移除给定位置的一个元素的removeAt方法了。现在有了indexOf方法，如果传入元素的值，就能找到它的位置，然后调用removeAt方法并传入找到的位置。这样非常简<br>单，如果需要更改removeAt方法的代码，这样也更容易——两个方法都会被更改（这就是重用代码的妙处）。这样，我们就不需要维护两个从列表中移除一项的方法，只需要一个！同时，removeAt方法将会检查边界约束。</p>
<h4 id="2-4-4-isEmpty、size和getHead方法"><a href="#2-4-4-isEmpty、size和getHead方法" class="headerlink" title="2.4.4  isEmpty、size和getHead方法"></a>2.4.4  isEmpty、size和getHead方法</h4><p>isEmpty方法检查链表是否为空、size获取链表长度，这两个方法与队列中的isEmpty方法、size方法类似，如下实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果列表中没有元素，isEmpty方法就返回true，否则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>size方法返回列表的length。和已经实现的Queue类、Stack类有所不同，列表的length是内部控制的，因为LinkedList是从头构建的。</p>
<p>最后还有getHead方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>head变量是LinkedList类的私有变量（这意味着它不能在LinkedList实例外部被访问和更改，只有通过LinkedList实例才可以）。但是，如果我们需要在类的外部循环访问列表，就需要提供一种获取类的第一个元素的方法。</p>
<h2 id="三、双向链表"><a href="#三、双向链表" class="headerlink" title="三、双向链表"></a>三、双向链表</h2><p>双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素，如下图所示</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-11.png" alt="双向链表图示"></p>
<p>先从实现DoublyLinkedList类所需的变动开始</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DoublyLinkedList类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    <span class="comment">//这里是方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中可以看到，LinkedList类和DoublyLinkedList类之间的区别标为新增的。在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一<br>项的引用的tail属性。</p>
<p>双向链表提供了两种迭代列表的方法：从头到尾，或者反过来。我们也可以访问一个特定节点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。</p>
<h3 id="3-1-在任意位置插入新元素"><a href="#3-1-在任意位置插入新元素" class="headerlink" title="3.1 在任意位置插入新元素"></a>3.1 在任意位置插入新元素</h3><p>向双向链表中插入一个新项跟（单向）链表非常类似。区别在于，链表只要控制一个next指针，而双向链表则要同时控制next和prev（previous，前一个）这两个指针。</p>
<p>这是向任意位置插入一个新元素的算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DoublyLinkedList类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    <span class="comment">//这里是方法</span></span><br><span class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//检查越界值</span></span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</span><br><span class="line">                current = head,</span><br><span class="line">                previous,</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">//在第一个位置添加</span></span><br><span class="line">                <span class="keyword">if</span> (!head) &#123; <span class="comment">//新增的 &#123;1&#125;</span></span><br><span class="line">                    head = node;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = current;</span><br><span class="line">                    current.prev = node; <span class="comment">//新增的 &#123;2&#125;</span></span><br><span class="line">                    head = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length) &#123; <span class="comment">//最后一项 //新增的</span></span><br><span class="line">                current = tail; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">                current.next = node;</span><br><span class="line">                node.prev = current;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (index++ &lt; position) &#123; //&#123;4&#125;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node.next = current; //&#123;5&#125;</span><br><span class="line">                previous.next = node;</span><br><span class="line">                current.prev = node; //新增的</span><br><span class="line">                node.prev = previous; //新增的</span><br><span class="line">            &#125;</span><br><span class="line">            length++; //更新列表的长度</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来分析第一种场景：在列表的第一个位置（列表的起点）插入一个新元素。如果列表为空（行{1}），只需要把head和tail都指向这个新节点。如果不为空，current变量将是对列表中第一个元素的引用。就像我们在链表中所做的，把node.next设为current，而head将指向node（它将成为列表中的第一个元素）。不同之处在于，我们还需要为指向上一个元素的指针设一个值。current.prev指针将由指向null变为指向新元素（node——行{2}）。node.prev指针已经是null，因此不需要再更新任何东西。下图演示了这个过程：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-12.png" alt="双向链表图示"></p>
<p>现在来分析一下，假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current变量将引用最后一个元素（行{3}）。然后开始建立第一个链接：node.prev将引用current。current.next指针（指向null）将指向node（由于构造函数，node.next已经指向了null）。然后只剩一件事了，就是更新tail，它将由指向current变为指向node。下图展示了这些行为：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-13.png" alt="双向链表图示"></p>
<p>然后还有第三种场景：在列表中间插入一个新元素。就像我们在之前的方法中所做的，迭代列表，直到到达要找的位置（行{4}）。我们将在current和previous元素之间插入新元素。首先，node.next将指向current（行{5}），而previous.next将指向node，这样就不会丢失节点之间的链接。然后需要处理所有的链接：current.prev将指向node，而node.prev将指向previous。下图展示了这一过程：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-14.png" alt="双向链表图示"></p>
<h3 id="3-2-从任意位置移除元素"><a href="#3-2-从任意位置移除元素" class="headerlink" title="3.2 从任意位置移除元素"></a>3.2 从任意位置移除元素</h3><p>从双向链表中移除元素跟链表非常类似。唯一的区别就是还需要设置前一个位置的指针。我们来看一下它的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//移除第一项</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">            head = current.next; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">            <span class="comment">//如果只有一项，更新tail //新增的</span></span><br><span class="line">            <span class="keyword">if</span> (length === <span class="number">1</span>) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">                tail = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head.prev = <span class="literal">null</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length - <span class="number">1</span>) &#123; <span class="comment">//最后一项 //新增的</span></span><br><span class="line">            current = tail; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">            tail = current.prev;</span><br><span class="line">            tail.next = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (index++ &lt; position) &#123; // &#123;5&#125;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //将previous与current的下一项链接起来——跳过current</span><br><span class="line">            previous.next = current.next; // &#123;6&#125;</span><br><span class="line">            current.next.prev = previous; //新增的</span><br><span class="line">        &#125;</span><br><span class="line">        length--;</span><br><span class="line">        return current.element;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。</p>
<p>我们来看看如何移除第一个元素。current变量是对列表中第一个元素的引用，也就是我们想移除的元素。需要做的就是改变 head 的引用，将其从 current 改为下一个元素（current.next——行{1}）。但我们还需要更新current.next指向上一个元素的指针（因为第一个元素的prev指针是null）。因此，把head.prev的引用改为null（行{3}——因为head也指向列表中新的第一个元素，或者也可以用current.next.prev）。由于还需要控制tail的引用，我们可以检查要移除的元素是否是第一个元素，如果是，只需要把tail也设为null（行{2}）。</p>
<p>下图勾画了从双向链表移除第一个元素的过程：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-15.png" alt="双向链表图示"></p>
<p>下一种场景是从最后一个位置移除元素。既然已经有了对最后一个元素的引用（tail），我们就不需要为找到它而迭代列表。这样我们也就可以把tail的引用赋给current变量（行{4}）。接下来，需要把tail的引用更新为列表中倒数第二个元素（current.prev，或者tail.prev也可以）。既然tail指向了倒数第二个元素，我们就只需要把next指针更新为null（tail.next= null）。下图演示了这一行为：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-16.png" alt="双向链表图示"></p>
<p>第三种也是最后一种场景：从列表中间移除一个元素。首先需要迭代列表，直到到达要找的位置（行{5}）。current变量所引用的就是要移除的元素。那么要移除它，我们可以通过更新previous.next和current.next.prev的引用，在列表中跳过它。因此，previous.next将指向current.next，而current.next.prev将指向previous，如下图所示：</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-17.png" alt="双向链表图示"></p>
<h3 id="3-3-循环列表"><a href="#3-3-循环列表" class="headerlink" title="3.3 循环列表"></a>3.3 循环列表</h3><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用null，而是指向第一个元素（head），如下图所示。</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-18.png" alt="双向链表图示"></p>
<p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev。</p>
<p><img src="/2018/11/18/cjxb8wm44001esguplpasi5k6/LinkedList-19.png" alt="双向链表图示"></p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>本篇文章主要介绍链表这种数据结构，及其变体双向链表和循环链表。我们学习了如何在任意位置添加和移除元素，以及如何循环访问链表。还学习了链表相比数组最重要的优点，那就是无需移动链表中的元素，就能轻松地添加和移除元素。因此，当我们需要添加和移除很多元素时，最好的选择就是链表，而非数组。</p>
<script type="text/javascript" src="/js/jquery.js?v=2.0.1" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>坚持原创技术分享，您的支持将鼓励我继续创作！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/images/weChatMoney.png" title="微信打赏" alt="微信打赏"><img src="/images/alipayMoney.png" title="支付宝打赏" alt="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/12/28/cjxb8wm1r0018sgupfbo2qdop/" class="pre">javascript数据结构与算法六（集合）</a><a href="/2018/10/12/cjxb8wm0v000ysgup7t077z65/" class="next">javascript数据结构与算法四（队列）</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODk0OS8xNTQ3Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、链表数据结构"><span class="toc-text">一、链表数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、创建链表"><span class="toc-text">二、创建链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-向链表尾部追加元素"><span class="toc-text">2.1 向链表尾部追加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-从链表中移除元素"><span class="toc-text">2.2 从链表中移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-在任意位置插入元素"><span class="toc-text">2.3 在任意位置插入元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-实现链表的其他方法"><span class="toc-text">2.4 实现链表的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-toString方法"><span class="toc-text">2.4.1 toString方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-indexOf方法"><span class="toc-text">2.4.2 indexOf方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-remove方法"><span class="toc-text">2.4.3 remove方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-isEmpty、size和getHead方法"><span class="toc-text">2.4.4  isEmpty、size和getHead方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、双向链表"><span class="toc-text">三、双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-在任意位置插入新元素"><span class="toc-text">3.1 在任意位置插入新元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-从任意位置移除元素"><span class="toc-text">3.2 从任意位置移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-循环列表"><span class="toc-text">3.3 循环列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、小结"><span class="toc-text">四、小结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/cjxb8wm0t000usgup9v5kcvqa/">javascript设计模式与开发实践十二（享元模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/08/cjxb8wm4d001osgupem45fhdo/">javascript设计模式与开发实践十一（模板方法模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/cjxb8wm48001isgupq2mgeap6/">javascript设计模式与开发实践十（组合模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/cjxb8wm49001ksgupim8w34r7/">javascript设计模式与开发实践九（命令模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/cjxb8wm5i001wsgup9351hyx4/">javascript设计模式与开发实践八（发布—订阅模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/24/cjxb8wm0k000msguprxxbhcya/">javascript设计模式与开发实践七（迭代器模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/cjxb8wm4b001msgup385frnbu/">javascript设计模式与开发实践六（代理模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/cjxb8wm5k001ysgupgi4svi99/">javascript设计模式与开发实践五（策略模式 ）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/21/cjxb8wm1t001asgup4brtrxpm/">javascript设计模式与开发实践四（单例模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/07/cjxb8wm5y0021sgup8g7y0rql/">javascript设计模式与开发实践三（闭包和高阶函数）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/js实现拖拽/" style="font-size: 15px;">js实现拖拽</a> <a href="/tags/前端历史/" style="font-size: 15px;">前端历史</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/slot/" style="font-size: 15px;">slot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github-pages/" style="font-size: 15px;">github pages</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 新浪微博</i></div><iframe width="100%" height="400" frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1" class="share_self"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Abriams/Abriams.github.io" title="github地址" target="_blank">github地址</a><ul></ul><a href="https://weibo.com/u/6110018783/home?wvr=5" title="微博" target="_blank">微博</a><ul></ul><a href="https://juejin.im/timeline" title="掘金" target="_blank">掘金</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Abriams.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b1cc44eb56a7dbf6192c0702e5b38b08";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>