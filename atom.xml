<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淡笑忘、祈一世凡恋</title>
  
  <subtitle>进步的源泉来源于坚持不懈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.23ybob.club/"/>
  <updated>2019-05-16T09:46:47.816Z</updated>
  <id>https://www.23ybob.club/</id>
  
  <author>
    <name>Abriams</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript设计模式与开发实践三（闭包和高阶函数）</title>
    <link href="https://www.23ybob.club/2019/05/16/cjvqhlsmm0000rcvbpy02pawb/"/>
    <id>https://www.23ybob.club/2019/05/16/cjvqhlsmm0000rcvbpy02pawb/</id>
    <published>2019-05-16T03:18:40.000Z</published>
    <updated>2019-05-16T09:46:47.816Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript设计模式与开发实践二（this、call 和 apply）</title>
    <link href="https://www.23ybob.club/2019/05/16/cjvqhlstj0013rcvbsc079v2z/"/>
    <id>https://www.23ybob.club/2019/05/16/cjvqhlstj0013rcvbsc079v2z/</id>
    <published>2019-05-16T03:18:40.000Z</published>
    <updated>2019-05-16T09:45:59.152Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 编程中，this 关键字总是让初学者感到迷惑，Function.prototype.call 和Function.prototype.apply 这两个方法也有着广泛的运用。我们有必要在学习设计模式之前先理解这几个概念。</p><h2 id="一、-this"><a href="#一、-this" class="headerlink" title="一、 this"></a>一、 this</h2><p>跟别的语言大相径庭的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 </p><h3 id="1-1-this的指向"><a href="#1-1-this的指向" class="headerlink" title="1.1 this的指向"></a>1.1 this的指向</h3><p>除去不常用的 with 和 eval 的情况，具体到实际应用中，this 的指向大致可以分为以下 4 种。</p><blockquote><p>作为对象的方法调用。<br>作为普通函数调用。<br>构造器调用。<br>Function.prototype.call 或 Function.prototype.apply 调用。</p></blockquote><p>下面我们分别进行介绍。 </p><h4 id="1-1-1-作为对象的方法调用"><a href="#1-1-1-作为对象的方法调用" class="headerlink" title="1.1.1 作为对象的方法调用"></a>1.1.1 作为对象的方法调用</h4><p>当函数作为对象的方法被调用时，this 指向该对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    getA: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span> === obj); <span class="comment">// 输出：true</span></span><br><span class="line">        alert(<span class="keyword">this</span>.a); <span class="comment">// 输出: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><h4 id="1-1-2-作为普通函数调用"><a href="#1-1-2-作为普通函数调用" class="headerlink" title="1.1.2 作为普通函数调用"></a>1.1.2 作为普通函数调用</h4><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getName()); <span class="comment">// 输出：globalName</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    name: <span class="string">'sven'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = myObject.getName;</span><br><span class="line"><span class="built_in">console</span>.log(getName()); <span class="comment">// globalName</span></span><br></pre></td></tr></table></figure><p>有时候我们会遇到一些困扰，比如在 div 节点的事件函数内部，有一个局部的 callback 方法，callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向该 div 节点，见如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"div1"</span>&gt;我是一个 div&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">window</span>.id = <span class="string">'window'</span>;</span><br><span class="line">        <span class="built_in">document</span>.getElementById( <span class="string">'div1'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert ( <span class="keyword">this</span>.id ); <span class="comment">// 输出：'div1'</span></span><br><span class="line">            <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert ( <span class="keyword">this</span>.id ); <span class="comment">// 输出：'window'</span></span><br><span class="line">            &#125;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>此时有一种简单的解决方案，可以用一个变量保存 div 节点的引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'div1'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 保存 div 的引用</span></span><br><span class="line">    <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert ( that.id ); <span class="comment">// 输出：'div1'</span></span><br><span class="line">    &#125;</span><br><span class="line">    callback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 ECMAScript 5 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    alert ( <span class="keyword">this</span> ); <span class="comment">// 输出：undefined</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><h4 id="1-1-3-构造器调用"><a href="#1-1-3-构造器调用" class="headerlink" title="1.1.3 构造器调用"></a>1.1.3 构造器调用</h4><p>JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。</p><p>除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">alert ( obj.name ); <span class="comment">// 输出：sven</span></span><br></pre></td></tr></table></figure><p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 显式地返回一个对象</span></span><br><span class="line">        name: <span class="string">'anne'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">alert ( obj.name ); <span class="comment">// 输出：anne</span></span><br></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'sven'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'anne'</span>; <span class="comment">// 返回 string 类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">alert ( obj.name ); <span class="comment">// 输出：sven</span></span><br></pre></td></tr></table></figure><h4 id="1-1-4-Function-prototype-call-或-Function-prototype-apply-调用"><a href="#1-1-4-Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="1.1.4 Function.prototype.call 或 Function.prototype.apply 调用"></a>1.1.4 Function.prototype.call 或 Function.prototype.apply 调用</h4><p>跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'sven'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">'anne'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( obj1.getName() ); <span class="comment">// 输出: sven</span></span><br><span class="line"><span class="built_in">console</span>.log( obj1.getName.call( obj2 ) ); <span class="comment">// 输出：anne</span></span><br></pre></td></tr></table></figure><p>call 和 apply 方法能很好地体现 JavaScript 的函数式语言特性，在 JavaScript 中，几乎每一次编写函数式语言风格的代码，都离不开 call 和 apply。在 JavaScript 诸多版本的设计模式中，也用到了 call 和 apply。在下一节会详细介绍它们。 </p><h3 id="1-2-丢失的this"><a href="#1-2-丢失的this" class="headerlink" title="1.2 丢失的this"></a>1.2 丢失的this</h3><p>这是一个经常遇到的问题，我们先看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    myName: <span class="string">'sven'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.myName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">// 输出：'sven'</span></span><br><span class="line"><span class="keyword">var</span> getName2 = obj.getName;</span><br><span class="line"><span class="built_in">console</span>.log(getName2()); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><p>当调用 obj.getName 时，getName 方法是作为 obj 对象的属性被调用的，根据前面提到的规律，此时的 this 指向 obj 对象，所以 obj.getName()输出’sven’。</p><p>当用另外一个变量 getName2 来引用 obj.getName，并且调用 getName2 时，根据前面提到的规律，此时是普通函数调用方式，this 是指向全局 window 的，所以程序的执行结果是undefined。</p><p>再看另一个例子，document.getElementById 这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它，如同 prototype.js 等一些框架所做过的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById( id );</span><br><span class="line">&#125;;  </span><br><span class="line">getId( <span class="string">'div1'</span> );</span><br></pre></td></tr></table></figure><p>我们也许思考过为什么不能用下面这种更简单的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line">getId( <span class="string">'div1'</span> );</span><br></pre></td></tr></table></figure><p>在浏览器中运行以上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"div1"</span>&gt;我是一个 div&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line">        getId( <span class="string">'div1'</span> );</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>在 Chrome、Firefox、IE10 中执行过后就会发现，这段代码抛出了一个异常。这是因为许多引擎的 document.getElementById 方法的内部实现中需要用到 this。这个 this 本来被期望指向document，当 getElementById 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指向 document 的。</p><p>但当用 getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用，函数内部的 this 指向了 window，而不是原来的 document。</p><p>我们可以尝试利用 apply 把 document 当作 this 传入 getId 函数，帮助“修正”this：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.apply(<span class="built_in">document</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.getElementById);</span><br><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="keyword">var</span> div = getId(<span class="string">'div1'</span>);</span><br><span class="line">alert(div.id); <span class="comment">// 输出： div1</span></span><br></pre></td></tr></table></figure><h2 id="二、-call-和-apply"><a href="#二、-call-和-apply" class="headerlink" title="二、 call 和 apply"></a>二、 call 和 apply</h2><p>ECAMScript 3给Function的原型定义了两个方法，它们是Function.prototype.call和Function.prototype.apply。在实际开发中，特别是在一些函数式风格的代码编写中，call和 apply 方法尤为有用。在 JavaScript 版本的设计模式中，这两个方法的应用也非常广泛，能熟练运用这两个方法，是我们真正成为一名 JavaScript 程序员的重要一步。</p><h3 id="2-1-call和apply的区别"><a href="#2-1-call和apply的区别" class="headerlink" title="2.1 call和apply的区别"></a>2.1 call和apply的区别</h3><p>Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。 </p><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</span><br><span class="line">    alert ( [ a, b, c ] ); <span class="comment">// 输出 [ 1, 2, 3 ]</span></span><br><span class="line">&#125;;</span><br><span class="line">func.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br></pre></td></tr></table></figure><p>在这段代码中，参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列表中的 a、b、c。</p><p>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    alert([a, b, c]); <span class="comment">// 输出 [ 1, 2, 3 ]</span></span><br><span class="line">&#125;;</span><br><span class="line">func.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript 的参数在内部就是用一个数组来表示的。从这个意义上说，apply 比call 的使用率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了。</p><p>call 是包装在 apply 上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call 来传送参数。</p><p>当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</span><br><span class="line">    alert ( <span class="keyword">this</span> === <span class="built_in">window</span> ); <span class="comment">// 输出 true </span></span><br><span class="line">&#125;;</span><br><span class="line">func.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br></pre></td></tr></table></figure><p>但如果是在严格模式下，函数体内的 this 还是为 null：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> a, b, c </span>)</span>&#123;</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">    alert ( <span class="keyword">this</span> === <span class="literal">null</span> ); <span class="comment">// 输出 true</span></span><br><span class="line">&#125;</span><br><span class="line">func.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br></pre></td></tr></table></figure><p>有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply( <span class="literal">null</span>, [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span> ] ) <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure><h3 id="2-2-call和apply的用途"><a href="#2-2-call和apply的用途" class="headerlink" title="2.2 call和apply的用途"></a>2.2 call和apply的用途</h3><p>前面说过，能够熟练使用 call 和 apply，是我们真正成为一名 JavaScript 程序员的重要一步，本节我们将详细介绍 call 和 apply 在实际开发中的用途。</p><h4 id="2-2-1-改变-this-指向"><a href="#2-2-1-改变-this-指向" class="headerlink" title="2.2.1  改变 this 指向"></a>2.2.1  改变 this 指向</h4><p>call 和 apply 最常见的用途是改变函数内部的 this 指向，我们来看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'sven'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">'anne'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">getName(); <span class="comment">// 输出: window</span></span><br><span class="line">getName.call(obj1); <span class="comment">// 输出: sven</span></span><br><span class="line">getName.call(obj2); <span class="comment">// 输出: anne</span></span><br></pre></td></tr></table></figure><p>当执行 getName.call( obj1 )这句代码时，getName 函数体内的 this 就指向 obj1 对象，所以此处的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert ( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert ( obj1.name ); <span class="comment">// 输出: sven</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实际开发中，经常会遇到 this 指向被不经意改变的场景，比如有一个 div 节点，div 节点的 onclick 事件中的 this 本来是指向这个 div 的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'div1'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.id ); <span class="comment">// 输出：div1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假如该事件函数中有一个内部函数 func，在事件内部调用 func 函数时，func 函数体内的 this就指向了 window，而不是我们预期的 div，见如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'div1'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.id ); <span class="comment">// 输出：div1</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert ( <span class="keyword">this</span>.id ); <span class="comment">// 输出：undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候我们用 call 来修正 func 函数内的 this，使其依然指向 div：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'div1'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert( <span class="keyword">this</span>.id ); <span class="comment">// 输出：div1</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert ( <span class="keyword">this</span>.id ); <span class="comment">// 输出：输出：div1</span></span><br><span class="line">    &#125;</span><br><span class="line">    func.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 call 来修正 this 的场景，我们并非第一次遇到，在前面关于 this 的学习中，我们就曾经修正过 document.getElementById 函数内部“丢失”的 this，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span>(<span class="params"> func </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.apply( <span class="built_in">document</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)( <span class="built_in">document</span>.getElementById );</span><br><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="keyword">var</span> div = getId( <span class="string">'div1'</span> );</span><br><span class="line">alert ( div.id ); <span class="comment">// 输出： div1</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-Function-prototype-bind"><a href="#2-2-2-Function-prototype-bind" class="headerlink" title="2.2.2 Function.prototype.bind"></a>2.2.2 Function.prototype.bind</h4><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this指向，即使没有原生的 Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 保存原函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新的函数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>); <span class="comment">// 执行新的函数的时候，会把之前传入的 context</span></span><br><span class="line">        <span class="comment">// 当作新函数体内的 this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'sven'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name); <span class="comment">// 输出：sven</span></span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>我们通过 Function.prototype.bind 来“包装”func 函数，并且传入一个对象 context 当作参数，这个 context 对象就是我们想修正的 this 对象。</p><p>在 Function.prototype.bind 的内部实现中，我们先把 func 函数的引用保存起来，然后返回一个新的函数。当我们在将来执行 func 函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply( context, arguments )这句代码才是执行原来的 func 函数，并且指定 context对象为 func 函数体内的 this。</p><p>这是一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一点，使得可以往 func 函数中预先填入一些参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>, <span class="comment">// 保存原函数</span></span><br><span class="line">        context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 需要绑定的 this 上下文</span></span><br><span class="line">        args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// 剩余的参数转成数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新的函数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        <span class="comment">// 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this</span></span><br><span class="line">        <span class="comment">// 并且组合两次分别传入的参数，作为新函数的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'sven'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name); <span class="comment">// 输出：sven</span></span><br><span class="line">    alert([a, b, c, d]) <span class="comment">// 输出：[ 1, 2, 3, 4 ]</span></span><br><span class="line">&#125;.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">func(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-3-借用其他对象的方法"><a href="#2-2-3-借用其他对象的方法" class="headerlink" title="2.2.3 借用其他对象的方法"></a>2.2.3 借用其他对象的方法</h4><p>我们知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让它们代为孵化和养育。同样，在 JavaScript 中也存在类似的借用现象。</p><p>借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'sven'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.getName()); <span class="comment">// 输出： 'sven'</span></span><br></pre></td></tr></table></figure><p>借用方法的第二种运用场景跟我们的关系更加密切。</p><p>函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用Array.prototype.push：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// 输出[1,2,3]</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在操作 arguments 的时候，我们经常非常频繁地找 Array.prototype 对象借用方法。</p><p>想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内部实现原理是什么呢？我们不妨翻开 V8 的引擎源码，以 Array.prototype.push 为例，看看 V8 引擎中的具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = TO_UINT32(<span class="keyword">this</span>.length); <span class="comment">// 被 push 的对象的 length</span></span><br><span class="line">    <span class="keyword">var</span> m = % _ArgumentsLength(); <span class="comment">// push 的参数个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i + n] = % _Arguments(i); <span class="comment">// 复制元素 (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.length = n + m; <span class="comment">// 修正 length 属性的值 (2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这段代码可以看到，Array.prototype.push 实际上是一个属性复制的过程，把参数按照下标依次添加到被 push 的对象上面，顺便修改了这个对象的 length 属性。至于被修改的对象是谁，到底是数组还是类数组对象，这一点并不重要。</p><p>由此可以推断，我们可以把“任意”对象传入 Array.prototype.push</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(a, <span class="string">'first'</span>);</span><br><span class="line">alert(a.length); <span class="comment">// 输出：1</span></span><br><span class="line">alert(a[<span class="number">0</span>]); <span class="comment">// first</span></span><br></pre></td></tr></table></figure><p>这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版本的 IE 浏览器中执行，必须显式地给对象 a 设置 length 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    length: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面我们之所以把“任意”两字加了双引号，是因为可以借用 Array.prototype.push 方法的对象还要满足以下两个条件，从 ArrayPush 函数的(1)处和(2)处也可以猜到，这个对象至少还要满足：</p><blockquote><p>对象本身要可以存取属性；<br>对象的 length 属性可读写。</p></blockquote><p>对于第一个条件，对象本身存取属性并没有问题，但如果借用 Array.prototype.push 方法的不是一个 object 类型的数据，而是一个 number 类型的数据呢? 我们无法在 number 身上存取其他数据，那么从下面的测试代码可以发现，一个 number 类型的数据不可能借用到 Array.prototype.push 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(a, <span class="string">'first'</span>);</span><br><span class="line">alert(a.length); <span class="comment">// 输出：undefined</span></span><br><span class="line">alert(a[<span class="number">0</span>]); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><p>对于第二个条件，函数的 length 属性就是一个只读的属性，表示形参的个数，我们尝试把一个函数当作 this 传入 Array.prototype.push：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(func, <span class="string">'first'</span>);</span><br><span class="line">alert(func.length);</span><br><span class="line"><span class="comment">// 报错：cannot assign to read only property ‘length’ of function()&#123;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 JavaScript 编程中，this 关键字总是让初学者感到迷惑，Function.prototype.call 和Function.prototype.apply 这两个方法也有着广泛的运用。我们有必要在学习设计模式之前先理解这几个概念。&lt;/p&gt;
&lt;h2 id=&quot;一
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript设计模式与开发实践一（面向对象的JavaScript ）</title>
    <link href="https://www.23ybob.club/2019/05/14/cjvqhlsw0001krcvb5kzq1swj/"/>
    <id>https://www.23ybob.club/2019/05/14/cjvqhlsw0001krcvb5kzq1swj/</id>
    <published>2019-05-14T07:36:40.000Z</published>
    <updated>2019-05-16T03:04:12.989Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript 也没有在语言层面提供对抽象类和接口的支持。正因为存在这些跟传统面向对象语言不一致的地方，我们在用设计模式编写代码的时候，更要跟传统面向对象语言加以区别。所以在正式学习设计模式之前，我们有必要先了解一些 JavaScript 在面向对象方面的知识。</p><h2 id="一、-动态类型语言和鸭子类型"><a href="#一、-动态类型语言和鸭子类型" class="headerlink" title="一、 动态类型语言和鸭子类型"></a>一、 动态类型语言和鸭子类型</h2><p>编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。</p><p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。</p><p>静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。 </p><p>静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。</p><p>动态类型语言的优点是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。</p><p>动态类型语言的缺点是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。这好像在商店买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味。</p><p>JavaScript 中，当我们对一个变量赋值时，显然不需要考虑它的类型，因此，JavaScript是一门典型的动态类型语言。 </p><p>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。</p><p>这一切都建立在鸭子类型（duck typing）的概念上，鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。” </p><p>我们可以通过一个小故事来更深刻地了解鸭子类型。</p><p>从前在 JavaScript 王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫声，于是国王召集大臣，要组建一个 1000 只鸭子组成的合唱团。大臣们找遍了全国，终于找到 999 只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一模一样，于是这只鸡就成为了合唱团的最后一员。</p><p>这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注 HAS-A, 而不是 IS-A。</p><p>下面我们用代码来模拟这个故事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> duck = &#123;</span><br><span class="line">    duckSinging: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'嘎嘎嘎'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> chicken = &#123;</span><br><span class="line">    duckSinging: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'嘎嘎嘎'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> choir = []; <span class="comment">// 合唱团</span></span><br><span class="line"><span class="keyword">var</span> joinChoir = <span class="function"><span class="keyword">function</span> (<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animal &amp;&amp; <span class="keyword">typeof</span> animal.duckSinging === <span class="string">'function'</span>) &#123;</span><br><span class="line">        choir.push(animal);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'恭喜加入合唱团'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'合唱团已有成员数量:'</span> + choir.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">joinChoir(duck); <span class="comment">// 恭喜加入合唱团</span></span><br><span class="line">joinChoir(chicken); <span class="comment">// 恭喜加入合唱团</span></span><br></pre></td></tr></table></figure><p>我们看到，对于加入合唱团的动物，大臣们根本无需检查它们的类型，而是只需要保证它们拥有 duckSinging 方法。如果下次期望加入合唱团的是一只小狗，而这只小狗刚好也会鸭子叫，我相信这只小狗也能顺利加入。</p><p>在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥有 slice 和 splice 等方法），这个对象就可以被当作数组来使用。</p><p>在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行向上转型。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类型检查系统的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。</p><p>“面向接口编程”是设计模式中最重要的思想，但在 JavaScript 语言中，“面向接口编程”的过程跟主流的静态类型语言不一样，因此，在 JavaScript 中实现设计模式的过程与在一些我们熟悉的语言中实现的过程会大相径庭。</p><h2 id="二、-多肽"><a href="#二、-多肽" class="headerlink" title="二、 多肽"></a>二、 多肽</h2><p>“多态”一词源于希腊文 polymorphism，拆开来看是 poly（复数）+ morph（形态）+ ism，从字面上我们可以理解为复数形态。</p><p>多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。</p><p>从字面上来理解多态不太容易，下面我们来举例说明一下。</p><p>主人家里养了两只动物，分别是一只鸭和一只鸡，当主人向它们发出“叫”的命令时，鸭会“嘎嘎嘎”地叫，而鸡会“咯咯咯”地叫。这两只动物都会以自己的方式来发出叫声。它们同样“都是动物，并且可以发出叫声”，但根据主人的指令，它们会各自发出不同的叫声。</p><p>其实，其中就蕴含了多态的思想。下面我们通过代码进行具体的介绍。</p><h3 id="2-1-一段“多态”的JavaScript代码"><a href="#2-1-一段“多态”的JavaScript代码" class="headerlink" title="2.1 一段“多态”的JavaScript代码"></a>2.1 一段“多态”的JavaScript代码</h3><p>我们把上面的故事用 JavaScript 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span> (<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Duck) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'嘎嘎嘎'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Chicken) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'咯咯咯'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">makeSound(<span class="keyword">new</span> Duck()); <span class="comment">// 嘎嘎嘎</span></span><br><span class="line">makeSound(<span class="keyword">new</span> Chicken()); <span class="comment">// 咯咯咯</span></span><br></pre></td></tr></table></figure><p>这段代码确实体现了“多态性”，当我们分别向鸭和鸡发出“叫唤”的消息时，它们根据此消息作出了各自不同的反应。但这样的“多态性”是无法令人满意的，如果后来又增加了一只动物，比如狗，显然狗的叫声是“汪汪汪”，此时我们必须得改动 makeSound 函数，才能让狗也发出叫声。修改代码总是危险的，修改的地方越多，程序出错的可能性就越大，而且当动物的种类越来越多时，makeSound 有可能变成一个巨大的函数。</p><p>多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来是可生长的，也是符合开放—封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。</p><h3 id="2-2-对象的多态性"><a href="#2-2-对象的多态性" class="headerlink" title="2.2 对象的多态性"></a>2.2 对象的多态性</h3><p>下面是改写后的代码，首先我们把不变的部分隔离出来，那就是所有的动物都会发出叫声：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123;</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后把可变的部分各自封装起来，我们刚才谈到的多态性实际上指的是对象的多态性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Duck.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Chicken.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'咯咯咯'</span> );</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( <span class="keyword">new</span> Duck() ); <span class="comment">// 嘎嘎嘎</span></span><br><span class="line">makeSound( <span class="keyword">new</span> Chicken() ); <span class="comment">// 咯咯咯</span></span><br></pre></td></tr></table></figure><p>现在我们向鸭和鸡都发出“叫唤”的消息，它们接到消息后分别作出了不同的反应。如果有一天动物世界里又增加了一只狗，这时候只要简单地追加一些代码就可以了，而不用改动以前的makeSound 函数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Dog.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'汪汪汪'</span> );</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( <span class="keyword">new</span> Dog() ); <span class="comment">// 汪汪汪</span></span><br></pre></td></tr></table></figure><h3 id="2-3-类型检查和多态"><a href="#2-3-类型检查和多态" class="headerlink" title="2.3 类型检查和多态"></a>2.3 类型检查和多态</h3><p>类型检查是在表现出对象多态性之前的一个绕不开的话题，但 JavaScript 是一门不必进行类型检查的动态类型语言，为了真正了解多态的目的，我们需要转一个弯，从一门静态类型语言说起。</p><p>我们在前面已经说明过静态类型语言在编译时会进行类型匹配检查。以 Java 为例，由于在代码编译时要进行严格的类型检查，所以不能给变量赋予不同类型的值，这种类型检查有时候会让代码显得僵硬，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str;</span><br><span class="line">str = <span class="string">"abc"</span>; <span class="comment">// 没有问题</span></span><br><span class="line">str = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>现在我们尝试把上面让鸭子和鸡叫唤的例子换成 Java 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123; <span class="comment">// 鸭子类</span></span><br><span class="line">    public <span class="keyword">void</span> makeSound()&#123;</span><br><span class="line">        System.out.println( <span class="string">"嘎嘎嘎"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> </span>&#123; <span class="comment">// 鸡类</span></span><br><span class="line">    public <span class="keyword">void</span> makeSound()&#123;</span><br><span class="line">        System.out.println( <span class="string">"咯咯咯"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AnimalSound</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> makeSound( Duck duck )&#123; <span class="comment">// (1)</span></span><br><span class="line">        duck.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main( <span class="built_in">String</span> args[] )&#123;</span><br><span class="line">        AnimalSound animalSound = <span class="keyword">new</span> AnimalSound();</span><br><span class="line">        Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">        animalSound.makeSound( duck ); <span class="comment">// 输出：嘎嘎嘎</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经顺利地让鸭子可以发出叫声，但如果现在想让鸡也叫唤起来，我们发现这是一件不可能实现的事情。因为(1)处 AnimalSound 类的 makeSound 方法，被我们规定为只能接受Duck 类型的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main( <span class="built_in">String</span> args[] )&#123;</span><br><span class="line">        AnimalSound animalSound = <span class="keyword">new</span> AnimalSound();</span><br><span class="line">        Chicken chicken = <span class="keyword">new</span> Chicken();</span><br><span class="line">        animalSound.makeSound( chicken ); <span class="comment">// 报错，只能接受 Duck 类型的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某些时候，在享受静态语言类型检查带来的安全性的同时，我们亦会感觉被束缚住了手脚。</p><p>为了解决这一问题，静态类型的面向对象语言通常被设计为可以向上转型：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。这就像我们在描述天上的一只麻雀或者一只喜鹊时，通常说“一只麻雀在飞”或者“一只喜鹊在飞”。但如果想忽略它们的具体类型，那么也可以说“一只鸟在飞”。 </p><p>同理，当 Duck 对象和 Chicken 对象的类型都被隐藏在超类型 Animal 身后，Duck 对象和 Chicken对象就能被交换使用，这是让对象表现出多态性的必经之路，而多态性的表现正是实现众多设计模式的目标。</p><h3 id="2-4-使用继承得到多态效果"><a href="#2-4-使用继承得到多态效果" class="headerlink" title="2.4 使用继承得到多态效果"></a>2.4 使用继承得到多态效果</h3><p>使用继承来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括实现继承和接口继承。接下来我们先讨论实现继承。 </p><p>我们先创建一个 Animal 抽象类，再分别让 Duck 和 Chicken 都继承自 Animal 抽象类，下述代码中(1)处和(2)处的赋值语句显然是成立的，因为鸭子和鸡也是动物：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    abstract <span class="keyword">void</span> makeSound(); <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> makeSound()&#123;</span><br><span class="line">        System.out.println( <span class="string">"咯咯咯"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> makeSound()&#123;</span><br><span class="line">        System.out.println( <span class="string">"嘎嘎嘎"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Animal duck = <span class="keyword">new</span> Duck(); <span class="comment">// (1)</span></span><br><span class="line">Animal chicken = <span class="keyword">new</span> Chicken(); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>现在剩下的就是让 AnimalSound 类的 makeSound 方法接受 Animal 类型的参数，而不是具体的Duck 类型或者 Chicken 类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AnimalSound</span></span>&#123; </span><br><span class="line">    public <span class="keyword">void</span> makeSound( Animal animal )&#123; <span class="comment">// 接受 Animal 类型的参数</span></span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main( <span class="built_in">String</span> args[] )&#123;</span><br><span class="line">        AnimalSound animalSound= <span class="keyword">new</span> AnimalSound ();</span><br><span class="line">        Animal duck = <span class="keyword">new</span> Duck();</span><br><span class="line">        Animal chicken = <span class="keyword">new</span> Chicken();</span><br><span class="line">        animalSound.makeSound( duck ); <span class="comment">// 输出嘎嘎嘎</span></span><br><span class="line">        animalSound.makeSound( chicken ); <span class="comment">// 输出咯咯咯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-JavaScript的多态"><a href="#2-5-JavaScript的多态" class="headerlink" title="2.5 JavaScript的多态"></a>2.5 JavaScript的多态</h3><p>从前面的讲解我们得知，多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系。如果类型之间的耦合关系没有被消除，那么我们在 makeSound 方法中指定了发出叫声的对象是某个类型，它就不可能再被替换为另外一个类型。在 Java 中，可以通过向上转型来实现多态。 </p><p>而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript 对象的多态性是与生俱来的。</p><p>这种与生俱来的多态性并不难解释。JavaScript 作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。在前面的代码示例中，我们既可以往 makeSound 函数里传递 duck 对象当作参数，也可以传递 chicken 对象当作参数。</p><p>由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是否是某种类型的对象，这里不存在任何程度上的“类型耦合”。这正是我们从上一节的鸭子类型中领悟的道理。在 JavaScript 中，并不需要诸如向上转型之类的技术来取得多态的效果。</p><h3 id="2-6-多态在面向对象程序设计中的作用"><a href="#2-6-多态在面向对象程序设计中的作用" class="headerlink" title="2.6 多态在面向对象程序设计中的作用"></a>2.6 多态在面向对象程序设计中的作用</h3><p>有许多人认为，多态是面向对象编程语言中最重要的技术。但我们目前还很难看出这一点，毕竟大部分人都不关心鸡是怎么叫的，也不想知道鸭是怎么叫的。让鸡和鸭在同一个消息之下发出不同的叫声，这跟程序员有什么关系呢？ </p><p>Martin Fowler 在《重构：改善既有代码的设计》里写到：<br>    多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。</p><p>换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 </p><p>Martin Fowler 的话可以用下面这个例子很好地诠释：</p><p>在电影的拍摄现场，当导演喊出“action”时，主角开始背台词，照明师负责打灯光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前，确认它们的职业分工（类型），然后告诉他们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。</p><p>利用对象的多态性，导演在发布消息时，就不必考虑各个对象接到消息后应该做什么。对象应该做什么并不是临时决定的，而是已经事先约定和排练完毕的。每个对象应该做什么，已经成为了该对象的一个方法，被安装在对象的内部，每个对象负责它们自己的行为。所以这些对象可以根据同一个消息，有条不紊地分别进行各自的工作。</p><p>将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。</p><p>再看一个现实开发中遇到的例子，这个例子的思想和动物叫声的故事非常相似。</p><p>假设我们要编写一个地图应用，现在有两家可选的地图 API 提供商供我们接入自己的应用。目前我们选择的是谷歌地图，谷歌地图的 API 中提供了 show 方法，负责在页面上展示整个地图。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    googleMap.show();</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(); <span class="comment">// 输出：开始渲染谷歌地图</span></span><br></pre></td></tr></table></figure><p>后来因为某些原因，要把谷歌地图换成百度地图，为了让 renderMap 函数保持一定的弹性，我们用一些条件分支来让 renderMap 函数同时支持谷歌地图和百度地图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> type </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( type === <span class="string">'google'</span> )&#123;</span><br><span class="line">        googleMap.show();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( type === <span class="string">'baidu'</span> )&#123;</span><br><span class="line">        baiduMap.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap( <span class="string">'google'</span> ); <span class="comment">// 输出：开始渲染谷歌地图</span></span><br><span class="line">renderMap( <span class="string">'baidu'</span> ); <span class="comment">// 输出：开始渲染百度地图</span></span><br></pre></td></tr></table></figure><p>可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成搜搜地图，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。</p><p>我们还是先把程序中相同的部分抽象出来，那就是显示某个地图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params"> map </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123;</span><br><span class="line">        map.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap( googleMap ); <span class="comment">// 输出：开始渲染谷歌地图</span></span><br><span class="line">renderMap( baiduMap ); <span class="comment">// 输出：开始渲染百度地图</span></span><br></pre></td></tr></table></figure><p>现在来找找这段代码中的多态性。当我们向谷歌地图对象和百度地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。对象的多态性提示我们，“做什么”和“怎么去做”是可以分开的，即使以后增加了搜搜地图，renderMap 函数仍然不需要做任何改变，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sosoMap = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染搜搜地图'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap( sosoMap ); <span class="comment">// 输出：开始渲染搜搜地图</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们假设每个地图 API 提供展示地图的方法名都是 show，在实际开发中也许不会如此顺利，这时候可以借助适配器模式来解决问题。</p><h3 id="2-7-设计模式与多态"><a href="#2-7-设计模式与多态" class="headerlink" title="2.7 设计模式与多态"></a>2.7 设计模式与多态</h3><p>GoF 所著的《设计模式》一书的副书名是“可复用面向对象软件的基础”。该书完全是从面向对象设计的角度出发的，通过对封装、继承、多态、组合等技术的反复使用，提炼出一些可重复使用的面向对象设计技巧。而多态在其中又是重中之重，绝大部分设计模式的实现都离不开多态性的思想。</p><p>拿命令模式①来说，请求被封装在一些命令对象中，这使得命令的调用者和命令的接收者可以完全解耦开来，当调用命令的 execute 方法时，不同的命令会做不同的事情，从而会产生不同的执行结果。而做这些事情的过程是早已被封装在命令对象内部的，作为调用命令的客户，根本不必去关心命令执行的具体过程。 </p><p>在组合模式②中，多态性使得客户可以完全忽略组合对象和叶节点对象之前的区别，这正是组合模式最大的作用所在。对组合对象和叶节点对象发出同一个消息的时候，它们会各自做自己应该做的事情，组合对象把消息继续转发给下面的叶节点对象，叶节点对象则会对这些消息作出真实的反馈。</p><p>在策略模式③中，Context 并没有执行算法的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算”的消息时，它们会返回各自不同的计算结果。 </p><p>在 JavaScript 这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在 JavaScript 中可以用高阶函数来代替实现的原因。</p><h2 id="三、-封装"><a href="#三、-封装" class="headerlink" title="三、 封装"></a>三、 封装</h2><p>封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。</p><h3 id="3-1-封装数据"><a href="#3-1-封装数据" class="headerlink" title="3.1 封装数据"></a>3.1 封装数据</h3><p>在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private、public、protected 等关键字来提供不同的访问权限。</p><p>但 JavaScript 并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，而且只能模拟出 public 和 private 这两种封装性。</p><p>除了 ECMAScript 6 中提供的 let 之外，一般我们通过函数来创建作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __name = <span class="string">'sven'</span>; <span class="comment">// 私有（private）变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 公开（public）方法</span></span><br><span class="line">            <span class="keyword">return</span> __name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="built_in">console</span>.log(myObject.getName()); <span class="comment">// 输出：sven</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.__name) <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><p>另外值得一提的是，在 ECAMScript 6 中，还可以通过 Symbol 创建私有属性。详情可参阅 <a href="https://github.com/lukehoban/es6features，" target="_blank" rel="noopener">https://github.com/lukehoban/es6features，</a><br>二维码如下。</p><p><img src="/2019/05/14/cjvqhlsw0001krcvb5kzq1swj/JavaScriptOOP-01.png" alt="二维码"></p><h3 id="3-2-封装实现"><a href="#3-2-封装实现" class="headerlink" title="3.2 封装实现"></a>3.2 封装实现</h3><p>上一节描述的封装，指的是数据层面的封装。有时候我们喜欢把封装等同于封装数据，但这是一种比较狭义的定义。</p><p>封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是1隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p><p>从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。</p><p>封装实现细节的例子非常之多。拿迭代器来说明，迭代器的作用是在不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。我们编写了一个 each 函数，它的作用就是遍历一个聚合对象，使用这个 each 函数的人不用关心它的内部是怎样实现的，只要它提供的功能正确便可以。即使 each 函数修改了内部源代码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变。</p><h3 id="3-3-封装类型"><a href="#3-3-封装类型" class="headerlink" title="3.3 封装类型"></a>3.3 封装类型</h3><p>封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的①。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。</p><p>当然在 JavaScript 中，并没有对抽象类和接口的支持。JavaScript 本身也是一门类型模糊的语言。在封装类型方面，JavaScript 没有能力，也没有必要做得更多。对于 JavaScript 的设计模式实现来说，不区分类型是一种失色，也可以说是一种解脱。在后面的学习中，我们可以慢慢了解这一点。 </p><h3 id="3-4-封装变化"><a href="#3-4-封装变化" class="headerlink" title="3.4 封装变化"></a>3.4 封装变化</h3><p>从设计模式的角度出发，封装在更重要的层面体现为封装变化。</p><p>《设计模式》一书曾提到如下文字：<br>“考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念，这是许多设计模式的主题。”</p><p>这段文字即是《设计模式》提到的“找到变化并封装之”。《设计模式》一书中共归纳总结了 23种设计模式。从意图上区分，这 23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。</p><p>拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。 </p><p>通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。 </p><p>从《设计模式》副标题“可复用面向对象软件的基础”可以知道，这本书理应教我们如何编写可复用的面向对象程序。这本书把大多数笔墨都放在如何封装变化上面，这跟编写可复用的面向对象程序是不矛盾的。当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。</p><h2 id="四、-原型模式和基于原型继承的-JavaScript-对象系统"><a href="#四、-原型模式和基于原型继承的-JavaScript-对象系统" class="headerlink" title="四、 原型模式和基于原型继承的 JavaScript 对象系统"></a>四、 原型模式和基于原型继承的 JavaScript 对象系统</h2><p>在 Brendan Eich 为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。之所以选择基于原型的面向对象系统，并不是因为时间匆忙，它设计起来相对简单，而是因为从一开始 Brendan Eich 就没有打算在 JavaScript 中加入类的概念。 </p><p>在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。就像电影《第六日》一样，通过克隆可以创造另外一个一模一样的人，而且本体和克隆体看不出任何区别。</p><p>原型模式不单是一种设计模式，也被称为一种编程泛型。</p><p>本节我们将首先学习第一个设计模式——原型模式。随后会了解基于原型的 Io 语言，借助对 Io 语言的了解，我们对 JavaScript 的面向对象系统也将有更深的认识。在本节的最后，我们将详细了解 JavaScript 语言如何通过原型来构建一个面向对象系统。</p><h3 id="4-1-使用克隆的原型模式"><a href="#4-1-使用克隆的原型模式" class="headerlink" title="4.1 使用克隆的原型模式"></a>4.1 使用克隆的原型模式</h3><p>从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。</p><p>既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一模一样的对象，就可以使用原型模式。</p><p>假设我们在编写一个飞机大战的网页游戏。某种飞机拥有分身技能，当它使用分身技能的时候，要在页面中创建一些跟它一模一样的飞机。如果不使用原型模式，那么在创建分身之前，无疑必须先保存该飞机的当前血量、炮弹等级、防御等级等信息，随后将这些信息设置到新创建的飞机上面，这样才能得到一架一模一样的新飞机。</p><p>如果使用原型模式，我们只需要调用负责克隆的方法，便能完成同样的功能。</p><p>原型模式的实现关键，是语言本身是否提供了clone方法。ECMAScript 5提供了Object.create方法，可以用来克隆对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.attackLevel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.defenseLevel = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane();</span><br><span class="line">plane.blood = <span class="number">500</span>;</span><br><span class="line">plane.attackLevel = <span class="number">10</span>;</span><br><span class="line">plane.defenseLevel = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create( plane );</span><br><span class="line"><span class="built_in">console</span>.log( clonePlane ); <span class="comment">// 输出：Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125;</span></span><br><span class="line"><span class="comment">//在不支持 Object.create 方法的浏览器中，则可以使用以下代码：</span></span><br><span class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-克隆是创建对象的手段"><a href="#4-2-克隆是创建对象的手段" class="headerlink" title="4.2 克隆是创建对象的手段"></a>4.2 克隆是创建对象的手段</h3><p>通过上一节的代码，我们看到了如何通过原型模式来克隆出一个一模一样的对象。但原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。</p><p>在用 Java 等静态类型语言编写程序的时候，类型之间的解耦非常重要。依赖倒置原则提醒我们创建对象的时候要避免依赖具体类型，而用 new XXX 创建对象的方式显得很僵硬。工厂方法模式和抽象工厂模式可以帮助我们解决这个问题，但这两个模式会带来许多跟产品类平行的工厂类层次，也会增加很多额外的代码。</p><p>原型模式提供了另外一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类型名字。这就像一个仙女要送给三岁小女孩生日礼物，虽然小女孩可能还不知道飞机或者船怎么说，但她可以指着商店橱柜里的飞机模型说“我要这个”。</p><p>当然在 JavaScript 这种类型模糊的语言中，创建对象非常容易，也不存在类型耦合的问题。从设计模式的角度来讲，原型模式的意义并不算大 。但 JavaScript 本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型也许更合适。</p><h3 id="4-3-体验Io语言"><a href="#4-3-体验Io语言" class="headerlink" title="4.3 体验Io语言"></a>4.3 体验Io语言</h3><p>前面说过，原型模式不仅仅是一种设计模式，也是一种编程范型。JavaScript 就是使用原型模式来搭建整个面向对象系统的。在 JavaScript 语言中不存在类的概念，对象也并非从类中创建出来的，所有的 JavaScript 对象都是从某个对象上克隆而来的。</p><p>对于习惯了以类为中心语言的人来说，也许一时不容易理解这种基于原型的语言。即使是对于 JavaScript 语言的熟练使用者而言，也可能会有一种“不识庐山真面目，只缘身在此山中”的感觉。事实上，使用原型模式来构造面向对象系统的语言远非仅有 JavaScript 一家。</p><p>JavaScript 基于原型的面向对象系统参考了 Self 语言和 Smalltalk 语言，为了搞清 JavaScript中的原型，我们本该寻根溯源去瞧瞧这两门语言。但由于这两门语言距离现在实在太遥远，我们不妨转而了解一下另外一种轻巧又基于原型的语言——Io 语言。</p><p>Io 语言在 2002 年由 Steve Dekorte 发明。可以从<a href="http://iolanguage.com" target="_blank" rel="noopener">http://iolanguage.com</a> 下载到 Io 语言的解释器，安装好之后打开 Io 解释器，输入经典的“Hello World”程序。解释器打印出了 Hello World 的字符串，这说明我们已经可以使用 Io 语言来编写一些小程序了，如图 1-1 所示。</p><p><img src="/2019/05/14/cjvqhlsw0001krcvb5kzq1swj/JavaScriptOOP-02.png" alt="Io语言"></p><p>作为一门基于原型的语言，Io 中同样没有类的概念，每一个对象都是基于另外一个对象的克隆。</p><p>就像吸血鬼的故事里必然有一个吸血鬼祖先一样，既然每个对象都是由其他对象克隆而来的，那么我们猜测 Io 语言本身至少要提供一个根对象，其他对象都发源于这个根对象。这个猜测是正确的，在 Io 中，根对象名为 Object。</p><p>这一节我们依然拿动物世界的例子来讲解 Io 语言。在下面的代码中，通过克隆根对象 Object，就可以得到另外一个对象 Animal。虽然 Animal 是以大写开头的，但是记住 Io 中没有类，Animal跟所有的数据一样都是对象。</p><blockquote><p>Animal := Object clone // 克隆动物对象</p></blockquote><p>现在通过克隆根对象 Object 得到了一个新的 Animal 对象，所以 Object 就被称为 Animal 的原型。目前 Animal 对象和它的原型 Object 对象一模一样，还没有任何属于它自己的方法和能力。我们假设在 Io 的世界里，所有的动物都会发出叫声，那么现在就给 Animal 对象添加 makeSound 方法吧。代码如下：</p><blockquote><p>Animal makeSound := method( “animal makeSound “ print ); </p></blockquote><p>好了，现在所有的动物都能够发出叫声了，那么再来继续创建一个 Dog 对象。显而易见，Animal对象可以作为 Dog 对象的原型，Dog 对象从 Animal 对象克隆而来：</p><blockquote><p>Dog := Animal clone </p></blockquote><p>可以确定，Dog 一定懂得怎么吃食物，所以接下来给 Dog 对象添加 eat 方法：</p><blockquote><p>Dog eat := method( “dog eat “ print ); </p></blockquote><p>现在已经完成了整个动物世界的构建，通过一次次克隆，Io 的对象世界里不再只有形单影只的根对象 Object，而是多了两个新的对象：Animal 对象和 Dog 对象。其中 Dog 的原型是Animal，Animal 对象的原型是 Object。最后我们来测试 Animal 对象和 Dog 对象的功能。</p><p>先尝试调用 Animal 的 makeSound 方法，可以看到，动物顺利发出了叫声：</p><blockquote><p>Animal makeSound // 输出：animal makeSound</p></blockquote><p>然后再调用 Dog 的 eat 方法，同样我们也看到了预期的结果：</p><blockquote><p>Dog eat // 输出：dog eat </p></blockquote><h3 id="4-4-原型编程范型的一些规则"><a href="#4-4-原型编程范型的一些规则" class="headerlink" title="4.4 原型编程范型的一些规则"></a>4.4 原型编程范型的一些规则</h3><p>从上一节的讲解中，我们看到了如何在 Io 语言中从无到有地创建一些对象。跟使用“类”的语言不一样的地方是，Io 语言中最初只有一个根对象 Object，其他所有的对象都克隆自另外一个对象。如果 A 对象是从 B 对象克隆而来的，那么 B 对象就是 A 对象的原型。</p><p>在上一小节的例子中，Object 是 Animal 的原型，而 Animal 是 Dog 的原型，它们之间形成了一条原型链。这个原型链是很有用处的，当我们尝试调用 Dog 对象的某个方法时，而它本身却没有这个方法，那么 Dog 对象会把这个请求委托给它的原型 Animal 对象，如果 Animal 对象也没有这个属性，那么请求会顺着原型链继续被委托给 Animal 对象的原型Object 对象，这样一来便能得到继承的效果，看起来就像 Animal 是 Dog 的“父类”，Object 是 Animal 的“父类”。</p><p>这个机制并不复杂，却非常强大，Io 和 JavaScript 一样，基于原型链的委托机制就是原型继承的本质。</p><p>我们来进行一些测试。在 Io 的解释器中执行 Dog makeSound 时，Dog 对象并没有 makeSound 方法，于是把请求委托给了它的原型 Animal 对象 ，而 Animal 对象是有makeSound 方法的，所以该条语句可以顺利得到输出，如图 1-2 所示。</p><p><img src="/2019/05/14/cjvqhlsw0001krcvb5kzq1swj/JavaScriptOOP-03.png" alt="Io创建对象示意图"></p><p>现在我们明白了原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委托给它自己的原型。</p><p>最后整理一下本节的描述，我们可以发现原型编程范型至少包括以下基本规则。</p><blockquote><p>所有的数据都是对象。<br>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。<br>对象会记住它的原型。<br>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。</p></blockquote><h3 id="4-5-JavaScript中的原型继承"><a href="#4-5-JavaScript中的原型继承" class="headerlink" title="4.5 JavaScript中的原型继承"></a>4.5 JavaScript中的原型继承</h3><p>刚刚我们已经体验过同样是基于原型编程的 Io 语言，也已经了解了在 Io 语言中如何通过原型链来实现对象之间的继承关系。在原型继承方面，JavaScript 的实现原理和 Io 语言非常相似，JavaScript 也同样遵守这些原型编程的基本规则。</p><blockquote><p>所有的数据都是对象。<br>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。<br>对象会记住它的原型。<br>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。</p></blockquote><p>下面我们来分别讨论 JavaScript 是如何在这些规则的基础上来构建它的对象系统的。</p><h4 id="4-5-1-所有的数据都是对象"><a href="#4-5-1-所有的数据都是对象" class="headerlink" title="4.5.1 所有的数据都是对象"></a>4.5.1 所有的数据都是对象</h4><p>JavaScript 在设计的时候，模仿 Java 引入了两套类型机制：基本类型和对象类型。基本类型包括 undefined、number、boolean、string、function、object。从现在看来，这并不是一个好的想法。</p><p>按照 JavaScript 设计者的本意，除了 undefined 之外，一切都应是对象。为了实现这一目标，number、boolean、string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。</p><p>我们不能说在 JavaScript 中所有的数据都是对象，但可以说绝大部分数据都是对象。那么相信在 JavaScript 中也一定会有一个根对象存在，这些对象追根溯源都来源于这个根对象。 </p><p>事实上，JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是它们的原型。比如下面的 obj1 对象和 obj2 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>可以利用 ECMAScript 5 提供的 Object.getPrototypeOf 来查看这两个对象的原型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj1 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出：true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( obj2 ) === <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><h4 id="4-5-2-要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"><a href="#4-5-2-要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它" class="headerlink" title="4.5.2 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它"></a>4.5.2 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</h4><p>在Io 语言中，克隆一个对象的动作非常明显，我们可以在代码中清晰地看到 clone 的过程。</p><p>比如以下代码：</p><blockquote><p>Dog := Animal clone </p></blockquote><p>但在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。我们所需要做的只是显式地调用 var obj1 = new Object()或者 var obj2 = {}。此时，引擎内部会从Object.prototype 上面克隆一个对象出来，我们最终得到的就是这个对象。</p><p>再来看看如何用 new 运算符从构造器中得到一个对象，下面的代码我们再熟悉不过了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person( <span class="string">'sven'</span> )</span><br><span class="line"><span class="built_in">console</span>.log( a.name ); <span class="comment">// 输出：sven</span></span><br><span class="line"><span class="built_in">console</span>.log( a.getName() ); <span class="comment">// 输出：sven</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( a ) === Person.prototype ); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中没有类的概念，这句话我们已经重复过很多次了。但刚才不是明明调用了 newPerson()吗？</p><p>在这里 Person 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额外操作的过程。</p><p>在 Chrome 和 Firefox 等向外暴露了对象<strong>proto</strong>属性的浏览器下，我们可以通过下面这段代码来理解 new 运算的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> objectFactory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(), <span class="comment">// 从 Object.prototype 上克隆一个空的对象</span></span><br><span class="line">    Constructor = [].shift.call( <span class="built_in">arguments</span> ); <span class="comment">// 取得外部传入的构造器，此例是 Person </span></span><br><span class="line">    obj.__proto__ = Constructor.prototype; <span class="comment">// 指向正确的原型</span></span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply( obj, <span class="built_in">arguments</span> ); <span class="comment">// 借用外部传入的构造器给 obj 设置属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj; <span class="comment">// 确保构造器总是会返回一个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = objectFactory( Person, <span class="string">'sven'</span> );</span><br><span class="line"><span class="built_in">console</span>.log( a.name ); <span class="comment">// 输出：sven</span></span><br><span class="line"><span class="built_in">console</span>.log( a.getName() ); <span class="comment">// 输出：sven</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( a ) === Person.prototype ); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>我们看到，分别调用下面两句代码产生了一样的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = objectFactory( A, <span class="string">'sven'</span> );</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A( <span class="string">'sven'</span> );</span><br></pre></td></tr></table></figure><h4 id="4-5-3-对象会记住它的原型"><a href="#4-5-3-对象会记住它的原型" class="headerlink" title="4.5.3 对象会记住它的原型"></a>4.5.3 对象会记住它的原型</h4><p>如果请求可以在一个链条中依次往后传递，那么每个节点都必须知道它的下一个节点。同理，要完成 Io语言或者 JavaScript语言中的原型链查找机制，每个对象至少应该先记住它自己的原型。</p><p>目前我们一直在讨论“对象的原型”，就 JavaScript 的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型。那么对象如何把请求顺利地转交给它的构造器的原型呢？</p><p>JavaScript 给对象提供了一个名为<strong>proto</strong>的隐藏属性，某个对象的<strong>proto</strong>属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。在一些浏览器中，<strong>proto</strong>被公开出来，我们可以在 Chrome 或者 Firefox 上用这段代码来验证：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log ( a.__proto__=== <span class="built_in">Object</span>.prototype ); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><p>实际上，<strong>proto</strong>就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过<br><strong>proto</strong>属性来记住它的构造器的原型，所以我们用上一节的 objectFactory 函数来模拟用 new<br>创建对象时， 需要手动给 obj 对象设置正确的<strong>proto</strong>指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ = Constructor.prototype;</span><br></pre></td></tr></table></figure><p>通过这句代码，我们让 obj.<strong>proto</strong> 指向 Person.prototype，而不是原来的 Object.prototype。</p><h4 id="4-5-4-如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"><a href="#4-5-4-如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型" class="headerlink" title="4.5.4 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"></a>4.5.4 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</h4><p>这条规则即是原型继承的精髓所在。从对 Io 语言的学习中，我们已经了解到，当一个对象无法响应某个请求的时候，它会顺着原型链把请求传递下去，直到遇到一个可以处理该请求的对象为止。</p><p>JavaScript 的克隆跟 Io 语言还有点不一样，Io 中每个对象都可以作为原型被克隆，当 Animal对象克隆自 Object 对象，Dog 对象又克隆自 Animal 对象时，便形成了一条天然的原型链，如图1-3 所示。</p><p><img src="/2019/05/14/cjvqhlsw0001krcvb5kzq1swj/JavaScriptOOP-04.png" alt="原型链"></p><p>而在 JavaScript 中，每个对象都是从 Object.prototype 对象克隆而来的，如果是这样的话，我们只能得到单一的继承关系，即每个对象都继承自 Object.prototype 对象，这样的对象系统显然是非常受限的。</p><p>实际上，虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的效果。下面的代码是我们最常用的原型继承方式： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">A.prototype = obj;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log( a.name ); <span class="comment">// 输出：sven</span></span><br></pre></td></tr></table></figure><p>我们来看看执行这段代码的时候，引擎做了哪些事情。</p><blockquote><p>首先，尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。<br>查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.<strong>proto</strong> 记录着并且指向 A.prototype，而 A.prototype 被设置为对象 obj。<br>在对象 obj 中找到了 name 属性，并返回它的值。</p></blockquote><p>当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">A.prototype = &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="built_in">console</span>.log( b.name ); <span class="comment">// 输出：sven</span></span><br></pre></td></tr></table></figure><p>再看这段代码执行的时候，引擎做了什么事情。</p><blockquote><p>首先，尝试遍历对象 b 中的所有属性，但没有找到 name 这个属性。<br>查找 name 属性的请求被委托给对象 b 的构造器的原型，它被 b.<strong>proto</strong> 记录着并且指向B.prototype，而 B.prototype 被设置为一个通过 new A()创建出来的对象。<br>在该对象中依然没有找到 name 属性，于是请求被继续委托给这个对象构造器的原型A.prototype。<br>在 A.prototype 中找到了 name 属性，并返回它的值。</p></blockquote><p>和把 B.prototype 直接指向一个字面量对象相比，通过 B.prototype = new A()形成的原型链比之前多了一层。但二者之间没有本质上的区别，都是将对象构造器的原型指向另外一个对象，继承总是发生在对象和对象之间。</p><p>最后还要留意一点，原型链并不是无限长的。现在我们尝试访问对象 a 的 address 属性。而对象 b 和它构造器的原型上都没有 address 属性，那么这个请求会被最终传递到哪里呢？</p><p>实际上，当请求达到 A.prototype，并且在 A.prototype 中也没有找到 address 属性的时候，请求会被传递给 A.prototype 的构造器原型 Object.prototype，显然Object.prototype 中也没有address 属性，但 Object.prototype 的原型是 null，说明这时候原型链的后面已经没有别的节点了。所以该次请求就到此打住，a.address 返回 undefined。</p><blockquote><p>a.address // 输出：undefined </p></blockquote><h4 id="4-5-5-原型继承的未来"><a href="#4-5-5-原型继承的未来" class="headerlink" title="4.5.5 原型继承的未来"></a>4.5.5 原型继承的未来</h4><p>设计模式在很多时候其实都体现了语言的不足之处。Peter Norvig 曾说，设计模式是对语言不足的补充，如果要使用设计模式，不如去找一门更好的语言。这句话非常正确。不过，作为Web 前端开发者，相信 JavaScript 在未来很长一段时间内都是唯一的选择。虽然我们没有办法换一门语言，但语言本身也在发展，说不定哪天某个模式在 JavaScript 中就已经是天然的存在，不再需要拐弯抹角来实现。比如 Object.create 就是原型模式的天然实现。使用 Object.create 来完成原型继承看起来更能体现原型模式的精髓。目前大多数主流浏览器都供了 Object.create 方法。</p><p>但美中不足是在当前的 JavaScript 引擎下，通过 Object.create 来创建对象的效率并不高，通常比通过构造函数创建对象要慢。此外还有一些值得注意的地方，比如通过设置构造器的prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个原型。而通过 Object.create( null )可以创建出没有原型的对象。</p><p>另外，ECMAScript 6 带来了新的 Class 语法。这让 JavaScript 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。通过 Class 创建对象的一段简单示例代码①如下所示 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">"Scamp"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.getName() + <span class="string">' says '</span> + dog.speak());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript 也没有在语言层面提供对抽象类和接口的支持。正因为存在这些跟传统面向对象语言不一致的地方，我们在用设计模式编写代码的时候，更要跟传统面向对象语言
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法十二（算法复杂度）</title>
    <link href="https://www.23ybob.club/2019/05/13/cjvqhlso3000orcvbe1mvffsl/"/>
    <id>https://www.23ybob.club/2019/05/13/cjvqhlso3000orcvbe1mvffsl/</id>
    <published>2019-05-13T01:53:40.000Z</published>
    <updated>2019-05-14T01:51:44.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-大-O-表示法"><a href="#一、-大-O-表示法" class="headerlink" title="一、 大 O 表示法"></a>一、 大 O 表示法</h2><p>大O表示法用于描述算法的性能和复杂程度</p><p>分析算法时，时常遇到以下几类函数：</p><table><thead><tr><th>符 号</th><th>名 称</th></tr></thead><tbody><tr><td>O(1)</td><td>常数的</td></tr><tr><td>O(log(n))</td><td>对数的</td></tr><tr><td>O((log(n))c)</td><td>对数多项式的</td></tr><tr><td>O(n)</td><td>线性的</td></tr><tr><td>O(n^2)</td><td>二次的</td></tr><tr><td>O(n^c)</td><td>多项式的</td></tr><tr><td>O(c^n)</td><td>指数的</td></tr></tbody></table><h3 id="1-1-理解大-O-表示法"><a href="#1-1-理解大-O-表示法" class="headerlink" title="1.1 理解大 O 表示法"></a>1.1 理解大 O 表示法</h3><p>如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。</p><p>让我们试着用一些例子来理解大O表示法的规则。</p><h4 id="1-1-1-O-1"><a href="#1-1-1-O-1" class="headerlink" title="1.1.1 O(1)"></a>1.1.1 O(1)</h4><p>考虑以下函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设运行increment(1)函数，执行时间等于X。如果再用不同的参数（例如2）运行一次increment函数，执行时间依然是X。和参数无关，increment函数的性能都一样。因此，我们说上述函数的复杂度是O(1)（常数）。</p><h4 id="1-1-2-O-n"><a href="#1-1-2-O-n" class="headerlink" title="1.1.2 O(n)"></a>1.1.2 O(n)</h4><p>现在以前面实现的顺序搜索算法为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialSearch</span>(<span class="params">array, item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (item === array[i])&#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将含10个元素的数组（[1, …, 10]）传递给该函数，假如搜索1这个元素，那么，第一次判断时就能找到想要搜索的元素。在这里我们假设每执行一次行{1} ，开销是 1。</p><p>现在，假如要搜索元素11。行{1}会执行10次（遍历数组中所有的值，并且找不到要搜索的元素，因而结果返回 -1）。如果行{1}的开销是1，那么它执行10次的开销就是10，10倍于第一种假设。</p><p>现在，假如该数组有1000个元素（[1, …, 1000]）。搜索1001的结果是行{1}执行了1000次（然后返回-1）。</p><p>注意，sequentialSearch函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，行{1}会执行几次呢？如果查找的是数组中不存在的值，那么行{1}就会执行和数组大小一样多次，这就是通常所说的最坏情况。</p><p>最坏情况下，如果数组大小是10，开销就是10；如果数组大小是1000，开销就是1000。可以得出sequentialSearch函数的时间复杂度是O(n)，n是（输入）数组的大小。</p><p>回到之前的例子，修改一下算法的实现，使之计算开销：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialSearch</span>(<span class="params">array, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        cost++;</span><br><span class="line">        <span class="keyword">if</span> (item === array[i]) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cost for sequentialSearch with input size '</span> + array.length + <span class="string">' is '</span> + cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line">sequentialSearch([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], <span class="number">19</span>) <span class="comment">// cost for sequentialSearch with input size 9 is 9</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-O-n-2"><a href="#1-1-3-O-n-2" class="headerlink" title="1.1.3 O(n^2)"></a>1.1.3 O(n^2)</h4><p>用冒泡排序做O(n^2)的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, index1, index2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aux = array[index1];</span><br><span class="line">    array[index1] = array[index2];</span><br><span class="line">    array[index2] = aux;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设行{1}和行{2}的开销分别是1。修改算法的实现使之计算开销：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length;</span><br><span class="line">    <span class="keyword">var</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        cost++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            cost++;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cost for bubbleSort with input size '</span> + length + <span class="string">'is '</span> + cost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用大小为10的数组执行bubbleSort，开销是 100（102）。如果用大小为100的数组执行bubbleSort，开销就是 10 000（1002）。需要注意，我们每次增加输入的大小，执行都会越来越久。</p><p>时间复杂度O(n)的代码只有一层循环，而O(n2)的代码有双层嵌套循环。如果算法有三层遍历数组的嵌套循环，它的时间复杂度很可能就是O(n3)。</p><h3 id="1-2-时间复杂度比较"><a href="#1-2-时间复杂度比较" class="headerlink" title="1.2 时间复杂度比较"></a>1.2 时间复杂度比较</h3><p><img src="/2019/05/13/cjvqhlso3000orcvbe1mvffsl/algorithmComplexity-01.png" alt="时间复杂度比较示意图"></p><p>下图比较了前述各个大O符号表示的时间复杂度：</p><p>这个图表是用JavaScript绘制的哦！在本书示例代码中，你可以到Chapter12下的bigOChart目录中找到绘制本图表的源代码。</p><p>在接下来的部分，你可以找到本书实现的所有算法的时间复杂度的速查表。</p><h4 id="1-2-1-数据结构"><a href="#1-2-1-数据结构" class="headerlink" title="1.2.1  数据结构"></a>1.2.1  数据结构</h4><p>下表是常用数据结构的时间复杂度：</p><table style="text-align: center; width: 100%; margin: 0 auto; display: table;"><tr><th rowspan="2">数据结构</th><th colspan="3">一般情况</th><th colspan="3">最差情况</th></tr><tr><td>插入</td><td>删除</td><td>搜索</td><td>插入</td><td>删除</td><td>搜索</td></tr><tr><td>数组/栈/队列</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr><tr><td>链表</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr><tr><td>双向链表</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr><tr><td>散列表</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>二分搜索树</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>AVL树</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td></tr></table><p><br></p><h4 id="1-2-2-图"><a href="#1-2-2-图" class="headerlink" title="1.2.2 图"></a>1.2.2 图</h4><p>下表是图的时间复杂度：</p><table style="text-align: center; width: 100%; margin: 0 auto; display: table;"><tr><th>节点/边的管理方式</th><th>存储空间</th><th>增加顶点</th><th>增加边</th><th>删除顶点</th><th>删除边</th><th>轮 询</th></tr><tr><td>邻接表</td><td>O(|V|+|E|) </td><td>O(1) </td><td>O(1)</td><td>O(|V|+|E|)</td><td>O(|E|)</td><td>O(|V|)</td></tr><tr><td>邻接矩阵</td><td>O(|V|^2)</td><td>O(|V|^2)</td><td>O(1)</td><td>O(|V|^2</td><td>O(1)</td><td>O(1)</td></tr></table><p><br></p><h4 id="1-2-3-排序算法"><a href="#1-2-3-排序算法" class="headerlink" title="1.2.3 排序算法"></a>1.2.3 排序算法</h4><p>下表是排序算法的时间复杂度：</p><table style="text-align: center; width: 100%; margin: 0 auto; display: table;"><tr><th rowspan="2">数据结构</th><th colspan="3">时间复杂度</th></tr><tr><td>最好情况</td><td>一般情况</td>   <td>最差情况</td></tr><tr><td>冒泡排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td></tr><tr><td>插入排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td></tr><tr><td>归并排序</td><td>O(nlog(n))</td><td>O(nlog(n))</td><td>O(nlog(n))</td></tr><tr><td>快速排序</td><td>O(nlog(n))</td><td>O(log(n)) </td><td>O(n^2)</td></tr><tr><td>堆排序</td><td>O(nlog(n))</td><td>O(nlog(n))</td><td>O(nlog(n))</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n^2)</td></tr><tr><td>基数排序</td><td>O(nk)</td><td>O(nk)</td><td>O(nk)</td></tr><br></table><p><br></p><h4 id="1-2-4-搜索算法"><a href="#1-2-4-搜索算法" class="headerlink" title="1.2.4 搜索算法"></a>1.2.4 搜索算法</h4><p>下表是搜索算法的时间复杂度：</p><table style="text-align: center; width: 100%; margin: 0 auto; display: table;"><tr><th>算 法</th><th>数据结构</th><th>最差情况</th></tr><tr><td>顺序搜索</td><td>数组</td><td>O(n)</td></tr><tr><td>二分搜索</td><td>已排序的数组</td><td>O(log(n))</td></tr><tr><td>深度优先搜索（DPS）</td><td>顶点数为|V|，边数为|E|的图</td><td>O(|V|+|E|)</td></tr><tr><td>广度优先搜索（BFS）</td><td>顶点数为|V|，边数为|E|的图 </td><td>O(|V|+|E|) </td></tr></table><p><br></p><h3 id="1-3-NP-完全理论概述"><a href="#1-3-NP-完全理论概述" class="headerlink" title="1.3 NP 完全理论概述"></a>1.3 NP 完全理论概述</h3><p>一般来说，如果一个算法的复杂度为O(nk)，其中k是常数，我们就认为这个算法是高效的，这就是多项式算法。</p><p>对于给定的问题，如果存在多项式算法，则计为P（polynomial，多项式）。</p><p>还有一类NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为NP。</p><p>如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的P都是NP。然而，P = NP是否成立，仍然不得而知。</p><p>NP问题中最难的是NP完全问题，它满足以下两个条件：</p><blockquote><p>(1) 是NP问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；<br>(2) 所有的NP问题都能在多项式时间内归约为它。</p></blockquote><p>为了理解问题的归约，考虑两个决策问题L和M。假设算法A可以解决问题L，算法B可以验证输入y是否为M的解。目标是找到一个把L转化为M的方法，使得算法B可以用于构造算法A。</p><p>还有一类问题，只需满足NP完全问题的第二个条件，称为NP困难问题。因此，NP完全问题也是NP困难问题的子集。</p><p>P = NP是否成立，是计算机科学中最重要的难题之一。如果能找到答案，对密码学、算法研究、人工智能等诸多领域都会产生重大影响。</p><p>下面是满足P &lt; &gt; NP时，P、NP、NP完全和NP困难问题的欧拉图：</p><p><img src="/2019/05/13/cjvqhlso3000orcvbe1mvffsl/algorithmComplexity-02.png" alt="P、NP、NP完全和NP困难问题的欧拉图"></p><p>非NP完全的NP困难问题的例子有停机问题和布尔可满足性问题（SAT）</p><p>NP完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。</p><p>不可解问题与启发式算法</p><p>我们提到的有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。</p><p>启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。详情请查阅<a href="http://goo.gl/gxIu9w。" target="_blank" rel="noopener">http://goo.gl/gxIu9w。</a></p><h2 id="二、-用算法娱乐身心"><a href="#二、-用算法娱乐身心" class="headerlink" title="二、 用算法娱乐身心"></a>二、 用算法娱乐身心</h2><p>我们学习算法并不单单是因为它是大学必修课，也不单单是因为我们想成为开发者。通过用在本书中学到的算法来解决问题，我们可以提高解决问题的能力，进而成为更棒的专业人士。</p><p>增长（解题）知识的最好方式是练习，而练习不一定是枯燥的。本节将展示一些网站，你可以访问它们并尝试从算法中获到快乐（甚至小赚一笔）。</p><p>这里列出一些有用的网站（有些不支持用JavaScript提交解答，但是我们依然可以将从本书中所学到的逻辑应用到其他语言上）。</p><blockquote><p>UVa Online Judge（<a href="http://uva.onlinejudge.org/）：这个网站包含了世界各大赛事的题目，包括" target="_blank" rel="noopener">http://uva.onlinejudge.org/）：这个网站包含了世界各大赛事的题目，包括</a> 由IBM赞助的ACM国际大学生程序竞赛（ICPC。若你依然在校，应尽量参与这项赛事，如果团队获胜，则有可能免费享受一次国际旅行）。这个网站包括了成百上千的题目，可以应用本书所学的算法。<br>Sphere Online Judge（<a href="http://www.spoj.com/）：" target="_blank" rel="noopener">http://www.spoj.com/）：</a> 这个网站和UVa Online Judge差不多，但支持用更多语言解题（包括JavaScript）。<br>Coder Byte（<a href="http://coderbyte.com/）：这个网站包含了74个可以用JavaScript解答的题目（简单、中等难度和非常困难）。" target="_blank" rel="noopener">http://coderbyte.com/）：这个网站包含了74个可以用JavaScript解答的题目（简单、中等难度和非常困难）。</a><br>Project Euler（<a href="https://projecteuler.net/）：这个网站包含了一系列数学/计算机的编程题目。你所要做的就是输入那些题目的答案，不过我们可以用算法来找到正确的解答。" target="_blank" rel="noopener">https://projecteuler.net/）：这个网站包含了一系列数学/计算机的编程题目。你所要做的就是输入那些题目的答案，不过我们可以用算法来找到正确的解答。</a><br>Hacker Rank（<a href="https://www.hackerrank.com）：这个网站包含了263个挑战，分为16个类别（可以应用本书中的算法和更多其他算法）。它也支持JavaScript和其他语言。" target="_blank" rel="noopener">https://www.hackerrank.com）：这个网站包含了263个挑战，分为16个类别（可以应用本书中的算法和更多其他算法）。它也支持JavaScript和其他语言。</a><br>Code Chef（<a href="http://www.codechef.com/）：这个网站包含一些题目，并会举办在线比赛。" target="_blank" rel="noopener">http://www.codechef.com/）：这个网站包含一些题目，并会举办在线比赛。</a><br>Top Coder（<a href="http://www.topcoder.com/）：此网站会举办算法联赛，这些联赛通常由NASA、Google、Yahoo!、Amazon和Facebook这样的公司赞助。参加其中一些赛事，你可以获得到赞助公司工作的机会，而参与另一些赛事会赢得奖金。这个网站也提供很棒的解题和算法教程。" target="_blank" rel="noopener">http://www.topcoder.com/）：此网站会举办算法联赛，这些联赛通常由NASA、Google、Yahoo!、Amazon和Facebook这样的公司赞助。参加其中一些赛事，你可以获得到赞助公司工作的机会，而参与另一些赛事会赢得奖金。这个网站也提供很棒的解题和算法教程。</a></p></blockquote><p>以上网站的另一个好处是，它们通常给出的是真实世界中的问题，而我们需要鉴别用哪一个算法解决它。通过这样的方式也能让我们明白本书中的算法并非局限于学术，而是能应用到现实<br>问题上。</p><p>如果你想从事技术工作，强烈推荐你创建一个免费的GitHub（<a href="https://github.com）" target="_blank" rel="noopener">https://github.com）</a> 账号，你可以将上述网站的解答代码提交上去。如果你没有任何专业经验，GitHub可以帮助你建立一个作品集，还会对你找到第一份工作有帮助！</p><h2 id="三、延-展-阅-读"><a href="#三、延-展-阅-读" class="headerlink" title="三、延 展 阅 读"></a>三、延 展 阅 读</h2><p><img src="/2019/05/13/cjvqhlso3000orcvbe1mvffsl/algorithmComplexity-03.png" alt="P、NP、NP完全和NP困难问题的欧拉图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-大-O-表示法&quot;&gt;&lt;a href=&quot;#一、-大-O-表示法&quot; class=&quot;headerlink&quot; title=&quot;一、 大 O 表示法&quot;&gt;&lt;/a&gt;一、 大 O 表示法&lt;/h2&gt;&lt;p&gt;大O表示法用于描述算法的性能和复杂程度&lt;/p&gt;
&lt;p&gt;分析算法时，时常遇到以
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法十一（算法模式）</title>
    <link href="https://www.23ybob.club/2019/05/07/cjvqhlsv7001hrcvbk1gdhtqw/"/>
    <id>https://www.23ybob.club/2019/05/07/cjvqhlsv7001hrcvbk1gdhtqw/</id>
    <published>2019-05-07T07:49:40.000Z</published>
    <updated>2019-05-13T01:39:05.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h2><p>递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。</p><p>递归函数是像下面这样能够直接调用自身的方法或函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFunction</span>(<span class="params">someParam</span>)</span>&#123;</span><br><span class="line">    recursiveFunction(someParam);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>能够像下面这样间接调用自身的函数，也是递归函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFunction1</span>(<span class="params">someParam</span>)</span>&#123;</span><br><span class="line">    recursiveFunction2(someParam);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFunction2</span>(<span class="params">someParam</span>)</span>&#123;</span><br><span class="line">    recursiveFunction1(someParam);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设现在必须要执行recursiveFunction，结果是什么？单单就上述情况而言，它会一直执行下去。因此，每个递归函数都必须要有边界条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p><h3 id="1-1-JavaScript-调用栈大小的限制"><a href="#1-1-JavaScript-调用栈大小的限制" class="headerlink" title="1.1 JavaScript 调用栈大小的限制"></a>1.1 JavaScript 调用栈大小的限制</h3><p>如果忘记加上用以停止函数递归调用的边界条件，会发生什么呢？递归并不会无限地执行下去；浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）。</p><p>每个浏览器都有自己的上限，可用以下代码测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    recursiveFn(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    recursiveFn();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    alert(<span class="string">'i = '</span> + i + <span class="string">' error: '</span> + ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Chrome v37中，这个函数执行了20 955次，而后浏览器抛出错误RangeError: Maximumcall stack size exceeded（超限错误：超过最大调用栈大小）。在Firefox v27中，函数执行了343 429次，然后浏览器抛出错误 InternalError: too much recursion（内部错误：递归次数过多）。</p><p>ECMAScript 6有尾调用优化（tail call optimization）。如果函数内最后一个操作是调用函数（就像示例中{1}的那行），会通过“跳转指令”（jump） 而不是“子程序调用”（subroutine call）来控制。也就是说，在ECMAScript 6中，这里的代码可以一直执行下去。所以，具有停止递归的边界条件非常重要。</p><h3 id="1-2-斐波那契数列"><a href="#1-2-斐波那契数列" class="headerlink" title="1.2 斐波那契数列"></a>1.2 斐波那契数列</h3><p>斐波那契数列的定义如下：</p><blockquote><p>1和2的斐波那契数是 1；<br>n（n&gt;2）的斐波那契数是(n-1)的斐波那契数加上(n-2)的斐波那契数。</p></blockquote><p>那么，让我们开始实现斐波那契函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span> || num === <span class="number">2</span>)&#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>边界条件是已知的，1和2的斐波那契数（行{1}）是1。现在，让我们完成斐波那契函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span> || num === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(num - <span class="number">1</span>) + fibonacci(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道，当n大于2时，Fibonacci(n)等于Fibonacci(n-1)+Fibonacci(n-2)。</p><p>现在，斐波那契函数实现完毕。让我们试着找出6的斐波那契数，其会产生如下函数调用</p><p><img src="/2019/05/07/cjvqhlsv7001hrcvbk1gdhtqw/algorithMpattern-01.png" alt="斐波那契函数示意图"></p><p>我们也可以用非递归的方式实现斐波那契函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n1 = <span class="number">1</span>,</span><br><span class="line">    n2 = <span class="number">1</span>,</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i&lt;=num; i++)&#123;</span><br><span class="line">        n = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何用递归呢？更快吗？递归并不比普通版本更快，反倒更慢。但要知道，递归更容易理解，并且它所需的代码量更少。</p><p>在ECMAScript 6中，因为尾调用优化的缘故，递归并不会更慢。但是在其他语言中，递归通常更慢。</p><p>所以，我们用递归，通常是因为它更容易解决问题。</p><h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><p>动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p><p>之前提到过几次动态规划技术。用动态规划解决的一个问题就是深度优先搜索。</p><p>要注意动态规划和分而治之（归并排序和快速排序算法中用到的那种）是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。</p><p>另一个例子是上一节解决的斐波那契问题。我们将斐波那契问题分解成如该节图示的小问题。</p><p>用动态规划解决问题时，要遵循三个重要步骤：</p><blockquote><p>(1) 定义子问题；<br>(2) 实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；<br>(3) 识别并求解出边界条件。</p></blockquote><p>能用动态规划解决的一些著名的问题如下。</p><blockquote><p>背包问题：给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。<br>最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。<br>矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。<br>硬币找零：给出面额为d1…dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。<br>图的全源最短路径：对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。我们在前面已经学习过这个问题的Floyd-Warshall算法。</p></blockquote><h3 id="2-1-最少硬币找零问题"><a href="#2-1-最少硬币找零问题" class="headerlink" title="2.1 最少硬币找零问题"></a>2.1 最少硬币找零问题</h3><p>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找到所需的最少的硬币个数。</p><p>例如，美国有以下面额（硬币）：d1=1，d2=5，d3=10，d4=25。</p><p>如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（1美分）。</p><p>如何将这个解答转化成算法？</p><p>最少硬币找零的解决方案是找到n所需的最小硬币数。但要做到这一点，首先得找到对每个x&lt;n的解。然后，我们将解建立在更小的值的解的基础上。</p><p>来看看算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinCoinChange</span>(<span class="params">coins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coins = coins; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.makeChange = <span class="function"><span class="keyword">function</span> (<span class="params">amount</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!amount) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache[amount]) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            <span class="keyword">return</span> cache[amount];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> min = [], newMin, newAmount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">                <span class="keyword">var</span> coin = coins[i];</span><br><span class="line">                newAmount = amount - coin; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (newAmount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    newMin = me.makeChange(newAmount); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    newAmount &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">                    (newMin.length &lt; min.length - <span class="number">1</span> || !min.length)<span class="comment">//&#123;9&#125;</span></span><br><span class="line">                    &amp;&amp; (newMin.length || !newAmount)) <span class="comment">//&#123;10&#125;)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                    min = [coin].concat(newMin); <span class="comment">//&#123;11&#125;</span></span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'new Min '</span> + min + <span class="string">' for '</span> + amount); </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (cache[amount] = min); <span class="comment">//&#123;12&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更有条理，我们创建了一个类，解决给定面额的最少硬币找零问题。让我们一步步解读这个算法。</p><p>MinCoinChange类接收coins参数（行{1}），该参数代表问题中的面额。对美国的硬币系统而言，它是[1, 5, 10, 25]。我们可以随心所欲传递任何面额。此外，为了更加高效且不重复计算值，我们使用了cache（行{2}）。</p><p>接下来是makeChange方法，它也是一个递归函数，找零问题由它解决。首先，若amount不为正（&lt; 0），就返回空数组（行{3}）；方法执行结束后，会返回一个数组，包含用来找零的各个面额的硬币数量（最少硬币数）。接着，检查cache缓存。若结果已缓存（行{4}），则直接返回结果；否则，执行算法。</p><p>我们基于coins参数（面额）解决问题。因此，对每个面额（行{5}），我们都计算newAmount（行{6}）的值，它的值会一直减小，直到能找零的最小钱数（别忘了本算法对所有的x &lt; amount都会计算makeChange结果）。若newAmount是合理的值（正值），我们也会计算它的找零结果（行{7}）。</p><p>最后，我们判断newAmount是否有效，minValue（最少硬币数）是否是最优解，与此同时minValue和newAmount是否是合理的值（{行10}）。若以上判断都成立，意味着有一个比之前更优的答案（行{11}。以5美分为例，可以给5便士或者1个5美分镍币，1个5美分镍币是最优解）。最后，返回最终结果（行{12}）。</p><p>测试一下这个算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCoinChange = <span class="keyword">new</span> MinCoinChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(minCoinChange.makeChange(<span class="number">36</span>));</span><br></pre></td></tr></table></figure><p>要知道，如果我们检查cache变量，会发现它存储了从1到36美分的所有结果。以上代码的结果是[1, 10, 25]。</p><p>本节的源码中会有几行多余的代码，输出算法的步骤。例如，使用面额[1, 3, 4]，并对钱数6执行算法，会产生以下输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Min <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">1</span> <span class="keyword">for</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span> <span class="keyword">for</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">3</span> <span class="keyword">for</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">3</span> <span class="keyword">for</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">4</span> <span class="keyword">for</span> <span class="number">4</span> </span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">4</span> <span class="keyword">for</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span> <span class="keyword">for</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">3</span>,<span class="number">3</span> <span class="keyword">for</span> <span class="number">6</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>所以，找零钱数为6时，最佳答案是两枚价值为3的硬币。</p><h3 id="2-2-背包问题"><a href="#2-2-背包问题" class="headerlink" title="2.2 背包问题"></a>2.2 背包问题</h3><p>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重W的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大。</p><p>下面是一个例子：</p><table><thead><tr><th>物 品#</th><th>重 量</th><th>价 值</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td></tr></tbody></table><p>考虑背包能够携带的重量只有5。对于这个例子，我们可以说最佳解决方案是往背包里装入物品1和物品2，这样，总重量为5，总价值为7。</p><p>这个问题有两个版本。0-1版本只能往背包里装完整的物品，而分数背包问题则允许装入分数物品。在这个例子里，我们将处理该问题的0-1版本。动态规划对分数版本无能为力，但稍后要学习的贪心算法可以解决它。</p><p>我们来看看下面这个背包算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapSack</span>(<span class="params">capacity, weights, values, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, w, a, b, kS = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        kS[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt;= capacity; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || w == <span class="number">0</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">                kS[i][w] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &lt;= w) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                a = values[i - <span class="number">1</span>] + kS[i - <span class="number">1</span>][w - weights[i - <span class="number">1</span>]];</span><br><span class="line">                b = kS[i - <span class="number">1</span>][w];</span><br><span class="line">                kS[i][w] = (a &gt; b) ? a : b; <span class="comment">//&#123;4&#125; max(a,b)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                kS[i][w] = kS[i - <span class="number">1</span>][w]; <span class="comment">//&#123;5&#125; </span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kS[n][capacity]; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看这个算法是如何工作的。</p><blockquote><p>行{1}：首先，初始化将用于寻找解决方案的矩阵ks[n+1][capacity+1]。</p></blockquote><blockquote><p>行{2}：忽略矩阵的第一列和第一行，只处理索引不为0的列和行。</p></blockquote><blockquote><p>行{3}：物品i的重量必须小于约束（capacity）才有可能成为解决方案的一部分；否则，总重量就会超出背包能够携带的重量，这是不可能发生的。发生这种情况时，只要忽略它，用之前的值就可以了（行{5}）。</p></blockquote><blockquote><p>行{4}：当找到可以构成解决方案的物品时，选择价值最大的那个。</p></blockquote><blockquote><p>行{6}：最后，问题的解决方案就在这个二维表格右下角的最后一个格子里。</p></blockquote><p>我们可以用开头的例子来测试这个算法：</p><p>下图举例说明了例子中kS矩阵的构造：</p><p><img src="/2019/05/07/cjvqhlsv7001hrcvbk1gdhtqw/algorithMpattern-02.png" alt="背包问题函数示意图"></p><p>请注意，这个算法只输出背包携带物品价值的最大值，而不列出实际的物品。我们可以增加下面的附加函数来找出构成解决方案的物品：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findValues</span>(<span class="params">n, capacity, kS, weights, values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = n, k = capacity; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'解决方案包含以下物品：'</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kS[i][k] !== kS[i - <span class="number">1</span>][k]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'物品'</span> + i + <span class="string">'，重量：'</span> + weights[i - <span class="number">1</span>] + <span class="string">'，价值：'</span> + values[i - <span class="number">1</span>]);</span><br><span class="line">            i--;</span><br><span class="line">            k = k - kS[i][k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在knapsack函数的行{6}之前调用这个函数。执行完整的算法，会得到如下输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方案包含以下物品：</span><br><span class="line"><span class="number">88</span> 物品<span class="number">2</span>，重量：<span class="number">3</span>，价值：<span class="number">4</span></span><br><span class="line"><span class="number">88</span> 物品<span class="number">1</span>，重量：<span class="number">2</span>，价值：<span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="2-3-最长公共子序列"><a href="#2-3-最长公共子序列" class="headerlink" title="2.3 最长公共子序列"></a>2.3 最长公共子序列</h3><p>另一个经常被当作编程挑战问题的动态规划问题是最长公共子序列（LCS）：找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。</p><p>考虑如下例子：</p><p><img src="/2019/05/07/cjvqhlsv7001hrcvbk1gdhtqw/algorithMpattern-03.png" alt="案例示意图"></p><p>再看看下面这个算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lcs</span>(<span class="params">wordX, wordY</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = wordX.length,</span><br><span class="line">        n = wordY.length,</span><br><span class="line">        l = [],</span><br><span class="line">        i, j, a, b;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        l[i] = [];</span><br><span class="line">        <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            l[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                l[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordX[i - <span class="number">1</span>] == wordY[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                l[i][j] = l[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = l[i - <span class="number">1</span>][j];</span><br><span class="line">                b = l[i][j - <span class="number">1</span>];</span><br><span class="line">                l[i][j] = (a &gt; b) ? a : b; <span class="comment">//max(a, b)</span></span><br><span class="line">                <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">return</span> l[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较背包问题和LCS算法，我们会发现两者非常相似。这项从顶部开始构建解决方案的技术被称为记忆，而解决方案就在表格或矩阵的右下角。</p><p>像背包问题算法一样，这种方法只输出LCS的长度，而不包含LCS的实际结果。要提取这个信息，需要对算法稍作修改，声明一个新的solution矩阵。如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lcs</span>(<span class="params">wordX, wordY</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = wordX.length,</span><br><span class="line">        n = wordY.length,</span><br><span class="line">        l = [],</span><br><span class="line">        i, j, a, b;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        l[i] = [];</span><br><span class="line">        solution[i] = [];<span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            l[i][j] = <span class="number">0</span>;</span><br><span class="line">            solution[i][j] = <span class="string">'0'</span>;<span class="comment">//&#123;2&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                l[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordX[i - <span class="number">1</span>] == wordY[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                l[i][j] = l[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                solution[i][j] = <span class="string">'diagonal'</span>;<span class="comment">//&#123;3&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = l[i - <span class="number">1</span>][j];</span><br><span class="line">                b = l[i][j - <span class="number">1</span>];</span><br><span class="line">                l[i][j] = (a &gt; b) ? a : b; <span class="comment">//max(a, b)</span></span><br><span class="line">                solution[i][j]=(l[i][j] == l[i<span class="number">-1</span>][j]) ? <span class="string">'top'</span> : <span class="string">'left'</span>;<span class="comment">//&#123;4&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printSolution(solution, l, wordX, wordY, m, n);<span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">return</span> l[m][n];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//printSolution函数如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSolution</span>(<span class="params">solution, l, wordX, wordY, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = m, b = n, i, j,</span><br><span class="line">    x = solution[a][b],</span><br><span class="line">    answer = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span> (x !== <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solution[a][b] === <span class="string">'diagonal'</span>) &#123;</span><br><span class="line">            answer = wordX[a - <span class="number">1</span>] + answer;</span><br><span class="line">            a--;</span><br><span class="line">            b--; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (solution[a][b] === <span class="string">'left'</span>) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (solution[a][b] === <span class="string">'top'</span>) &#123;</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">        x = solution[a][b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'lcs: '</span> + answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当解矩阵的方向为对角线时，我们可以将字符添加到答案中。</p><p>如果用’acbaed’和’abcadf’两个字符串执行上面的算法，我们将得到输出4。用于构建结果的矩阵l看起来像下面这样。我们也可以用附加的算法来跟踪LCS的值（如下图高亮所示）。</p><p><img src="/2019/05/07/cjvqhlsv7001hrcvbk1gdhtqw/algorithMpattern-04.png" alt="最长公共子序列执行示意图"></p><p>通过上面的矩阵，我们知道LCS算法的结果是长度为4的acad。</p><h3 id="2-4-矩阵链相乘"><a href="#2-4-矩阵链相乘" class="headerlink" title="2.4 矩阵链相乘"></a>2.4 矩阵链相乘</h3><p>矩阵链相乘是另一个可以用动态规划解决的著名问题。这个问题是要找出一组矩阵相乘的最佳方式（顺序）。</p><p>让我们试着更好地理解这个问题。n行m列的矩阵A和m行p列的矩阵B相乘，结果是n行p列的矩阵C。</p><p>考虑我们想做A<em>B</em>C*D的乘法。因为乘法满足结合律，所以我们可以让这些矩阵以任意顺序相乘。因此，考虑如下情况：</p><blockquote><p>A是一个10行100列的矩阵<br>B是一个100行5列的矩阵<br>C是一个5行50列的矩阵<br>D是一个50行1列的矩阵</p></blockquote><p>A<em>B</em>C*D的结果是一个10行1列的矩阵</p><p>在这个例子里，相乘的方式有五种。</p><blockquote><p>(1) (A(B(CD)))：乘法运算的次数是1750次。<br>(2) ((AB)(CD))：乘法运算的次数是5300次。<br>(3) (((AB)C)D)：乘法运算的次数是8000次。<br>(4) ((A(BC))D)：乘法运算的次数是75 500次。<br>(5) (A((BC)D))：乘法运算的次数是31 000次。</p></blockquote><p>相乘的顺序不一样，要进行的乘法运算总数也有很大差异。那么，要如何构建一个算法，求出最少的乘法运算操作次数？矩阵链相乘的算法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matrixChainOrder</span>(<span class="params">p, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, k, l, q, m = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        m[i] = [];</span><br><span class="line">        m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">2</span>; l &lt; n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            j = i + l - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                q = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j]; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (q &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = q;</span><br><span class="line">                    <span class="comment">//&#123;2&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个算法中最重要的是行{1}，神奇之处全都在这一行。它计算了给定括号顺序的乘法运算次数，并将值保存在辅助矩阵m中。</p><p>对开头的例子执行上面的算法，会得到结果7500；正如我们前面提到的，这是最少的操作次数。看看这个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = [<span class="number">10</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">1</span>],</span><br><span class="line">n = p.length;</span><br><span class="line"><span class="built_in">console</span>.log(matrixChainOrder(p, n)); <span class="comment">//1750</span></span><br></pre></td></tr></table></figure><p>然而，这个算法也不会给出最优解的括号顺序。为了得到这些信息，我们可以对代码做一些改动。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matrixChainOrder</span>(<span class="params">p, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, k, l, q, m = [];</span><br><span class="line">    <span class="keyword">var</span> s = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        s[i] = [];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            s[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        m[i] = [];</span><br><span class="line">        m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">2</span>; l &lt; n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            j = i + l - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                q = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j]; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (q &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = q;</span><br><span class="line">                    s[i][j] = k; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printOptimalParenthesis(s, <span class="number">1</span>, n - <span class="number">1</span>); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printOptimalParenthesis</span>(<span class="params">s, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"A["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"("</span>);</span><br><span class="line">        printOptimalParenthesis(s, i, s[i][j]);</span><br><span class="line">        printOptimalParenthesis(s, s[i][j] + <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> p = [<span class="number">10</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">1</span>],</span><br><span class="line">n = p.length;</span><br><span class="line"><span class="built_in">console</span>.log(matrixChainOrder(p, n));</span><br></pre></td></tr></table></figure><p>执行修改后的算法，也能得到括号的最佳顺序(A<a href="A[2](A[3]A[4]">1</a>))，并可以转化为(A(B(CD)))。</p><h2 id="三、-贪心算法"><a href="#三、-贪心算法" class="headerlink" title="三、 贪心算法"></a>三、 贪心算法</h2><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。</p><p>我们来看看如何用贪心算法解决前面的最少硬币找零问题和背包问题。（我们已经介绍了一些其他的贪心算法，比如Dijkstra算法、Prim算法和Kruskal算法。）</p><h3 id="3-1-最少硬币找零问题"><a href="#3-1-最少硬币找零问题" class="headerlink" title="3.1 最少硬币找零问题"></a>3.1 最少硬币找零问题</h3><p>最少硬币找零问题也能用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。</p><p>来看看算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinCoinChange</span>(<span class="params">coins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coins = coins; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.makeChange = <span class="function"><span class="keyword">function</span> (<span class="params">amount</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> change = [],</span><br><span class="line">            total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = coins.length; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">var</span> coin = coins[i];</span><br><span class="line">            <span class="keyword">while</span> (total + coin &lt;= amount) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                change.push(coin); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">                total += coin; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> change;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说贪心版本的MinCoinChange比动态规划版本的简单多了。和动态规划方法相似，我们传递面额参数，实例化MinCoinChange（行{1}）。</p><p>对每个面额（行{2}——从大到小），把它的值和total相加后，total需要小于amount（行{3}）。我们会将当前面额coin添加到结果中（行{4}），也会将它和total相加（行{5}）。</p><p>如你所见，这个解法很简单。从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。</p><p>用和DP方法同样的测试代码测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCoinChange = <span class="keyword">new</span> MinCoinChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(minCoinChange.makeChange(<span class="number">36</span>));</span><br></pre></td></tr></table></figure><p>结果依然是[25, 10, 1]，和用DP得到的一样。下图阐释了算法的执行过程：</p><p><img src="/2019/05/07/cjvqhlsv7001hrcvbk1gdhtqw/algorithMpattern-05.png" alt="贪心算法最少硬币找零问题执行示意图"></p><p>然而，如果用[1, 3, 4]面额执行贪心算法，会得到结果[4, 1, 1]。如果用动态规划的解法，会得到最优的结果[3, 3]。</p><p>比起动态规划算法而言，贪心算法更简单、更快。然而，如我们所见，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</p><h3 id="3-2-分数背包问题"><a href="#3-2-分数背包问题" class="headerlink" title="3.2 分数背包问题"></a>3.2 分数背包问题</h3><p>求解分数背包问题的算法与动态规划版本稍有不同。在0-1背包问题中，只能向背包里装入完整的物品，而在分数背包问题中，我们可以装入分数的物品。我们用前面用过的例子来比较两者的差异，如下所示：</p><table><thead><tr><th>物 品#</th><th>重 量</th><th>价 值</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td></tr></tbody></table><p>在动态规划的例子里，我们考虑背包能够携带的重量只有5。而在这个例子里，我们可以说最佳解决方案是往背包里装入物品1和物品2，总重量为5，总价值为7。</p><p>如果在分数背包问题中考虑相同的容量，得到的结果是一样的。因此，我们考虑容量为6的情况。</p><p>在这种情况下，解决方案是装入物品1和物品2，还有25%的物品3。这样，重量为6的物品总价值为8.25。</p><p>我们来看看下面这个算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapSack</span>(<span class="params">capacity, values, weights</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = values.length,</span><br><span class="line">        load = <span class="number">0</span>, i = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (weights[i] &lt;= (capacity - load)) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            val += values[i];</span><br><span class="line">            load += weights[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> r = (capacity - load) / weights[i]; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            val += r * values[i];</span><br><span class="line">            load += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对算法的解释。</p><blockquote><p>行{1}：总重量少于背包容量，继续迭代，装入物品。<br>行{2}：如果物品可以完整地装入背包，就将其价值和重量分别计入背包已装入物品的总价值（val）和总重量（load）。<br>行{3}：如果物品不能完整地装入背包，计算能够装入部分的比例（r）。</p></blockquote><p>如果在0-1背包问题中考虑同样的容量6，我们就会看到，物品1和物品3组成了解决方案。在这种情况下，对同一个问题应用不同的解决方法，会得到两种不同的结果。</p><p>测试以上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    weights = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    capacity = <span class="number">5</span>,</span><br><span class="line">    n = values.length;</span><br><span class="line"><span class="built_in">console</span>.log(knapSack(capacity, values, weights)) <span class="comment">//7</span></span><br></pre></td></tr></table></figure><h2 id="四、-函数式编程简介"><a href="#四、-函数式编程简介" class="headerlink" title="四、 函数式编程简介"></a>四、 函数式编程简介</h2><p>到目前为止，我们在本书中所用的编程范式都是命令式编程。在命令式编程中，我们按部就班地编写程序代码，详细描述要完成的事情以及完成的顺序。</p><p>在本节中，我们会介绍一种新的范式，叫作函数式编程。函数式编程是一种曾经主要用于学术领域的范式，多亏了Python和Ruby等现代语言，它才开始在行业开发者中流行起来。值得欣慰的是，借助ES6的能力，JavaScript也能够进行函数式编程。</p><h3 id="4-1-函数式编程与命令式编程"><a href="#4-1-函数式编程与命令式编程" class="headerlink" title="4.1 函数式编程与命令式编程"></a>4.1 函数式编程与命令式编程</h3><p>以函数式范式进行开发并不简单；关键在于习惯这种范式的机制。我们编写一个例子来说明差异。</p><p>假设我们想打印一个数组中所有的元素。我们可以用命令式编程，声明的函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printArray = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">printArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们迭代数组，打印每一项。</p><p>现在，我们试着把这个例子转换成函数式编程。在函数式编程中，函数就是摇滚明星。我们关注的重点是需要描述什么，而不是如何描述。回到这一句：“我们迭代数组，打印每一项”。那么，我们首先要关注的是迭代数据，然后进行操作，即打印数组项。下面的函数负责迭代数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forEach = <span class="function"><span class="keyword">function</span> (<span class="params">array, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        action(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，我们要创建另一个负责把数组元素打印到控制台的函数（考虑为回调函数），如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logItem = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，像下面这样使用声明的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], logItem);</span><br></pre></td></tr></table></figure><p>只需要上面这一行代码，我们就能描述我们要把数组的每一项打印到控制台。这是我们的第一个函数式编程的例子！</p><p>有几点要注意：</p><blockquote><p>主要目标是描述数据，以及要对数据应用的转换；<br>程序执行顺序的重要性很低，而在命令式编程中，步骤和顺序是非常重要的；<br>函数和数据集合是函数式编程的核心；<br>在函数式编程中，我们可以使用和滥用函数和递归，而在命令式编程中，则使用循环、赋值、条件和函数。</p></blockquote><h3 id="4-2-ES2015-和函数式编程"><a href="#4-2-ES2015-和函数式编程" class="headerlink" title="4.2 ES2015 和函数式编程"></a>4.2 ES2015 和函数式编程</h3><p>有了ES2015的新功能，用JavaScript进行函数式编程变得更加容易了。我们来看一个例子。</p><p>考虑我们要找出数组中最小的值。要用命令式编程完成这个任务，只要迭代数组，检查当前的最小值是否大于数组元素；如果是，就更新最小值，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMinArray = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> minValue = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minValue &gt; array[i]) &#123;</span><br><span class="line">            minValue = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(findMinArray([<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>])); <span class="comment">//输出4</span></span><br></pre></td></tr></table></figure><p>用函数式编程完成相同的任务，可以使用Math.min函数，传入所有要比较的数组元素。我们可以像下面的例子里这样，使用ES2015的解构操作符（…），把数组转换成单个的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> min_ = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(...array)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(min_([<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>])); <span class="comment">//输出4</span></span><br></pre></td></tr></table></figure><p>使用ES2015的箭头函数，我们可以进一步简化上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> min = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Math</span>.min(...arr);</span><br><span class="line"><span class="built_in">console</span>.log(min([<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]));</span><br></pre></td></tr></table></figure><h3 id="4-3-JavaScript-函数式工具箱——-map、filter-和-reduce"><a href="#4-3-JavaScript-函数式工具箱——-map、filter-和-reduce" class="headerlink" title="4.3 JavaScript 函数式工具箱—— map、filter 和 reduce"></a>4.3 JavaScript 函数式工具箱—— map、filter 和 reduce</h3><p>map、filter和reduce函数是函数式编程的基础。</p><p>我们可以使用map函数，把一个数据集合转换或映射成另一个数据集合。先看一个命令式编程的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> daysOfWeek = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Monday'</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Tuesday'</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Wednesday'</span>, <span class="attr">value</span>: <span class="number">7</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> daysOfWeekValues_ = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; daysOfWeek.length; i++) &#123;</span><br><span class="line">    daysOfWeekValues_.push(daysOfWeek[i].value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再以函数式编程来考虑同样的例子，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> daysOfWeekValues = daysOfWeek.map(<span class="function"><span class="keyword">function</span>(<span class="params">day</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> day.value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(daysOfWeekValues);</span><br></pre></td></tr></table></figure><p>我们可以使用filter函数过滤一个集合的值。来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> positiveNumbers_ = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> positive = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            positive.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positive;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(positiveNumbers_([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>]));</span><br></pre></td></tr></table></figure><p>我们可以把同样的代码写成函数式的，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> positiveNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(positiveNumbers([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>]));</span><br></pre></td></tr></table></figure><p>我们也可以使用reduce函数，把一个集合归约成一个特定的值。比如，对一个数组中的值求和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumValues = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        total += array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sumValues([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]));</span><br></pre></td></tr></table></figure><p>上面的代码也可以写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum_ = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sum_([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]));</span><br></pre></td></tr></table></figure><p>我们还可以把这些函数与ES2015的功能结合起来，比如解构操作符和箭头函数，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="built_in">console</span>.log(sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]));</span><br></pre></td></tr></table></figure><p>我们再看另一个例子。考虑我们需要写一个函数，把几个数组连接起来。为此，可以创建另一个数组，用于存放其他数组的元素。我们可以执行以下命令式的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> mergeArrays_ = <span class="function"><span class="keyword">function</span> (<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = arrays.length,</span><br><span class="line">        newArray = [],</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arrays[i].length; j++) &#123;</span><br><span class="line">            newArray[k++] = arrays[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(mergeArrays_([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>]]));</span><br></pre></td></tr></table></figure><p>注意，在这个例子中，我们声明了变量，还使用了循环。现在，我们用JavaScript函数式编程把上面的代码重写如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeArraysConcat = <span class="function"><span class="keyword">function</span> (<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arrays.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">p, n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.concat(n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(mergeArraysConcat([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>]]));</span><br></pre></td></tr></table></figure><p>上面的代码完成了同样的任务，但它是面向函数的。我们也可以用ES2015使代码更加精简，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> mergeArrays = <span class="function">(<span class="params">...arrays</span>) =&gt;</span> [].concat(...arrays);</span><br><span class="line">    <span class="built_in">console</span>.log(mergeArrays([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>])); </span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="4-4-JavaScript-函数式类库和数据结构"><a href="#4-4-JavaScript-函数式类库和数据结构" class="headerlink" title="4.4 JavaScript 函数式类库和数据结构"></a>4.4 JavaScript 函数式类库和数据结构</h3><p>有一些很棒的JavaScript类库借助工具函数和函数式数据结构，对函数式编程提供支持。通过下面的列表，你可以找到一些最有名的JavaScript函数式类库。</p><blockquote><p>Underscode.js：<a href="http://underscorejs.org/" target="_blank" rel="noopener">http://underscorejs.org/</a><br>Bilby.js：<a href="http://bilby.brianmckenna.org/" target="_blank" rel="noopener">http://bilby.brianmckenna.org/</a><br>Lazy.js：<a href="http://danieltao.com/lazy.js/" target="_blank" rel="noopener">http://danieltao.com/lazy.js/</a><br>Bacon.js：<a href="https://baconjs.github.io/" target="_blank" rel="noopener">https://baconjs.github.io/</a><br>Fn.js：<a href="http://eliperelman.com/fn.js/" target="_blank" rel="noopener">http://eliperelman.com/fn.js/</a><br>Functional.js：<a href="http://functionaljs.com/" target="_blank" rel="noopener">http://functionaljs.com/</a><br>Ramda.js：<a href="http://ramdajs.com/0.20.1/index.html" target="_blank" rel="noopener">http://ramdajs.com/0.20.1/index.html</a><br>Mori：<a href="http://swannodette.github.io/mori/" target="_blank" rel="noopener">http://swannodette.github.io/mori/</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、递归&quot;&gt;&lt;a href=&quot;#一、递归&quot; class=&quot;headerlink&quot; title=&quot;一、递归&quot;&gt;&lt;/a&gt;一、递归&lt;/h2&gt;&lt;p&gt;递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。&lt;/p&gt;
&lt;p&gt;递归函数是
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法十（排序和搜索算法）</title>
    <link href="https://www.23ybob.club/2019/05/05/cjvqhlsut001brcvbcg43rv2u/"/>
    <id>https://www.23ybob.club/2019/05/05/cjvqhlsut001brcvbcg43rv2u/</id>
    <published>2019-05-05T02:51:50.000Z</published>
    <updated>2019-05-06T07:40:13.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h2><p>在开始排序算法之前，我们先创建一个数组（列表）来表示待排序和搜索的数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = []; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">return</span> array.join();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，ArrayList是一个简单的数据结构，它将项存储在数组中（行{1}）。我们只需要一个插入方法来向数据结构中添加元素（行{2}），用JavaScript Array类原生的push方法即可。最后，为了帮助我们验证结果，toString方法使用JavaScript原生Array类的join方法，来拼接数组中的所有元素至一个单一的字符串，这样我们就可以轻松地在浏览器的控制台输出结果了。</p><p>注意ArrayList类并没有任何方法来移除数据或插入数据到特定位置。我们刻意保持简单是为了能够专注于排序和搜索算法。所有的排序和搜索算法会添加至这个类中。</p><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><p>在开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。</p><p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p><p>让我们来实现一下冒泡排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.bubbleSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">                swap(array, j, j + <span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，声明一个名为length的变量，用来存储数组的长度（行{1}）。这一步可选，它能帮助我们在行{2}和行{3}时直接使用数组的长度。接着，外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处，反之亦然。</p><p>现在我们得声明swap函数（一个私有函数，只能用在ArrayList类的内部代码中）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swap = <span class="function"><span class="keyword">function</span> (<span class="params">array, index1, index2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aux = array[index1]; </span><br><span class="line">    array[index1] = array[index2];</span><br><span class="line">    array[index2] = aux;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>交换时，我们用一个中间值来存储某一交换项的值。其他排序法也会用到这个方法，因此我们声明一个方法放置这段交换代码以便重用。</p><p>如果使用在第1章学过的ES6（ECMAScript 2015）增强的对象属性，这个函数可以写成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[array[index1], array[index2]] = [array[index2], array[index1]];</span><br></pre></td></tr></table></figure><p>下面这个示意图展示了冒泡排序的工作过程：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-01.png" alt="冒泡排序的工作过程示意图"></p><p>该示意图中每一小段表示外循环的一轮（行{2}），而相邻两项的比较则是在内循环中进行<br>的（行{3}）。</p><p>我们将使用下面这段代码来测试冒泡排序算法，看结果是否和示意图所示一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNonSortedArray</span>(<span class="params">size</span>) </span>&#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = size; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        array.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> array = createNonSortedArray(<span class="number">5</span>); <span class="comment">//&#123;7&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(array.toString()); <span class="comment">//&#123;8&#125;</span></span><br><span class="line">array.bubbleSort(); <span class="comment">//&#123;9&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(array.toString()); <span class="comment">//&#123;10&#125;</span></span><br></pre></td></tr></table></figure><p>为了辅助测试本章将要学习的排序算法，我们将创建一个函数来自动地创建一个未排序的数组，数组的长度由函数参数指定（行{6}）。如果传递5作为参数，该函数会创建如下数组：[5, 4 ,3, 2, 1]。调用这个函数并将返回值存储在一个变量中，该变量将包含这个以某些数字来初始化的ArrayList类实例（行{7}）。我们在控制台上输出这个数组内容，确保这是一个未排序数组（行{8}），接着我们调用冒泡排序方法（行{9}）并再次在控制台上输出数组内容以验证数组已被排序了（行{10}）。</p><p>注意当算法执行外循环的第二轮的时候，数字4和5已经是正确排序的了。尽管如此，在后续比较中，它们还一直在进行着比较，即使这是不必要的。因此，我们可以稍稍改进一下冒泡排序<br>算法。</p><p>改进后的冒泡排序</p><p>如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较（行{1}）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.modifiedBubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>-i; j++ )&#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面这个示意图展示了改进后的冒泡排序算法是如何执行的：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-02.png" alt="改进后冒泡排序的工作过程示意图"></p><h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p><p>下面是选择排序算法的源代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.selectionSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length, <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        indexMin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        indexMin = i; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &lt; length; j++) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (array[indexMin] &gt; array[j]) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">                indexMin = j; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i !== indexMin) &#123; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            swap(array, i, indexMin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先声明一些将在算法内使用的变量（行{1}）。接着，外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。我们假设本迭代轮次的第一个值为数组最小值（行<br>{3}）。然后，从当前i的值开始至数组结束（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。当内循环结束（行{4}），将得出数组第n小的值。最后，如果该最小值和原最小值不同（行{7}），则交换其值。</p><p>用以下代码段来测试选择排序算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = createNonSortedArray(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array.toString()); <span class="comment">//[5, 4, 3, 2, 1]</span></span><br><span class="line">array.selectionSort();         </span><br><span class="line"><span class="built_in">console</span>.log(array.toString()); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>下面的示意图展示了选择排序算法，此例基于之前代码中所用的数组。</p><p>数组底部的箭头指示出当前迭代轮寻找最小值的数组范围（内循环{4}），示意图中的每一步则表示外循环。</p><p>选择排序同样也是一个复杂度为O(n2)的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。然而，接下来要学的插入排序比选择排序性能要好。</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-03.png" alt="选择排序的工作过程示意图"></p><h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><p>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。</p><p>下面这段代码表示插入排序算法：</p><p>照例，算法的第一行用来声明代码中使用的变量（行{1}）。接着，迭代数组来给第i项找到正确的位置（行{2}）。注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），便于之后将其插入到正确的位置上。下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比待比较的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。</p><p>下面的示意图展示了一个插入排序的实例：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-04.png" alt="插入排序的工作过程示意图"></p><p>举个例子，假定待排序数组是[3, 5, 1, 4, 2]。这些值将被插入排序算法按照下面形容的步骤进行排序。</p><blockquote><p>(1) 3已被排序，所以我们从数组第二个值5开始。3比5小，所以5待在原位（数组的第二位）。3和5排序完毕。<br>(2) 下一个待排序和插到正确位置上去的值是1（目前在数组的第三位）。5比1大，所以5被移至第三位去了。我们得分析1是否应该被插入到第二位——1比3大吗？不，所以3被移到第二位去了。接着，我们得证明1应该插入到数组的第一位上。因为0是第一个位置且没有负数位，所以1必须被插入到第一位。1、3、5三个数字已经排序。<br>(3) 4应该在当前位置（索引3）还是要移动到索引较低的位置上呢？4比5小，所以5移动到索引3位置上去。那么应该把4插到索引2的位置上去吗？4要比3大，所以4插入到数组的位置3上。<br> 下一个待插入的数字是2（数组的位置4）。5比2大，所以5移动至索引4。4比2大，所以4也得移动（位置3）。3也比2大，所以3还得移动。1比2小，所以2插入到数组的第二位置上。至此，数组已排序完成。</p></blockquote><p>排序小型数组时，此算法比选择排序和冒泡排序性能要好。</p><h3 id="1-4-归并排序"><a href="#1-4-归并排序" class="headerlink" title="1.4 归并排序"></a>1.4 归并排序</h3><p>归并排序是第一个可以被实际使用的排序算法。前面学到的三个排序算法性能不好，但归并排序性能不错，其复杂度为O(nlogn)。</p><p>JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。</p><p>归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p><p>由于是分治法，归并排序也是递归的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    array = mergeSortRec(array);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像之前的章节一样，每当要实现一个递归函数，我们都会实现一个实际被执行的辅助函数。对归并排序我们也会这么做。我们将声明mergeSort方法以供随后使用，而mergeSort方法将会调用mergeSortRec，该函数是一个递归函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeSortRec = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length;</span><br><span class="line">    <span class="keyword">if</span>(length === <span class="number">1</span>) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> array; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>), <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    left = array.slice(<span class="number">0</span>, mid), <span class="comment">//&#123;4&#125;</span></span><br><span class="line">    right = array.slice(mid, length); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">return</span> merge(mergeSortRec(left), mergeSortRec(right)); <span class="comment">//&#123;6&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的数组（行{2}），因为它已排序了。</p><p>如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的中间位（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。</p><p>下面的步骤是调用merge函数（行{6}），它负责合并和排序小数组来产生大数组，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [], <span class="comment">// &#123;7&#125;</span></span><br><span class="line">        il = <span class="number">0</span>,</span><br><span class="line">        ir = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (left[il] &lt; right[ir]) &#123;</span><br><span class="line">            result.push(left[il++]); <span class="comment">// &#123;9&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right[ir++]); <span class="comment">// &#123;10&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (il &lt; left.length) &#123; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">        result.push(left[il++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ir &lt; right.length) &#123; <span class="comment">// &#123;12&#125;</span></span><br><span class="line">        result.push(right[ir++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// &#123;13&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。</p><p>接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。</p><p>如果执行mergeSort函数，下图是具体的执行过程：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-05.png" alt="归并排序的工作过程示意图"></p><p>可以看到，算法首先将原始数组分割直至只有一个元素的子数组，然后开始归并。归并过程也会完成排序，直至原始数组完全合并并完成排序。</p><h3 id="1-5-快速排序"><a href="#1-5-快速排序" class="headerlink" title="1.5 快速排序"></a>1.5 快速排序</h3><p>快速排序也许是最常用的排序算法了。它的复杂度为O(nlogn)，且它的性能通常比其他的复杂度为O(nlogn)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。</p><p>快速排序比到目前为止你学过的其他排序算法要复杂一些。让我们一步步地来学习。</p><blockquote><p>(1) 首先，从数组中选择中间一项作为主元。<br>(2) 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分操作。<br>(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。</p></blockquote><p>让我们开始快速排序的实现吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    quick(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quick = <span class="function"><span class="keyword">function</span> (<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (array.length &gt; <span class="number">1</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        index = partition(array, left, right); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            quick(array, left, index - <span class="number">1</span>); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; right) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            quick(array, index, right); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。</p><p>如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。</p><h4 id="1-5-1-划分过程"><a href="#1-5-1-划分过程" class="headerlink" title="1.5.1 划分过程"></a>1.5.1 划分过程</h4><p>第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。</p><p>现在，让我们看看划分过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> partition = <span class="function"><span class="keyword">function</span> (<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pivot = array[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)], <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        i = left, <span class="comment">//&#123;9&#125;</span></span><br><span class="line">        j = right; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123; <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        <span class="keyword">while</span> (array[i] &lt; pivot) &#123; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (array[j] &gt; pivot) &#123; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123; <span class="comment">//&#123;14&#125;</span></span><br><span class="line">            swap(array, i, j); <span class="comment">//&#123;15&#125;</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">//&#123;16&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。</p><p>只要left和right指针没有相互交错（行{11}），就执行划分操作。首先，移动left指针直到找到一个元素比主元大（行{12}）。对right指针，我们做同样的事情，移动right指针直到我们找到一个元素比主元小。</p><p>当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。</p><p>在划分操作结束后，返回左指针的索引，用来在行{3}处创建子数组。</p><p>swap函数和我们在本章开始为冒泡排序算法实现的相同。我们也可以将此函数替换为以下ES6代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[array[index1], array[index2]] = [array[index2], array[index1]];</span><br></pre></td></tr></table></figure><h4 id="1-5-2-快速排序实战"><a href="#1-5-2-快速排序实战" class="headerlink" title="1.5.2 快速排序实战"></a>1.5.2 快速排序实战</h4><p>让我们来一步步地看一个快速排序的实际例子：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-06.png" alt="快速排序的工作过程示意图"></p><p>给定数组[3, 5, 1, 6, 4, 7, 2]，前面的示意图展示了划分操作的第一次执行。</p><p>下面的示意图展示了对有较小值的子数组执行的划分操作（注意7和6不包含在子数组之内）：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-07.png" alt="快速排序的工作过程示意图"></p><p>接着，我们继续创建子数组，请看下图，但是这次操作是针对上图中有较大值的子数组（有1的那个较小子数组不用再划分了，因为它仅含有一个项）。</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-08.png" alt="快速排序的工作过程示意图"></p><p>子数组（[2, 3, 5, 4]）中的较小子数组（[2, 3]）继续进行划分（算法代码中的行{5}）：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-09.png" alt="快速排序的工作过程示意图"></p><p>然后子数组（[2, 3, 5, 4]）中的较大子数组（[5, 4]）也继续进行划分（算法中的行{7}），示意图如下：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-10.png" alt="快速排序的工作过程示意图"></p><p>最终，较大子数组[6, 7]也会进行划分（partition）操作，快速排序算法的操作执行完成。</p><h3 id="1-6-堆排序"><a href="#1-6-堆排序" class="headerlink" title="1.6 堆排序"></a>1.6 堆排序</h3><p>堆排序也是一种很高效的算法，因其把数组当作二叉树来排序而得名。这个算法会根据以下信息，把数组当作二叉树来管理。</p><blockquote><p>索引0是树的根节点；<br>除根节点外，任意节点N的父节点是N/2；<br>节点L的左子节点是2<em>L；<br>节点R的右子节点是2</em>R+1。</p></blockquote><p>举例来说，可以将数组[3, 5, 1, 6, 4, 7, 2]想象成下面的树：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-11.png" alt="堆排序示意图"></p><p>堆排序算法实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.heapSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> heapSize = array.length;</span><br><span class="line">    buildHeap(array); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        heapSize--;</span><br><span class="line">        swap(array, <span class="number">0</span>, heapSize); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        heapify(array, heapSize, <span class="number">0</span>); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一步，构造一个满足array[parent(i)] ≥ array[i]的堆结构（行{1}）。</p><p>第二步，交换堆里第一个元素（数组中较大的值）和最后一个元素的位置（行{2}）。这样，最大的值就会出现在它已排序的位置。</p><p>第二步可能会丢掉堆的属性。因此，我们还需要执行一个heapify函数，再次将数组转换成堆，也就是说，它会找到当前堆的根节点（较小的值），重新放到树的底部。</p><p>buildHeap函数实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildHeap = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> heapSize = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, heapSize, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果对数组[3, 5, 1, 6, 4, 7, 2]调用buildHeap函数，堆的构建过程如下：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-12.png" alt="堆排序示意图"></p><p>最后，heapify函数实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> heapify = <span class="function"><span class="keyword">function</span> (<span class="params">array, heapSize, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> left = i * <span class="number">2</span> + <span class="number">1</span>,</span><br><span class="line">        right = i * <span class="number">2</span> + <span class="number">2</span>,</span><br><span class="line">        largest = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">        swap(array, i, largest);</span><br><span class="line">        heapify(array, heapSize, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆构造好之后，就可以应用堆排序的算法了，也就是行{2}和行{3} </p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-13.png" alt="堆排序示意图"></p><h2 id="二、搜索算法"><a href="#二、搜索算法" class="headerlink" title="二、搜索算法"></a>二、搜索算法</h2><p>现在，让我们来谈谈搜索算法。回顾一下之前章节所实现的算法，我们会发现BinarySearchTree类的search方法（第8章），以及LinkedList类的indexOf方法（第5章）等，都是搜索算法，当然，它们每一个都是根据其各自的数据结构来实现的。所以，我们已经熟悉两个搜索算法了，只是还不知道它们“正式”的名称而已。</p><h3 id="2-1-顺序搜索"><a href="#2-1-顺序搜索" class="headerlink" title="2.1 顺序搜索"></a>2.1 顺序搜索</h3><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。</p><p>以下是其实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sequentialSearch = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (item === array[i]) <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>顺序搜索迭代整个数组（行{1}），并将每个数组元素和搜索项作比较（行{2}）。如果搜索到了，算法将用返回值来标示搜索成功。返回值可以是该搜索项本身，或是true，又或是搜索项的索引（行{3}）。如果没有找到该项，则返回-1（行{4}），表示该索引不存在；也可以考虑返回false或者null。</p><p>假定有数组[5, 4, 3, 2, 1]和待搜索值3，下图展示了顺序搜索的示意图：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-14.png" alt="顺序搜索示意图"></p><h3 id="2-2-二分搜索"><a href="#2-2-二分搜索" class="headerlink" title="2.2 二分搜索"></a>2.2 二分搜索</h3><p>二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。</p><p>这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。</p><blockquote><p>(1) 选择数组的中间值。</p></blockquote><blockquote><p>(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。</p></blockquote><blockquote><p>(3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。</p></blockquote><blockquote><p>(4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。</p></blockquote><p>以下是其实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.binarySearch = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.quickSort(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">var</span> low = <span class="number">0</span>, <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        high = array.length - <span class="number">1</span>, <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        mid, element;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        element = array[mid]; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (element &lt; item) &#123; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; item) &#123; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">            high = mid - <span class="number">1</span>; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始前需要先将数组排序，我们可以选择任何一个在10.1节中实现的排序算法。这里我们选择了快速排序。在数组排序之后，我们设置low（行{2}）和high（行{3}）指针（它们是边界）。</p><p>当low比high小时（行{4}），我们计算得到中间项索引并取得中间项的值，此处如果low比high大，则意思是该待搜索值不存在并返回-1（行{12}）。接着，我们比较选中项的值和搜索值（行{7}）。如果小了，则选择数组低半边并重新开始。如果选中项的值比搜索值大了，则选择数组高半边并重新开始。若两者都是不是，则意味着选中项的值和搜索值相等，因此，直接返回该索引（行{11}）。</p><p>给定下图所示数组，让我们试试看搜索2。这些是算法将会执行的步骤：</p><p><img src="/2019/05/05/cjvqhlsut001brcvbcg43rv2u/arithmetic-15.png" alt="二分搜索示意图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、排序算法&quot;&gt;&lt;a href=&quot;#一、排序算法&quot; class=&quot;headerlink&quot; title=&quot;一、排序算法&quot;&gt;&lt;/a&gt;一、排序算法&lt;/h2&gt;&lt;p&gt;在开始排序算法之前，我们先创建一个数组（列表）来表示待排序和搜索的数据结构。&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法九（图）</title>
    <link href="https://www.23ybob.club/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/"/>
    <id>https://www.23ybob.club/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/</id>
    <published>2019-03-08T01:45:50.000Z</published>
    <updated>2019-04-23T08:45:03.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、图的相关术语"><a href="#一、图的相关术语" class="headerlink" title="一、图的相关术语"></a>一、图的相关术语</h2><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。</p><p>任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。</p><p>我们还可以使用图来表示道路、航班以及通信状态，如下图所示：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-01.png" alt="数据结构-图示例"></p><p>让我们来学习一下图在数学及技术上的概念。</p><p>一个图G = (V, E)由以下元素组成。</p><blockquote><p>V：一组顶点<br>E：一组边，连接V中的顶点</p></blockquote><p>下图表示一个图：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-02.png" alt="数据结构-图示例"></p><p>在着手实现算法之前，让我们先了解一下图的一些术语。</p><p>由一条边连接在一起的顶点称为相邻顶点。比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。</p><p>一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3；E和其他两个顶点相连，因此，E的度为2。</p><p>路径是顶点v1, v2,…,vk的一个连续序列，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。</p><p>简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如A D C A（最后一个顶点重新回到A）。</p><p>如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。</p><h3 id="1-1-有向图和无向图"><a href="#1-1-有向图和无向图" class="headerlink" title="1.1 有向图和无向图"></a>1.1 有向图和无向图</h3><p>图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-03.png" alt="数据结构-图示例"></p><p>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的，而A和B不是强连通的。</p><p>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-04.png" alt="加权图示例"></p><p>我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。</p><h2 id="二、-图的表示"><a href="#二、-图的表示" class="headerlink" title="二、 图的表示"></a>二、 图的表示</h2><p>从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。</p><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0，如下图所示：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-05.png" alt="邻接矩阵示例"></p><p>不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而2维数组不太灵活。</p><h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-06.png" alt="邻接矩阵示例"></p><p>尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质（例如，要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。在本书的示例中，我们将会使用邻接表表示法。</p><h3 id="2-3-关联矩阵"><a href="#2-3-关联矩阵" class="headerlink" title="2.3 关联矩阵"></a>2.3 关联矩阵</h3><p>我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-07.png" alt="关联矩阵示意图"></p><p>关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。</p><h2 id="三、创建Graph类"><a href="#三、创建Graph类" class="headerlink" title="三、创建Graph类"></a>三、创建Graph类</h2><p>照例，我们声明类的骨架：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = []; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">var</span> adjList = <span class="keyword">new</span> Dictionary(); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个数组来存储图中所有顶点的名字（行{1}），以及一个字典（在第7章中已经实现）来存储邻接表（行{2}）。字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和adjList字典两者都是我们Graph类的私有属性。</p><p>接着，我们将实现两个方法：一个用来向图中添加一个新的顶点（因为图实例化后是空的），另外一个方法用来添加顶点之间的边。我们先实现addVertex方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addVertex = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    vertices.push(v); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    adjList.set(v, []); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法接受顶点v作为参数。我们将该顶点添加到顶点列表中（行{3}），并且在邻接表中，设置顶点v作为键对应的字典值为一个空数组（行{4}）。</p><p>现在，我们来实现addEdge方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEdge = <span class="function"><span class="keyword">function</span>(<span class="params">v, w</span>)</span>&#123;</span><br><span class="line">    adjList.get(v).push(w); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    adjList.get(w).push(v); <span class="comment">//&#123;6&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法接受两个顶点作为参数。首先，通过将w加入到v的邻接表中，我们添加了一条自顶点v到顶点w的边。如果你想实现一个有向图，则行{5}就足够了。由于本章中大多数的例子都是基于无向图的，我们需要添加一条自w向v的边（行{6}）。</p><p>为了更方便一些，让我们来实现一下Graph类的toString方法，以便于在控制台输出图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;vertices.length; i++)&#123; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">        s += vertices[i] + <span class="string">' -&gt; '</span>;</span><br><span class="line">        <span class="keyword">var</span> neighbors = adjList.get(vertices[i]); <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;neighbors.length; j++)&#123; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">            s += neighbors[j] + <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="string">'\n'</span>; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们为邻接表表示法构建了一个字符串。首先，迭代vertices数组列表（行{10}），将顶点的名字加入字符串中。接着，取得该顶点的邻接表（行{11}），同样也迭代该邻接表（行{12}），将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符（行{13}），这样就可以在控制台看到一个漂亮的输出了。运行如下代码：</p><p>测试以上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"><span class="keyword">var</span> myVertices = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>]; <span class="comment">//&#123;7&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;myVertices.length; i++)&#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">    graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">//&#123;9&#125;</span></span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'C'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'H'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'E'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'F'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'E'</span>, <span class="string">'I'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(graph.toString());</span><br></pre></td></tr></table></figure><p>为方便起见，我们创建了一个数组，包含所有我们想添加到图中的顶点（行{7}）。接下来，我们只要遍历vertices数组并将其中的值逐一添加到我们的图中（行{8}）。最后，我们添加想要的边（行{9}）。这段代码将会创建一个图，也就是到目前为止本章的示意图所使用的。</p><p>输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B C D</span><br><span class="line">B -&gt; A E F</span><br><span class="line">C -&gt; A D G</span><br><span class="line">D -&gt; A C G H</span><br><span class="line">E -&gt; B I</span><br><span class="line">F -&gt; B</span><br><span class="line">G -&gt; C D</span><br><span class="line">H -&gt; D</span><br><span class="line">I -&gt; E</span><br></pre></td></tr></table></figure><p>一个漂亮的邻接表！从该输出中，我们知道顶点A有这几个相邻顶点：B、C和D。</p><h2 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h2><p>和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。</p><p>在实现算法之前，让我们来更好地理解一下图遍历的思想方法。</p><p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</p><p>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p><p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p><p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。</p><table><thead><tr><th>算 法</th><th>数据结构</th><th>描述</th></tr></thead><tbody><tr><td>深度优先搜索</td><td>栈</td><td>通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td></tr><tr><td>广度优先搜索</td><td>队列</td><td>通过将顶点存入队列中，最先入队列的顶点先被探索</td></tr></tbody></table><p>当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。</p><blockquote><p>白色：表示该顶点还没有被访问。<br>灰色：表示该顶点被访问过，但并未被探索过。<br>黑色：表示该顶点被访问过且被完全探索过。</p></blockquote><p>这就是之前提到的务必访问每个顶点最多两次的原因。</p><h3 id="4-1-广度优先搜索"><a href="#4-1-广度优先搜索" class="headerlink" title="4.1 广度优先搜索"></a>4.1 广度优先搜索</h3><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-08.png" alt="广度优先遍历"></p><p>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。</p><p>(1) 创建一个队列Q。<br>(2) 将v标注为被发现的（灰色），并将v入队列Q。<br>(3) 如果Q非空，则运行以下步骤：<br>    (a) 将u从Q中出队列；<br>    (b) 将标注u为被发现的（灰色）；<br>    (c) 将u所有未被访问过的邻点（白色）入队列；<br>    (d) 将u标注为已被探索的（黑色）。</p><p>让我们来实现广度优先搜索算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initializeColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">        color[vertices[i]] = <span class="string">'white'</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.bfs = <span class="function"><span class="keyword">function</span> (<span class="params">v, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(), <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    queue = <span class="keyword">new</span> Queue(); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    queue.enqueue(v); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">var</span> u = queue.dequeue(), <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            neighbors = adjList.get(u); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">        color[u] = <span class="string">'grey'</span>; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">            <span class="keyword">var</span> w = neighbors[i]; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">                color[w] = <span class="string">'grey'</span>; <span class="comment">// &#123;12&#125;</span></span><br><span class="line">                queue.enqueue(w); <span class="comment">// &#123;13&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = <span class="string">'black'</span>; <span class="comment">// &#123;14&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (callback) &#123; <span class="comment">// &#123;15&#125;</span></span><br><span class="line">            callback(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>广度优先搜索和深度优先搜索都需要标注被访问过的顶点。为此，我们将使用一个辅助数组color。由于当算法开始执行时，所有的顶点颜色都是白色（行{1}），所以我们可以创建一个辅助函数initializeColor，为这两个算法执行此初始化操作。</p><p>让我们深入学习广度优先搜索方法的实现。我们要做的第一件事情是用initializeColor函数来将color数组初始化为white（行{2}）。我们还需要声明和创建一个Queue实例（行{3}），它将会存储待访问和待探索的顶点。</p><p>照着本章开头解释过的步骤，bfs方法接受一个顶点作为算法的起始点。起始顶点是必要的，我们将此顶点入队列（行{4}）。</p><p>如果队列非空（行{5}），我们将通过出队列（行{6}）操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表（行{7}）。该顶点将被标注为grey（行{8}），表示我们发现了它（但还未完成对其的探索）。</p><p>对于u（行{9}）的每个邻点，我们取得其值（该顶点的名字——行{10}），如果它还未被访问过（颜色为white——行{11}），则将其标注为我们已经发现了它（颜色设置为grey——行<br>{12}），并将这个顶点加入队列中（行{13}），这样当其从队列中出列的时候，我们可以完成对其的探索。</p><p>当完成探索该顶点和其相邻顶点后，我们将该顶点标注为已探索过的（颜色设置为black——行{14}）。</p><p>我们实现的这个bfs方法也接受一个回调（我们在第8章中遍历树时使用了一个相似的方法）。这个参数是可选的，如果我们传递了回调函数（行{15}），会用到它。</p><p>让我们执行下面这段代码来测试一下这个算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNode</span>(<span class="params">value</span>)</span>&#123; <span class="comment">//&#123;16&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Visited vertex: '</span> + value); <span class="comment">//&#123;17&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">graph.bfs(myVertices[<span class="number">0</span>], printNode); <span class="comment">//&#123;18&#125;</span></span><br></pre></td></tr></table></figure><p>首先，我们声明了一个回调函数（行{16}），它仅仅在浏览器控制台上输出已经被完全探索过的顶点的名字。接着，我们会调用bfs方法，给它传递第一个顶点（A——从本章开头声明的myVertices数组）和回调函数。当我们执行这段代码时，该算法会在浏览器控制台输出下示的结果：</p><blockquote><p>Visited vertex: A<br>Visited vertex: B<br>Visited vertex: C<br>Visited vertex: D<br>Visited vertex: E<br>Visited vertex: F<br>Visited vertex: G<br>Visited vertex: H<br>Visited vertex: I </p></blockquote><p>顶点被访问的顺序和本节开头的示意图中所展示的一致。</p><h4 id="4-1-1-使用BFS寻找最短路径"><a href="#4-1-1-使用BFS寻找最短路径" class="headerlink" title="4.1.1 使用BFS寻找最短路径"></a>4.1.1 使用BFS寻找最短路径</h4><p>到目前为止，我们只展示了BFS算法的工作原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面这个问题。</p><p>给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。</p><p>对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改bfs方法以返回给我们一些信息：</p><ul><li>从v到u的距离d[u]；</li><li>前溯点pred[u]，用来推导出从v到其他每个顶点u的最短路径。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.BFS = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(),</span><br><span class="line">        queue = <span class="keyword">new</span> Queue(),</span><br><span class="line">        d = [], <span class="comment">//&#123;1&#125; </span></span><br><span class="line">        pred = []; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    queue.enqueue(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        d[vertices[i]] = <span class="number">0</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        pred[vertices[i]] = <span class="literal">null</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">var</span> u = queue.dequeue(),</span><br><span class="line">            neighbors = adjList.get(u);</span><br><span class="line">        color[u] = <span class="string">'grey'</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> w = neighbors[i];</span><br><span class="line">            <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123;</span><br><span class="line">                color[w] = <span class="string">'grey'</span>;</span><br><span class="line">                d[w] = d[u] + <span class="number">1</span>; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                pred[w] = u; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = <span class="string">'black'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        distances: d,</span><br><span class="line">        predecessors: pred</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们来看看改进过的广度优先方法的实现：</p><p>我们还需要声明数组d（行{1}）来表示距离，以及pred数组来表示前溯点。下一步则是对图中的每一个顶点，用0来初始化数组d（行{4}），用null来初始化数组pred。</p><p>当我们发现顶点u的邻点w时，则设置w的前溯点值为u（行{7}）。我们还通过给d[u]加1来设置v和w之间的距离（u是w的前溯点，d[u]的值已经有了）。</p><p>方法最后返回了一个包含d和pred的对象（行{8}）。</p><p>现在，我们可以再次执行BFS方法，并将其返回值存在一个变量中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortestPathA = graph.BFS(myVertices[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(shortestPathA);</span><br></pre></td></tr></table></figure><p>对顶点A执行BFS方法，以下将会是输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distances: [A: <span class="number">0</span>, <span class="attr">B</span>: <span class="number">1</span>, <span class="attr">C</span>: <span class="number">1</span>, <span class="attr">D</span>: <span class="number">1</span>, <span class="attr">E</span>: <span class="number">2</span>, <span class="attr">F</span>: <span class="number">2</span>, <span class="attr">G</span>: <span class="number">2</span>, <span class="attr">H</span>: <span class="number">2</span> , <span class="attr">I</span>: <span class="number">3</span>],</span><br><span class="line">predecessors: [A: <span class="literal">null</span>, <span class="attr">B</span>: <span class="string">"A"</span>, <span class="attr">C</span>: <span class="string">"A"</span>, <span class="attr">D</span>: <span class="string">"A"</span>, <span class="attr">E</span>: <span class="string">"B"</span>, <span class="attr">F</span>: <span class="string">"B"</span>, <span class="attr">G</span>: <span class="string">"C"</span>, <span class="attr">H</span>: <span class="string">"D"</span>, <span class="attr">I</span>: <span class="string">"E"</span>]</span><br></pre></td></tr></table></figure><p>这意味着顶点A与顶点B、C和D的距离为1；与顶点E、F、G和H的距离为2；与顶点I的距离为3。</p><p>通过前溯点数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fromVertex = myVertices[<span class="number">0</span>]; <span class="comment">//&#123;9&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; myVertices.length; i++) &#123; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">    <span class="keyword">var</span> toVertex = myVertices[i], <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        path = <span class="keyword">new</span> Stack(); <span class="comment">//&#123;12&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> v = toVertex; v !== fromVertex;v = shortestPathA.predecessors[v]) &#123; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">        path.push(v); <span class="comment">//&#123;14&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    path.push(fromVertex); <span class="comment">//&#123;15&#125;</span></span><br><span class="line">    <span class="keyword">var</span> s = path.pop(); <span class="comment">//&#123;16&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (!path.isEmpty()) &#123; <span class="comment">//&#123;17&#125;</span></span><br><span class="line">        s += <span class="string">' - '</span> + path.pop(); <span class="comment">//&#123;18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(s); <span class="comment">//&#123;19&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用顶点A作为源顶点（行{9}）。对于每个其他顶点（除了顶点A——行{10}），我们会计算顶点A到它的路径。我们从顶点数组得到toVertex（行{11}），然后会创建一个栈来存储路径值（行{12}）。</p><p>接着，我们追溯toVertex到fromVertex的路径（行{13}）。变量v被赋值为其前溯点的值，这样我们能够反向追溯这条路径。将变量v添加到栈中（行{14}）。最后，源顶点也会被添加到栈中，以得到完整路径。</p><p>这之后，我们创建了一个s字符串，并将源顶点赋值给它（它是最后一个加入栈中的，所以它是第一个被弹出的项 ——行{16}）。当栈是非空的，我们就从栈中移出一个项并将其拼接到字符串s的后面（行{18}）。最后（行{19}）在控制台上输出路径。</p><p>执行该代码段，我们会得到如下输出：</p><blockquote><p>A - B<br>A - C<br>A - D<br>A - B - E<br>A - B - F<br>A - C - G<br>A - D - H<br>A - B - E - I </p></blockquote><p>这里，我们得到了从顶点A到图中其他顶点的最短路径（衡量标准是边的数量）。</p><h4 id="4-1-2-深入学习最短路径算法"><a href="#4-1-2-深入学习最短路径算法" class="headerlink" title="4.1.2 深入学习最短路径算法"></a>4.1.2 深入学习最短路径算法</h4><p>本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法），广度优先搜索未必合适。</p><p>举些例子，Dijkstra算法解决了单源最短路径问题。Bellman-Ford算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。Floyd-Warshall算法解决了求所有顶点对间的最短路径这一问题。</p><p>如文章开头提到的，图是一个广泛的主题，对最短路径问题及其变种问题，我们有很多的解决方案。但在开始学习这些其他解决方案前，我们需要掌握好图的基本概念，这是本章涵盖的内容。而这些其他解决方案则不会在本章讲述，但你可以自行探索图的奇妙世界</p><h3 id="4-2深度优先搜索"><a href="#4-2深度优先搜索" class="headerlink" title="4.2深度优先搜索"></a>4.2深度优先搜索</h3><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-09.png" alt="深度优先搜索示意图"></p><p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。</p><p>要访问顶点v，照如下步骤做。</p><blockquote><p>(1) 标注v为被发现的（灰色）。<br>(2) 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。</p></blockquote><p>如你所见，深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。</p><p>让我们来实现一下深度优先算法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dfs = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(); <span class="comment">//&#123;1&#125; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (color[vertices[i]] === <span class="string">'white'</span>) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            dfsVisit(vertices[i], color, callback); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dfsVisit = <span class="function"><span class="keyword">function</span> (<span class="params">u, color, callback</span>) </span>&#123;</span><br><span class="line">    color[u] = <span class="string">'grey'</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (callback) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">        callback(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> neighbors = adjList.get(u); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        <span class="keyword">var</span> w = neighbors[i]; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">            dfsVisit(w, color, callback); <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = <span class="string">'black'</span>; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，我们创建颜色数组（行{1}），并用值white为图中的每个顶点对其做初始化，广度优先搜索也这么做的。接着，对于图实例中每一个未被访问过的顶点（行{2}和{3}），我们调用私有的递归函数dfsVisit，传递的参数为顶点、颜色数组以及回调函数（行{4}）。</p><p>当访问u顶点时，我们标注其为被发现的（grey——行{5}）。如果有callback函数的话（行{6}），则执行该函数输出已访问过的顶点。接下来一步是取得包含顶点u所有邻点的列表（行{7}）。对于顶点u的每一个未被访问过（颜色为white——行{10}和行{8}）的邻点w（行{9}），我们将调用dfsVisit函数，传递w和其他参数（行{11}——添加顶点w入栈，这样接下来就能访问它）。最后，在该顶点和邻点按深度访问之后，我们回退，意思是该顶点已被完全探索，并将其标注为black（行{12}）。</p><p>让我们执行下面的代码段来测试一下dfs方法：</p><p>输出如下：</p><blockquote><p>Visited vertex: A<br>Visited vertex: B<br>Visited vertex: E<br>Visited vertex: I<br>Visited vertex: F<br>Visited vertex: C<br>Visited vertex: D<br>Visited vertex: G<br>Visited vertex: H </p></blockquote><p>这个顺序和本节开头处示意图所展示的一致。下面这个示意图展示了该算法每一步的执行过程：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-10.png" alt="深度优先搜索执行过程示意图"></p><p>在我们示例所用的图中，行{4}只会被执行一次，因为所有其他的顶点都有路径到第一个调用dfsVisit函数的顶点（顶点A）。如果顶点B第一个调用函数，则行{4}将会为其他顶点再执行一次（比如顶点A）。</p><h4 id="4-2-1-深度优先搜索"><a href="#4-2-1-深度优先搜索" class="headerlink" title="4.2.1 深度优先搜索"></a>4.2.1 深度优先搜索</h4><p>到目前为止，我们只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事情，而不只是输出被访问顶点的顺序。</p><p>对于给定的图G，我们希望深度优先搜索算法遍历图G的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。我们可以修改dfs方法来返回给我们一些信息：</p><blockquote><p>顶点u的发现时间d[u]；<br>当顶点u被标注为黑色时，u的完成探索时间f[u]；<br>顶点u的前溯点p[u]。</p></blockquote><p>让我们来看看改进了的DFS方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="number">0</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line"><span class="keyword">this</span>.DFS = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(), <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        d = [],</span><br><span class="line">        f = [],</span><br><span class="line">        p = [];</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        f[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">        d[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">        p[vertices[i]] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[vertices[i]] === <span class="string">'white'</span>) &#123;</span><br><span class="line">            DFSVisit(vertices[i], color, d, f, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        discovery: d,</span><br><span class="line">        finished: f,</span><br><span class="line">        predecessors: p</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> DFSVisit = <span class="function"><span class="keyword">function</span> (<span class="params">u, color, d, f, p</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'discovered '</span> + u);</span><br><span class="line">    color[u] = <span class="string">'grey'</span>;</span><br><span class="line">    d[u] = ++time; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">var</span> neighbors = adjList.get(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> w = neighbors[i];</span><br><span class="line">        <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123;</span><br><span class="line">            p[w] = u; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">            DFSVisit(w, color, d, f, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = <span class="string">'black'</span>;</span><br><span class="line">    f[u] = ++time; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'explored '</span> + u);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要一个变量来要追踪发现时间和完成探索时间（行{1}）。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他JavaScript方法（将变量作为引用传递的意思是如果该变量在其他方法内部被修改，新值会在原始变量中反映出来）。接下来，我们声明数组d、f和p（行{2}）。我们需要为图的每一个顶点来初始化这些数组（行{3}）。在这个方法结尾处返回这些值（行{4}），之后我们要用到它们。</p><p>当一个顶点第一次被发现时，我们追踪其发现时间（行{5}）。当它是由引自顶点u的边而被发现的，我们追踪它的前溯点（行{6}）。最后，当这个顶点被完全探索后，我们追踪其完成时间（行{7}）。</p><p>深度优先算法背后的思想是什么？边是从最近发现的顶点u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法回退到u被发现的地方去探索其他的边。这个过程持续到我们发现了所有从原始顶点能够触及的顶点。如果还留有任何其他未被发现的顶点，我们对新源顶点重复这个过程。重复该算法，直到图中所有的顶点都被探索了。</p><p>对于改进过的深度优先搜索，有两点需要我们注意：</p><blockquote><p>时间（time）变量值的范围只可能在图顶点数量的一倍到两倍之间；<br>对于所有的顶点u，d[u]&lt;f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）。</p></blockquote><p>在这两个假设下，我们有如下的规则：</p><blockquote><p>1 ≤ d [u] &lt; f [u] ≤ 2|V| </p></blockquote><p>如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-11.png" alt="深度优先搜索执行过程示意图"></p><h4 id="4-2-2-拓扑排序——使用深度优先搜索"><a href="#4-2-2-拓扑排序——使用深度优先搜索" class="headerlink" title="4.2.2 拓扑排序——使用深度优先搜索"></a>4.2.2 拓扑排序——使用深度优先搜索</h4><p>给定下图，假定每个顶点都是一个我们需要去执行的任务：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-12.png" alt="深度优先搜索执行过程示意图"></p><p>这是一个有向图，意味着任务的执行是有顺序的。例如，任务F不能在任务A之前执行。注意这个图没有环，意味着这是一个无环图。所以，我们可以说该图是一个有向无环图（DAG）。</p><p>当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting，英文亦写作topsort或是toposort）。在日常生活中，这个问题在不同情形下都会出现。例如，当我们开始学习一门计算机科学课程，在学习某些知识之前得按顺序完成一些知识储备（你不可以在上算法I前先上算法II）。当我们在开发一个项目时，需要按顺序执行一些步骤，例如，首先我们得从客户那里得到需求，接着开发客户要求的东西，最后交付项目。你不能先交付项目再去收集需求。</p><p>拓扑排序只能应用于DAG。那么，如何使用深度优先搜索来实现拓扑排序呢？让我们在本节开头的示意图上执行一下深度优先搜索。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = <span class="keyword">new</span> Graph();</span><br><span class="line">myVertices = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;myVertices.length; i++)&#123;</span><br><span class="line">graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'C'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'E'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'F'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'F'</span>, <span class="string">'E'</span>);</span><br><span class="line"><span class="keyword">var</span> result = graph.DFS();</span><br></pre></td></tr></table></figure><p>这段代码将创建图，添加边，执行改进版本的深度优先搜索算法，并将结果保存到result变量。下图展示了深度优先搜索算法执行后，该图的发现和完成时间</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-13.png" alt="拓扑排序示意图"></p><p>现在要做的仅仅是以倒序来排序完成时间数组，这便得出了该图的拓扑排序：</p><blockquote><p>B - A - D - C - F - E  </p></blockquote><p>注意之前的拓扑排序结果仅是多种可能性之一。如果我们稍微修改一下算法，就会有不同的结果，比如下面这个结果也是众多其他可能性中的一个：</p><blockquote><p>A - B - C - D - F - E </p></blockquote><h2 id="五、-最短路径算法"><a href="#五、-最短路径算法" class="headerlink" title="五、 最短路径算法"></a>五、 最短路径算法</h2><p>设想你要从街道地图上的A点，通过可能的最短路径到达B点。举例来说，从洛杉矶的圣莫尼卡大道到好莱坞大道，如下图所示：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-14.png" alt="最短路径演示"></p><p>这种问题在生活中非常常见，我们（特别是生活在大城市的人们）会求助于苹果地图、谷歌地图、Waze等应用程序。当然，我们也有其他的考虑，如时间或路况，但根本的问题仍然是：从A到B的最短路径是什么？</p><p>我们可以用图来解决这个问题，相应的算法被称为最短路径。本节我们将介绍两种非常著名的算法，即Dijkstra算法和Floyd-Warshall算法。</p><h3 id="5-1-Dijkstra-算法"><a href="#5-1-Dijkstra-算法" class="headerlink" title="5.1 Dijkstra 算法"></a>5.1 Dijkstra 算法</h3><p>Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。</p><p>考虑下图：</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-15.png" alt="Dijkstra 算法示意图"></p><p>我们来看看如何找到顶点A和其余顶点之间的最短路径。但首先，我们需要声明表示上图的邻接矩阵，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]];</span><br></pre></td></tr></table></figure><p>现在，通过下面的代码来看看Dijkstra算法是如何工作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dijkstra = <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dist = [],</span><br><span class="line">        visited = [],</span><br><span class="line">        length = <span class="keyword">this</span>.graph.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        dist[i] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[src] = <span class="number">0</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">var</span> u = minDistance(dist, visited); <span class="comment">//&#123;4&#125; </span></span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; <span class="keyword">this</span>.graph[u][v] != <span class="number">0</span> &amp;&amp; dist[u] != <span class="built_in">Number</span>.MAX_SAFE_INTEGER &amp;&amp; dist[u] + <span class="keyword">this</span>.graph[u][v] &lt; dist[v]) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                dist[v] = dist[u] + <span class="keyword">this</span>.graph[u][v]; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是对算法过程的描述。</p><blockquote><p>行{1}：首先，把所有的距离（dist）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），将visited[]初始化为false。<br>行{2}：然后，把源顶点到自己的距离设为0。<br>行{3}：接下来，要找出到其余顶点的最短路径。<br>行{4}：为此，我们需要从尚未处理的顶点中选出距离最近的顶点。<br>行{5}：把选出的顶点标为visited，以免重复计算。<br>行{6}：如果找到更短的路径，则更新最短路径的值（行{7}）。<br>行{8}：处理完所有顶点后，返回从源顶点（src）到图中其他顶点最短路径的结果。</p></blockquote><p>要计算顶点间的minDistance，就要搜索dist数组中的最小值，返回它在数组中的索引：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">dist, visited</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min = INF, minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[v] == <span class="literal">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">        min = dist[v];</span><br><span class="line">            minIndex = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对本节开始的图执行以上算法，会得到如下输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="5-2-Floyd-Warshall-算法"><a href="#5-2-Floyd-Warshall-算法" class="headerlink" title="5.2 Floyd-Warshall 算法"></a>5.2 Floyd-Warshall 算法</h3><p>Floyd-Warshall算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。</p><p>Floyd-Warshall算法实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.floydWarshall = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dist = [],</span><br><span class="line">        length = <span class="keyword">this</span>.graph.length,</span><br><span class="line">        i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            dist[i] = [];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                dist[i][j] = <span class="keyword">this</span>.graph[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; length; k++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                        dist[i][j] = dist[i][k] + dist[k][j]; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">下面是对算法过程的描述:</span><br><span class="line"></span><br><span class="line">&gt; 行&#123;<span class="number">1</span>&#125;：首先，把dist数组初始化为每个顶点之间的权值，因为i到j可能的最短距离就是这些顶点间的权值。</span><br><span class="line">&gt; 行&#123;<span class="number">2</span>&#125;：通过k，得到i途径顶点<span class="number">0</span>至k，到达j的最短路径。</span><br><span class="line">&gt; 行&#123;<span class="number">3</span>&#125;：判断i经过顶点k到达j的路径是否比已有的最短路径更短。</span><br><span class="line">&gt; 行&#123;<span class="number">4</span>&#125;：如果是更短的路径，则更新最短路径的值。</span><br><span class="line"></span><br><span class="line">行&#123;<span class="number">3</span>&#125;是Floyd-Warshall算法的核心。对本节开始的图执行以上算法，会得到如下输出：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">    0 2 3 6 4 6</span></span><br><span class="line"><span class="string">    INF 0 1 4 2 4</span></span><br><span class="line"><span class="string">    INF INF 0 6 3 5</span></span><br><span class="line"><span class="string">    INF INF INF 0 INF 2 </span></span><br><span class="line"><span class="string">    INF INF INF 3 0 2</span></span><br><span class="line"><span class="string">    INF INF INF INF INF 0</span></span><br></pre></td></tr></table></figure><p>其中，INF代表顶点i到j的最短路径不存在。</p><p>对图中每一个顶点执行Dijkstra算法，也可以得到相同的结果。</p><h2 id="六、-最小生成树"><a href="#六、-最小生成树" class="headerlink" title="六、 最小生成树"></a>六、 最小生成树</h2><p>最小生成树（MST）问题是网络设计中常见的问题。想象一下，你的公司有几间办公室，要以最低的成本实现办公室电话线路相互连通，以节省资金，最好的办法是什么？</p><p>这也可以应用于岛桥问题。设想你要在n个岛屿之间建造桥梁，想用最低的成本实现所有岛屿相互连通。</p><p>这两个问题都可以用MST算法来解决，其中的办公室或者岛屿可以表示为图中的一个顶点，边代表成本。这里我们有一个图的例子，其中较粗的边是一个MST的解决方案。</p><p><img src="/2019/03/08/cjvqhlsv5001frcvbcifjwrgr/Graph-16.png" alt="Dijkstra 算法示意图"></p><h3 id="6-1-Prim-算法"><a href="#6-1-Prim-算法" class="headerlink" title="6.1 Prim 算法"></a>6.1 Prim 算法</h3><p>Prim算法是一种求解加权无向连通图的MST问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p><p>现在，通过下面的代码来看看Prim算法是如何工作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.prim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = [],</span><br><span class="line">        key = [],</span><br><span class="line">        visited = [];</span><br><span class="line">        length = <span class="keyword">this</span>.graph.length,</span><br><span class="line">        i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        key[i] = INF;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">var</span> u = minKey(key, visited); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.graph[u][v] &amp;&amp; visited[v] == <span class="literal">false</span> &amp;&amp; <span class="keyword">this</span>.graph[u][v] &lt; key[v]) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            parent[v] = u; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            key[v] = <span class="keyword">this</span>.graph[u][v]; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是对算法过程的描述。</p><blockquote><p>行{1}：首先，把所有顶点（key）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），visited[]初始化为false。<br>行{2}：其次，选择第一个key作为第一个顶点，同时，因为第一个顶点总是MST的根节点，所以parent[0] = -1。<br>行{3}：然后，对所有顶点求MST。<br>行{4}：从未处理的顶点集合中选出key值最小的顶点（与Dijkstra算法中使用的函数一样，只是名字不同）。<br>行{5}：把选出的顶点标为visited，以免重复计算。<br>行{6}：如果得到更小的权值，则保存MST路径（parent，行{7}）并更新其权值（行{8}）。<br>行{9}：处理完所有顶点后，返回包含MST的结果。</p></blockquote><p>比较Prim算法和Dijkstra算法，我们会发现除了行{7}和行{8}之外，两者非常相似。行{7}用parent数组保存MST的结果。行{8}用key数组保存权值最小的边，而在Dijkstra算法中，用dist数组保存距离。我们可以修改Dijkstra算法，加入parent数组。这样，就可以在求出距离的同时得到路径。</p><p>对如下的图执行以上算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>]];</span><br></pre></td></tr></table></figure><p>我们会得到如下输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Edge Weight</span><br><span class="line"><span class="number">0</span> - <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> - <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> - <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> - <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> - <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="6-1-Kruskal-算法"><a href="#6-1-Kruskal-算法" class="headerlink" title="6.1 Kruskal 算法"></a>6.1 Kruskal 算法</h3><p>和Prim算法类似，Kruskal算法也是一种求加权无向连通图的MST的贪心算法。</p><p>现在，通过下面的代码来看看Kruskal算法是如何工作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.kruskal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="keyword">this</span>.graph.length,</span><br><span class="line">    parent = [], cost,</span><br><span class="line">    ne = <span class="number">0</span>, a, b, u, v, i, j, min;</span><br><span class="line">    cost = initializeCost(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (ne &lt; length<span class="number">-1</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, min = INF; i &lt; length; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class="line">                    min = cost[i][j];</span><br><span class="line">                    u = i;</span><br><span class="line">                    v = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u = find(u, parent); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        v = find(v, parent); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (union(u, v, parent)) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            ne++;</span><br><span class="line">        &#125;</span><br><span class="line">        cost[u][v] = cost[v][u] = INF; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对算法过程的描述。</p><blockquote><p>行{1}：首先，把邻接矩阵的值复制到cost数组，以方便修改且可以保留原始值行{7}。<br>行{2}：当MST的边数小于顶点总数减1时。<br>行{3}：找出权值最小的边。<br>行{4}和行{5}：检查MST中是否已存在这条边，以避免环路。<br>行{6}：如果u和v是不同的边，则将其加入MST。<br>行{7}：从列表中移除这些边，以免重复计算。<br>行{8}：返回MST。</p></blockquote><p>下面是find函数的定义。它能防止MST出现环路：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find = <span class="function"><span class="keyword">function</span>(<span class="params">i, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[i]) &#123;</span><br><span class="line">        i = parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>union函数的定义如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> union = <span class="function"><span class="keyword">function</span>(<span class="params">i, j, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">        parent[j] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个算法有几种变体。这取决于对边的权值排序时所使用的数据结构（如优先队列），以及图是如何表示的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、图的相关术语&quot;&gt;&lt;a href=&quot;#一、图的相关术语&quot; class=&quot;headerlink&quot; title=&quot;一、图的相关术语&quot;&gt;&lt;/a&gt;一、图的相关术语&lt;/h2&gt;&lt;p&gt;图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法八（树）</title>
    <link href="https://www.23ybob.club/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/"/>
    <id>https://www.23ybob.club/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/</id>
    <published>2019-02-28T08:08:07.000Z</published>
    <updated>2019-03-07T08:08:44.212Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们学习了一些顺序数据结构，学习的第一个非顺序数据结构是散列表。在节章，我们将要学习另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用。</p><h2 id="一、-树数据结构"><a href="#一、-树数据结构" class="headerlink" title="一、 树数据结构"></a>一、 树数据结构</h2><p>树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图，如下图所示：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-01.png" alt="树数据结构演示"></p><h2 id="二、-树的相关术语"><a href="#二、-树的相关术语" class="headerlink" title="二、 树的相关术语"></a>二、 树的相关术语</h2><p>一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-02.png" alt="树数据结构演示"></p><p>位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。</p><p>一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。</p><p>有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。</p><p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。</p><p>树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）。</p><h2 id="三、-二叉树和二叉搜索树"><a href="#三、-二叉树和二叉搜索树" class="headerlink" title="三、 二叉树和二叉搜索树"></a>三、 二叉树和二叉搜索树</h2><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。</p><p>二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。</p><p>二叉搜索树将是我们在本章中要研究的数据结构。</p><h3 id="3-1-创建-BinarySearchTree-类"><a href="#3-1-创建-BinarySearchTree-类" class="headerlink" title="3.1 创建 BinarySearchTree 类"></a>3.1 创建 BinarySearchTree 类</h3><p>让我们开始创建自己的BinarySearchTree类。首先，声明它的结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="literal">null</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展现了二叉搜索树数据结构的组织方式：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-03.png" alt="二叉搜索树数据结构演示"></p><p>和链表一样，将通过指针来表示节点之间的关系（术语称其为边）。在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树，使用同样的方式（也使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。因此，将声明一个Node类来表示树中的每个节点（行{1}）。值得注意的一个小细节是，不同于在之前的章节中将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼。</p><p>我们将会遵循和LinkedList类中相同的模式，这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是根元素（行{2}）</p><p>然后，我们需要实现一些方法。下面是将要在树类中实现的方法。</p><ul><li>insert(key)：向树中插入一个新的键。</li><li>search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。</li><li>inOrderTraverse：通过中序遍历方式遍历所有节点。</li><li>preOrderTraverse：通过先序遍历方式遍历所有节点。</li><li>postOrderTraverse：通过后序遍历方式遍历所有节点。</li><li>min：返回树中最小的值/键。</li><li>max：返回树中最大的值/键。</li><li>remove(key)：从树中移除某个键。</li></ul><h4 id="3-1-1-向树中插入一个键"><a href="#3-1-1-向树中插入一个键" class="headerlink" title="3.1.1 向树中插入一个键"></a>3.1.1 向树中插入一个键</h4><p>下面的代码是用来向树插入一个新键的算法的第一部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        root = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertNode(root, newNode); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要向树中插入一个新的节点（或项），要经历三个步骤。</p><p>第一步是创建用来表示新节点的Node类实例（行{1}）。只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针的值会由构造函数自动设置为null。</p><p>第二步要验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点（行{2}）。如果是，就将根节点指向新节点</p><p>第三步是将节点加在非根节点的其他位置。这种情况下，需要一个私有的辅助函数（行{3}），函数定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">            node.left = newNode; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insertNode(node.left, newNode); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">            node.right = newNode; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insertNode(node.right, newNode); <span class="comment">//&#123;10&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入树的根节点和要插入的节点。</li><li>如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}），那么需要检查当前节点的左侧子节点。如果它没有左侧子节点（行{5}），就在那里插入新的节点。</li><li>如果有左侧子节点，需要通过递归调用insertNode方法（行{7}）继续找到树的下一层。在这里，下次将要比较的节点将会是当前节点的左侧子节点。</li><li>如果节点的键比当前节点的键大，同时当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。如果有右侧子节点，同样需要递归调用insertNode方法，但是要用来和新节点比较的节点将会是右侧子节点。</li></ul><p>让我们通过一个例子来更好地理解这个过程。</p><p>考虑下面的情景：我们有一个新的树，并且想要向它插入第一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">tree.insert(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>这种情况下，树中有一个单独的节点，根指针将会指向它。源代码的行{2}将会执行。</p><p>现在，来考虑下图所示树结构的情况：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-04.png" alt="二叉搜索树数据结构演示"></p><p>创建上图所示的树的代码如下，它们接着上面一段代码（插入了键为11的节点）之后输入执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tree.insert(<span class="number">7</span>);</span><br><span class="line">tree.insert(<span class="number">15</span>);</span><br><span class="line">tree.insert(<span class="number">5</span>);</span><br><span class="line">tree.insert(<span class="number">3</span>);</span><br><span class="line">tree.insert(<span class="number">9</span>);</span><br><span class="line">tree.insert(<span class="number">8</span>);</span><br><span class="line">tree.insert(<span class="number">10</span>);</span><br><span class="line">tree.insert(<span class="number">13</span>);</span><br><span class="line">tree.insert(<span class="number">12</span>);</span><br><span class="line">tree.insert(<span class="number">14</span>);</span><br><span class="line">tree.insert(<span class="number">20</span>);</span><br><span class="line">tree.insert(<span class="number">18</span>);</span><br><span class="line">tree.insert(<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>同时我们想要插入一个值为6的键，执行下面的代码：</p><blockquote><p>tree.insert(6); </p></blockquote><p>下面的步骤将会被执行。</p><blockquote><ol><li>树不是空的，行{3}的代码将会执行。insertNode方法将会被调用（root, key[6]）。</li><li>算法将会检测行{4}（key[6] &lt; root[11]为真），并继续检测行{5}（node.left[7]不是null），然后将到达行{7}并调用insertNode（node.left[7], key[6]）。</li><li>将再次进入insertNode方法内部，但是使用了不同的参数。它会再次检测行{4}（key[6]&lt; node[7]为真），然后再检测行{5}（node.left[5]不是null），接着到达行{7}，调用insertNode（node.left[5], key[6]）。</li><li>将再一次进入insertNode方法内部。它会再次检测行{4}（key[6] &lt; node[5]为假），然后到达行{8}（node.right是null</li><li>然后，方法调用会依次出栈，代码执行过程结束</li></ol></blockquote><p>这是插入键6后的结果：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-05.png" alt="二叉搜索树数据结构演示"></p><h2 id="四、树的遍历"><a href="#四、树的遍历" class="headerlink" title="四、树的遍历"></a>四、树的遍历</h2><p>遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做呢？应该从树的顶端还是底端开始呢？从左开始还是从右开始呢？访问树的所有节点有三种方式：中序、先序和后序。</p><h3 id="4-1-中序遍历"><a href="#4-1-中序遍历" class="headerlink" title="4.1 中序遍历"></a>4.1 中序遍历</h3><p>中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。我们来看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    inOrderTraverseNode(root, callback); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>inOrderTraverse方法接收一个回调函数作为参数。回调函数用来定义我们对遍历到的每个节点进行的操作（这也叫作访问者模式，要了解更多关于访问者模式的信息，请参考<a href="http://en.wikipedia.org/wiki/Visitor_pattern）。由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Visitor_pattern）。由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123; <span class="comment">//&#123;2&#125; </span></span><br><span class="line">        inOrderTraverseNode(node.left, callback); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        callback(node.key); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        inOrderTraverseNode(node.right, callback); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为null（这就是停止递归继续执行的判断条件——行{2}——递归算法的基本条件）。</p><p>然后，递归调用相同的函数来访问左侧子节点（行{3}）。接着对这个节点进行一些操作（callback），然后再访问右侧子节点（行{5}）。</p><p>我们试着在之前展示的树上执行下面的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNode</span>(<span class="params">value</span>)</span>&#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">tree.inOrderTraverse(printNode); <span class="comment">//&#123;7&#125;</span></span><br></pre></td></tr></table></figure><p>但首先，需要创建一个回调函数（行{6}）。我们要做的，是在浏览器的控制台上输出节点的值。然后，调用inOrderTraverse方法并将回调函数作为参数传入（行{7}）。当执行上面的代码后，下面的结果将会在控制台上输出（每个数字将会输出在不同的行）：</p><blockquote><p>3 5 6 7 8 9 10 11 12 13 14 15 18 20 25 </p></blockquote><p>完整案例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 BinarySearchTree 类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="literal">null</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的辅助函数</span></span><br><span class="line">    <span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newNode.key &lt; node.key) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">                node.left = newNode; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                insertNode(node.left, newNode); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">                node.right = newNode; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                insertNode(node.right, newNode); <span class="comment">//&#123;10&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert向树中插入一个键</span></span><br><span class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insertNode(root, newNode); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//inOrderTraverse中序遍历</span></span><br><span class="line">    <span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(callback)</span></span><br><span class="line">        inOrderTraverseNode(root, callback); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123; <span class="comment">//&#123;2&#125; </span></span><br><span class="line">            inOrderTraverseNode(node.left, callback); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            callback(node.key); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            inOrderTraverseNode(node.right, callback); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tree.inOrderTraverse(printNode); //&#123;7&#125; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> binarySearchTree = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNode</span>(<span class="params">value</span>) </span>&#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">binarySearchTree.insert(<span class="number">7</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">15</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">5</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">3</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">9</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">8</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">10</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">13</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">12</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">14</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">20</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">18</span>);</span><br><span class="line">binarySearchTree.insert(<span class="number">25</span>); </span><br><span class="line">binarySearchTree.insert(<span class="number">6</span>); </span><br><span class="line">binarySearchTree.inOrderTraverse(printNode)</span><br></pre></td></tr></table></figure><p>下面的图描绘了inOrderTraverse方法的访问路径：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-06.png" alt="中序遍历示例图"></p><h3 id="4-2-先序遍历"><a href="#4-2-先序遍历" class="headerlink" title="4.2 先序遍历"></a>4.2 先序遍历</h3><p>先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。</p><p>我们来看实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    preOrderTraverseNode(root, callback);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//preOrderTraverseNode方法的实现如下：</span></span><br><span class="line"><span class="keyword">var</span> preOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        callback(node.key); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        preOrderTraverseNode(node.left, callback); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        preOrderTraverseNode(node.right, callback); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先序遍历和中序遍历的不同点是，先序遍历会先访问节点本身（行{1}），然后再访问它的左侧子节点（行{2}），最后是右侧子节点（行{3}），而中序遍历的执行顺序是：{2}、{1}和{3}。</p><p>下面是控制台上的输出结果（每个数字将会输出在不同的行）：</p><blockquote><p>11 7 5 3 6 9 8 10 15 13 12 14 20 18 25</p></blockquote><p>下面的图描绘了preOrderTraverse方法的访问路径：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-07.png" alt="先序遍历示例图"></p><h3 id="4-3-后序遍历"><a href="#4-3-后序遍历" class="headerlink" title="4.3 后序遍历"></a>4.3 后序遍历</h3><p>后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。</p><p>我们来看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.postOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    postOrderTraverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//postOrderTraverseNode方法的实现如下：</span></span><br><span class="line"><span class="keyword">var</span> postOrderTraverseNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        postOrderTraverseNode(node.left, callback); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        postOrderTraverseNode(node.right, callback); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        callback(node.key); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子中，后序遍历会先访问左侧子节点（行{1}），然后是右侧子节点（行{2}），最后是父节点本身（行{3}）。</p><p>你会发现，中序、先序和后序遍历的实现方式是很相似的，唯一不同的是行{1}、{2}和{3}的执行顺序。</p><p>下面是控制台的输出结果（每个数字将会输出在不同行）：</p><blockquote><p>3 6 5 8 10 9 7 12 14 13 18 25 20 15 11</p></blockquote><p>下面的图描绘了postOrderTraverse方法的访问路径：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-08.png" alt="后序遍历示例图"></p><h2 id="五、搜索树中的值"><a href="#五、搜索树中的值" class="headerlink" title="五、搜索树中的值"></a>五、搜索树中的值</h2><p>在树中，有三种经常执行的搜索类型：</p><blockquote><p>搜索最小值<br>搜索最大值<br>搜索特定的值</p></blockquote><h3 id="5-1-搜索最小值和最大值"><a href="#5-1-搜索最小值和最大值" class="headerlink" title="5.1 搜索最小值和最大值"></a>5.1 搜索最小值和最大值</h3><p>我们使用下面的树作为示例：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-09.png" alt="树"></p><p>只用眼睛看这张图，你能一下找到树中的最小值和最大值吗？</p><p>如果你看一眼树最后一层最左侧的节点，会发现它的值为3，这是这棵树中最小的键。如果你再看一眼树最右端的节点（同样是树的最后一层），会发现它的值为25，这是这棵树中最大的键。这条信息在我们实现搜索树节点的最小值和最大值的方法时能给予我们很大的帮助。</p><p>首先，我们来看寻找树的最小键的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minNode(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>min方法将会暴露给用户。这个方法调用了minNode方法（行{1}）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="keyword">while</span>(node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>minNode方法允许我们从树中任意一个节点开始寻找最小的键。我们可以使用它来找到一棵树或它的子树中最小的键。因此，我们在调用minNode方法的时候传入树的根节点（行{1}），因为我们想要找到整棵树的最小键。</p><p>在minNode内部，我们会遍历树的左边（行{2}和行{3}）直到找到树的最下层（最左端）。</p><p>以相似的方式，可以实现max方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxNode(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maxNode方法实现</span></span><br><span class="line"><span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="keyword">while</span>(node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要找到最大的键，我们要沿着树的右边进行遍历（行{5}）直到找到最右端的节点。</p><p>因此，对于寻找最小值，总是沿着树的左边；而对于寻找最大值，总是沿着树的右边。</p><h3 id="5-2-搜索一个特定的值"><a href="#5-2-搜索一个特定的值" class="headerlink" title="5.2 搜索一个特定的值"></a>5.2 搜索一个特定的值</h3><p>在之前的学习中，我们同样实现了find、search或get方法来查找数据结构中的一个特定的值（和之前实现的has方法相似）。我们将同样在BST中实现搜索的方法，来看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchNode(root, key); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">return</span> searchNode(node.left, key); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">return</span> searchNode(node.right, key); <span class="comment">//&#123;6&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们要做的第一件事，是声明search方法。和BST中声明的其他方法的模式相同，我们将会使用一个辅助函数（行{1}）。</p><p>searchNode方法可以用来寻找一棵树或它的任意子树中的一个特定的值。这也是为什么在行{1}中调用它的时候传入树的根节点作为参数。</p><p>在开始算法之前，先要验证作为参数传入的node是否合法（不是null）。如果是null的话，说明要找的键没有找到，返回false。</p><p>如果传入的节点不是null，需要继续验证。如果要找的键比当前的节点小（行{3}），那么继续在左侧的子树上搜索（行{4}）。如果要找的键比当前的节点大，那么就从右侧子节点开始继续搜索（行{6}），否则就说明要找的键和当前节点的键相等，就返回true来表示找到了这个键（行{7}）。</p><p>可以通过下面的代码来测试这个方法：</p><blockquote><p>console.log(binarySearchTree.search(1) ? ‘Key 1 found.’ : ‘Key 1 not found.’);<br>console.log(binarySearchTree.search(8) ? ‘Key 8 found.’ : ‘Key 8 not found.’); </p></blockquote><p>输出结果如下：</p><blockquote><p>Value 1 not found.<br>Value 8 found. </p></blockquote><p>让我们详细展示查找1这个键的时候方法是如何执行的。</p><blockquote><p>(1) 调用searchNode方法，传入根节点作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们执行到行{3}。<br>(2) （key[1] &lt; node[11]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[7], key[1]）作为参数。<br>(3) （node[7]）不是null（{2}），因此继续执行行{3}。<br>(4) （key[1] &lt; node[7]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[5], key[1]）作为参数。<br>(5) （node[5]）不是null（行{2}），因此继续执行行{3}。<br>(6) （key[1] &lt; node[5]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[3], key[1]）作为参数。<br>(7) （node[3]）不是null（行{2}），因此来到行{3}。<br>(8) （key[1] &lt; node[3]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（null, key[1]）作为参数。null被作为参数传入是因为node[3]是一个叶节点（它没有子节点，所以它的左侧子节点的值为null）。<br>(9) 节点（null）的值为null（行{2}，这时要搜索的节点为null），因此返回false。<br>(10) 然后，方法调用会依次出栈，代码执行过程结束。</p></blockquote><p>让我们再来查找值为8的节点。</p><blockquote><p>(1) 调用searchNode方法，传入root作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们来到行{3}。<br>(2) （key[8] &lt; node[11]）为真（行{3}），因此执行到行{4}并再次调用searchNode方法，传入（node[7], key[8]）作为参数。<br>(3) （node[7]）不是null，因此来到行{3}。<br>(4) （key[8] &lt; node[7]）为假（行{3}），因此来到行{5}。<br>(5) （key[8] &gt; node[7]）为真（行{5}），因此来到行{6}并再次调用searchNode方法，传入（node[9], key[8]）作为参数。<br>(6) （node[9]）不是null（行{2}），因此来到行{3}。<br>(7) （key[8] &lt; node[9]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[8], key[8]）作为参数。<br>(8) （node[8]）不是null（行{2}），因此来到行{3}。<br>(9) （key[8] &lt; node[8]）为假（行{3}），因此来到行{5}。<br>(10)（key[8] &gt; node[8]）为假（行{5}），因此来到行{7}并返回true，因为node[8]就是要找的键。<br>(11) 然后，方法调用会依次出栈，代码执行过程结束。</p></blockquote><h3 id="5-3-移除一个节点"><a href="#5-3-移除一个节点" class="headerlink" title="5.3 移除一个节点"></a>5.3 移除一个节点</h3><p>我们要为BST实现的下一个、也是最后一个方法是remove方法。这是我们在本书中要实现的最复杂的方法。我们先创建这个方法，使它能够在树的实例上被调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123; </span><br><span class="line">    root = removeNode(root, key); <span class="comment">//&#123;1&#125; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法接收要移除的键并且它调用了removeNode方法，传入root和要移除的键作为参数（行{1}）。我要提醒大家的一件非常重要的事情是，root被赋值为removeNode方法的返回值。我们稍后会明白其中的原因。</p><p>removeNode方法的复杂之处在于我们要处理不同的运行场景，当然也包括它同样是通过递归来实现的。</p><p>我们来看removeNode方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    root = removeNode(root, key); <span class="comment">//&#123;1&#125; </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> removeNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        node.left = removeNode(node.left, key); <span class="comment">//&#123;4&#125; </span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">        node.right = removeNode(node.right, key); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//键等于node.key</span></span><br><span class="line">        <span class="comment">//第一种情况——一个叶节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">            node = <span class="literal">null</span>; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种情况——一个只有一个子节点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">            node = node.right; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">//&#123;14&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123; <span class="comment">//&#123;15&#125;</span></span><br><span class="line">            node = node.left; <span class="comment">//&#123;16&#125;</span></span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">//&#123;17&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三种情况——一个有两个子节点的节点</span></span><br><span class="line">        <span class="keyword">var</span> aux = findMinNode(node.right); <span class="comment">//&#123;18&#125;</span></span><br><span class="line">        node.key = aux.key; <span class="comment">//&#123;19&#125;</span></span><br><span class="line">        node.right = removeNode(node.right, aux.key); <span class="comment">//&#123;20&#125;</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">//&#123;21&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> findMinNode = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看行{2}，如果正在检测的节点是null，那么说明键不存在于树中，所以返回null。</p><p>然后，我们要做的第一件事，就是在树中找到要移除的节点。因此，如果要找的键比当前节点的值小（行{3}），就沿着树的左边找到下一个节点（行{4}）。如果要找的键比当前节点的值大（行{6}），那么就沿着树的右边找到下一个节点（行{7}）。</p><p>如果我们找到了要找的键（键和node.key相等），就需要处理三种不同的情况。</p><h4 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5.3.1"></a>5.3.1</h4><p>第一种情况是该节点是一个没有左侧或右侧子节点的叶节点——行{9}。在这种情况下，我们要做的就是给这个节点赋予null值来移除它（行{9}）。但是当学习了链表的实现之后，我们知道仅仅赋一个null值是不够的，还需要处理指针。在这里，这个节点没有任何子节点，但是它有一个父节点，需要通过返回null来将对应的父节点指针赋予null值（行{11}）。</p><p>现在节点的值已经是null了，父节点指向它的指针也会接收到这个值，这也是我们要在函数中返回节点的值的原因。父节点总是会接收到函数的返回值。另一种可行的办法是将父节点和节点本身都作为参数传入方法内部。</p><p>如果回头来看方法的第一行代码，会发现我们在行{4}和行{7}更新了节点左右指针的值，同样也在行{5}和行{8}返回了更新后的节点。</p><p>下图展现了移除一个叶节点的过程：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-10.png" alt="移除一个叶节点示意图"></p><h4 id="5-3-2-移除有一个左侧或右侧子节点的节点"><a href="#5-3-2-移除有一个左侧或右侧子节点的节点" class="headerlink" title="5.3.2 移除有一个左侧或右侧子节点的节点"></a>5.3.2 移除有一个左侧或右侧子节点的节点</h4><p>现在我们来看第二种情况，移除有一个左侧子节点或右侧子节点的节点。这种情况下，需要跳过这个节点，直接将父节点指向它的指针指向子节点。如果这个节点没有左侧子节点（行{12}），也就是说它有一个右侧子节点。因此我们把对它的引用改为对它右侧子节点的引用（行{13}）并返回更新后的节点（行{14}）。如果这个节点没有右侧子节点，也是一样——把对它的引用改为对它左侧子节点的引用（行{16}）并返回更新后的值（行{17}）。</p><p>下图展现了移除只有一个左侧子节点或右侧子节点的节点的过程：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-11.png" alt="移除有一个左侧或右侧子节点的节点示意图"></p><h4 id="5-3-3-移除有两个子节点的节点"><a href="#5-3-3-移除有两个子节点的节点" class="headerlink" title="5.3.3 移除有两个子节点的节点"></a>5.3.3 移除有两个子节点的节点</h4><p>现在是第三种情况，也是最复杂的情况，那就是要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。</p><blockquote><p>(1) 当找到了需要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。<br>(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们改变了这个节点的键，也就是说它被移除了。<br>(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。<br>(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。</p></blockquote><p>findMinNode方法的实现和min方法的实现方式是一样的。唯一不同之处在于，在min方法中只返回键，而在findMinNode中返回了节点。</p><p>下图展现了移除有两个子节点的节点的过程：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-12.png" alt="移除有两个子节点的节点示意图"></p><h2 id="六、-自平衡树"><a href="#六、-自平衡树" class="headerlink" title="六、 自平衡树"></a>六、 自平衡树</h2><p>BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层，如下图所示：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-13.png" alt="自平衡树示意图"></p><p>这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作Adelson-Velskii-Landi树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树。</p><h3 id="6-1-Adelson-Velskii-Landi-树（AVL-树）"><a href="#6-1-Adelson-Velskii-Landi-树（AVL-树）" class="headerlink" title="6.1 Adelson-Velskii-Landi 树（AVL 树）"></a>6.1 Adelson-Velskii-Landi 树（AVL 树）</h3><p>AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1。添加或移除节点时，AVL树会尽可能尝试转换为完全树。</p><h4 id="6-1-1-在AVL树中插入节点"><a href="#6-1-1-在AVL树中插入节点" class="headerlink" title="6.1.1 在AVL树中插入节点"></a>6.1.1 在AVL树中插入节点</h4><p>在AVL树中插入或移除节点和BST完全相同。然而，AVL树的不同之处在于我们需要检验它的平衡因子，如果有需要，则将其逻辑应用于树的自平衡。</p><p>下面的代码是向AVL树插入新节点的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &lt; node.key) &#123;</span><br><span class="line">        node.left = insertNode(node.left, element);</span><br><span class="line">        <span class="keyword">if</span> (node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 确认是否需要平衡 &#123;1&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; node.key) &#123;</span><br><span class="line">        node.right = insertNode(node.right, element);</span><br><span class="line">        <span class="keyword">if</span> (node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 确认是否需要平衡 &#123;2&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而，插入新节点时，还要检查是否需要平衡树（行{1}和行{2}）</p><ol><li>计算平衡因子</li></ol><p>在AVL树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）的差值，该值（hr－hl）应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。这就是平衡因子的概念。</p><p>下图举例说明了一些树的平衡因子（所有的树都是平衡的）：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-14.png" alt="平衡因子示意图"></p><p>计算节点高度的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> heightNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(heightNode(node.left),heightNode(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，向左子树插入新节点时，需要计算其高度；如果高度大于1（即不为-1、0和1之一），就需要平衡左子树。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换insertNode方法的行&#123;1&#125;</span></span><br><span class="line"><span class="keyword">if</span> ((heightNode(node.left) - heightNode(node.right)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 旋转 &#123;3&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向右子树插入新节点时，应用同样的逻辑，代码如下：</span></span><br><span class="line"><span class="comment">// 替换insertNode方法的行&#123;2&#125;</span></span><br><span class="line"><span class="keyword">if</span> ((heightNode(node.right) - heightNode(node.left)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 旋转 &#123;4&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>AVL旋转</li></ol><p>向AVL树插入节点时，可以执行单旋转或双旋转两种平衡操作，分别对应四种场景。</p><blockquote><p>右-右（RR）：向左的单旋转<br>左-左（LL）：向右的单旋转<br>左-右（LR）：向右的双旋转<br>右-左（RL）：向左的双旋转</p></blockquote><p>我们依次看看它们是如何工作的。</p><ul><li>右-右（RR）：向左的单旋转</li></ul><p>如下图所示：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-15.png" alt="向左的单旋转示意图"></p><p>假设向AVL树插入节点90，这会造成树失衡（节点50-Y高度为-2），因此需要恢复树的平衡。下面是我们执行的操作：</p><blockquote><p>与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为-2）所在的位置（行{1}）；<br>节点X的右子树保持不变；<br>将节点Y的右子节点置为节点X的左子节点Z（行{2}）；<br>将节点X的左子节点置为节点Y（行{3}）。</p></blockquote><p>下面的代码举例说明了整个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotationRR = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = node.right; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    node.right = tmp.left; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    tmp.left = node; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>左-左（LL）：向右的单旋转</li></ul><p>如下图所示：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-16.png" alt="向右的单旋转示意图"></p><p>假设向AVL树插入节点5，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作：</p><blockquote><p>与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为+2）所在的位置（行{1}）；<br>节点X的左子树保持不变；<br>将节点Y的左子节点置为节点X的右子节点Z（行{2}）；<br>将节点X的右子节点置为节点Y（行{3}）。</p></blockquote><p>下面的代码举例说明了整个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotationLL = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = node.left; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    node.left = tmp.right; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    tmp.right = node; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>左-右（LR）：向右的双旋转</li></ul><p>如下图所示：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-17.png" alt="向右的单旋转示意图"></p><p>假设向AVL树插入节点35，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作：</p><blockquote><p>将节点X置于节点Y（平衡因子为+2）所在的位置；<br>将节点Y的左子节点置为节点X的右子节点；<br>将节点Z的右子节点置为节点X的左子节点；<br>将节点X的右子节点置为节点Y；<br>将节点X的左子节点置为节点Z。</p></blockquote><p>基本上，就是先做一次RR旋转，再做一次LL旋转</p><p>下面的代码举例说明了整个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotationLR = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.left = rotationRR(node.left);</span><br><span class="line">    <span class="keyword">return</span> rotationLL(node);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>右-左（RL）：向左的双旋转</li></ul><p>如下图所示：</p><p><img src="/2019/02/28/cjvqhlsv4001ercvbg1ztnq6k/BinarySearchTree-18.png" alt="向右的单旋转示意图"></p><p>假设向AVL树插入节点75，这会造成树失衡（节点70-Y高度为-2），需要恢复树的平衡。下面是我们执行的操作：</p><blockquote><p>将节点X置于节点Y（平衡因子为-2）所在的位置；<br>将节点Z的左子节点置为节点X的右子节点；<br>将节点Y的右子节点置为节点X的左子节点；<br>将节点X的左子节点置为节点Y；<br>将节点X的右子节点置为节点Z。</p></blockquote><p>基本上，就是先做一次LL旋转，再做一次RR旋转</p><p>下面的代码举例说明了整个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotationRL = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.right = rotationLL(node.right);</span><br><span class="line">    <span class="keyword">return</span> rotationRR(node);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>完成insertNode方法</li></ol><p>确认树需要平衡后，就需要对每种情况分别应用正确的旋转。</p><p>向左子树插入新节点，且节点的值小于其左子节点时，应进行LL旋转。否则，进行LR旋转。该过程的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换insertNode方法的行&#123;1&#125;</span></span><br><span class="line"><span class="keyword">if</span> ((heightNode(node.left) - heightNode(node.right)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 旋转 &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (element &lt; node.left.key)&#123;</span><br><span class="line">        node = rotationLL(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node = rotationLR(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向右子树插入新节点，且节点的值大于其右子节点时，应进行RR旋转。否则，进行RL旋转。该过程的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换insertNode方法的行&#123;2&#125;</span></span><br><span class="line"><span class="keyword">if</span> ((heightNode(node.right) - heightNode(node.left)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 旋转 &#123;4&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (element &gt; node.right.key)&#123;</span><br><span class="line">        node = rotationRR(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node = rotationRL(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、-小结"><a href="#七、-小结" class="headerlink" title="七、 小结"></a>七、 小结</h2><p>在本节中，我们学习了在计算机科学中被广泛使用的基本树数据结构——二叉搜索树中添加、搜索和移除项的算法。我们同样介绍了访问树中每个节点的三种遍历方式。此外还学习了如<br>何开发名叫AVL的自平衡树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到目前为止，我们学习了一些顺序数据结构，学习的第一个非顺序数据结构是散列表。在节章，我们将要学习另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用。&lt;/p&gt;
&lt;h2 id=&quot;一、-树数据结构&quot;&gt;&lt;a href=&quot;#一、-树数据结构&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法七（字典和散列表）</title>
    <link href="https://www.23ybob.club/2019/01/18/cjvqhlsuq0018rcvbwrh1y8py/"/>
    <id>https://www.23ybob.club/2019/01/18/cjvqhlsuq0018rcvbwrh1y8py/</id>
    <published>2019-01-18T11:40:59.000Z</published>
    <updated>2019-03-04T09:22:04.052Z</updated>
    
    <content type="html"><![CDATA[<p>字典和散也是用来存储唯一值（不重复的值）的数据结构。</p><p>集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。</p><h2 id="一、-字典"><a href="#一、-字典" class="headerlink" title="一、 字典"></a>一、 字典</h2><p>前面已经学习过，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。</p><h3 id="1-1-创建字典"><a href="#1-1-创建字典" class="headerlink" title="1.1 创建字典"></a>1.1 创建字典</h3><p>首先创建Dictionary类的骨架：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Set类类似，我们将在一个Object的实例而不是数组中存储元素。然后，我们需要声明一些映射/字典所能使用的方法。</p><blockquote><p>set(key,value)：向字典中添加新元素。<br>delete(key)：通过使用键值来从字典中移除键值对应的数据值。<br>has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。<br>get(key)：通过键值查找特定的数值并返回。<br>clear()：将这个字典中的所有元素全部删除。<br>size()：返回字典所包含元素的数量。与数组的length属性类似。<br>keys()：将字典所包含的所有键名以数组形式返回。<br>values()：将字典所包含的所有数值以数组形式返回。</p></blockquote><h4 id="1-1-1-has-和-set-方法"><a href="#1-1-1-has-和-set-方法" class="headerlink" title="1.1.1 has 和 set 方法"></a>1.1.1 has 和 set 方法</h4><p>我们首先来实现has(key)方法。之所以要先实现这个方法，是因为它会被set和remove等其他方法调用。我们可以通过如下代码来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> items;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法的实现和我们之前在Set类中的实现是一样的。我们使用JavaScript中的in操作符来验证一个key是否是items对象的一个属性。</p><p>然后是set方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    items[key] = value; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法接受一个key和一个value作为参数。我们直接将value设为items对象的key属性的值。它可以用来给字典添加一个新的值，或者用来更新一个已有的值。</p><h4 id="1-1-2-delete方法"><a href="#1-1-2-delete方法" class="headerlink" title="1.1.2 delete方法"></a>1.1.2 delete方法</h4><p>接下来，我们实现delete方法。它和Set类中的delete方法很相似，唯一的不同点在于我们将先搜索key（而不是value）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.delete= <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> items[key];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们可以使用JavaScript的delete操作符来从items对象中移除key属性。</p><h4 id="1-1-3-get和values方法"><a href="#1-1-3-get和values方法" class="headerlink" title="1.1.3 get和values方法"></a>1.1.3 get和values方法</h4><p>如果我们想在字典中查找一个特定的项，并检索它的值，可以使用下面的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>get方法首先会验证我们想要检索的值是否存在（通过查找key值），如果存在，将返回该值，反之将返回一个undefined值（请记住undefined值和null值是不一样的</p><p>下一个是values方法。这个方法以数组的形式返回字典中所有values实例的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> items) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">            values.push(items[key]) <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们遍历items对象的所有属性值（行{1}）。为了确定值存在，我们使用has函数来验证key确实存在，然后将它的值加入values数组（行{2}）。最后，我们就能返回所有找到的值。</p><p>我们不能仅仅使用for-in语句来遍历items对象的所有属性，还需要使用hasOwnProperty方法（验证items对象是否包含某个属性），因为对象的原型也会包含对象的其他属性（JavaScript基本的Object类中的属性将会被继承，并存在于当前对象中，而对于这个数据结构来说，我们并不需要它们）。</p><h4 id="1-1-4-clear、size、keys和getItems方法"><a href="#1-1-4-clear、size、keys和getItems方法" class="headerlink" title="1.1.4 clear、size、keys和getItems方法"></a>1.1.4 clear、size、keys和getItems方法</h4><p>clear和size 方法与前面介绍的Set类中对应的方法是完全一样的。</p><p>keys方法返回在Dictionary类中所有用于标识值的键名。要取出一个JavaScript对象中所有的键名，可以把这个对象作为参数传入Object类的keys方法（到目前为止，书中创建的类，包括Dictionary在内，都是JavaScript对象），如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object.keys(items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们来验证items属性的输出值。我们可以实现一个返回items变量的方法，叫作getItems：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getItems = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-5-使用Dictionary"><a href="#1-1-5-使用Dictionary" class="headerlink" title="1.1.5 使用Dictionary"></a>1.1.5 使用Dictionary</h4><p>首先，我们来创建一个Dictionary类的实例，然后给它添加三条电子邮件地址。我们将会使用这个dictionary实例来实现一个电子邮件地址簿。</p><p>使用我们创建的类来执行如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> Dictionary();</span><br><span class="line">dictionary.set(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">dictionary.set(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">dictionary.set(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br></pre></td></tr></table></figure><p>如果执行了如下代码，输出结果将会是true：</p><blockquote><p>console.log(dictionary.has(‘Gandalf’)); </p></blockquote><p>下面的代码将会输出3，因为我们向字典实例中添加了三个元素：</p><blockquote><p>console.log(dictionary.size()); </p></blockquote><p>现在，执行下面的几行代码：</p><blockquote><p>console.log(dictionary.keys());<br>console.log(dictionary.values());<br>console.log(dictionary.get(‘Tyrion’)); </p></blockquote><p>输出结果分别如下所示：</p><blockquote><p>[“Gandalf”, “John”, “Tyrion”]<br>[“<a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a>“, “<a href="mailto:johnsnow@email.com" target="_blank" rel="noopener">johnsnow@email.com</a>“, “<a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a>“]<br><a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a> </p></blockquote><p>最后，再执行几行代码：</p><blockquote><p>dictionary.delete(‘John’);</p></blockquote><p>再执行下面的代码：</p><blockquote><p>console.log(dictionary.keys());<br>console.log(dictionary.values());<br>console.log(dictionary.getItems());</p></blockquote><p>输出结果如下所示：</p><blockquote><p>[“Gandalf”, “Tyrion”]<br>[“<a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a>“, “<a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a>“]<br>Object {Gandalf: “<a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a>“, Tyrion:”<a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a>“}</p></blockquote><p>移除了一个元素后，现在的dictionary实例中只包含两个元素了。</p><h2 id="二、-散列表"><a href="#二、-散列表" class="headerlink" title="二、 散列表"></a>二、 散列表</h2><p>接下来我们会学到HashTable类，也叫HashMap类，它是Dictionary类的一种散列表实现方式。</p><p>散列算法的作用是尽可能快地在数据结构中找到一个值。在前面我们已经知道如果要在数据结构中获得一个值（使用get方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址</p><p>举个例子，我们继续使用字典中的案例使用电子邮件地址簿。我们将要使用最常见的散列函数——“lose lose”散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。</p><p><img src="/2019/01/18/cjvqhlsuq0018rcvbwrh1y8py/hashTable-01.png" alt="“lose lose”函数示例"></p><h3 id="2-1-创建散列表"><a href="#2-1-创建散列表" class="headerlink" title="2.1 创建散列表"></a>2.1 创建散列表</h3><p>我们将使用数组来表示我们的数据结构，该数据结构的图表（“lose lose”）所用的非常相似。</p><p>和之前一样，我们从搭建类的骨架开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> table = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，给类添加一些方法。我们给每个类实现三个基本方法</p><blockquote><p>put(key,value)：向散列表增加一个新的项（也能更新散列表）。<br>remove(key)：根据键值从散列表中移除值。<br>get(key)：返回根据键值检索到的特定的值。</p></blockquote><p>在实现这三个方法之前，要实现的第一个方法是散列函数，它是HashTable类中的一个私有方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loseloseHashCode = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">0</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        hash += key.charCodeAt(i); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">37</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给定一个key参数，我们就能根据组成key的每个字符的ASCII码值的和得到一个数字。所以，首先需要一个变量来存储这个总和（行{1}）。然后，遍历key（行{2}）并将从ASCII表中查到的每个字符对应的ASCII值加到hash变量中（可以使用JavaScript的String类中的charCodeAt方法——行{3}）。最后，返回hash值。为了得到比较小的数值，我们会使用hash值和一个任意数做除法的余数（mod）。</p><p>现在，有了散列函数，我们就可以实现put方法了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(position + <span class="string">' - '</span> + key); <span class="comment">//&#123;6&#125;</span></span><br><span class="line">    table[position] = value; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，根据给定的key，我们需要根据所创建的散列函数计算出它在表中的位置（行{5}）。为了便于展示信息，我们将计算出的位置输出至控制台（行{6}）。由于它不是必需的，我们也可以将这行代码移除。然后要做的，是将value参数添加到用散列函数计算出的对应的位置上。（行{7}）。</p><p>从HashTable实例中查找一个值也很简单。为此，我们将会实现一个get方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> table[loseloseHashCode(key)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，我们会使用所创建的散列函数来求出给定key所对应的位置。这个函数会返回值的位置，因此我们所要做的就是根据这个位置从数组table中获得这个值。</p><p>我们要实现的最后一个方法是remove方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    table[loseloseHashCode(key)] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要从HashTable实例中移除一个元素，只需要求出元素的位置（可以使用散列函数来获取）并赋值为undefined。</p><p>对于HashTable类来说，我们不需要像ArrayList类一样从table数组中将位置也移除。由于元素分布于整个数组范围内，一些位置会没有任何元素占据，并默认为undefined值。我们也不能将位置本身从数组中移除（这会改变其他元素的位置），否则，当下次需要获得或移除一个元素的时候，这个元素会不在我们用散列函数求出的位置上。</p><h3 id="2-2-使用-HashTable-类"><a href="#2-2-使用-HashTable-类" class="headerlink" title="2.2 使用 HashTable 类"></a>2.2 使用 HashTable 类</h3><p>让我们执行一些代码来测试HashTable类:</p><blockquote><p>var hash = new HashTable();<br>hash.put(‘Gandalf’, <a href="mailto:&#39;gandalf@email.com" target="_blank" rel="noopener">&#39;gandalf@email.com</a>‘);<br>hash.put(‘John’, <a href="mailto:&#39;johnsnow@email.com" target="_blank" rel="noopener">&#39;johnsnow@email.com</a>‘);<br>hash.put(‘Tyrion’, <a href="mailto:&#39;tyrion@email.com" target="_blank" rel="noopener">&#39;tyrion@email.com</a>‘); </p></blockquote><p>执行上述代码，会在控制台中获得如下输出：</p><blockquote><p>19 - Gandalf<br>29 - John<br>16 - Tyrion </p></blockquote><p>下面的图表展现了包含这三个元素的HashTable数据结构：</p><p><img src="/2019/01/18/cjvqhlsuq0018rcvbwrh1y8py/hashTable-02.png" alt="HashTable数据结构展示"></p><p>现在来测试get方法：</p><blockquote><p>console.log(hash.get(‘Gandalf’));<br>console.log(hash.get(‘Loiane’)); </p></blockquote><p>获得如下的输出：</p><blockquote><p><a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a><br>undefined </p></blockquote><p>由于Gandalf是一个在散列表中存在的键，get方法将会返回它的值。而由于Loiane是一个不存在的键，当我们试图在数组中根据位置获取值的时候（一个由散列函数生成的位置），返回值将会是undefined（即不存在）。</p><p>然后，我们试试从散列表中移除Gandalf：</p><blockquote><p>hash.remove(‘Gandalf’);<br>console.log(hash.get(‘Gandalf’)); </p></blockquote><p>由于Gandalf不再存在于表中，hash.get(‘Gandalf’)方法将会在控制台上给出undefined的输出结果。</p><h3 id="2-3-散列表和散列集合"><a href="#2-3-散列表和散列集合" class="headerlink" title="2.3 散列表和散列集合"></a>2.3 散列表和散列集合</h3><p>散列表和散列映射是一样的，我们学习过这种数据结构了。</p><p>在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是散列函数。我们可以重用本章实现HashTable的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。</p><h3 id="2-4-处理散列表中的冲突"><a href="#2-4-处理散列表中的冲突" class="headerlink" title="2.4 处理散列表中的冲突"></a>2.4 处理散列表中的冲突</h3><p>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。例如，我们看看下面的代码会得到怎样的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> HashTable();</span><br><span class="line">hash.put(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Aaron'</span>, <span class="string">'aaron@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Donnie'</span>, <span class="string">'donnie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Ana'</span>, <span class="string">'ana@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jonathan'</span>, <span class="string">'jonathan@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jamie'</span>, <span class="string">'jamie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Sue'</span>, <span class="string">'sue@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Mindy'</span>, <span class="string">'mindy@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Paul'</span>, <span class="string">'paul@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Nathan'</span>, <span class="string">'nathan@email.com'</span>);</span><br></pre></td></tr></table></figure><p>注意，Tyrion和Aaron有相同的散列值（16）。Donnie和Ana有相同的散列值（13），Jonathan、Jamie和Sue有相同的散列值（5），Mindy和Paul也有相同的散列值（32）。</p><p>那HashTable实例会怎样呢？执行之前的代码后散列表中会有哪些值呢？</p><p>为了获得结果，我们来实现一个叫作print的辅助方法，它会在控制台上输出HashTable中的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; ++i) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (table[i] !== <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="built_in">console</span>.log(i + <span class="string">": "</span> + table[i]);<span class="comment">//&#123;3&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在来使用这个方法：</p><blockquote><p>hash.print(); </p></blockquote><p>在控制台上得到如下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>: sue              @email.com</span><br><span class="line"><span class="number">10</span>: nathan@email.com</span><br><span class="line"><span class="number">13</span>: ana@email.com</span><br><span class="line"><span class="number">16</span>: aaron@email.com</span><br><span class="line"><span class="number">19</span>: gandalf@email.com</span><br><span class="line"><span class="number">29</span>: johnsnow@email.com</span><br><span class="line"><span class="number">32</span>: paul@email.com</span><br></pre></td></tr></table></figure><p>Jonathan、Jamie和Sue有相同的散列值，也就是5。由于Sue是最后一个被添加的，Sue将是在HashTable实例中占据位置5的元素。首先，Jonathan会占据这个位置，然后Jamie会覆<br>盖它，然后Sue会再次覆盖。这对于其他发生冲突的元素来说也是一样的。</p><p>使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接、线性探查和双散列法。在本节中，我们会介绍前两种方法。</p><h4 id="2-4-1-分离链接"><a href="#2-4-1-分离链接" class="headerlink" title="2.4.1 分离链接"></a>2.4.1 分离链接</h4><p>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。</p><p>例如，我们在之前的测试代码中使用分离链接的话，输出结果将会是这样：</p><p><img src="/2019/01/18/cjvqhlsuq0018rcvbwrh1y8py/hashTable-03.png" alt="分离链接展示"></p><p>在位置5上，将会有包含三个元素的LinkedList实例；在位置13、16和32上，将会有包含两个元素的LinkedList实例；在位置10、19和29上，将会有包含单个元素的LinkedList实例。</p><p>对于分离链接和线性探查来说，只需要重写三个方法：put、get和remove。这三个方法在每种技术实现中都是不同的。</p><p>为了实现一个使用了分离链接的HashTable实例，我们需要一个新的辅助类来表示将要加入LinkedList实例的元素。我们管它叫ValuePair类（在HashTable类内部定义）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ValuePair = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="keyword">this</span>.key + <span class="string">' - '</span> + <span class="keyword">this</span>.value + <span class="string">']'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类只会将key和value存储在一个Object实例中。我们也重写了toString方法，以便之后在浏览器控制台中输出结果。</p><ol><li>put方法</li></ol><p>我们来实现第一个方法，put方法，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] == <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        table[position] = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    table[position].append(<span class="keyword">new</span> ValuePair(key, value)); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个方法中，将验证要加入新元素的位置是否已经被占据（行{1}）。如果这个位置是第一次被加入元素，我们会在这个位置上初始化一个LinkedList类的实例（你已经在第5章中学习过）。然后，使用第5章中实现的append方法向LinkedList实例中添加一个ValuePair实例（键和值）（行{2}）。</p><ol start="2"><li>(2) get方法</li></ol><p>然后，我们实现用来获取特定值的get方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="comment">//遍历链表来寻找键/值</span></span><br><span class="line">        <span class="keyword">var</span> current = table[position].getHead(); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                <span class="keyword">return</span> current.element.value; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查元素在链表第一个或最后一个节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">            <span class="keyword">return</span> current.element.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们要做的第一个验证，是确定在特定的位置上是否有元素存在（行{3}）。如果没有，则返回一个undefined表示在HashTable实例中没有找到这个值（行{10}）。如果在这个位置上有值存在，我们知道这是一个LinkedList实例。现在要做的是遍历这个链表来寻找我们需要的元素。在遍历之前先要获取链表表头的引用（行{4}），然后就可以从链表的头部遍历到尾部（行{5}，current.next将会是null）。</p><p>Node链表包含next指针和element属性。而element属性又是ValuePair的实例，所以它又有value和key属性。可以通过current.element.key来获得Node链表的key属性，并通过比较它来确定它是否就是我们要找的键（行{6}）。（这就是要使用ValuePair这个辅助类来存储元素的原因。我们不能简单地存储值本身，这样就不能确定哪个值对应着特定的键。）如果key值相同，就返回Node的值（行{7}）；如果不相同，就继续遍历链表，访问下一个节点（行{8}）。</p><p>如果要找的元素是链表的第一个或最后一个节点，那么就不会进入while循环的内部。因此，需要在行{9}处理这种特殊的情况</p><ol start="3"><li>remove方法</li></ol><p>使用分离链接法从HashTable实例中移除一个元素和之前在本章实现的remove方法有一些不同。现在使用的是链表，我们需要从链表中移除一个元素。来看看remove方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> current = table[position].getHead();</span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;11&#125;</span></span><br><span class="line">                table[position].remove(current.element); <span class="comment">//&#123;12&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (table[position].isEmpty()) &#123; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">                    table[position] = <span class="literal">undefined</span>; <span class="comment">//&#123;14&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//&#123;15&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否为第一个或最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;16&#125;</span></span><br><span class="line">            table[position].remove(current.element);</span><br><span class="line">            <span class="keyword">if</span> (table[position].isEmpty()) &#123;</span><br><span class="line">                table[position] = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//&#123;17&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在remove方法中，我们使用和get方法一样的步骤找到要找的元素。遍历LinkedList实例时，如果链表中的current元素就是要找的元素（行{11}），使用remove方法将其从链表中移<br>除。然后进行一步额外的验证：如果链表为空了（行{13}——链表中不再有任何元素了），就将散列表这个位置的值设为undefined（行{14}），这样搜索一个元素或打印它的内容的时候，就可以跳过这个位置了。最后，返回true表示这个元素已经被移除（行{15}）或者在最后返回false表示这个元素在散列表中不存在（行{17}）。同样，需要和get方法一样，处理元素在第一个或最后一个的情况（行{16}）。</p><p>重写了这三个方法后，我们就拥有了一个使用了分离链接法来处理冲突的HashMap实例。</p><h4 id="2-4-1-线性探查"><a href="#2-4-1-线性探查" class="headerlink" title="2.4.1 线性探查"></a>2.4.1 线性探查</h4><p>另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推</p><p>然后重写put、get、remove方法</p><ol><li>put方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (table[position] == <span class="literal">undefined</span>) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        table[position] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = ++position; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        <span class="keyword">while</span> (table[index] != <span class="literal">undefined</span>) &#123; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">            index++; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和之前一样，先获得由散列函数生成的位置（行{1}），然后验证这个位置是否有元素存在（如果这个位置被占据了，将会通过行{2}的验证）。如果没有元素存在，就在这个位置加入新元素（行{3}——一个ValuePair的实例）。</p><p>如果这个位置已经被占据了，需要找到下一个没有被占据的位置（position的值是undefined），因此我们声明一个index变量并赋值为position+1（行{4}——在变量名前使用自增运算符++会先递增变量值然后再将其赋值给index）。然后验证这个位置是否被占据（行{5}），如果被占据了，继续将index递增（行{6}），直到找到一个没有被占据的位置。然后要做的，就是将值分配到这个位置（行{7}）。</p><p>如果再次执行插入数据的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> HashTable();</span><br><span class="line">hash.put(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Aaron'</span>, <span class="string">'aaron@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Donnie'</span>, <span class="string">'donnie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Ana'</span>, <span class="string">'ana@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jonathan'</span>, <span class="string">'jonathan@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jamie'</span>, <span class="string">'jamie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Sue'</span>, <span class="string">'sue@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Mindy'</span>, <span class="string">'mindy@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Paul'</span>, <span class="string">'paul@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Nathan'</span>, <span class="string">'nathan@email.com'</span>);</span><br></pre></td></tr></table></figure><p>下图展示使用了线性探查的散列表的最终结果：</p><p><img src="/2019/01/18/cjvqhlsuq0018rcvbwrh1y8py/hashTable-04.png" alt="分离链接展示"></p><p>让我们来模拟一下散列表中的插入操作。</p><p>(1) 试着插入Gandalf。它的散列值是19，由于散列表刚刚被创建，位置19还是空的——可以在这里插入数据。<br>(2) 试着在位置29插入John。它也是空的，所以可以插入这个姓名。<br>(3) 试着在位置16插入Tyrion。它是空的，所以可以插入这个姓名。<br>(4) 试着插入Aaron，它的散列值也是16。位置16已经被Tyrion占据了，所以需要检查索引值为position+1的位置（16+1）。位置17是空的，所以可以在位置17插入Aaron。<br>(5) 接着，试着在位置13插入Donnie。它是空的，所以可以插入这个姓名。<br>(6) 想在位置13插入Ana，但是这个位置被占据了。因此在位置14进行尝试，它是空的，所以可以在这里插入姓名。<br>(7) 然后，在位置5插入Jonathan，这个位置是空的，所以可以插入这个姓名。<br>(8) 试着在位置5插入Jamie，但是这个位置被占了。所以跳至位置6，这个位置是空的，因此可以在这个位置插入姓名。<br>(9) 试着在位置5插入Sue，但是位置被占据了。所以跳至位置6，但也被占了。接着跳至位置7，这里是空的，所以可以在这里插入姓名。以此类推。</p><ol start="2"><li>get方法</li></ol><p>现在插入了所有的元素，让我们实现get方法来获取它们的值吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (table[position].key === key) &#123; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">            <span class="keyword">return</span> table[position].value; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> index = ++position;</span><br><span class="line">            <span class="keyword">while</span> (table[index] === <span class="literal">undefined</span> || table[index].key !== key) &#123; <span class="comment">//&#123;11&#125;</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (table[index].key === key) &#123; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">                <span class="keyword">return</span> table[index].value; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">//&#123;14&#125;                     </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要获得一个键对应的值，先要确定这个键存在（行{8}）。如果这个键不存在，说明要查找的值不在散列表中，因此可以返回undefined（行{14}）。如果这个键存在，需要检查我们要找的值是否就是这个位置上的值（行{9}）。如果是，就返回这个值（行{10}）。</p><p>如果不是，就在散列表中的下一个位置继续查找，直到找到一个键值与我们要找的键值相同的元素（行{11}）。然后，验证一下当前项就是我们要找的项（行{12}——只是为了确认一下）并且将它的值返回（行{13}）。</p><p>我们无法确定要找的元素实际上在哪个位置，这就是使用ValuePair来表示HashTable元素的原因。</p><ol start="3"><li>remove方法</li></ol><p>remove方法和get方法基本相同，不同之处在于行{10}和{13}，它们将会由下面的代码代替：</p><blockquote><p>table[index] = undefined;</p></blockquote><p>要移除一个元素，只需要给其赋值为undefined，来表示这个位置不再被占据并且可以在必要时接受一个新元素。</p><h3 id="2-5-创建更好的散列函数"><a href="#2-5-创建更好的散列函数" class="headerlink" title="2.5 创建更好的散列函数"></a>2.5 创建更好的散列函数</h3><p>我们实现的“lose lose”散列函数并不是一个表现良好的散列函数，因为它会产生太多的冲突。如果我们使用这个函数的话，会产生各种各样的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。我们可以在网上找到一些不同的实现方法，或者也可以实现自己的散列函数。</p><p>另一个可以实现的比“lose lose”更好的散列函数是djb2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> djb2HashCode = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">5381</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        hash = hash * <span class="number">33</span> + key.charCodeAt(i); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">1013</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它包括初始化一个hash变量并赋值为一个质数（行{1}——大多数实现都使用5381），然后迭代参数key（行{2}），将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加（行{3}）。</p><p>最后，我们将使用相加的和与另一个随机质数（比我们认为的散列表的大小要大——在本例中，我们认为散列表的大小为1000）相除的余数。</p><p>如果再次执行插入数据的代码，这将是使用djb2HashCode代替loseloseHashCode的最终结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">798</span> - Gandalf</span><br><span class="line"><span class="number">838</span> - John</span><br><span class="line"><span class="number">624</span> - Tyrion</span><br><span class="line"><span class="number">215</span> - Aaron</span><br><span class="line"><span class="number">278</span> - Donnie</span><br><span class="line"><span class="number">925</span> - Ana</span><br><span class="line"><span class="number">288</span> - Jonathan</span><br><span class="line"><span class="number">962</span> - Jamie</span><br><span class="line"><span class="number">502</span> - Sue</span><br><span class="line"><span class="number">804</span> - Mindy</span><br><span class="line"><span class="number">54</span> - Paul</span><br><span class="line"><span class="number">223</span> - Nathan</span><br></pre></td></tr></table></figure><p>这并不是最好的散列函数，但这是最受社区推崇的散列函数之一。</p><h2 id="三、es6——Map类"><a href="#三、es6——Map类" class="headerlink" title="三、es6——Map类"></a>三、es6——Map类</h2><p>我们看看原生的Map类怎么用。</p><p>还是用我们原来测试Dictionary类的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">map.set(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">map.set(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'Gandalf'</span>)); <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">//输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">//输出["Gandalf", "John", "Tyrion"]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">//输出["gandalf@email.com", s"johnsnow@email.com", "tyrion@email.com"]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'Tyrion'</span>)); <span class="comment">//输出tyrion@email.com</span></span><br></pre></td></tr></table></figure><p>和我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator（第2章提到过），而不是值或键构成的数组。另一个区别是，我们实现的size方法返回字典中存储的值的个数，而ES6的Map类则有一个size属性。</p><p>删除map中的元素可以用delete方法：</p><blockquote><p>map.delete(‘John’);</p></blockquote><p>clear方法会重置map数据结构，这跟我们在Dictionary类里实现的一样。</p><h2 id="四、ES6——WeakMap-类和-WeakSet-类"><a href="#四、ES6——WeakMap-类和-WeakSet-类" class="headerlink" title="四、ES6——WeakMap 类和 WeakSet 类"></a>四、ES6——WeakMap 类和 WeakSet 类</h2><p>除了Set和Map这两种新的数据结构，ES6还增加了它们的弱化版本，WeakSet和WeakMap。</p><p>基本上，Map和Set与其弱化版本之间仅有的区别是：</p><ul><li><p>WeakSet或WeakMap类没有entries、keys和values等方法；</p></li><li><p>只能用对象作为键。</p></li></ul><p>创建和使用这两个类主要是为了性能。WeakSet和WeakMap是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。</p><p>另一个优点是，必须用键才可以取出值。这些类没有entries、keys和values等迭代器方法，因此，除非你知道键，否则没有办法取出值。这印证了我们在前面的做法，即使用WeakMap类封装ES6类的私有属性。</p><p>使用WeakMap类的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">var</span> ob1 = &#123;<span class="attr">name</span>:<span class="string">'Gandalf'</span>&#125;, <span class="comment">//&#123;1&#125;</span></span><br><span class="line">ob2 = &#123;<span class="attr">name</span>:<span class="string">'John'</span>&#125;,</span><br><span class="line">ob3 = &#123;<span class="attr">name</span>:<span class="string">'Tyrion'</span>&#125;;</span><br><span class="line">map.set(ob1, <span class="string">'gandalf@email.com'</span>); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">map.set(ob2, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">map.set(ob3, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob1)); <span class="comment">//&#123;3&#125; 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(ob3)); <span class="comment">//&#123;4&#125; 输出tyrion@email.com</span></span><br><span class="line">map.delete(ob2); <span class="comment">//&#123;5&#125;</span></span><br></pre></td></tr></table></figure><p>WeakMap类也可以用set方法，但不能使用数字、字符串、布尔值等基本数据类型，需要将名字转换为对象（行{1}和行{2}）。搜索（行{3}）、读取（行{4}）和删除值（行{5}），也要传入作为键的对象。同样的逻辑也适用于WeakSet类。</p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>在本节中，我们学习了字典的相关知识，了解了如何添加、移除和获取元素以及其他的一些方法。我们还了解了字典和集合的不同之处。</p><p>我们也学习了散列运算，怎样创建一个散列表（或者说散列映射）数据结构，如何添加、移除和获取元素，以及如何创建散列函数。我们学习了怎样使用两种不同的方法解决散列表中的冲突问题。</p><p>我们还介绍了如何使用ES6的Map、WeakMap和WeakSet类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字典和散也是用来存储唯一值（不重复的值）的数据结构。&lt;/p&gt;
&lt;p&gt;集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法六（集合）</title>
    <link href="https://www.23ybob.club/2018/12/28/cjvqhlstl0015rcvbs944w42n/"/>
    <id>https://www.23ybob.club/2018/12/28/cjvqhlstl0015rcvbs944w42n/</id>
    <published>2018-12-28T08:10:32.000Z</published>
    <updated>2019-03-04T09:22:31.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、构建数据集合"><a href="#一、构建数据集合" class="headerlink" title="一、构建数据集合"></a>一、构建数据集合</h2><p>集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。 </p><p>在深入学习集合的计算机科学实现之前，我们先看看它的数学概念。在数学中，集合是一组不同的对象（的集）。</p><p>比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6, …}。集合中的对象列表用“{}”（大括号）包围。</p><p>还有一个概念叫空集。空集就是不包含任何元素的集合。比如24和29之间的素数集合。由于24和29之间没有素数（除了1和自身，没有其他正因数的大于1的自然数），这个集合就是空集。空集用“{ }”表示。</p><p>你也可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。</p><p>在数学中，集合也有并集、交集、差集等基本操作。在本片文章中我们也会介绍这些操作</p><h2 id="二、创建集合"><a href="#二、创建集合" class="headerlink" title="二、创建集合"></a>二、创建集合</h2><p>首先创建set类，Set类的骨架如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个非常重要的细节，我们使用对象而不是数组来表示集合（items）。但也可以用数组实现。在这里我们用对象来实现，稍微有点儿不一样，也学习一下实现相似数据结构的新方<br>法。同时，JavaScript的对象不允许一个键指向两个不同的属性，也保证了集合里的元素都是唯一的。</p><p>接下来，需要声明一些集合可用的方法（我们会尝试模拟与ECMAScript 6实现相同的Set类）。</p><blockquote><p>add(value)：向集合添加一个新的项。<br>delete(value)：从集合移除一个值。<br>has(value)：如果值在集合中，返回true，否则返回false。<br>clear()：移除集合中的所有项。<br>size()：返回集合所包含元素的数量。与数组的length属性类似。<br>values()：返回一个包含集合中所有值的数组。</p></blockquote><h3 id="2-1-has-value-方法"><a href="#2-1-has-value-方法" class="headerlink" title="2.1 has(value)方法"></a>2.1 has(value)方法</h3><p>首先要实现的是has(value)方法。这是因为它会被add、remove等其他方法调用。下面看看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value <span class="keyword">in</span> items;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>既然我们使用对象来存储集合的值，就可以用JavaScript的in操作符来验证给定的值是否是items对象的属性。</p><p>但这个方法还有更好的实现方式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有JavaScript对象都有hasOwnProperty方法。这个方法返回一个表明对象是否具有特定属性的布尔值。</p><h3 id="2-2-add方法"><a href="#2-2-add方法" class="headerlink" title="2.2 add方法"></a>2.2 add方法</h3><p>接下来要实现add方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</span><br><span class="line">        items[value] = value; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于给定的value，可以检查它是否存在于集合中。如果不存在，就把value添加到集合中（行{1}），返回true，表示添加了这个值。如果集合中已经有这个值，就返回false，表示没有添加它。</p><p>添加一个值的时候，把它同时作为键和值保存，因为这样有利于查找这个值。</p><h3 id="2-3-remove-和-clear-方法"><a href="#2-3-remove-和-clear-方法" class="headerlink" title="2.3 remove 和 clear 方法"></a>2.3 remove 和 clear 方法</h3><p>下面要实现remove方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</span><br><span class="line">    <span class="keyword">delete</span> items[value]; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在remove方法中，我们会验证给定的value是否存在于集合中。如果存在，就从集合中移除value（行{2}），返回true，表示值被移除；否则返回false。</p><p>既然用对象来存储集合的items对象，就可以简单地使用delete操作符从items对象中移除属性（行{2}）。</p><p>使用Set类的示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>); <span class="comment">//true</span></span><br><span class="line">set.add(<span class="number">2</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>如果想移除集合中的所有值，可以用clear方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    items = &#123;&#125;; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要重置items对象，需要做的只是把一个空对象重新赋值给它（行{3}）。我们也可以迭代集合，用remove方法依次移除所有的值，但既然有更简单的方法，那样做就太麻烦了</p><h3 id="2-4-size-方法"><a href="#2-4-size-方法" class="headerlink" title="2.4 size 方法"></a>2.4 size 方法</h3><p>下一个要实现的是size方法（返回集合中有多少项）。这个方法有三种实现方式。</p><p>第一种方法是使用一个length变量，每当使用add或remove方法时控制它，就像在上一章中使用LinkedList类一样。</p><p>第二种方法，使用JavaScript内建的Object类的一个内建函数（ECMAScript 5以上版本）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript的Object类有一个keys方法，它返回一个包含给定对象所有属性的数组。在这种情况下，可以使用这个数组的length属性（行{4}）来返回items对象的属性个数。以上代码只能在现代浏览器中运行（比如IE9以上版本、Firefox 4以上版本、Chrome 5以上版本、Opera 12以上版本、Safari 5以上版本，等等）。</p><p>第三种方法是手动提取items对象的每一个属性，记录属性的个数并返回这个数字。这个方法可以在任何浏览器上运行，和之前的代码是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sizeLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(items.hasOwnProperty(key)) <span class="comment">//&#123;6&#125;</span></span><br><span class="line">        ++count; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍历items对象的所有属性（行{5}），检查它们是否是对象自身的属性（避免重复计数——行{6}）。如果是，就递增count变量的值（行{7}），最后在方法结束时返回这个数字。</p><p>不能简单地使用for-in语句遍历items对象的属性，并递增count变量的值。还需要使用hasOwnProperty方法（以验证items对象具有该属性），因为对象的原型包含了额外的属性（属性既有继承自JavaScript的Object类的，也有属于对象自身，未用于数据结构的）。</p><h3 id="2-5-values-方法"><a href="#2-5-values-方法" class="headerlink" title="2.5 values 方法"></a>2.5 values 方法</h3><p>values方法也应用了相同的逻辑，提取items对象的所有属性，以数组的形式返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (items.hasOwnProperty(key)) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">            values.push(items[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先遍历items对象的所有属性（行{7}），把它们添加一个数组中（行{8}），并返回这个数组。该方法类似于我们开发的sizeLegacy方法，但我们添加一个数组，而不是计算属性个数。</p><h3 id="2-6-使用-Set-类"><a href="#2-6-使用-Set-类" class="headerlink" title="2.6 使用 Set 类"></a>2.6 使用 Set 类</h3><p>现在数据结构已经完成了，执行Set类的方法，测试我们的Set类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出["1"]</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">1</span>)); <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size()); <span class="comment">//输出1 </span></span><br><span class="line">set.add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出["1", "2"]</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">2</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size()); <span class="comment">//2</span></span><br><span class="line">set.remove(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出["2"]</span></span><br><span class="line">set.remove(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出[]</span></span><br></pre></td></tr></table></figure><h2 id="三、-集合操作"><a href="#三、-集合操作" class="headerlink" title="三、 集合操作"></a>三、 集合操作</h2><p>对集合可以进行如下操作。</p><blockquote><p>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。<br>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。<br>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。<br>子集：验证一个给定集合是否是另一集合的子集。</p></blockquote><h3 id="3-1-并集"><a href="#3-1-并集" class="headerlink" title="3.1 并集"></a>3.1 并集</h3><p>并集的数学概念是集合A和集合B的并集，表示为：</p><blockquote><p>A∪B</p></blockquote><p>该集合定义如下：</p><blockquote><p>A∪B = { x | x ∈ A∨x ∈ B } </p></blockquote><p>意思是x（元素）存在于A中，或x存在于B中。下图展示了并集操作：</p><p><img src="/2018/12/28/cjvqhlstl0015rcvbs944w42n/union-01.png" alt="并集图示"></p><p>现在来实现Set类的union方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//union 方法</span></span><br><span class="line"><span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values(); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        unionSet.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values = otherSet.values(); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        unionSet.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先需要创建一个新的集合，代表两个集合的并集（行{1}）。接下来，获取第一个集合（当前的Set类实例）所有的值（values），遍历并全部添加到代表并集的集合中（行{2}）。然后对第二个集合做同样的事（行{3}）。最后返回结果。</p><p>测试一下上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line">setB.add(<span class="number">5</span>);</span><br><span class="line">setB.add(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> unionAB = setA.union(setB);</span><br><span class="line"><span class="built_in">console</span>.log(unionAB.values());  <span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>输出为[“1”, “2”, “3”, “4”, “5”, “6”]。注意元素3同时存在于A和B中，它在结果的集合中只出现一次。</p><h3 id="3-2-交集"><a href="#3-2-交集" class="headerlink" title="3.2 交集"></a>3.2 交集</h3><p>交集的数学概念是集合A和集合B的交集，表示为：</p><blockquote><p>A∩B</p></blockquote><p>该集合定义如下：</p><blockquote><p>A∩B = { x | x ∈ A∧x ∈ B } </p></blockquote><p>意思是x（元素）存在于A中，且x存在于B中。下图展示了交集操作：</p><p><img src="/2018/12/28/cjvqhlstl0015rcvbs944w42n/intersection-01.png" alt="交集图示"></p><p>现在来实现Set类的intersection方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (otherSet.has(values[i]))&#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            intersectionSet.add(values[i]); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intersection方法需要找到当前Set实例中，所有也存在于给定Set实例中的元素。首先创建一个新的Set实例，这样就能用它返回共有的元素（行{1}）。接下来，遍历当前Set实例所有的值（行{2}），验证它们是否也存在于otherSet实例（行{3}）之中。可以用前面实现的has方法来验证元素是否存在于Set实例中。然后，如果这个值也存在于另一个Set实例中，就将其添加到创建的intersectionSet变量中（行{4}），最后返回它。</p><p>测试一下intersection方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> intersectionAB = setA.intersection(setB);</span><br><span class="line"><span class="built_in">console</span>.log(intersectionAB.values());</span><br></pre></td></tr></table></figure><p>输出为[“2”, “3”]，因为2和3同时存在于两个集合中。</p><h3 id="3-3-差集"><a href="#3-3-差集" class="headerlink" title="3.3 差集"></a>3.3 差集</h3><p>差集的数学概念是集合A和集合B的差集，表示为：AB，定义如下图：</p><p><img src="/2018/12/28/cjvqhlstl0015rcvbs944w42n/difference-01.png" alt="差集图示"></p><p>意思是x（元素）存在于A中，且x不存在于B中。下图展示了集合A和B的差集操作：</p><p><img src="/2018/12/28/cjvqhlstl0015rcvbs944w42n/difference-02.png" alt="差集图示"></p><p>现在来实现Set类的difference方法： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (!otherSet.has(values[i])) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            differenceSet.add(values[i]); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>intersection方法会得到所有同时存在于两个集合中的值。而difference方法会得到所有存在于集合A但不存在于B的值。因此这两个方法在实现上唯一的区别就是行{3}。只获取不存在于otherSet实例中的值，而不是也存在于其中的值。行{1}、{2}和{4}是完全相同的。</p><p>测试difference方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> differenceAB = setA.difference(setB);</span><br><span class="line"><span class="built_in">console</span>.log(differenceAB.values());</span><br></pre></td></tr></table></figure><p>输出为[“1”]，因为1是唯一一个仅存在于setA的元素。</p><h3 id="3-4-子集"><a href="#3-4-子集" class="headerlink" title="3.4 子集"></a>3.4 子集</h3><p>子集的数学概念是集合A是集合B的子集（或集合B包含了A），表示为</p><blockquote><p>A⊆B</p></blockquote><p>该集合定义如下：</p><p>∀x { x ∈ A → x ∈ B } </p><p>意思是集合A中的每一个x（元素），也需要存在于B中。下图展示了集合A是集合B的子集：</p><p><img src="/2018/12/28/cjvqhlstl0015rcvbs944w42n/difference-01.png" alt="差集图示"></p><p>现在来实现Set类的subset方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size()) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(values[i])) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先需要验证的是当前Set实例的大小。如果当前实例中的元素比otherSet实例更多，它就不是一个子集（行{1}）。子集的元素个数需要小于或等于要比较的集合。</p><p>接下来要遍历集合中的所有元素（行{2}），验证这些元素也存在于otherSet中（行{3}）。如果有任何元素不存在于otherSet中，就意味着它不是一个子集，返回false（行{4}）。如果所有元素都存在于otherSet中，行{4}就不会被执行，那么就返回true（行{5}）。</p><p>检验一下上面的代码效果如何：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>); </span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">1</span>);</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setC = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setC.add(<span class="number">2</span>);</span><br><span class="line">setC.add(<span class="number">3</span>);</span><br><span class="line">setC.add(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(setA.subset(setB));</span><br><span class="line"><span class="built_in">console</span>.log(setA.subset(setC));</span><br></pre></td></tr></table></figure><p>我们有三个集合：setA是setB的子集（因此输出为true），然而setA不是setC的子集（setC只包含了setA中的2，而不包含1），因此输出为false。</p><h2 id="四、-ES6——Set-类"><a href="#四、-ES6——Set-类" class="headerlink" title="四、 ES6——Set 类"></a>四、 ES6——Set 类</h2><p>我们先看看原生的Set类怎么用。</p><p>还是用我们原来测试Set类的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">// 输出@Iterator</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">1</span>)); <span class="comment">// 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure><p>和我们的Set不同，ES6的Set的values方法返回Iterator（第2章提到过），而不是值构成的数组。另一个区别是，我们实现的size方法返回set中存储的值的个数，而ES6的Set则有一个size属性。</p><p>可以用delete方法删除set中的元素：</p><p>set.delete(1); </p><p>clear方法会重置set数据结构，这跟我们实现的功能一样</p><h3 id="4-1-ES6-Set-类的操作"><a href="#4-1-ES6-Set-类的操作" class="headerlink" title="4.1 ES6 Set 类的操作"></a>4.1 ES6 Set 类的操作</h3><p>我们的Set类实现了并集、交集、差集、子集等数学操作，然而ES6原生的Set并没有这些功能。不过，有需要的话，我们也可以模拟。</p><p>我们的例子会用到下面两个集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="4-1-1-模拟并集操作"><a href="#4-1-1-模拟并集操作" class="headerlink" title="4.1.1 模拟并集操作"></a>4.1.1 模拟并集操作</h4><p>我们可以创建一个新的集合，用来添加两个集合中所有的元素（行{1}）。迭代这两个集合（行{2}、行{3}），把所有元素都添加到并集的集合中。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unionAb = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setA) unionAb.add(x); <span class="comment">//&#123;2&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setB) unionAb.add(x); <span class="comment">//&#123;3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4-1-2-模拟交集操作"><a href="#4-1-2-模拟交集操作" class="headerlink" title="4.1.2 模拟交集操作"></a>4.1.2 模拟交集操作</h4><p>模拟交集操作需要创建一个辅助函数，来生成包含setA和setB都有的元素的新集合（行{1}）。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intersection = <span class="function"><span class="keyword">function</span>(<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (setB.has(x)) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            intersectionSet.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> intersectionAB = intersection(setA, setB);</span><br></pre></td></tr></table></figure><p>交集可以用更简单的语法实现，代码如下：</p><blockquote><p>intersectionAb = new Set([x for (x of setA) if (setB.has(x))]); </p></blockquote><p>这和intersection函数的效果完全一样。</p><h4 id="4-1-3-模拟差集操作"><a href="#4-1-3-模拟差集操作" class="headerlink" title="4.1.3 模拟差集操作"></a>4.1.3 模拟差集操作</h4><p>交集操作创建的集合包含setA和setB都有的元素，差集操作创建的集合包含的则是setA有而setB没有的元素。看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> difference = <span class="function"><span class="keyword">function</span>(<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!setB.has(x)) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            differenceSet.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> differenceAB = difference(setA, setB);</span><br></pre></td></tr></table></figure><p>intersection函数和difference函数只有行{1}不同，因为差集中只添加setA有而setB没有的元素。</p><p>差集也可以用更简单的语法实现，代码如下：</p><blockquote><p>differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); </p></blockquote><p>目前只有Firefox支持简化的语法，但在所有支持ES6的现代浏览器中都可以执行difference函数</p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>在这片文章中，我们学习了如何从头实现一个与ECMAScript 6中定义的类似的Set类。我们还介绍了在其他编程语言的集合数据结构的实现中不常见的一些方法，比如并集、交集、差集和子集。因此，相比于其他编程语言目前的Set实现，我们实现了一个非常完备的Set类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、构建数据集合&quot;&gt;&lt;a href=&quot;#一、构建数据集合&quot; class=&quot;headerlink&quot; title=&quot;一、构建数据集合&quot;&gt;&lt;/a&gt;一、构建数据集合&lt;/h2&gt;&lt;p&gt;集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法五（链表）</title>
    <link href="https://www.23ybob.club/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/"/>
    <id>https://www.23ybob.club/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/</id>
    <published>2018-11-18T11:41:53.000Z</published>
    <updated>2019-03-04T09:22:48.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链表数据结构"><a href="#一、链表数据结构" class="headerlink" title="一、链表数据结构"></a>一、链表数据结构</h2><p>要存储多个元素，数组（或列表）可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管JavaScript的array类方法做这些事，但背后的情况同样是这样）。</p><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展示了一个链表的结构：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-01.png" alt="链表数据结构"></p><p>相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。</p><p>现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来。</p><p>另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法，就是从起点（第一条线索）顺着列表寻找。</p><p>还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或移除它。下图演示了一列火车。每节车皮都是列表的元素，车皮间的连接就是指针：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-02.png" alt="链表数据结构"></p><h2 id="二、创建链表"><a href="#二、创建链表" class="headerlink" title="二、创建链表"></a>二、创建链表</h2><p>理解了链表是什么之后，现在就要开始实现我们的数据结构了，以下是我们的LinkedList类的骨架：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123; &#125;; </span><br><span class="line">    <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList数据结构还需要一个Node辅助类（行{1}）。Node类表示要加入列表的项。它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。</p><p>LinkedList类也有存储列表项的数量的length属性（内部/私有变量）（行{2}）。</p><p>另一个重要的点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在一个称为head的变量中（行{3}）</p><p>然后就是LinkedList类的方法。在实现这些方法之前，先来看看它们的职责。</p><ul><li>append(element)：向列表尾部添加一个新的项。</li><li>insert(position, element)：向列表的特定位置插入一个新的项。</li><li>remove(element)：从列表中移除一项。</li><li>indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。</li><li>removeAt(position)：从列表的特定位置移除一项。</li><li>isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。</li><li>size()：返回链表包含的元素个数。与数组的length属性类似。</li><li>toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。</li></ul><h3 id="2-1-向链表尾部追加元素"><a href="#2-1-向链表尾部追加元素" class="headerlink" title="2.1 向链表尾部追加元素"></a>2.1 向链表尾部追加元素</h3><p>向LinkedList对象尾部添加一个元素时，可能有两种场景：列表为空，添加的是第一个元素，或者列表不为空，向其追加元素。</p><p>下面是我们实现的append方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedList类的骨架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>; <span class="comment">// </span></span><br><span class="line">    <span class="comment">//实现LinkedList类的append方法</span></span><br><span class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element), <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            current; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123; <span class="comment">//列表中第一个节点 //&#123;3&#125;</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = head; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            <span class="comment">//循环列表，直到找到最后一项</span></span><br><span class="line">            <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到最后一项，将其next赋为node，建立链接</span></span><br><span class="line">            current.next = node; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        length++; <span class="comment">//更新列表的长度 //&#123;6&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要做的是把element作为值传入，创建Node项（行{1}）。</p><p>先来实现第一个场景：向为空的列表添加一个元素。当我们创建一个LinkedList对象时，head会指向null：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-03.png" alt="链表数据结构"></p><p>如果head元素为null（列表为空——行{3}），就意味着在向列表添加第一个元素。因此要做的就是让head元素指向node元素。下一个node元素将会自动成为null。</p><p>列表最后一个节点的下一个元素始终是null。</p><p>再来看看第二个场景，也就是向一个不为空的列表尾部添加元素。</p><p>要向列表的尾部添加一个元素，首先需要找到最后一个元素。记住，我们只有第一个元素的引用（行{4}），因此需要循环访问列表，直到找到最后一项。为此，我们需要一个指向列表中current项的变量（行{2}）。</p><p>循环访问列表时，当current.next元素为null时，我们就知道已经到达列表尾部了。然后要做的就是让当前（也就是最后一个）元素的next指针指向想要添加到列表的节点（行{5}）。下图展示了这个行为：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-04.png" alt="链表数据结构"></p><p>而当一个Node元素被创建时，它的next指针总是null。这没问题，因为我们知道它会是列表的最后一项。</p><p>当然，别忘了递增列表的长度，这样就能控制它，轻松地得到列表的长度（行{6}）。</p><p>我们可以通过以下代码来使用和测试目前创建的数据结构：</p><blockquote><p>let list = new LinkedList();<br>list.append(15);<br>list.append(10); </p></blockquote><h3 id="2-2-从链表中移除元素"><a href="#2-2-从链表中移除元素" class="headerlink" title="2.2 从链表中移除元素"></a>2.2 从链表中移除元素</h3><p>现在，让我们看看如何从LinkedList对象中移除元素。移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种remove方法：第一种是从特定位置移除一个元素，第二种是根据元素的值移除元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedList类的骨架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//实现LinkedList类的append方法</span></span><br><span class="line">    <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//检查越界值</span></span><br><span class="line">        <span class="keyword">if</span> (position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">            <span class="keyword">let</span> current = head, <span class="comment">// &#123;2&#125;</span></span><br><span class="line">                previous, <span class="comment">// &#123;3&#125;</span></span><br><span class="line">                index = <span class="number">0</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">            <span class="comment">//移除第一项</span></span><br><span class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">                head = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (index++ &lt; position) &#123; // &#123;6&#125;</span><br><span class="line">                    previous = current; // &#123;7&#125;</span><br><span class="line">                    current = current.next; // &#123;8&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //将previous与current的下一项链接起来：跳过current，从而移除它</span><br><span class="line">                previous.next = current.next; // &#123;9&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            length--; // &#123;10&#125;</span><br><span class="line">            return current.element;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null; // &#123;11&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一步一步来看这段代码。该方法要得到需要移除的元素的位置，就需要验证这个位置是有效的（行{1}）。从0（包括0）到列表的长度（size – 1，因为索引是从零开始的）都是有效的位置。如果不是有效的位置，就返回null（意即没有从列表中移除元素）。</p><p>首先为第一种场景编写代码：我们要从列表中移除第一个元素（position === 0——行{5}）。下图展示了这个过程：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-05.png" alt="链表数据结构"></p><p>因此，如果想移除第一个元素，要做的就是让head指向列表的第二个元素。我们将用current变量创建一个对列表中第一个元素的引用（行{2}——我们还会用它来迭代列表，但稍等一下再说）。这样current变量就是对列表中第一个元素的引用。如果把head赋为current.next，就会移除第一个元素</p><p>现在，假设我们要移除列表的最后一项或者中间某一项。为此，需要依靠一个细节来迭代列表，直到到达目标位置（行{6}——我们会使用一个用于内部控制和递增的index变量）：current变量总是为对所循环列表的当前元素的引用（行{8}）。我们还需要一个对当前元素的前一个元素的引用（行{7}）；它被命名为previous（行{3}）。</p><p>因此，要从列表中移除当前元素，要做的就是将previous.next和current.next链接起来（行{9}）。这样，当前元素就会被丢弃在计算机内存中，等着被垃圾回收器清除。</p><p>我们试着通过一些图表来更好地理解。首先考虑移除最后一个元素：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-06.png" alt="链表数据结构"></p><p>对于最后一个元素，当我们在行{6}跳出循环时，current变量将是对列表中最后一个元素的引用（要移除的元素）。current.next的值将是null（因为它是最后一个元素）。由于还保留了对previous元素的引用（当前元素的前一个元素），previous.next就指向了current。那么要移除current，要做的就是把previous.next的值改变为current.next。</p><p>现在来看看，对于列表中间的元素是否可以应用相同的逻辑：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-06.png" alt="链表数据结构"></p><p>current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。那么要移除current元素，需要做的就是将previous.next与current.next链接起来。因此，我们的逻辑对这两种情况都管用。</p><h3 id="2-3-在任意位置插入元素"><a href="#2-3-在任意位置插入元素" class="headerlink" title="2.3 在任意位置插入元素"></a>2.3 在任意位置插入元素</h3><p>接下来，我们要实现insert方法。使用这个方法可以在任意位置插入一个元素。我们来看一看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</span><br><span class="line">            current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">//在第一个位置添加</span></span><br><span class="line">            node.next = current; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (index++ &lt; position) &#123; //&#123;3&#125;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = current; //&#123;4&#125;</span><br><span class="line">            previous.next = node; //&#123;5&#125; </span><br><span class="line">        &#125;</span><br><span class="line">        length++; //更新列表的长度</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false; //&#123;6&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们处理的是位置，就需要检查越界值（行{1}，跟removeAt方法类似）。如果越界了，就返回false值，表示没有添加项到列表中（行{6}）。</p><p>现在我们要处理不同的场景。第一种场景，需要在列表的起点添加一个元素，也就是第一个位置。下图展示了这种场景：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-08.png" alt="insert图示"></p><p>current变量是对列表中第一个元素的引用。我们需要做的是把node.next的值设为current（列表中第一个元素）。现在head和node.next都指向了current。接下来要做的就是把head的引用改为node（行{2}），这样列表中就有了一个新元素。</p><p>现在来处理第二种场景：在列表中间或尾部添加一个元素。首先，我们需要循环访问列表，找到目标位置（行{3}）。当跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用，而previous将是对想要插入新元素的位置之前一个元素的引用。在这种情况下，我们要在previous和current之间添加新项。因此，首先需要把新项（node）和当前项链接起来（行{4}），然后需要改变previous和current之间的链接。我们还需要让previous.next指向node（行{5}）。</p><p>我们通过一张图表来看看代码所做的事：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-09.png" alt="insert图示"></p><p>如果我们试图向最后一个位置添加一个新元素，previous将是对列表最后一项的引用，而current将是null。在这种情况下，node.next将指向current，而previous.next将指向node，这样列表中就有了一个新的项。</p><p>现在来看看如何向列表中间添加一个新元素：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-10.png" alt="insert图示"></p><p>在这种情况下，我们试图将新的项（node）插入到previous和current元素之间。首先，我们需要把node.next的值指向current。然后把previous.next的值设为node。这样列表中就有了一个新的项。</p><p>使用变量引用我们需要控制的节点非常重要，这样就不会丢失节点之间的链接。我们可以只使用一个变量（previous），但那样会很难控制节点之间的链接。由于这个原因，最好是声明一个额外的变量来帮助我们处理这些引用。</p><h3 id="2-4-实现链表的其他方法"><a href="#2-4-实现链表的其他方法" class="headerlink" title="2.4 实现链表的其他方法"></a>2.4 实现链表的其他方法</h3><h4 id="2-4-1-toString方法"><a href="#2-4-1-toString方法" class="headerlink" title="2.4.1 toString方法"></a>2.4.1 toString方法</h4><p>toString方法会把LinkedList对象转换成一个字符串。下面是toString方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head, <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        string = <span class="string">''</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        string += current.element + (current.next ? <span class="string">'n'</span> : <span class="string">''</span>);<span class="comment">//&#123;4&#125;</span></span><br><span class="line">        current = current.next; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，要循环访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引（行{1}），控制循环访问列表。我们还需要初始化用于拼接元素值的变量（行{2}）。</p><p>接下来就是循环访问列表中的每个元素（行{3}）。我们要用current来检查元素是否存在（如果列表为空，或是到达列表中最后一个元素的下一位（null），while循环中的代码就不会执行）。然后我们就得到了元素的内容，将其拼接到字符串中（行{4}）。最后，继续迭代下一个元素（行{5}）。最后，返回列表内容的字符串（行{6}）。</p><h4 id="2-4-2-indexOf方法"><a href="#2-4-2-indexOf方法" class="headerlink" title="2.4.2 indexOf方法"></a>2.4.2 indexOf方法</h4><p>indexOf方法接收一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head, <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">            <span class="keyword">return</span> index; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        index++; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        current = current.next; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一如既往，我们需要一个变量来帮助我们循环访问列表，这个变量是current，它的初始值是head（列表的第一个元素——我们还需要一个index变量来计算位置数（行{1}））。然后循环访问元素（行{2}），检查当前元素是否是我们要找的。如果是，就返回它的位置（行{3}）；如果不是，就继续计数（行{4}），检查列表中下一个节点（行{5}）。</p><p>如果列表为空，或是到达列表的尾部（current = current.next将是null），循环就不会执行。如果没有找到值，就返回-1。</p><h4 id="2-4-3-remove方法"><a href="#2-4-3-remove方法" class="headerlink" title="2.4.3 remove方法"></a>2.4.3 remove方法</h4><p>实现了indexOf方法就可以实现remove方法了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们已经有一个移除给定位置的一个元素的removeAt方法了。现在有了indexOf方法，如果传入元素的值，就能找到它的位置，然后调用removeAt方法并传入找到的位置。这样非常简<br>单，如果需要更改removeAt方法的代码，这样也更容易——两个方法都会被更改（这就是重用代码的妙处）。这样，我们就不需要维护两个从列表中移除一项的方法，只需要一个！同时，removeAt方法将会检查边界约束。</p><h4 id="2-4-4-isEmpty、size和getHead方法"><a href="#2-4-4-isEmpty、size和getHead方法" class="headerlink" title="2.4.4  isEmpty、size和getHead方法"></a>2.4.4  isEmpty、size和getHead方法</h4><p>isEmpty方法检查链表是否为空、size获取链表长度，这两个方法与队列中的isEmpty方法、size方法类似，如下实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果列表中没有元素，isEmpty方法就返回true，否则返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>size方法返回列表的length。和已经实现的Queue类、Stack类有所不同，列表的length是内部控制的，因为LinkedList是从头构建的。</p><p>最后还有getHead方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>head变量是LinkedList类的私有变量（这意味着它不能在LinkedList实例外部被访问和更改，只有通过LinkedList实例才可以）。但是，如果我们需要在类的外部循环访问列表，就需要提供一种获取类的第一个元素的方法。</p><h2 id="三、双向链表"><a href="#三、双向链表" class="headerlink" title="三、双向链表"></a>三、双向链表</h2><p>双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素，如下图所示</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-11.png" alt="双向链表图示"></p><p>先从实现DoublyLinkedList类所需的变动开始</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DoublyLinkedList类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    <span class="comment">//这里是方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中可以看到，LinkedList类和DoublyLinkedList类之间的区别标为新增的。在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一<br>项的引用的tail属性。</p><p>双向链表提供了两种迭代列表的方法：从头到尾，或者反过来。我们也可以访问一个特定节点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。</p><h3 id="3-1-在任意位置插入新元素"><a href="#3-1-在任意位置插入新元素" class="headerlink" title="3.1 在任意位置插入新元素"></a>3.1 在任意位置插入新元素</h3><p>向双向链表中插入一个新项跟（单向）链表非常类似。区别在于，链表只要控制一个next指针，而双向链表则要同时控制next和prev（previous，前一个）这两个指针。</p><p>这是向任意位置插入一个新元素的算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DoublyLinkedList类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> tail = <span class="literal">null</span>; <span class="comment">//新增的</span></span><br><span class="line">    <span class="comment">//这里是方法</span></span><br><span class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//检查越界值</span></span><br><span class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element),</span><br><span class="line">                current = head,</span><br><span class="line">                previous,</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">//在第一个位置添加</span></span><br><span class="line">                <span class="keyword">if</span> (!head) &#123; <span class="comment">//新增的 &#123;1&#125;</span></span><br><span class="line">                    head = node;</span><br><span class="line">                    tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = current;</span><br><span class="line">                    current.prev = node; <span class="comment">//新增的 &#123;2&#125;</span></span><br><span class="line">                    head = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length) &#123; <span class="comment">//最后一项 //新增的</span></span><br><span class="line">                current = tail; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">                current.next = node;</span><br><span class="line">                node.prev = current;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (index++ &lt; position) &#123; //&#123;4&#125;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                node.next = current; //&#123;5&#125;</span><br><span class="line">                previous.next = node;</span><br><span class="line">                current.prev = node; //新增的</span><br><span class="line">                node.prev = previous; //新增的</span><br><span class="line">            &#125;</span><br><span class="line">            length++; //更新列表的长度</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析第一种场景：在列表的第一个位置（列表的起点）插入一个新元素。如果列表为空（行{1}），只需要把head和tail都指向这个新节点。如果不为空，current变量将是对列表中第一个元素的引用。就像我们在链表中所做的，把node.next设为current，而head将指向node（它将成为列表中的第一个元素）。不同之处在于，我们还需要为指向上一个元素的指针设一个值。current.prev指针将由指向null变为指向新元素（node——行{2}）。node.prev指针已经是null，因此不需要再更新任何东西。下图演示了这个过程：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-12.png" alt="双向链表图示"></p><p>现在来分析一下，假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current变量将引用最后一个元素（行{3}）。然后开始建立第一个链接：node.prev将引用current。current.next指针（指向null）将指向node（由于构造函数，node.next已经指向了null）。然后只剩一件事了，就是更新tail，它将由指向current变为指向node。下图展示了这些行为：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-13.png" alt="双向链表图示"></p><p>然后还有第三种场景：在列表中间插入一个新元素。就像我们在之前的方法中所做的，迭代列表，直到到达要找的位置（行{4}）。我们将在current和previous元素之间插入新元素。首先，node.next将指向current（行{5}），而previous.next将指向node，这样就不会丢失节点之间的链接。然后需要处理所有的链接：current.prev将指向node，而node.prev将指向previous。下图展示了这一过程：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-14.png" alt="双向链表图示"></p><h3 id="3-2-从任意位置移除元素"><a href="#3-2-从任意位置移除元素" class="headerlink" title="3.2 从任意位置移除元素"></a>3.2 从任意位置移除元素</h3><p>从双向链表中移除元素跟链表非常类似。唯一的区别就是还需要设置前一个位置的指针。我们来看一下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//移除第一项</span></span><br><span class="line">        <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">            head = current.next; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">            <span class="comment">//如果只有一项，更新tail //新增的</span></span><br><span class="line">            <span class="keyword">if</span> (length === <span class="number">1</span>) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">                tail = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head.prev = <span class="literal">null</span>; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length - <span class="number">1</span>) &#123; <span class="comment">//最后一项 //新增的</span></span><br><span class="line">            current = tail; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">            tail = current.prev;</span><br><span class="line">            tail.next = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (index++ &lt; position) &#123; // &#123;5&#125;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //将previous与current的下一项链接起来——跳过current</span><br><span class="line">            previous.next = current.next; // &#123;6&#125;</span><br><span class="line">            current.next.prev = previous; //新增的</span><br><span class="line">        &#125;</span><br><span class="line">        length--;</span><br><span class="line">        return current.element;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。</p><p>我们来看看如何移除第一个元素。current变量是对列表中第一个元素的引用，也就是我们想移除的元素。需要做的就是改变 head 的引用，将其从 current 改为下一个元素（current.next——行{1}）。但我们还需要更新current.next指向上一个元素的指针（因为第一个元素的prev指针是null）。因此，把head.prev的引用改为null（行{3}——因为head也指向列表中新的第一个元素，或者也可以用current.next.prev）。由于还需要控制tail的引用，我们可以检查要移除的元素是否是第一个元素，如果是，只需要把tail也设为null（行{2}）。</p><p>下图勾画了从双向链表移除第一个元素的过程：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-15.png" alt="双向链表图示"></p><p>下一种场景是从最后一个位置移除元素。既然已经有了对最后一个元素的引用（tail），我们就不需要为找到它而迭代列表。这样我们也就可以把tail的引用赋给current变量（行{4}）。接下来，需要把tail的引用更新为列表中倒数第二个元素（current.prev，或者tail.prev也可以）。既然tail指向了倒数第二个元素，我们就只需要把next指针更新为null（tail.next= null）。下图演示了这一行为：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-16.png" alt="双向链表图示"></p><p>第三种也是最后一种场景：从列表中间移除一个元素。首先需要迭代列表，直到到达要找的位置（行{5}）。current变量所引用的就是要移除的元素。那么要移除它，我们可以通过更新previous.next和current.next.prev的引用，在列表中跳过它。因此，previous.next将指向current.next，而current.next.prev将指向previous，如下图所示：</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-17.png" alt="双向链表图示"></p><h3 id="3-3-循环列表"><a href="#3-3-循环列表" class="headerlink" title="3.3 循环列表"></a>3.3 循环列表</h3><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用null，而是指向第一个元素（head），如下图所示。</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-18.png" alt="双向链表图示"></p><p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev。</p><p><img src="/2018/11/18/cjvqhlsur0019rcvbe1bm38wf/LinkedList-19.png" alt="双向链表图示"></p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>本篇文章主要介绍链表这种数据结构，及其变体双向链表和循环链表。我们学习了如何在任意位置添加和移除元素，以及如何循环访问链表。还学习了链表相比数组最重要的优点，那就是无需移动链表中的元素，就能轻松地添加和移除元素。因此，当我们需要添加和移除很多元素时，最好的选择就是链表，而非数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、链表数据结构&quot;&gt;&lt;a href=&quot;#一、链表数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、链表数据结构&quot;&gt;&lt;/a&gt;一、链表数据结构&lt;/h2&gt;&lt;p&gt;要存储多个元素，数组（或列表）可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法四（队列）</title>
    <link href="https://www.23ybob.club/2018/10/12/cjvqhlso9000vrcvbitjnex2k/"/>
    <id>https://www.23ybob.club/2018/10/12/cjvqhlso9000vrcvbitjnex2k/</id>
    <published>2018-10-12T11:31:39.000Z</published>
    <updated>2019-03-04T09:23:46.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、队列数据结构"><a href="#一、队列数据结构" class="headerlink" title="一、队列数据结构"></a>一、队列数据结构</h2><p>队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p><p>在现实中，最常见的队列的例子就是排队：</p><p><img src="/2018/10/12/cjvqhlso9000vrcvbitjnex2k/queue-01.png" alt="队列排队案例"></p><h3 id="1-1-创建队列"><a href="#1-1-创建队列" class="headerlink" title="1.1 创建队列"></a>1.1 创建队列</h3><p>首先需要创建自己的类表示队列，先从最基本的声明开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quene</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里是属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像在Stack类中那样使用（你会发现Queue类和Stack类非常类似，只是添加和移除元素的原则不同）：</p><blockquote><p>let items = [];</p></blockquote><p>接下来需要声明一些队列可用的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enqueue(element(s))：向队列尾部添加一个（或多个）新的项。</span><br><span class="line"></span><br><span class="line">dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</span><br><span class="line"></span><br><span class="line">front()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）。</span><br><span class="line"></span><br><span class="line">isEmpty()：如果队列中不包含任何元素，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line">size()：返回队列包含的元素个数，与数组的length属性类似。</span><br></pre></td></tr></table></figure><h3 id="1-2-向队列添加元素"><a href="#1-2-向队列添加元素" class="headerlink" title="1.2 向队列添加元素"></a>1.2 向队列添加元素</h3><p>首先要实现的是enqueue方法。这个方法负责向队列添加新元素。这里有一个非常重要的细节，新的项只能添加到队列末尾：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    items.push(element);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-从队列移除元素"><a href="#1-2-从队列移除元素" class="headerlink" title="1.2 从队列移除元素"></a>1.2 从队列移除元素</h3><p>接下来要实现dequeue方法。这个方法负责从队列移除项。由于队列遵循先进先出原则，最先添加的项也是最先被移除的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.shift();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只有enqueue方法和dequeue方法可以添加和移除元素，这样就确保了Queue类遵循先进先出原则。</p><h3 id="1-3-查看队列头元素"><a href="#1-3-查看队列头元素" class="headerlink" title="1.3 查看队列头元素"></a>1.3 查看队列头元素</h3><p>现在来为我们的类实现一些额外的辅助方法。如果想知道队列最前面的项是什么，可以用front方法。这个方法会返回队列最前面的项（数组的索引为0）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4-检查队列是否为空"><a href="#1-4-检查队列是否为空" class="headerlink" title="1.4 检查队列是否为空"></a>1.4 检查队列是否为空</h3><p>下一个是isEmpty方法。如果队列为空，它会返回true，否则返回false（注意这个方法和Stack类里的一样）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于isEmpty方法，可以简单地验证内部数组的length是否为0。</p><p>我们也可以为Queue类实现类似于array类的length属性的方法。size方法也跟Stack类里的一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-5-打印队列元素"><a href="#1-5-打印队列元素" class="headerlink" title="1.5 打印队列元素"></a>1.5 打印队列元素</h3><p>我们的Queue类已经实现好了。为了方便也可以像Stack类一样增加一个print方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-6-使用quene类"><a href="#1-6-使用quene类" class="headerlink" title="1.6 使用quene类"></a>1.6 使用quene类</h3><p>首先要做的是实例化我们刚刚创建的Queue类，然后就可以验证它为空（输出为true，因为我们还没有向队列添加任何元素）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[<span class="number">0</span>];      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty()); <span class="comment">//输出true</span></span><br></pre></td></tr></table></figure><p>接下来，添加一些元素（添加”John”和”Jack”两个元素——你可以向队列添加任何类型的元素）：</p><blockquote><p>queue.enqueue(“John”);</p></blockquote><blockquote><p>queue.enqueue(“Jack”); </p></blockquote><p>添加另一个元素：</p><pre><code>queue.enqueue(&quot;Camila&quot;); </code></pre><p>再执行一些其他的命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue.print(); <span class="comment">//["John", "Jack", "Camila"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.size()); <span class="comment">//输出3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty()); <span class="comment">//输出false</span></span><br><span class="line"></span><br><span class="line">queue.dequeue(); <span class="comment">//"John"</span></span><br><span class="line"></span><br><span class="line">queue.dequeue(); <span class="comment">//"Jack"</span></span><br><span class="line"></span><br><span class="line">queue.print();   <span class="comment">//["Camila"]</span></span><br></pre></td></tr></table></figure><p>如果打印队列的内容，就会得到John、Jack和Camila这三个元素。因为我们向队列添加了三个元素，所以队列的大小为3（当然也就不为空了）。</p><p>下图展示了目前为止执行的所有入列操作，以及队列当前的状态：</p><p><img src="/2018/10/12/cjvqhlso9000vrcvbitjnex2k/queue-02.png" alt="队列添加元素"></p><p>然后，出列两个元素（执行两次dequeue方法）。下图展示了dequeue方法的执行过程：</p><p><img src="/2018/10/12/cjvqhlso9000vrcvbitjnex2k/queue-03.png" alt="队列添加元素"></p><p>最后，再次打印队列内容时，就只剩Camila一个元素了。前两个入列的元素出列了，最后入列的元素也将是最后出列的。也就是说，我们遵循了先进先出原则。</p><h2 id="二、用ECMAscript6语法实现的Queue类"><a href="#二、用ECMAscript6语法实现的Queue类" class="headerlink" title="二、用ECMAscript6语法实现的Queue类"></a>二、用ECMAscript6语法实现的Queue类</h2><p>和Stack类一样，我们也可以用ECMAScript 6语法编写Queue类。在这种方法中，我们要用一个WeakMap来保存私有属性items，并用外层函数（闭包）来封装Queue类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Queue = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            items.set(<span class="keyword">this</span>, []);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(element) &#123;</span><br><span class="line">            items.get(<span class="keyword">this</span>).push(element)</span><br><span class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dequeue() &#123;</span><br><span class="line">            items.get(<span class="keyword">this</span>).shift();</span><br><span class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"><span class="built_in">console</span>.log(queue.enqueue(<span class="number">10</span>)); <span class="comment">//[10]</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.enqueue(<span class="number">11</span>)); <span class="comment">//[10,11]</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.dequeue());   <span class="comment">//[11]</span></span><br></pre></td></tr></table></figure><h2 id="三、优先队列"><a href="#三、优先队列" class="headerlink" title="三、优先队列"></a>三、优先队列</h2><p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些修改版本。</p><p>其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和妇（或带小孩的妇女）登机时也享有高于其他乘客的优先级。</p><p>另一个现实中的例子是医院的（急诊科）候诊室。医生会优先处理病情比较严重的患者。通常，护士会鉴别分类，根据患者病情的严重程度放号。</p><p>实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此可以对它们使用默认的出列操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PriorityQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span>(<span class="params">element, priority</span>) </span>&#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items)</span><br><span class="line">        <span class="keyword">let</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority);</span><br><span class="line">        <span class="keyword">let</span> added = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queueElement.priority &lt; items[i].priority) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">                items.splice(i, <span class="number">0</span>, queueElement); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">                added = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">            items.push(queueElement); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;items[i].element&#125;</span> -</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;items[i].priority&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//其他方法和默认的Queue实现相同</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">priorityQueue.enqueue(<span class="string">"John"</span>, <span class="number">2</span>);</span><br><span class="line">priorityQueue.enqueue(<span class="string">"Jack"</span>, <span class="number">1</span>);</span><br><span class="line">priorityQueue.enqueue(<span class="string">"Camila"</span>, <span class="number">1</span>);</span><br><span class="line">priorityQueue.print();</span><br></pre></td></tr></table></figure><p>默认的Queue类和PriorityQueue类实现上的区别是，要向PriorityQueue添加元素，需要创建一个特殊的元素（行{1}）。这个元素包含了要添加到队列的元素（它可以是任意类型）及其在队列中的优先级。</p><p>如果队列为空，可以直接将元素入列（行{2}）。否则，就需要比较该元素与其他元素的优先级。当找到一个比要添加的元素的priority值更大（优先级更低）的项时，就把新元素插入到它之前（根据这个逻辑，对于其他优先级相同，但是先添加到队列的元素，我们同样遵循先进先出的原则）。要做到这一点，我们可以用第2章学习过的JavaScript的array类的splice方法。一旦找到priority值更大的元素，就插入新元素（行{3}）并终止队列循环（行{4}）。这样，队列也就根据优先级排序了。</p><p>如果要添加元素的priority值大于任何已有的元素，把它添加到队列的末尾就行了（行{5}）:</p><blockquote><p>let priorityQueue = new PriorityQueue();<br>priorityQueue.enqueue(“John”, 2);<br>priorityQueue.enqueue(“Jack”, 1);<br>priorityQueue.enqueue(“Camila”, 1);<br>priorityQueue.print(); </p></blockquote><p>以上代码是一个使用PriorityQueue类的示例。在下图中可以看到每条命令的结果（以上代码的结果）</p><p><img src="/2018/10/12/cjvqhlso9000vrcvbitjnex2k/queue-04.png" alt="优先队列执行过程"></p><p>第一个被添加的元素是优先级为2的John。因为此前队列为空，所以它是队列中唯一的元素。接下来，添加了优先级为1的Jack。由于Jack的优先级高于John，它就成了队列中的第一个元素。然后，添加了优先级也为1的Camila。Camila的优先级和Jack相同，所以它会被插入到Jack之后（因为Jack先被插入队列）；Camila的优先级高于John，所以它会被插入到John之前。</p><p>我们在这里实现的优先队列称为最小优先队列，因为优先级的值较小的元素被放置在队列最前面（1代表更高的优先级）。最大优先队列则与之相反，把优先级的值较大的元素放置在队列最前面。</p><h2 id="四、循环队列——击鼓传花"><a href="#四、循环队列——击鼓传花" class="headerlink" title="四、循环队列——击鼓传花"></a>四、循环队列——击鼓传花</h2><p>还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏（HotPotato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子（胜者）。</p><p>在下面这个示例中，我们要实现一个模拟的击鼓传花游戏：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Queue = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            items.set(<span class="keyword">this</span>, []);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(element) &#123;</span><br><span class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).push(element)</span><br><span class="line">            <span class="comment">// return items.get(this);</span></span><br><span class="line">        &#125;</span><br><span class="line">        dequeue() &#123;</span><br><span class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).shift();</span><br><span class="line">            <span class="comment">// return items.get(this);</span></span><br><span class="line">        &#125;</span><br><span class="line">        size() &#123;</span><br><span class="line">            <span class="keyword">return</span> items.get(<span class="keyword">this</span>).length;</span><br><span class="line">        &#125;</span><br><span class="line">        print() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(items.get(<span class="keyword">this</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue(); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">        queue.enqueue(nameList[i]); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> eliminated = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue()); <span class="comment">// &#123;3&#125; John</span></span><br><span class="line">            queue.print()</span><br><span class="line">        &#125;</span><br><span class="line">        eliminated = queue.dequeue();<span class="comment">// &#123;4&#125;  //</span></span><br><span class="line">        <span class="built_in">console</span>.log(eliminated + <span class="string">'在击鼓传花游戏中被淘汰。'</span>); <span class="comment">//Camila,Jack,Carl,Ingrid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.dequeue();<span class="comment">// &#123;5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'Camila'</span>, <span class="string">'Ingrid'</span>, <span class="string">'Carl'</span>]; </span><br><span class="line"><span class="keyword">let</span> winner = hotPotato(names, <span class="number">7</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'The winner is: '</span> + winner); <span class="comment">//The winner is: John</span></span><br></pre></td></tr></table></figure><p>实现一个模拟的击鼓传花游戏，要用到实现的Queue类（行{1}）。我们会得到一份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被淘汰的威胁立刻就解除了）。一旦传递次数达到给定的数字，拿着花的那个人就被淘汰了（从队列中移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）。</p><p>以上算法的输出如下：</p><blockquote><p>Camila在击鼓传花游戏中被淘汰。<br>Jack在击鼓传花游戏中被淘汰。<br>Carl在击鼓传花游戏中被淘汰。<br>Ingrid在击鼓传花游戏中被淘汰。<br>胜利者：John </p></blockquote><p>下图模拟了这个输出过程：</p><p><img src="/2018/10/12/cjvqhlso9000vrcvbitjnex2k/queue-05.png" alt="击鼓传花游戏算法"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、队列数据结构&quot;&gt;&lt;a href=&quot;#一、队列数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、队列数据结构&quot;&gt;&lt;/a&gt;一、队列数据结构&lt;/h2&gt;&lt;p&gt;队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法三（栈）</title>
    <link href="https://www.23ybob.club/2018/09/28/cjvqhlso4000prcvbygjmntoc/"/>
    <id>https://www.23ybob.club/2018/09/28/cjvqhlso4000prcvbygjmntoc/</id>
    <published>2018-09-28T09:58:31.000Z</published>
    <updated>2019-03-25T06:35:40.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、栈数据结构"><a href="#一、栈数据结构" class="headerlink" title="一、栈数据结构"></a>一、栈数据结构</h2><p>栈是一种遵从后进先出(LIFO)原则的有序数据集合。新添加的或者待删除的元素保存在栈的同一端称为栈顶，另一端称为栈底。在栈里新添加的元素都靠近栈顶，旧添加的元素都接近栈底</p><h3 id="1-1-创建栈"><a href="#1-1-创建栈" class="headerlink" title="1.1 创建栈"></a>1.1 创建栈</h3><p>先创建一个类表示栈，先声明一个类：</p><pre><code>function Stack() {    //各种属性和方法的声明} </code></pre><p>首先，我们需要一种数据结构来保存栈里的元素。可以选择数组：</p><pre><code>let items = [];</code></pre><p>接下来，要为我们的栈声明一些方法。</p><ul><li>push(element(s))：添加一个（或几个）新元素到栈顶。</li><li>pop()：移除栈顶的元素，同时返回被移除的元素。</li><li>peek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。</li><li>isEmpty()：如果栈里没有任何元素就返回true，否则返回false。</li><li>clear()：移除栈里的所有元素。</li><li>size()：返回栈里的元素个数。这个方法和数组的length属性很类似。</li></ul><h3 id="1-2-像栈中添加元素"><a href="#1-2-像栈中添加元素" class="headerlink" title="1.2 像栈中添加元素"></a>1.2 像栈中添加元素</h3><p>我们要实现的第一个方法是push。这个方法负责往栈里添加新元素，有一点很重要：该方法只添加元素到栈顶，也就是栈的末尾。push方法可以这样写：</p><pre><code>this.push = function(element){    items.push(element);}; </code></pre><h3 id="1-3-从栈中移除元素"><a href="#1-3-从栈中移除元素" class="headerlink" title="1.3 从栈中移除元素"></a>1.3 从栈中移除元素</h3><p>接着，我们来实现pop方法。这个方法主要用来移除栈里的元素。栈遵从LIFO原则，因此移出的是最后添加进去的元素。因此，我们可以用数组的pop方法。栈的pop方法可以这样写：</p><pre><code>this.pop = function(){    return items.pop();}; </code></pre><h3 id="1-4-查看栈顶元素"><a href="#1-4-查看栈顶元素" class="headerlink" title="1.4 查看栈顶元素"></a>1.4 查看栈顶元素</h3><p>现在，为我们的类实现一些额外的辅助方法。如果想知道栈里最后添加的元素是什么，可以用peek方法。这个方法将返回栈顶的元素：</p><pre><code>this.peek = function(){    return items[items.length-1];}; </code></pre><h3 id="1-5-检测栈是否为空"><a href="#1-5-检测栈是否为空" class="headerlink" title="1.5 检测栈是否为空"></a>1.5 检测栈是否为空</h3><p>下一个要实现的方法是 isEmpty，如果栈为空的话将返回true，否则就返回false：</p><pre><code>this.isEmpty = function(){    return items.length == 0;};</code></pre><p>使用isEmpty方法，我们能简单地判断内部数组的长度是否为0。</p><p>类似于数组的length属性，我们也能实现栈的length。对于集合，最好用size代替length。因为栈的内部使用数组保存元素，所以能简单地返回栈的长度：</p><pre><code>this.size = function(){    return items.length;}; </code></pre><h3 id="1-6-清空和打印栈元素"><a href="#1-6-清空和打印栈元素" class="headerlink" title="1.6 清空和打印栈元素"></a>1.6 清空和打印栈元素</h3><p>最后，我们来实现clear方法。clear方法用来移除栈里所有的元素，把栈清空。实现这个方法最简单的方式是：</p><pre><code>this.clear = function(){    items = [];}; </code></pre><p>另外也可以多次调用pop方法，把数组中的元素全部移除，这样也能实现clear方法。</p><p>如下案例，为了检查栈里的内容，实现一个辅助方法print。它会把栈里的元素都输出到控制台：</p><pre><code>this.print = function(){    console.log(items.toString());}; </code></pre><h3 id="1-7-使用Stack类"><a href="#1-7-使用Stack类" class="headerlink" title="1.7 使用Stack类"></a>1.7 使用Stack类</h3><p>首先，我们需要初始化Stack类。然后，验证一下栈是否为空（输出是true，因为还没有往栈里添加元素）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.pop();</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        items = [];</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = [];</span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>接下来，往栈里添加一些元素（这里我们添加数字5和8；你可以添加任意类型的元素）: </p><pre><code>Stack.push(5);Stack.push(8);</code></pre><p>如果调用peek方法，将会输出8，因为它是往栈里添加的最后一个元素：</p><pre><code>console.log(stack.peek()); //输出8 </code></pre><p>再添加一个元素：</p><pre><code>stack.push(11);console.log(stack.size()); //输出3console.log(stack.isEmpty()); //输出false </code></pre><p>我们往栈里添加了11。如果调用size方法，输出为3，因为栈里有三个元素（5、8和11）。如果我们调用isEmpty方法，会看到输出了false（因为栈里有三个元素，不是空栈）。最后，我们再添加一个元素：</p><pre><code>stack.push(15); </code></pre><p>下图描绘了目前为止我们对栈的操作，以及栈的当前状态：</p><p><img src="/2018/09/28/cjvqhlso4000prcvbygjmntoc/stack-01.png" alt="栈状态描述"></p><p>然后，调用两次pop方法从栈里移除2个元素：</p><pre><code>stack.pop();stack.pop();console.log(stack.size()); //输出2stack.print(); //输出[5, 8] </code></pre><p>在两次调用pop方法前，我们的栈里有四个元素。调用两次后，现在栈里仅剩下5和8了。下图描绘这个过程的执行：</p><p><img src="/2018/09/28/cjvqhlso4000prcvbygjmntoc/stack-02.png" alt="栈状态描述"></p><h2 id="二、ECMAScript-6-和-Stack-类"><a href="#二、ECMAScript-6-和-Stack-类" class="headerlink" title="二、ECMAScript 6 和 Stack 类"></a>二、ECMAScript 6 和 Stack 类</h2><h3 id="2-1-用-ES6-语法声明-Stack-类"><a href="#2-1-用-ES6-语法声明-Stack-类" class="headerlink" title="2.1 用 ES6 语法声明 Stack 类"></a>2.1 用 ES6 语法声明 Stack 类</h3><pre><code>class Stack {    constructor () {        this.items = []; //{1}    }    push(element){        this.items.push(element);    }    //其他方法} </code></pre><p>我们只是用ES6的简化语法把Stack函数转换成Stack类。这种方法不能像其他语言（Java、C++、C#）一样直接在类里面声明变量，只能在类的构造函数constructor里声明（行{1}，在类的其他函数里用this.nameofVariable就可以引用这个变量。</p><p>尽管代码看起来更简洁、更漂亮，变量items却是公共的。ES6的类是基于原型的。虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性（变量）或方法。而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法。否则，就有可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。</p><h4 id="2-1-1-用ES6的限定作用域Symbol实现类"><a href="#2-1-1-用ES6的限定作用域Symbol实现类" class="headerlink" title="2.1.1 用ES6的限定作用域Symbol实现类"></a>2.1.1 用ES6的限定作用域Symbol实现类</h4><p>ES6新增了一种叫作Symbol的基本类型，它是不可变的，可以用作对象的属性。</p><pre><code>let _items = Symbol(); //{1}class Stack {    constructor () {        this[_items] = []; //{2}    }    //Stack方法} </code></pre><p>在上面的代码中，我们声明了Symbol类型的变量_items（行{1}），在类的constructor函数中初始化它的值（行{2}）。要访问_items，只需把所有的this.items都换成this[_items]。 </p><p>这种方法创建了一个假的私有属性，因为ES6新增的Object.getOwnPropertySymbols方法能够取到类里面声明的所有Symbols属性。下面是一个破坏Stack类的例子：</p><pre><code>let _items = Symbol(); class Stack {    constructor() {        this[_items] = [];     }    push(element) {        return this[_items].push(element);    };    print() {        console.log(this[_items].toString());    };} let stack = new Stack();stack.push(5);stack.push(8);let objectSymbols = Object.getOwnPropertySymbols(stack);console.log(objectSymbols.length); // 1console.log(objectSymbols); // [Symbol()]console.log(objectSymbols[0]); // Symbol()stack[objectSymbols[0]].push(1); stack.print(); //输出 5, 8, 1</code></pre><p>从以上代码可以看到，访问stack[objectSymbols[0]]是可以得到_items的。并且，_items属性是一个数组，可以进行任意的数组操作，比如从中间删除或添加元素。我们操作的是栈，不应该出现这种行为。</p><h4 id="2-1-2-用ES6的WeakMap实现类"><a href="#2-1-2-用ES6的WeakMap实现类" class="headerlink" title="2.1.2 用ES6的WeakMap实现类"></a>2.1.2 用ES6的WeakMap实现类</h4><p>有一种数据类型可以确保属性是私有的，这就是WeakMap。WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。</p><p>如果用WeakMap来存储items变量，Stack类就是这样的：</p><pre><code>const items = new WeakMap(); //{1}class Stack {    constructor () {        items.set(this, []); //{2}    }    push(element) {        let s = items.get(this); //{3}        s.push(element);    }    pop() {        let s = items.get(this);        let r = s.pop();        return r;    }    //其他方法} //行{1}，声明一个WeakMap类型的变量items。//行{2}，在constructor中，以this（Stack类自己的引用）为键，把代表栈的数组存入items。//行{3}，从WeakMap中取出值，即以this为键（行{2}设置的）从items中取值。</code></pre><p>现在我们知道，items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap：</p><pre><code>let Stack = (function () {    const items = new WeakMap();    class Stack {        constructor () {            items.set(this, []);        }        //其他方法    }     return Stack; //{5}})(); //当Stack函数里的构造函数被调用时，会返回Stack类的一个实例（行{5}）。</code></pre><p>现在，Stack类有一个名为items的私有属性。虽然它很丑陋，但毕竟实现了私有属性。然而，用这种方法的话，扩展类无法继承私有属性。鱼与熊掌不可兼得！</p><p>把上面的代码跟本章最初实现的Stack类做个比较，我们会发现有一些相似之处：</p><pre><code>function Stack() {    let items = [];    //其他方法} </code></pre><p>事实上，尽管ES6引入了类的语法，我们仍然不能像在其他编程语言中一样声明私有属性或方法。有很多种方法都可以达到相同的效果，但无论是语法还是性能，这些方法都有各自的优点和缺点</p><p>哪种方法更好？这取决于你在实际项目中如何使用本书中这些算法，要处理的数据量，要创建的实例个数，以及其他约束条件。最终，还是取决于你。</p><h3 id="2-2-用栈解决问题"><a href="#2-2-用栈解决问题" class="headerlink" title="2.2 用栈解决问题"></a>2.2 用栈解决问题</h3><p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后续再讨论图和回溯问题时，我们会学习如何应用这个例子）。Java和C#用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。</p><h4 id="2-2-1-从十进制到二进制"><a href="#2-2-1-从十进制到二进制" class="headerlink" title="2.2.1 从十进制到二进制"></a>2.2.1 从十进制到二进制</h4><p>现实生活中，我们主要使用十进制。但在计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的（0和1）。没有十进制和二进制相互转化的能力，与计算机交流就很困难。</p><p>要把十进制转化成二进制，我们可以将该十进制数字和2整除（二进制是满二进一），直到结果是0为止。举个例子，把十进制的数字10转化成二进制的数字，过程大概是这样：</p><p><img src="/2018/09/28/cjvqhlso4000prcvbygjmntoc/stack-03.png" alt="十进制转二进制"></p><p>大学的计算机课一般都会先教这个进制转换。下面是对应的算法描述：</p><pre><code>let Stack = (function () {    const items = new WeakMap();    class Stack {        constructor() {            items.set(this, []);        }        push(element) {            items.get(this).push(element);        }        pop() {            return items.get(this).pop();        }        isEmpty() {            return items.get(this).length == 0;        };    }    return Stack; })();function divideBy2(decNumber) {    var remStack = new Stack(),        rem,        binaryString = &apos;&apos;;    while (decNumber &gt; 0) { //{1}        rem = Math.floor(decNumber % 2); //{2}        remStack.push(rem); //{3}        decNumber = Math.floor(decNumber / 2); //{4}    }    while (!remStack.isEmpty()) {         binaryString += remStack.pop().toString(); //{5}    }    return binaryString;} console.log(divideBy2(13)); //1101</code></pre><p>在这段代码里，当结果满足和2做整除的条件时（行{2}），我们会获得当前结果和2的余数，放到栈里（行{2}、{3}）。然后让结果和2做整除（行{4}）。另外请注意：JavaScript有数字类型，但是它不会区分究竟是整数还是浮点数。因此，要使用Math.floor函数让除法的操作仅返回整数部分。最后，用pop方法把栈中的元素都移除，把出栈的元素变成连接成字符串（行{5}）。</p><h4 id="2-2-2-进制转换算法"><a href="#2-2-2-进制转换算法" class="headerlink" title="2.2.2 进制转换算法"></a>2.2.2 进制转换算法</h4><p>我们很容易修改之前的算法，使之能把十进制转换成任何进制。除了让十进制数字和2整除转成二进制数，还可以传入其他任意进制的基数为参数，就像下面算法这样：</p><pre><code>let Stack = (function () {    const items = new WeakMap();    class Stack {        constructor() {            items.set(this, []);        }        push(element) {            items.get(this).push(element);        }        pop() {            return items.get(this).pop()        }        isEmpty() {            return items.get(this).length == 0;        };    }    return Stack; //{5}})();function baseConverter(decNumber, base) {    var remStack = new Stack(),        rem,        baseString = &apos;&apos;,        digits = &apos;0123456789ABCDEF&apos;; //{6}    while (decNumber &gt; 0) {        rem = Math.floor(decNumber % base);        remStack.push(rem);        decNumber = Math.floor(decNumber / base);    }    while (!remStack.isEmpty()) {        baseString += digits[remStack.pop()]; //{7}    }    return baseString;} console.log(baseConverter(13,2)); //1101console.log(baseConverter(13,8)); //15</code></pre><p>我们只需要改变一个地方。在将十进制转成二进制时，余数是0或1；在将十进制转成八进制时，余数是0到7之间的数；但是将十进制转成16进制时，余数是0到9之间的数字加上A、B、C、D、E和F（对应10、11、12、13、14和15）。因此，我们需要对栈中的数字做个转化才可以（行{6}和行{7}）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、栈数据结构&quot;&gt;&lt;a href=&quot;#一、栈数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、栈数据结构&quot;&gt;&lt;/a&gt;一、栈数据结构&lt;/h2&gt;&lt;p&gt;栈是一种遵从后进先出(LIFO)原则的有序数据集合。新添加的或者待删除的元素保存在栈的同一端称为栈顶
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法二（数组的使用）</title>
    <link href="https://www.23ybob.club/2018/09/10/cjvqhlsti0012rcvbs6zjfwhk/"/>
    <id>https://www.23ybob.club/2018/09/10/cjvqhlsti0012rcvbs6zjfwhk/</id>
    <published>2018-09-10T11:24:31.000Z</published>
    <updated>2019-03-04T09:24:33.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、创建和初始化数组"><a href="#一、创建和初始化数组" class="headerlink" title="一、创建和初始化数组"></a>一、创建和初始化数组</h3><h4 id="1-1-创建数组"><a href="#1-1-创建数组" class="headerlink" title="1.1 创建数组"></a>1.1 创建数组</h4><p>用JavaScript声明、创建和初始化数组有两种方式</p><pre><code>//使用new创建数组var daysOfWeek = new Array(); //{1}var daysOfWeek = new Array(7); //{2}var daysOfWeek = new Array(&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;,&apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;); //{3}使用new关键字，就能简单地声明并初始化一个数组（行{1}）。用这种方式，还可以创建一个指定长度的数组（行{2}）。另外，也可以直接将数组元素作为参数传递给它的构造器（行{3}）。//使用[]创建数组var daysOfWeek = [];也可使用一些元素初始化数组，如下：var daysOfWeek = [&apos;Sunday&apos;, &apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;,&apos;Thursday&apos;, &apos;Friday&apos;, &apos;Saturday&apos;]; 使用数组的length属性获取数组的长度console.log(daysOfWeek.length); //7</code></pre><h4 id="1-2-访问元素和迭代数组"><a href="#1-2-访问元素和迭代数组" class="headerlink" title="1.2 访问元素和迭代数组"></a>1.2 访问元素和迭代数组</h4><p>要访问数组里特定位置的元素，可以用中括号传递数值位置，得到想知道的值或者赋新的值。如下：</p><pre><code>for (var i=0; i&lt;daysOfWeek.length; i++){    console.log(daysOfWeek[i]);} </code></pre><p>我们来看另一个例子：求斐波那契数列的前20个数字。已知斐波那契数列中第一个数字是1，<br>第二个是2，从第三项开始，每一项都等于前两项之和：</p><pre><code>var fibonacci = []; //{1}fibonacci[1] = 1; //{2}fibonacci[2] = 2; //{3}for(var i = 3; i &lt; 20; i++){    fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]; ////{4}}for(var i = 1; i&lt;fibonacci.length; i++){ //{5}    console.log(fibonacci[i]); //{6}} 在行{1}处，我们声明并创建了一个数组。在行{2}和行{3}，把斐波那契数列中的前两个数字分别赋给了数组的第二和第三位（在JavaScript中，数组的第一位是0，这里我们略过，从第二位开始分别保存斐波那契数列中对应位置的元素）。然后，我们需要做的就是想办法得到斐波那契数列的第三到第二十位的数字（前两个值我们已经初始化过了）。我们可以用循环来处理，把数组中前两位上的元素相加，结果赋给当前位置上的元素（行{4}——从数组中的索引3到索引19）。最后，看看输出（行{6}），我们只需要循环遍历数组的各个元素（行{5}）。</code></pre><h4 id="1-3-添加元素"><a href="#1-3-添加元素" class="headerlink" title="1.3 添加元素"></a>1.3 添加元素</h4><h5 id="1-3-1-使用数组索引直接添加"><a href="#1-3-1-使用数组索引直接添加" class="headerlink" title="1.3.1 使用数组索引直接添加"></a>1.3.1 使用数组索引直接添加</h5><pre><code>var numbers = [0,1,2,3,4,5,6,7,8,9];如果想要给数组添加一个元素（比如10），只要把值赋给数组中最后一个空位上的元素即可。numbers[numbers.length] = 10; </code></pre><h5 id="1-3-2-使用push方法"><a href="#1-3-2-使用push方法" class="headerlink" title="1.3.2 使用push方法"></a>1.3.2 使用push方法</h5><p>push方法，能把元素添加到数组的末尾</p><pre><code>numbers.push(11);numbers.push(12, 13); </code></pre><h5 id="1-3-3-插入元素到数组首位"><a href="#1-3-3-插入元素到数组首位" class="headerlink" title="1.3.3 插入元素到数组首位"></a>1.3.3 插入元素到数组首位</h5><p>现在，我们希望在数组中插入一个值，不像之前那样插入到最后，而是放到数组的首位。为了实现这个需求，首先我们要腾出数组里第一个元素的位置，把所有的元素向右移动一位。我们可以循环数组中的元素，从最后一位+1（长度）开始，将其对应的前一个元素的值赋给它，依次处理，最后把我们想要的值赋给第一个位置（-1）上。</p><pre><code>for (var i=numbers.length; i&gt;=0; i--){    numbers[i] = numbers[i-1];}numbers[0] = -1; </code></pre><p>下面这张图描述了我们刚才的操作过程：</p><p><img src="/2018/09/10/cjvqhlsti0012rcvbs6zjfwhk/shift.png" alt="插入元素到数组首位">;</p><pre><code>也可以使用unshift方法numbers.unshift(-2);numbers.unshift(-4, -3);</code></pre><h4 id="1-4-删除元素"><a href="#1-4-删除元素" class="headerlink" title="1.4 删除元素"></a>1.4 删除元素</h4><h5 id="1-4-1-删除数组里最靠后的元素"><a href="#1-4-1-删除数组里最靠后的元素" class="headerlink" title="1.4.1 删除数组里最靠后的元素"></a>1.4.1 删除数组里最靠后的元素</h5><pre><code>删除数组里最靠后的元素使用pop方法：numbers.pop();</code></pre><h5 id="1-4-2-从数组首位删除元素"><a href="#1-4-2-从数组首位删除元素" class="headerlink" title="1.4.2 从数组首位删除元素"></a>1.4.2 从数组首位删除元素</h5><p>如果要移除数组里的第一个元素，可以用下面的代码：</p><pre><code>for (var i = 0; i &lt; numbers.length; i++){    numbers[i] = numbers[i+1];} </code></pre><p>下面这张图呈现了这段代码的执行过程：</p><p><img src="/2018/09/10/cjvqhlsti0012rcvbs6zjfwhk/shift.png" alt="从数组首位删除元素"></p><pre><code>我们把数组里所有的元素都左移了一位。但数组的长度依然是17，这意味着数组中有额外的一个元素（值是undefined）。在最后一次循环里，i + 1引用了一个数组里还未初始化的位置。在Java、C/C+或C#等一些语言里，这样写可能就会抛出异常了，因此不得不在 numbers.length- 1处停止循环。可以看到，我们只是把数组第一位的值用第二位覆盖了，并没有删除元素（因为数组的长度和之前还是一样的，并且了多一个未定义元素）。</code></pre><p>使用unshift()方法</p><pre><code>numbers.shift(); //通过shift和unshift方法，就能用数组模拟基本的队列数据结构，</code></pre><h5 id="1-4-3-在任意位置添加或删除元素"><a href="#1-4-3-在任意位置添加或删除元素" class="headerlink" title="1.4.3 在任意位置添加或删除元素"></a>1.4.3 在任意位置添加或删除元素</h5><p>使用splice方法，简单地通过指定位置/索引，就可以删除相应位置和数量的元素： //如下</p><pre><code>numbers.splice(5,3); //这行代码删除了从数组索引5开始的3个元素。这就意味着numbers[5]、numbers[6]和numbers[7]从数组中删除了。</code></pre><p>splice方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除元素的个数（这个例子里，我们的目的不是删除元素，所以传入0）。第三个参数往后，就是要添加到数组里的值（元素2、3、4）。输出会发现值又变成了从3到12。</p><pre><code>numbers.splice(5,3,2,3,4);//我们从索引5开始删除了3个元素，但也从索引5开始添加了元素2、3、4</code></pre><p>对于JavaScript数组和对象，我们还可以用delete操作符删除数组中的元素，例如delete numbers[0]。然而，数组位置0的值会变成undefined，也就是说，以上操作等同于numbers[0] = undefined。因此，我们应该始终使用splice、pop或shift（马上就会学到）方法来删除数组元素。</p><h3 id="二、-二维和多维数组"><a href="#二、-二维和多维数组" class="headerlink" title="二、 二维和多维数组"></a>二、 二维和多维数组</h3><p>JavaScript只支持一维数组，并不支持矩阵(二维数组)。但是，我们可以用数组套数组，实现矩阵或任一多维数组。代码也可以写成这样：</p><pre><code>var averageTemp = [];averageTemp[0] = [];averageTemp[0][0] = 72;averageTemp[0][1] = 75;averageTemp[0][2] = 79;averageTemp[0][3] = 79;averageTemp[0][4] = 81;averageTemp[0][5] = 81;//day 2averageTemp[1] = [];averageTemp[1][0] = 81;averageTemp[1][1] = 79;averageTemp[1][2] = 75;averageTemp[1][3] = 75;averageTemp[1][4] = 73;averageTemp[1][5] = 72; </code></pre><p>上面的代码里，我们分别指定了每天和每小时的数据。数组中的内容如下图所示：</p><p><img src="/2018/09/10/cjvqhlsti0012rcvbs6zjfwhk/images-01.png" alt="每天和每小时的数据"></p><p>每行就是每天的数据，每列是当天不同时段的气温</p><h4 id="2-1-迭代二维数组的元素"><a href="#2-1-迭代二维数组的元素" class="headerlink" title="2.1 迭代二维数组的元素"></a>2.1 迭代二维数组的元素</h4><p>如果想看矩阵的输出，我们可以创建一个通用函数，专门输出其中的值：</p><pre><code>function printMatrix(myMatrix) {    for (var i=0; i&lt;myMatrix.length; i++){         for (var j=0; j&lt;myMatrix[i].length; j++){            console.log(myMatrix[i][j]);        }    }} 需要遍历所有的行和列。因此，我们需要使用一个嵌套的for循环来处理，其中变量i为行，变量j为列。使用以下代码查看矩阵averageTemp的输出：printMatrix(averageTemp); </code></pre><h4 id="2-2-多维数组"><a href="#2-2-多维数组" class="headerlink" title="2.2 多维数组"></a>2.2 多维数组</h4><p>我们也可以用这种方式来处理多维数组。假如我们要创建一个3×3×3的矩阵，每一格里包含矩阵的i（行）、j（列）及z（深度）之和：</p><pre><code>var matrix3x3x3 = [];for (var i=0; i&lt;3; i++){    matrix3x3x3[i] = [];    for (var j=0; j&lt;3; j++){        matrix3x3x3[i][j] = [];        for (var z=0; z&lt;3; z++){            matrix3x3x3[i][j][z] = i+j+z;        }    }}</code></pre><p>数据结构中有几个维度都没关系，我们都可以用循环遍历每个维度来访问所有格子。3×3×3的矩阵也可用立体图表示如下：</p><p><img src="/2018/09/10/cjvqhlsti0012rcvbs6zjfwhk/images-02.png" alt="3×3×3的矩阵"></p><p>可以用以下代码输出这个矩阵的内容：</p><pre><code>for (var i=0; i&lt;matrix3x3x3.length; i++){    for (var j=0; j&lt;matrix3x3x3[i].length; j++){        for (var z=0; z&lt;matrix3x3x3[i][j].length; z++){            console.log(matrix3x3x3[i][j][z]);        }    }} </code></pre><p>如果是一个3×3×3×3的矩阵，代码中就会用四层嵌套的for语句，以此类推。</p><h4 id="2-3-JavaScript-的数组方法参考"><a href="#2-3-JavaScript-的数组方法参考" class="headerlink" title="2.3 JavaScript 的数组方法参考"></a>2.3 JavaScript 的数组方法参考</h4><table><thead><tr><th>方法名</th><th style="text-align:center">语法</th></tr></thead><tbody><tr><td>concat</td><td style="text-align:center">连接数组（一个或多个），返回连接后的结果</td></tr><tr><td>every</td><td style="text-align:center">对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true</td></tr><tr><td>filter</td><td style="text-align:center">对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组</td></tr><tr><td>forEach</td><td style="text-align:center">遍历数组</td></tr><tr><td>join</td><td style="text-align:center">将所有的数组元素连接成一个字符串</td></tr><tr><td>indexOf</td><td style="text-align:center">从数组开始查找数组元素在数组中的的位置，并返回，没有找到则返回-1 </td></tr><tr><td>lastIndexOf</td><td style="text-align:center">从数组结尾查找数组元素在数组中的的位置，并返回，没有找到则返回-1</td></tr><tr><td>map</td><td style="text-align:center">遍历数组元素，并返回</td></tr><tr><td>reverse</td><td style="text-align:center">颠倒数组中元素的顺序</td></tr><tr><td>slice</td><td style="text-align:center">截取数组中的元素</td></tr><tr><td>some</td><td style="text-align:center">对数组中的每一项运行给定函数，如果任一项返回true，则返回true</td></tr><tr><td>sort</td><td style="text-align:center">按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数</td></tr><tr><td>toString</td><td style="text-align:center">将数组作为字符串返回</td></tr><tr><td>valueOf</td><td style="text-align:center">和toString类似，将数组作为字符串返回</td></tr></tbody></table><h5 id="2-3-1-数组合并"><a href="#2-3-1-数组合并" class="headerlink" title="2.3.1 数组合并"></a>2.3.1 数组合并</h5><p>concat方法可以向一个数组传递数组、对象或是元素。数组会按照该方法传入的参数顺序连接指定数组。如下：</p><pre><code>var zero = 0;var positiveNumbers = [1,2,3];var negativeNumbers = [-3,-2,-1];var numbers = negativeNumbers.concat(zero, positiveNumbers);  //[3,2,1,0,1,2,3]</code></pre><h5 id="2-3-1-迭代器函数"><a href="#2-3-1-迭代器函数" class="headerlink" title="2.3.1 迭代器函数"></a>2.3.1 迭代器函数</h5><p>迭代数组中的元素可以使用for循环，同样JavaScript内置了许多数组可用的迭代方法</p><p>解决如下案例：</p><p>假如有一个数组，它值是从1到15，如果数组里的元素可以被2整除（偶数），函数就返回true，否则返回false：</p><pre><code>var isEven = function (x) {    // 如果x是2的倍数，就返回true    console.log(x);    return (x % 2 == 0) ? true : false;};var numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; </code></pre><ul><li><p>用every方法迭代</p><p>  numbers.every(isEven);  //false</p><p>  //数组numbers的第一个元素是1，它不是2的倍数（1是奇数），因此isEven 函数返回false，然后every执行结束。</p></li><li><p>用some方法迭代</p></li></ul><p>some方法会迭代数组的每个元素，直到函数返回true：</p><pre><code>numbers.some(isEven); //numbers数组中第一个偶数是2（第二个元素）。第一个被迭代的元素是1，isEven会返回false。第二个被迭代的元素是2，isEven返回true——迭代结束。</code></pre><ul><li><p>用forEach方法迭代</p><p> numbers.forEach(function(x){</p><pre><code>console.log((x % 2 == 0));</code></pre><p> }); </p></li><li><p>使用map和filter方法</p><p>  var myMap = numbers.map(isEven); </p><p>  //[false, true, false, true, false, true, false, true,false, true, false, true, false, true, false]。</p><p>  filter方法返回新数组由使函数返回true的元素组成：</p><p>  var evenNumbers = numbers.filter(isEven); </p><p>  //[2, 4, 6, 8, 10, 12, 14]</p></li><li><p>使用reduce方法</p></li></ul><p>reduce方法接收一个函数作为参数，这个函数有四个参数：previousValue、currentValue、index和array。这个函数会返回一个将被叠加到累加器的值，reduce方法停止执行后会返回这个累加器</p><pre><code>numbers.reduce(function(previous, current, index){    return previous + current; //120}); </code></pre><h4 id="2-4-ECMAScript-6-和数组的新功能"><a href="#2-4-ECMAScript-6-和数组的新功能" class="headerlink" title="2.4 ECMAScript 6 和数组的新功能"></a>2.4 ECMAScript 6 和数组的新功能</h4><p>下标展示了一些ES6和ES7新增的数组方法</p><table><thead><tr><th>方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>@@iterator</td><td style="text-align:center">返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对</td></tr><tr><td>copyWithin</td><td style="text-align:center">复制数组中一系列元素到同一数组指定的起始位置</td></tr><tr><td>entries</td><td style="text-align:center">返回包含数组所有键值对的@@iterator</td></tr><tr><td>includes</td><td style="text-align:center">如果数组中存在某个元素则返回true，否则返回false。ES7新增</td></tr><tr><td>find</td><td style="text-align:center">根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素</td></tr><tr><td>findIndex</td><td style="text-align:center">根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引-1 </td></tr><tr><td>fill</td><td style="text-align:center">用静态值填充数组-1</td></tr><tr><td>from</td><td style="text-align:center">根据已有数组创建一个新数组</td></tr><tr><td>keys</td><td style="text-align:center">返回包含数组所有索引的@@iterator</td></tr><tr><td>of</td><td style="text-align:center">根据传入的参数创建一个新数组</td></tr><tr><td>values</td><td style="text-align:center">返回包含数组中所有值的@@iterator</td></tr><tr><td>sort</td><td style="text-align:center">按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数</td></tr></tbody></table><p>除了这些新的方法，还有一种用for…of循环来迭代数组的新做法，以及可以从数组实例得到的迭代器对象</p><h5 id="2-4-1-使用forEach和箭头函数迭代"><a href="#2-4-1-使用forEach和箭头函数迭代" class="headerlink" title="2.4.1 使用forEach和箭头函数迭代"></a>2.4.1 使用forEach和箭头函数迭代</h5><p>箭头函数可以简化使用forEach迭代数组元素的做法，如下</p><pre><code>numbers.forEach(function (x) {    console.log(x % 2 == 0);});//这段代码可以简化如下：numbers.forEach(x =&gt; {    console.log((x % 2 == 0));}); </code></pre><h5 id="2-4-2-使用for…of循环迭代"><a href="#2-4-2-使用for…of循环迭代" class="headerlink" title="2.4.2 使用for…of循环迭代"></a>2.4.2 使用for…of循环迭代</h5><pre><code>for (let n of numbers) {    console.log((n % 2 == 0) ? &apos;even&apos; : &apos;odd&apos;);} </code></pre><h5 id="2-4-3-ES6新的迭代器（-iterator）"><a href="#2-4-3-ES6新的迭代器（-iterator）" class="headerlink" title="2.4.3 ES6新的迭代器（@@iterator）"></a>2.4.3 ES6新的迭代器（@@iterator）</h5><p>ES6还为Array类增加了一个@@iterator属性，需要通过Symbol.iterator来访问。代码如下:</p><pre><code>let iterator = numbers[Symbol.iterator]();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().value); // 4console.log(iterator.next().value); // 5 </code></pre><p>然后，不断调用迭代器的next方法，就能依次得到数组中的值,数组中所有值都迭代完之后，iterator.next().value会返回undefined。 </p><h5 id="2-4-4-数组的entries、keys和values方法"><a href="#2-4-4-数组的entries、keys和values方法" class="headerlink" title="2.4.4 数组的entries、keys和values方法"></a>2.4.4 数组的entries、keys和values方法</h5><ol><li>entries: 返回包含键值对的@@iterator，如下案例：</li></ol><pre><code>let numbers = [1,2,3]let aEntries = numbers.entries(); // 得到键值对的迭代器,key是数组中的位置，value是保存在数组索引的值。console.log(aEntries.next().value); // [0, 1] - 位置0的值为1console.log(aEntries.next().value); // [1, 2] - 位置1的值为2console.log(aEntries.next().value); // [2, 3] - 位置2的值为3 </code></pre><p>entries方法会返回numbers数组位置以及对应的值，如果没有可迭代的值则返回undefined。</p><ol start="2"><li>entries：方法返回包含数组索引的@@iterator，如下案例：</li></ol><pre><code>let numbers = [1,2,3]let aKeys = numbers.keys(); // 得到数组索引的迭代器console.log(aKeys.next()); // {value: 0, done: false }console.log(aKeys.next()); // {value: 1, done: false }console.log(aKeys.next()); // {value: 2, done: false } console.log(aKeys.next()); // {value: undefined, done: true } </code></pre><p>keys方法会返回numbers数组的索引。一旦没有可迭代的值，aKeys.next()就会返回一个value属性为undefined，done属性为true的对象。如果done属性的值为false，就意味着还有可迭代的值。</p><ol start="3"><li>values：方法返回的@@iterator则包含数组的值</li></ol><pre><code>let numbers = [1,2,3]let aValues = numbers.values();console.log(aValues.next()); // {value: 1, done: false }console.log(aValues.next()); // {value: 2, done: false }console.log(aValues.next()); // {value: 3, done: false } console.log(aValues.next()); // {value: undefined, done: true } </code></pre><h5 id="2-4-5-from方法"><a href="#2-4-5-from方法" class="headerlink" title="2.4.5 from方法"></a>2.4.5 from方法</h5><p>Array.from方法根据已有的数组创建一个新数组，参数为过滤Array中元素的函数</p><pre><code>let evens = Array.from(numbers, x =&gt; (x % 2 == 0)); </code></pre><h5 id="2-4-6-用Array-of方法"><a href="#2-4-6-用Array-of方法" class="headerlink" title="2.4.6 用Array.of方法"></a>2.4.6 用Array.of方法</h5><p>Array.of方法根据传入的参数创建一个新数组</p><pre><code>let numbers4 = Array.of(1, 2, 3, 4, 5, 6); //[1,2,3,4,5,6]</code></pre><p>也可以用这个方法复制已有的数组</p><pre><code>let numbersCopy = Array.of(...numbers4);  //[1,2,3,4,5,6]</code></pre><h5 id="2-4-7-使用fill方法"><a href="#2-4-7-使用fill方法" class="headerlink" title="2.4.7 使用fill方法"></a>2.4.7 使用fill方法</h5><p>fill方法用静态值填充数组,参数为要添加的位置范围</p><pre><code>let numbersCopy = Array.of(1, 2, 3, 4, 5, 6); numbersCopy.fill(0); //（[0, 0, 0, 0, 0, 0]numbersCopy.fill(1, 3, 5); //[0, 0, 0, 1, 1, 0]</code></pre><p>创建数组并初始化值的时候，fill方法非常方便，如下：</p><pre><code>let ones = Array(6).fill(1); //[1, 1, 1, 1, 1, 1]</code></pre><h5 id="2-4-8-copyWithin方法"><a href="#2-4-8-copyWithin方法" class="headerlink" title="2.4.8 copyWithin方法"></a>2.4.8 copyWithin方法</h5><p>copyWithin方法复制数组中的一系列元素到同一数组指定的起始位置</p><pre><code>let copyArray = [1, 2, 3, 4, 5, 6]; copyArray.copyWithin(0, 3); // [4, 5, 6, 4, 5, 6]   copyArray.copyWithin(1, 3, 5); //[4,4,5,4,5,6]</code></pre><h5 id="2-4-9-排序元素"><a href="#2-4-9-排序元素" class="headerlink" title="2.4.9 排序元素"></a>2.4.9 排序元素</h5><ul><li>反转数组reverse：</li></ul><pre><code>let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. 15];numbers.reverse(); //[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];</code></pre><ul><li>对数组进行排序sort：</li></ul><pre><code>numbers.sort(); //[1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9]//sort方法在对数组做排序时，把元素默认成字符串进行相互比较。//所以在使用的时候传入自己写的比较函数numbers.sort(function(a, b){    return a-b;}); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]</code></pre><ul><li>自定义排序</li></ul><p>我们可以对任何对象类型的数组排序，也可以创建compareFunction来比较元素。例如，对象Person有名字和年龄属性，我们希望根据年龄排序，就可以这么写：</p><pre><code>var friends = [    {name: &apos;John&apos;, age: 30},    {name: &apos;Ana&apos;, age: 20},    {name: &apos;Chris&apos;, age: 25}];function comparePerson(a, b){    if (a.age &lt; b.age){        return -1    }    if (a.age &gt; b.age){        return 1    }    return 0;}console.log(friends.sort(comparePerson)); //在这个例子里，最后会输出Ana(20), Chris(25), John(30)。</code></pre><ul><li>字符串排序</li></ul><p>JavaScript在做字符比较的时候，是根据字符对应的ASCII值来比较的。 如下案例：</p><pre><code>var names =[&apos;Ana&apos;, &apos;ana&apos;, &apos;john&apos;, &apos;John&apos;];console.log(names.sort());  //[&quot;Ana&quot;, &quot;John&quot;, &quot;ana&quot;, &quot;john&quot;] //因为A、J、a、j对应的ASCII值分别是65、75、97、106。</code></pre><p>现在，如果给sort传入一个忽略大小写的比较函数，将会输出[“Ana”, “ana”, “John”,”john”]：</p><pre><code>names.sort(function(a, b){    if (a.toLowerCase() &lt; b.toLowerCase()){        return -1    }    if (a.toLowerCase() &gt; b.toLowerCase()){        return 1    }    return 0;}); </code></pre><p>假如对带有重音符号的字符做排序的话，我们可以用localeCompare来实现：</p><pre><code>var names2 = [&apos;Maève&apos;, &apos;Maeve&apos;];console.log(names2.sort(function(a, b){    return a.localeCompare(b);})); //[&quot;Maeve&quot;, &quot;Maève&quot;]</code></pre><ul><li>搜索（indexOf/lastIndexOf）</li></ul><p>搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引,如果没有匹配的元素则返回-1。</p><pre><code>console.log(numbers.indexOf(10)); //9console.log(numbers.indexOf(100)); //-1</code></pre><ul><li>搜索（ECMAScript 6——find和findIndex方法）</li></ul><p>find和findIndex方法接收一个回调函数，搜索一个满足回调函数条件的值。</p><pre><code>let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];function multipleOf13(element, index, array) {    return (element % 13 == 0) ? true : false;}console.log(numbers.find(multipleOf13)); //13console.log(numbers.findIndex(multipleOf13)); //12//find和findIndex的不同之处在于，find方法返回第一个满足条件的值。//findIndex方法则返回这个值在数组里的索引。//如果没有满足条件的值，find会返回undefined，而findIndex返回-1。</code></pre><ul><li>搜索（ECMAScript 7——使用includes方法） </li></ul><p>如果数组里存在某个元素，includes方法会返回true，否则返回false。</p><pre><code>console.log(numbers.includes(15)); //trueconsole.log(numbers.includes(20));  //false</code></pre><p>如果给includes方法传入一个起始索引，搜索会从索引指定的位置开始：</p><pre><code>let numbers2 = [7, 6, 5, 4, 3, 2, 1];console.log(numbers2.includes(4, 5)); //false</code></pre><h5 id="2-4-10-输出数组为字符串"><a href="#2-4-10-输出数组为字符串" class="headerlink" title="2.4.10 输出数组为字符串"></a>2.4.10 输出数组为字符串</h5><ul><li>toString</li></ul><p>把数组里所有元素输出为一个字符串</p><pre><code>let numbers = [1, 2, 3, 4]console.log(numbers.toString()); //1,2,3,4</code></pre><p>如果想用一个不同的分隔符（比如-）把元素隔开，可以用join方法：</p><pre><code>var numbersString = numbers.join(&apos;-&apos;);console.log(numbersString); //1-2-3-4</code></pre><h4 id="三、-类型数组"><a href="#三、-类型数组" class="headerlink" title="三、 类型数组"></a>三、 类型数组</h4><p>JavaScript数组不是强类型的，因此它可以存储任意类型的数据。而类型数组则用于存储单一类型的数据。它的语法是let myArray = new TypedArray<br>(length)，其中TypedArray需替换为下表所列之一。</p><table><thead><tr><th>类型数组</th><th style="text-align:center">数据类型</th></tr></thead><tbody><tr><td>Int8Array</td><td style="text-align:center">8位二进制补码整数</td></tr><tr><td>Uint8Array</td><td style="text-align:center">8位无符号整数</td></tr><tr><td>Uint8ClampedArray</td><td style="text-align:center">8位无符号整数</td></tr><tr><td>Int16Array</td><td style="text-align:center">16位二进制补码整数</td></tr><tr><td>Uint16Array</td><td style="text-align:center">16位无符号整数</td></tr><tr><td>Int32Array</td><td style="text-align:center">32位二进制补码整数</td></tr><tr><td>Uint32Array</td><td style="text-align:center">32位无符号整数</td></tr><tr><td>Float32Array</td><td style="text-align:center">32位IEEE浮点数</td></tr><tr><td>Float64Array</td><td style="text-align:center">64位IEEE浮点数</td></tr></tbody></table><p>代码示例如下：</p><pre><code>let length = 5;let int16 = new Int16Array(length);for (let i=0; i&lt;length; i++){    int16[i] = i+1;}console.log(int16); //[1, 2, 3, 4, 5]</code></pre><p>使用WebGL API、进行位操作、处理文件和图像时，类型数组都可以大展拳脚。它用起来和普通数组也毫无二致，本章所学的数组方法和功能都可以用于类型数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、创建和初始化数组&quot;&gt;&lt;a href=&quot;#一、创建和初始化数组&quot; class=&quot;headerlink&quot; title=&quot;一、创建和初始化数组&quot;&gt;&lt;/a&gt;一、创建和初始化数组&lt;/h3&gt;&lt;h4 id=&quot;1-1-创建数组&quot;&gt;&lt;a href=&quot;#1-1-创建数组&quot; cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据结构与算法一（javascript基础）</title>
    <link href="https://www.23ybob.club/2018/08/16/cjvqhlsn60009rcvbazk9n18l/"/>
    <id>https://www.23ybob.club/2018/08/16/cjvqhlsn60009rcvbazk9n18l/</id>
    <published>2018-08-16T11:20:30.000Z</published>
    <updated>2019-03-04T09:25:00.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、相等操作符（-和-）"><a href="#一、相等操作符（-和-）" class="headerlink" title="一、相等操作符（==和===）"></a>一、相等操作符（==和===）</h4><h5 id="1-相等操作符（-）"><a href="#1-相等操作符（-）" class="headerlink" title="1.相等操作符（==）"></a>1.相等操作符（==）</h5><p>在使用==时，不同类型的值也可以被看作相等<br>下面表格展示了不同类型的值用相等操作符比较后的结果。</p><table><thead><tr><th>类型（x）</th><th style="text-align:center">类型（y）</th><th style="text-align:right">结 果</th></tr></thead><tbody><tr><td>null</td><td style="text-align:center">undefined</td><td style="text-align:right">true</td></tr><tr><td>undefined</td><td style="text-align:center">null</td><td style="text-align:right">true</td></tr><tr><td>数字</td><td style="text-align:center">字符串</td><td style="text-align:right">x == toNumber(y) </td></tr><tr><td>字符串</td><td style="text-align:center">数字</td><td style="text-align:right">toNumber(x) == y </td></tr><tr><td>布尔值</td><td style="text-align:center">任意类型</td><td style="text-align:right">toNumber(x) == y </td></tr><tr><td>任意类型</td><td style="text-align:center">布尔值</td><td style="text-align:right">x == toNumber(y) </td></tr><tr><td>字符串或数字</td><td style="text-align:center">对象</td><td style="text-align:right">x == toPrimitive(y) </td></tr><tr><td>对象</td><td style="text-align:center">字符串或数字</td><td style="text-align:right">toPrimitive(x) == y </td></tr></tbody></table><p>如果x和y是相同类型，JavaScript会比较它们的值或对象值。其他没有列在这个表格中的情况<br>都会返回false。<br>toNumber和toPrimitive方法是内部的，并根据以下表格对其进行估值。<br>toNumber方法对不同类型返回的结果如下：</p><table><thead><tr><th>值类型</th><th style="text-align:center">结 果</th></tr></thead><tbody><tr><td>undefined</td><td style="text-align:center">NAN</td></tr><tr><td>null</td><td style="text-align:center">+0</td></tr><tr><td>布尔值</td><td style="text-align:center">如果是true，返回1；如果是false，返回+0</td></tr><tr><td>数字</td><td style="text-align:center">数字对应的值</td></tr><tr><td>字符串</td><td style="text-align:center">将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字</td></tr><tr><td>对象</td><td style="text-align:center">Number(toPrimitive(vale)) </td></tr></tbody></table><p>toPrimitive方法对不同类型返回的结果如下：</p><table><thead><tr><th>值类型</th><th style="text-align:center">结 果</th></tr></thead><tbody><tr><td>对象</td><td style="text-align:center">如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误</td></tr></tbody></table><pre><code>例：console.log(&apos;packt&apos; == true); //输出false首先，布尔值会被toNumber方法转成数字，因此得到packt == 1。其次，用toNumber转换字符串值。因为字符串包含有字母，所以会被转成NaN，表达式就变成了NaN == 1，结果就是false。</code></pre><h5 id="1-相等操作符（-）-1"><a href="#1-相等操作符（-）-1" class="headerlink" title="1.相等操作符（===）"></a>1.相等操作符（===）</h5><p>如果比较的两个值或者类型不同则返回false，如果比较的两个值类型相同，结果会根据下表判断。</p><table><thead><tr><th>类型（x）</th><th style="text-align:center">类型（y）</th><th style="text-align:right">结 果</th></tr></thead><tbody><tr><td>数字</td><td style="text-align:center">x和y数值相同（但不是NaN）</td><td style="text-align:right">true</td></tr><tr><td>字符串</td><td style="text-align:center">x和y是相同的字符</td><td style="text-align:right">true</td></tr><tr><td>布尔值</td><td style="text-align:center">x和y都是true或false</td><td style="text-align:right">true</td></tr><tr><td>对象</td><td style="text-align:center">x和y引用同一个对象</td><td style="text-align:right">true</td></tr></tbody></table><pre><code>例：console.log(&apos;packt&apos; === true); //false     console.log(&apos;packt&apos; === &apos;packt&apos;); //true </code></pre><h4 id="二、声明展开和剩余参数"><a href="#二、声明展开和剩余参数" class="headerlink" title="二、声明展开和剩余参数"></a>二、声明展开和剩余参数</h4><h5 id="2-1展开操作符"><a href="#2-1展开操作符" class="headerlink" title="2.1展开操作符"></a>2.1展开操作符</h5><p>在es5中使用apply()函数将数组转化为参数，在es6中使用展开操作符(…);</p><pre><code>例：var params = [1, 3, 5]function sum(a=1, b=3, c=4) {    return a+b+c}console.log(sum(...params));  //es6使用扩展符传入数组console.log(sum.apply(null, params)); //es5使用apply传入数组</code></pre><p>在函数中也可以使用展开操作符(…)代替arguments，当做剩余参数使用，如下案例：</p><pre><code>function restParamaterFunction (x, y, ...a) {    return (x + y) * a.length;}console.log(restParamaterFunction(1, 2, &quot;hello&quot;, true, 7)); //输出9; es5中实现function restParamaterFunction(x, y) {    var a = Array.prototype.slice.call(arguments, 2);    console.log(a)    return (x + y) * a.length;}; </code></pre><h5 id="2-2数组解构"><a href="#2-2数组解构" class="headerlink" title="2.2数组解构"></a>2.2数组解构</h5><p>es6引入数组解构的概念，可以一次初始化多个变量，如下：</p><pre><code>var [x, y] = [&apos;a&apos;, &apos;b&apos;]; 等同于var x = &apos;a&apos;; var y = &apos;b&apos;;</code></pre><p>数组解构也可以用来进行值的互换，而不需要创建临时变量，如下：</p><pre><code>[x, y] = [y, x]; //等同于var temp = x,x = y,y = temp; </code></pre><p>对象也可以解构，如下：</p><pre><code>//属性简写的功能，var [x, y] = [&apos;a&apos;, &apos;b&apos;];var obj = { x, y };console.log(obj); // { x: &quot;a&quot;, y: &quot;b&quot; } //等同于var x = &apos;a&apos;;var y = &apos;b&apos;;var obj2 = { x: x, y: y };console.log(obj2); // { x: &quot;a&quot;, y: &quot;b&quot; } //方法属性var hello = {    name : &apos;abcdef&apos;,    printHello() {        console.log(&apos;Hello&apos;);    }}console.log(hello.printHello()); //等同于var hello = {    name: &apos;abcdef&apos;,    printHello: function printHello() {        console.log(&apos;Hello&apos;);    }}; </code></pre><h4 id="三、使用类进行面向对象编程"><a href="#三、使用类进行面向对象编程" class="headerlink" title="三、使用类进行面向对象编程"></a>三、使用类进行面向对象编程</h4><pre><code>声明一个book类的方式function Book(title, pages, isbn){ //{1}    this.title = title;    this.pages = pages;    this.isbn = isbn;}Book.prototype.printTitle = function(){    console.log(this.title);}; 使用es6可以简化为一下语法只需要使用class关键字声明一个constructor函数和其他函数class Book { //{2}    constructor (title, pages, isbn) {        this.title = title;        this.pages = pages;        this.isbn = isbn;    }    printIsbn(){        console.log(this.isbn);    }} //以上两种声明据用相同的效果和输出let book = new Book(&apos;title&apos;, &apos;pag&apos;, &apos;isbn&apos;);console.log(book.title); //输出图书标题book.title = &apos;new title&apos;; //更新图书标题console.log(book.title); //输出图书标题</code></pre><h5 id="3-1继承"><a href="#3-1继承" class="headerlink" title="3.1继承"></a>3.1继承</h5><p>es6简化声明类的方式 如下：</p><pre><code>class Book { //{2}    constructor (title, pages, isbn) {        this.title = title;        this.pages = pages;        this.isbn = isbn;    }    printIsbn(){        console.log(this.isbn);    }} class ITBook extends Book { //{扩展book并继承其行为    constructor (title, pages, isbn, technology) {    super(title, pages, isbn); //引用父类的构造函数        this.technology = technology;    }    printTechnology(){        console.log(this.technology);    }}let jsBook = new ITBook(&apos;学习JS算法&apos;, &apos;200&apos;, &apos;1234567890&apos;, &apos;JavaScript&apos;);console.log(jsBook.title);console.log(jsBook.printTechnology()); //我们可以使用extends关键字扩展一个类并继承它的行为。在构造函数中，也可以通过super关键字引用父类的构造函数。</code></pre><h5 id="3-2使用属性存取器"><a href="#3-2使用属性存取器" class="headerlink" title="3.2使用属性存取器"></a>3.2使用属性存取器</h5><p>使用新的类语法也可以为属性创建存取器函数。如下：</p><pre><code>class Person {    constructor(name) {        this._name = name; //{1}    }    get name() { //{2}        return this._name;    }    set name(value) { //{3}        this._name = value;    }}let lotrChar = new Person(&apos;Frodo&apos;);console.log(lotrChar.name); //FrodolotrChar.name = &apos;Gandalf&apos;; console.log(lotrChar.name); //GandalflotrChar._name = &apos;Sam&apos;; console.log(lotrChar.name); //Sam//要声明get和set函数，只需要在我们要暴露和使用的函数名前面加上get或set关键字。可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的。然后，只要像普通的属性一样，引用它们的名字，就可以执行get和set函数。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、相等操作符（-和-）&quot;&gt;&lt;a href=&quot;#一、相等操作符（-和-）&quot; class=&quot;headerlink&quot; title=&quot;一、相等操作符（==和===）&quot;&gt;&lt;/a&gt;一、相等操作符（==和===）&lt;/h4&gt;&lt;h5 id=&quot;1-相等操作符（-）&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>认识es6</title>
    <link href="https://www.23ybob.club/2018/08/05/cjvqhlso6000rrcvbscqzjoxx/"/>
    <id>https://www.23ybob.club/2018/08/05/cjvqhlso6000rrcvbscqzjoxx/</id>
    <published>2018-08-05T11:02:07.000Z</published>
    <updated>2019-03-04T09:34:49.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="es6常用api介绍"><a href="#es6常用api介绍" class="headerlink" title="es6常用api介绍"></a>es6常用api介绍</h3><h4 id="一、let和const命令介绍及区别"><a href="#一、let和const命令介绍及区别" class="headerlink" title="一、let和const命令介绍及区别"></a>一、let和const命令介绍及区别</h4><h5 id="1-let命令："><a href="#1-let命令：" class="headerlink" title="1. let命令："></a>1. let命令：</h5><p>1）、基本用法：<br>    es5只有两种方式声明变量var以及function，es6新增了四种let、const、import、class；<br>    let声明的变量的方式与var相似，但是声明的变量，只在let命令所在的代码块中生效;</p><pre><code>{    let a = 1;    var b = 2;}console.log(a);//Error in created hook: &quot;ReferenceError: a is not defined&quot;console.log(b);//2上面在代码块中使用let，var分别声明了连个变量，然后再代码块外面调用，let声明的变量会报错，var声明的返回值正常，表明let只在它所在的代码块中生效；</code></pre><p>2）、let不存在变量提升问题<br>    我们知道使用var声明的变量会存在变量提升问题，但是在let中不存在这种现象</p><pre><code>console.log(a);//undefinedvar a = 1;console.log(b);//报错let b = 2;上述代码中，使用let声明了变量b，在声明之前使用会报错，而使用var声明的变量，在使用前值是undefined；</code></pre><p>3）、暂时性死区<br>在es6中规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，在声明前使用这些变量就会报错；</p><pre><code>var a = 1;{    a = 3;    console.log(a);//报错    let a;}</code></pre><p>4）、不允许重复声明<br>let不允许在相同作用域内重复声明同一个变量</p><pre><code>// 报错function fn1() {    let a = 1;    var a = 2;}// 报错function fn2() {    let a = 1;    let a = 2;}function fn3(argements) {    let argements; // 也会报错}</code></pre><p>es6规定暂时性死区，以及let，const语句不提升变量，主要是为了减少运行时错误，防止在变量声明前就是用这个变量。从而导致意料之外的行为；</p><h5 id="1-const命令："><a href="#1-const命令：" class="headerlink" title="1. const命令："></a>1. const命令：</h5><p>const声明一个常量，一旦声明，常量的值就不能改变了，所以const在声明是必须立即初始化，不能留到以后赋值，如果修改它的值会报错</p><pre><code>const index = 1;console.log(index)//1index = 3;// 报错const num;报错const声明的常量也不存在变量提升，同样的也是有暂时性死区，也不能重复声明变量</code></pre><h4 id="二、块级作用域"><a href="#二、块级作用域" class="headerlink" title="二、块级作用域"></a>二、块级作用域</h4><h5 id="1、块级作用域的用处"><a href="#1、块级作用域的用处" class="headerlink" title="1、块级作用域的用处"></a>1、块级作用域的用处</h5><p>在es5中只有全局作用域以及函数作用域，在许多情况下使用很不方便</p><pre><code>var num = 1;function f() {    console.log(num);    if (false) {        var num = 2;    }}f(); // undefined//在上述代码中在函数内部声明的变量覆盖了外层声明的变量；var index = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) {    console.log(s[i]);}console.log(i); // 5//在for循环中的计数变量会泄露到全局</code></pre><h5 id="2、es6中的块级作用域"><a href="#2、es6中的块级作用域" class="headerlink" title="2、es6中的块级作用域"></a>2、es6中的块级作用域</h5><pre><code>function fn1() {    let i = 5;    if (true) {        let i = 10;    }    console.log(n); // 5}//上述代码中存在两个代码块，都声明了变量i，在运行后输出5，说明function声明的代码块不受if(){}代码块的影响{    {        {let i = 5}；        console.log(i)//报错    }}//let只在当前代码块中生效,其他代码块中是无法使用的，在es6中允许使用作用域的任意嵌套{{{        let i = 1;        {let i = 2};//不报错，不同的作用域中可以声明同一个变量}}}</code></pre><h5 id="3、块级作用域域函数作用域"><a href="#3、块级作用域域函数作用域" class="headerlink" title="3、块级作用域域函数作用域"></a>3、块级作用域域函数作用域</h5><p>在es5中函数只能在顶层作用域中以及函数作用域中声明，不能再块级作用域中声明，而es6中则可以在块级作用域中声明函数，在块级作用域中声明的函数只在当前作用域中生效，对其他作用域不会造成影响；另外，es6的块级作用域内声明函数必须使用大括号，如果没有会报错</p><pre><code>// 不报错if (true) {    function f() {}}// 报错if (true)function f() {}</code></pre><h4 id="三、变量的解构赋值"><a href="#三、变量的解构赋值" class="headerlink" title="三、变量的解构赋值"></a>三、变量的解构赋值</h4><h5 id="1、数组的解构赋值"><a href="#1、数组的解构赋值" class="headerlink" title="1、数组的解构赋值"></a>1、数组的解构赋值</h5><p>在es6以前为变量赋值只能指定值</p><pre><code>let a = 1;let b = 2;let c = 3;</code></pre><p>上述代码在es6中可以住这样写</p><pre><code>let [a, b, c] = [1, 2, 3];//a=1,b=2,c=3//只要等号两边的模式相同，左边的变量就会被赋值对应的值{    let [x, y] = [1, 2, 3] //x=1,y=2};{    let [x, ,y] = [1, 2, 3] //x=1,y=3};{    let [x, [y], [z]] = [1, [2], [3]] //x=1,y=2,z=3};{    let [x, ...y] = [1, 2, 3, 4] //x=1,y=[2,3,4]};{    let [x, y, ...z] = [1] //x=1,y=undefined,z=[]};</code></pre><p>如果结构不成功就会返回undefined</p><pre><code>{    let x = []; //x = undefined;}{    let [x, y] = [1] //y =undefined;}    </code></pre><p>如果等号左边的变量只能匹配等号右边变量的一部分值，这种情况就是不完全解构，但是解构依然会成功；</p><pre><code>{    let [x, y] = [1, 2, 3] //x=1,y=2;}{    let [x, [y], z] = [1, [2, 4], 3] //x=1,y=2,z=3;}</code></pre><p>如果等号右边不是数组（不可遍历的结构）就会报错</p><pre><code>{    let [x] = 1;    let [y] = false;    let [z] = NaN;    let [a] = undefined;    let [b] = null;    let [c] = {};}</code></pre><p>结构赋值允许指定默认值</p><pre><code>{    let [x = 1] = [];//x = 1    let [i, n = 2] = [1];//i=1,n=2    let [a = 1, b = 2] = [3]//a=3,b=2}</code></pre><p>在es6内部使用严格相等运算符（===），来判断一个位置是否有值，所以只有一个数组成员严格等于undefined默认值才会生效</p><pre><code>{    let [x = 1] = [undefined] //x=1     let [y = 2] = [null] //y=null,以为null===undefined不成立；   }</code></pre><p>如果默认是一个表达式，那么这个表达式只有在用到的时候才会求值</p><pre><code>{    function fn() {        console.log(111);    }    let [x = f()] = [1];//fn不会执行,因为x能取到值1}</code></pre><p>默认值也可以使用解构赋值的其他变量，但是该变量必须先声明</p><pre><code>{    let [x = 1, y = x] = [] //x= 1;y =2  }{    let [x = 1, y = x] = [2] //x=2,y=2}{    let [x = y, y = 1] = [] //报错 y is not defined，因为y还没有声明}</code></pre><h5 id="2、对象的解构赋值"><a href="#2、对象的解构赋值" class="headerlink" title="2、对象的解构赋值"></a>2、对象的解构赋值</h5><p>对象的结构和数组类似，但是数组的解构按数组的顺序一次取值，而对象是没有顺序的，变量名必须与属性名一直才能取到正确的值；</p><pre><code>{    let {bar, foo} = {foo: 1, bar: 2} //foo:1,bar:2;    let {bar1} = {foo1: 1, bar2: 2} //bar1的值为undefined；}</code></pre><p>如果变量名与属性名不一致，必须要写成如下形式</p><pre><code>{    let {foo: foo1} = {foo: 1} //foo1:1    let foo2 = {num1: 10, num2: 20  };    let {num1: f1, num2: f2} = foo2; //f1:10, f2:20;}</code></pre><p>变量结构的机制是先找到同名的属性，然后在赋值给对应的变量，如下：</p><pre><code>{    let {bar: foo1} = {bar: 10, bar1: 20} //foo1:10; bar: error: bar is not defined    //bar 只是匹配的模式，foo1才是变量，真正被赋值的是变量foo1而不是模式bar}</code></pre><p>与数组解构一样对象的解构也可以嵌套  </p><pre><code>{    let foo = {        index: [            10,            {                y: 20            }        ]    }    let {index:[x, {y}]} = foo;//x:10,y:20}</code></pre><p>对象结构中要注意赋值的是变量，而不是模式，模式只是用来匹配变量的</p><pre><code>{    let obj = {        foo: {            index: {                num: 1,                col: 2            }        }    }     let {foo:{index: {num,col}}} = obj; //num:1, col:2}</code></pre><p>对象的解构也可以指定默认值</p><pre><code>{    let {x=1} = {} //x=3}{    let {x: y= 1} = {} // y = 3;}{    let {x: y= 1} = {null} // y:null;}//和数组一样默认值生效的条件也是严格等于undefined</code></pre><p>如果解构失败，变量的值是undefined</p><pre><code>{    let {foo} = {bar: 1} //foo:undefined}</code></pre><p>如果解构模式是嵌套的对象，如果子对象所在的父对象不存在，则会报错</p><pre><code>{    let {foo: {bar}} = {x: 1} //报错}</code></pre><p>解构赋值允许等号左边的模式中，不放置任何变量名，因此如下写法是可以执行的</p><pre><code>{    ({} = [1, 2])    ({} = &apos;abc)    ({} = [])}</code></pre><p>也可以对数组进行对象属性的解构</p><pre><code>{    let arr = [1, 2, 3];    let {0: f1, [arr.length-1]: f2} = arr //f1:1, f2:3}</code></pre><h5 id="2、字符串的解构赋值"><a href="#2、字符串的解构赋值" class="headerlink" title="2、字符串的解构赋值"></a>2、字符串的解构赋值</h5><pre><code>字符串在解构的时候会被转换成一个类似数组的对象{    let [A, B, C, D] = &apos;abcd&apos;;    //A:a,B:b,C:c,D:d;} </code></pre><h5 id="3、数值和布尔值的解构赋值"><a href="#3、数值和布尔值的解构赋值" class="headerlink" title="3、数值和布尔值的解构赋值"></a>3、数值和布尔值的解构赋值</h5><p>数值和布尔值的解构赋值会先转成对象（隐式调用toString方法）</p><pre><code>{    let {toString: s} = 123;//true    s === Number.prototype.toString(隐式调用)}{    let {toString: s} = true;//true    s === Boolean.prototype.toString }{    let { prop: x } = undefined; // TypeError    let { prop: y } = null; // TypeError    //undefined,null无法转成对象}</code></pre><h5 id="4、函数参数的解构赋值"><a href="#4、函数参数的解构赋值" class="headerlink" title="4、函数参数的解构赋值"></a>4、函数参数的解构赋值</h5><pre><code>{    function fn([x, y]) {        return x + y;    }    fn([1, 2]);//3}</code></pre><p>函数参数的结解构也可以指定默认值</p><pre><code>{    function fn({x=3, y=4} = {}) {        return [x, y]    }    fn({x:10, y:20});// [10, 20]    fn(); // [3, 4]}</code></pre><h4 id="四、圆括号的使用"><a href="#四、圆括号的使用" class="headerlink" title="四、圆括号的使用"></a>四、圆括号的使用</h4><p>es6对于圆括号的规则是可能导致解构发生歧义，就不能使用圆括号</p><h5 id="1、不能使用圆括号的场景"><a href="#1、不能使用圆括号的场景" class="headerlink" title="1、不能使用圆括号的场景"></a>1、不能使用圆括号的场景</h5><p>(1). 变量的声明赋值 </p><pre><code>{    let [(a)] = [1];    let {x: (c)} = {};    let ({x: c}) = {};    let {(x: c)} = {};    let {(x): c} = {};    let { o: ({ p: p }) } = { o: { p: 2 } };    //上面6个语句都会报错，因为它们都是变量声明语句，模式中不能使用圆括号}</code></pre><p>(2). 函数参数</p><pre><code>{    function f([(z)]) { return z; } // 报错    function f([z,(x)]) { return x; } // 报错    //函数参数也属于变量声明，因此不能带有圆括号。}</code></pre><p>(3). 赋值语句的模式</p><pre><code>{    ({ p: a }) = { p: 42 }; //报错    ([a]) = [5];//报错}</code></pre><h5 id="1、能使用圆括号的场景"><a href="#1、能使用圆括号的场景" class="headerlink" title="1、能使用圆括号的场景"></a>1、能使用圆括号的场景</h5><p>(1). 赋值语句的非模式部分，可以使用圆括号。</p><pre><code>{    [(b)] = [3]; // 正确    ({ p: (d) } = {}); // 正确    [(parseInt.prop)] = [3]; // 正确}</code></pre><h4 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h4><h5 id="1、箭头函数的使用"><a href="#1、箭头函数的使用" class="headerlink" title="1、箭头函数的使用"></a>1、箭头函数的使用</h5><p>在es6中允许使用“箭头”（=&gt;）定义函数</p><pre><code>{    var f = fn =&gt; v    //以上代码等同于    var f = function fn(v) {        return v    }}</code></pre><p>基本语法</p><pre><code>{    用法一：参数1（单一参数） =&gt; {函数声明} //一个参数，多个执行语句    用法二：（参数1）（单一参数） =&gt; 表达式（只有一条语句）//单个参数一条执行语句    用法三：(参数1，参数2，... , 参数n) =&gt; {函数声明} //多个参数，多个执行语句    用法四：(参数1，参数2，... , 参数n) =&gt; 表达式（只有一条语句）//相当于(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }//多个参数，一条语句    用法五： () =&gt; {函数声明} //没有参数时使用()代替}</code></pre><p>其他使用</p><pre><code>{    var f = bar =&gt; ({foo: bar})    console.log(f(1)); //{foo: 1}    //箭头函数如果想直接返回一个对象必须在对象外面加()，不然会报错}{    (参数1, 参数2, ...rest) =&gt; {函数声明}    (参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明}    //可以使用默认参数以及剩余参数}{    let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;    f();  // 6    //也可以使用解构}</code></pre><p>如果箭头函数不需要参数或者需要多个参数，则使用一个()代表参数部分</p><pre><code>{    var f1 = () =&gt; x //等同于 var f1 = function() {return x}}{    var f1 = (index1, index2) =&gt; index1 + index2;    //等同于var f1 = function(index1, index2) {return index1+index2}}</code></pre><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p><pre><code>{    var f1 = (index1, index2) =&gt; {        return index1 + index2;    }}</code></pre><h5 id="2、箭头函数注意点"><a href="#2、箭头函数注意点" class="headerlink" title="2、箭头函数注意点"></a>2、箭头函数注意点</h5><p>（1）、箭头函数内部的this是固定的，就是定义时所在的对象，而不是使用时调用的对象；<br>（2）、不能当做构造函数使用，如果和new一起使用会抛出错误；<br>（3）、箭头函数内部不存在arguments对象，但是可以用rest参数代替arguments对象；<br>（4）、call 或 apply 调用在箭头函数中不能修改this指针，他们的第一个参数会被忽略<br>（5）、箭头函数没有prototype属性。<br>（6）、箭头函数在参数和箭头之间不能换行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;es6常用api介绍&quot;&gt;&lt;a href=&quot;#es6常用api介绍&quot; class=&quot;headerlink&quot; title=&quot;es6常用api介绍&quot;&gt;&lt;/a&gt;es6常用api介绍&lt;/h3&gt;&lt;h4 id=&quot;一、let和const命令介绍及区别&quot;&gt;&lt;a href=&quot;#一、l
      
    
    </summary>
    
    
      <category term="es6" scheme="https://www.23ybob.club/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>drafting</title>
    <link href="https://www.23ybob.club/2018/07/21/cjvqhlsmv0002rcvboofy039g/"/>
    <id>https://www.23ybob.club/2018/07/21/cjvqhlsmv0002rcvboofy039g/</id>
    <published>2018-07-21T06:46:21.000Z</published>
    <updated>2019-03-04T09:36:28.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现目标div在另一个div中的拖拽效果"><a href="#实现目标div在另一个div中的拖拽效果" class="headerlink" title="实现目标div在另一个div中的拖拽效果"></a>实现目标div在另一个div中的拖拽效果</h3><p>最近项目中遇到的一个小功能，总结了一下，感觉还不错.<br>github地址： <a href="https://github.com/Abriams/js-drafting" target="_blank" rel="noopener">https://github.com/Abriams/js-drafting</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Page Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        *&#123;</span></span><br><span class="line"><span class="regexp">            margin: 0;</span></span><br><span class="line"><span class="regexp">            padding: 0;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        #draft_big &#123;  </span></span><br><span class="line"><span class="regexp">            border: 1px solid #FF3300;  </span></span><br><span class="line"><span class="regexp">            width: 300px;  </span></span><br><span class="line"><span class="regexp">            height: 300px;  </span></span><br><span class="line"><span class="regexp">            position: relative;  </span></span><br><span class="line"><span class="regexp">            margin-left: 400px;</span></span><br><span class="line"><span class="regexp">            margin-top: 400px;</span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        #draft_small &#123;  </span></span><br><span class="line"><span class="regexp">            background: #99CC00;  </span></span><br><span class="line"><span class="regexp">            width: 50px;  </span></span><br><span class="line"><span class="regexp">            height: 50px;  </span></span><br><span class="line"><span class="regexp">            position: absolute;  </span></span><br><span class="line"><span class="regexp">            cursor: pointer;  </span></span><br><span class="line"><span class="regexp">            right: -80px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;  </span></span><br><span class="line"><span class="regexp">    &lt;div id="draft_big"&gt;  </span></span><br><span class="line"><span class="regexp">        &lt;div id="draft_small"&gt;&lt;/</span>div&gt;  </span><br><span class="line">    &lt;<span class="regexp">/div&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;  </span><br><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;  </span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> draftBig = <span class="built_in">document</span>.getElementById(<span class="string">"draft_big"</span>);  </span><br><span class="line">        <span class="keyword">var</span> draftSmall = <span class="built_in">document</span>.getElementById(<span class="string">"draft_small"</span>);  </span><br><span class="line">        draftSmall.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;  </span><br><span class="line">            <span class="comment">//记录并保存可拖拽div（id为draftSmall的盒子）拖拽前的坐标 </span></span><br><span class="line">            <span class="keyword">var</span> startX = e.clientX - draftSmall.offsetLeft;</span><br><span class="line">            <span class="keyword">var</span> startY = e.clientY - draftSmall.offsetTop;</span><br><span class="line">            <span class="comment">// offsetHeight,包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话）;</span></span><br><span class="line">            <span class="comment">// offsetLeft,目标元素距离最近定位的父级元素左边的距离；</span></span><br><span class="line">            <span class="comment">// offsetTop,目标元素距离最近定位的父级元素上边的距离；</span></span><br><span class="line">            <span class="comment">// clientX 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的水平坐标。</span></span><br><span class="line">            <span class="comment">// clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（或客户区）的垂直坐标。</span></span><br><span class="line">            <span class="comment">/*鼠标的移动事件*/</span>  </span><br><span class="line">            <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">                <span class="comment">//判断被拖拽的盒子（id为draftSmall的盒子）必须拖拽到目标盒子（id为draftBig盒子中）才能移动；</span></span><br><span class="line">                <span class="keyword">if</span>(e.clientX - <span class="number">400</span> &lt; draftBig.offsetHeight &amp;&amp; e.clientX &gt; <span class="number">400</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(e.clientY <span class="number">-400</span> &lt; draftBig.offsetWidth &amp;&amp; e.clientY &gt; <span class="number">400</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;  </span><br><span class="line">                        <span class="comment">//计算当前拖拽的盒子（id为draftSmall的盒子）在目标盒子（id为draftBig盒子）中的坐标；</span></span><br><span class="line">                        draftSmall.style.left = e.clientX - startX + <span class="string">"px"</span>;  </span><br><span class="line">                        draftSmall.style.top = e.clientY - startY + <span class="string">"px"</span>;  </span><br><span class="line">                        <span class="comment">/*判断拖拽边界（id为draftSmall的盒子四个边界的判断）*/</span>  </span><br><span class="line">                        <span class="keyword">if</span> (e.clientX - startX &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                            draftSmall.style.left = <span class="number">0</span> + <span class="string">"px"</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">if</span> (e.clientY - startX &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                            draftSmall.style.top = <span class="number">0</span> + <span class="string">"px"</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">if</span> (e.clientX - startX &gt;= <span class="number">250</span>) &#123;  </span><br><span class="line">                            draftSmall.style.left = <span class="number">250</span> + <span class="string">"px"</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">if</span> (e.clientY - startX &gt;= <span class="number">250</span>) &#123;  </span><br><span class="line">                            draftSmall.style.top = <span class="number">250</span> + <span class="string">"px"</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;  </span><br><span class="line">            <span class="comment">/*鼠标的抬起事件,终止拖动*/</span>  </span><br><span class="line">            <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">                <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;  </span><br><span class="line">                <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;; </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现目标div在另一个div中的拖拽效果&quot;&gt;&lt;a href=&quot;#实现目标div在另一个div中的拖拽效果&quot; class=&quot;headerlink&quot; title=&quot;实现目标div在另一个div中的拖拽效果&quot;&gt;&lt;/a&gt;实现目标div在另一个div中的拖拽效果&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="js实现拖拽" scheme="https://www.23ybob.club/tags/js%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD/"/>
    
  </entry>
  
  <entry>
    <title>vue slot使用小结</title>
    <link href="https://www.23ybob.club/2018/07/14/cjvqhlsn7000brcvbjkbmlahm/"/>
    <id>https://www.23ybob.club/2018/07/14/cjvqhlsn7000brcvbjkbmlahm/</id>
    <published>2018-07-14T11:20:30.000Z</published>
    <updated>2019-03-04T09:26:57.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、slot简介"><a href="#一、slot简介" class="headerlink" title="一、slot简介"></a>一、slot简介</h3><p>在vue实际项目开发当中，我们经常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一个过程在Vue中被称为内容分发。<br>在Vue中，slot也分多种，从Vue的官网中可以获知，其主要分为：单个插槽、具名插槽和作用域插槽三种。<br>下面就逐一介绍这三种插槽的用法：</p><h3 id="二、slot插槽具体用法"><a href="#二、slot插槽具体用法" class="headerlink" title="二、slot插槽具体用法"></a>二、slot插槽具体用法</h3><h4 id="2-1单个插槽的使用"><a href="#2-1单个插槽的使用" class="headerlink" title="2.1单个插槽的使用"></a>2.1单个插槽的使用</h4><p>从官网中（<a href="https://cn.vuejs.org/）我们知道，如果子组件template中没有包含任何一个" target="_blank" rel="noopener">https://cn.vuejs.org/）我们知道，如果子组件template中没有包含任何一个</a><slot>时，就算父组件分发再多的内容也将会被丢弃。如下案例：</slot></p><pre><code>子组件slotChildren组件，&lt;template&gt;    &lt;div&gt;        &lt;header&gt;slotchildrenheader&lt;/header&gt;        &lt;main&gt;这是子组件的内容&lt;/main&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    &lt;/script&gt;父组件slotdemo组件&lt;template&gt;    &lt;div class=&quot;Slotdemo&quot;&gt;        &lt;slotChildren&gt;            &lt;div&gt;为子组件添加新内容&lt;/div&gt;        &lt;/slotChildren&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import slotChildren from &apos;./slotChildren.vue&apos;    export default {        name: &quot;Slotdemo&quot;,        components: {            slotChildren        }    } &lt;/script&gt;</code></pre><p>页面渲染结果如下图：<br>上图所示在<slotchildren></slotchildren>中添加内容并不会显示<br><img src="/2018/07/14/cjvqhlsn7000brcvbjkbmlahm/slot-01.png" alt="slot演示"></p><p>只有子组件模板只中拥有一个没有属性的slot（可以有多个带属性的slot，后面的内容会介绍），父组件传入的整个内容片段才会被插入到slot所在的位置，并将替换掉slot本身，如果传入的内容为空则会显示slot的默认内容。如下案例：</p><pre><code>父组件slotdemo&lt;template&gt;    &lt;div class=&quot;Slotdemo&quot;&gt;        &lt;slotChildren&gt;            &lt;div&gt;为子组件添加新内容&lt;/div&gt;        &lt;/slotChildren&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import slotChildren from &apos;./slotChildren.vue&apos;    export default {        name: &quot;Slotdemo&quot;,        components: {            slotChildren        }    }&lt;/script&gt;子组件slotChildren组件，&lt;template&gt;&lt;div&gt;    &lt;header&gt;slotchildrenheader&lt;/header&gt;    &lt;main&gt;这是子组件的内容&lt;/main&gt;    &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里&lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;</code></pre><p>页面渲染结果如下图：<br><img src="/2018/07/14/cjvqhlsn7000brcvbjkbmlahm/slot-02.png" alt="slot演示"></p><p>当派发的内容为空时，会默认显示slot的内容</p><pre><code>父组件slotdemo&lt;template&gt;    &lt;div class=&quot;Slotdemo&quot;&gt;        &lt;slotChildren&gt;        &lt;/slotChildren&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import slotChildren from &apos;./slotChildren.vue&apos;    export default {        name: &quot;Slotdemo&quot;,        components: {            slotChildren        }    }&lt;/script&gt;子组件slotChildren组件，&lt;template&gt;&lt;div&gt;    &lt;header&gt;slotchildrenheader&lt;/header&gt;    &lt;main&gt;这是子组件的内容&lt;/main&gt;    &lt;slot&gt;新添加内容显示在此显示&lt;/slot&gt;//派发的内容显示在这里&lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;</code></pre><p>页面渲染结果如下图：<br><img src="/2018/07/14/cjvqhlsn7000brcvbjkbmlahm/slot-03.png" alt="slot演示">  </p><h4 id="2-2具名插槽的使用"><a href="#2-2具名插槽的使用" class="headerlink" title="2.2具名插槽的使用"></a>2.2具名插槽的使用</h4><p><slot>可以用一个特殊的属性name来配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将根据name属性匹配内容片段中有对应slot属性的元素。</slot></p><pre><code>父组件slotdemo&lt;template&gt;    &lt;div class=&quot;Slotdemo&quot;&gt;        &lt;slotChildren&gt;            &lt;div slot=&quot;header&quot;&gt;新的slotchildrenheader&lt;/div&gt;            &lt;div slot=&quot;main&quot;&gt;新的内容&lt;/div&gt;            &lt;div&gt;没有name&lt;/div&gt;        &lt;/slotChildren&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import slotChildren from &apos;./slotChildren.vue&apos;    export default {        name: &quot;Slotdemo&quot;,        components: {            slotChildren        }    }  &lt;/script&gt;子组件slotChildren组件，&lt;template&gt;    &lt;div&gt;        &lt;header&gt;slotchildrenheader            &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;            &lt;slot&gt;&lt;/slot&gt;//如果匹配不到内容显示在这        &lt;/header&gt;        &lt;main&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;这是子组件的内容&lt;/main&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;</code></pre><p>页面渲染结果如下图：<br><img src="/2018/07/14/cjvqhlsn7000brcvbjkbmlahm/slot-04.png" alt="slot演示">  </p><h4 id="2-3作用域插槽的使用"><a href="#2-3作用域插槽的使用" class="headerlink" title="2.3作用域插槽的使用"></a>2.3作用域插槽的使用</h4><p>作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。</p><pre><code>在子组件中，只需将数据传递到插槽，就像你将prop传递给组件一样：&lt;template&gt;    &lt;div&gt;        &lt;header&gt;slotchildrenheader&lt;/header&gt;        &lt;main&gt;这是子组件的内容&lt;slot :text=&quot;msg&quot;&gt;&lt;/slot&gt;&lt;/main&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: &apos;&apos;,        data() {            return {                msg: &quot;slot分发内容&quot;,            }        },    }&lt;/script&gt;在父组件中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象。&lt;template&gt;    &lt;div class=&quot;Slotdemo&quot;&gt;        &lt;slotChildren&gt;            &lt;template slot-scope=&quot;props&quot;&gt;//作用域模板插槽必须存在                &lt;div&gt;新的slotchildrenheader&lt;/div&gt;                &lt;div&gt;新的内容&lt;div&gt;{{props.text}}&lt;/div&gt;&lt;/div&gt;            &lt;/template&gt;        &lt;/slotChildren&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import slotChildren from &apos;./slotChildren.vue&apos;    export default {        name: &quot;Slotdemo&quot;,        components: {            slotChildren        }    }&lt;/script&gt;</code></pre><p>页面渲染结果如下图：<br><img src="/2018/07/14/cjvqhlsn7000brcvbjkbmlahm/slot-05.png" alt="slot演示">  </p><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>这篇文章主要介绍vue中的<slot>插槽的使用方法。<slot>只是一个空壳子，他的显示以及如何显示手父组件的控制，插槽显示的位置由子组件自身决定。<br>父组件传过来的模板显示<slot>组件的template。<br>使用slot可以帮助我们更容易，灵活的使用组件，同时也提高了组件的复用性。</slot></slot></slot></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、slot简介&quot;&gt;&lt;a href=&quot;#一、slot简介&quot; class=&quot;headerlink&quot; title=&quot;一、slot简介&quot;&gt;&lt;/a&gt;一、slot简介&lt;/h3&gt;&lt;p&gt;在vue实际项目开发当中，我们经常会把父组件的内容与子组件自己的模板混合起来使用。而这样的一
      
    
    </summary>
    
    
      <category term="slot" scheme="https://www.23ybob.club/tags/slot/"/>
    
      <category term="vue" scheme="https://www.23ybob.club/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的问题总结</title>
    <link href="https://www.23ybob.club/2018/07/04/cjvqhlsna000ercvboo2a7l0f/"/>
    <id>https://www.23ybob.club/2018/07/04/cjvqhlsna000ercvboo2a7l0f/</id>
    <published>2018-07-04T11:20:30.000Z</published>
    <updated>2019-03-04T09:43:45.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、element-ui-的使用总结"><a href="#一、element-ui-的使用总结" class="headerlink" title="一、element ui 的使用总结"></a>一、element ui 的使用总结</h3><h4 id="1-1-自定义验证规则的使用"><a href="#1-1-自定义验证规则的使用" class="headerlink" title="1.1. 自定义验证规则的使用"></a>1.1. 自定义验证规则的使用</h4><pre><code>在自定义验证规则的时候每一个判断里（if()else()或者if()else if() else()）都要有callback,否则表单在执行this.$refs[formName].validate((valid) =&gt; {}) 的时候，内部代码是不会执行的；&lt;el-form :model=&quot;ruleForm2&quot; status-icon :rules=&quot;rules2&quot; ref=&quot;ruleForm2&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;    &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt;        &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt;        &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm2.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;        &lt;el-input v-model.number=&quot;ruleForm2.age&quot;&gt;&lt;/el-input&gt;    &lt;/el-form-item&gt;    &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm2&apos;)&quot;&gt;提交&lt;/el-button&gt;        &lt;el-button @click=&quot;resetForm(&apos;ruleForm2&apos;)&quot;&gt;重置&lt;/el-button&gt;    &lt;/el-form-item&gt;&lt;/el-form&gt;&lt;script&gt;export default {    data() {    var checkAge = (rule, value, callback) =&gt; {        if (!value) {            return callback(new Error(&apos;年龄不能为空&apos;));        }        setTimeout(() =&gt; {            if (!Number.isInteger(value)) {                callback(new Error(&apos;请输入数字值&apos;));            } else {                if (value &lt; 18) {                    callback(new Error(&apos;必须年满18岁&apos;));                } else {                    callback();//不能省略，不然无法执行                }            }        }, 1000);    };    var validatePass = (rule, value, callback) =&gt; {        if (value === &apos;&apos;) {                callback(new Error(&apos;请输入密码&apos;));            } else {            if (this.ruleForm2.checkPass !== &apos;&apos;) {                this.$refs.ruleForm2.validateField(&apos;checkPass&apos;);            }            callback();        }    };    var validatePass2 = (rule, value, callback) =&gt; {        if (value === &apos;&apos;) {            callback(new Error(&apos;请再次输入密码&apos;));        } else if (value !== this.ruleForm2.pass) {            callback(new Error(&apos;两次输入密码不一致!&apos;));        } else {            callback();        }    };    return {        ruleForm2: {        pass: &apos;&apos;,        checkPass: &apos;&apos;,        age: &apos;&apos;        },        rules2: {        pass: [            { validator: validatePass, trigger: &apos;blur&apos; }        ],        checkPass: [            { validator: validatePass2, trigger: &apos;blur&apos; }        ],        age: [            { validator: checkAge, trigger: &apos;blur&apos; }        ]        }    };    },    methods: {    submitForm(formName) {        this.$refs[formName].validate((valid) =&gt; {        if (valid) {            alert(&apos;submit!&apos;);        } else {            console.log(&apos;error submit!!&apos;);            return false;        }        });    },    resetForm(formName) {        this.$refs[formName].resetFields();    }    }}&lt;/script&gt;</code></pre><h4 id="1-2移动端ios以及andriod兼容问题"><a href="#1-2移动端ios以及andriod兼容问题" class="headerlink" title="1.2移动端ios以及andriod兼容问题"></a>1.2移动端ios以及andriod兼容问题</h4><h4 id="1-2-1-ios以及andriod使用overflow-scroll-遇到的问题；"><a href="#1-2-1-ios以及andriod使用overflow-scroll-遇到的问题；" class="headerlink" title="1.2.1 ios以及andriod使用overflow: scroll;遇到的问题；"></a>1.2.1 ios以及andriod使用overflow: scroll;遇到的问题；</h4><pre><code>页面滚动时使用overflow：scroll;在ios端会出现滑动不流畅问题。为了解决这个问题，首先我使用了-webkit-overflow-scrolling : touch;这个属性，发现使用这个属性以后，ios页面在滑动到底部或者顶部会出现页面卡死问题，在网上找了好多方法参考这篇文章https://hk.saowen.com/a/ba965995919b5f04ed8bcb7ccc5b4af1e95792e9769fd92a8d36881d1fad8683个人觉得这篇文章写得很好，试了一下这些方法，发现最后还是没有解决，最后发现不要用原生的滚动也就是overflow：scroll;并且阻止ios的默认滑动效果，改为使用better-scroll这个滚动插件完美解决了以上的问题；参考如下案例：&lt;template&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;contain-img wrapper&quot; ref=&quot;menuWrapper&quot; v-show=&quot;Show&quot; id=&quot;contain-img&quot;&gt;            &lt;ul class=&quot;content&quot; id=&quot;content&quot; ref=&quot;content&quot;&gt;                //合同图片显示                &lt;div class=&quot;img01&quot; id=&quot;img01&quot;&gt;&lt;img src=&quot;../../static/img/demo-detail01.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;img02&quot;&gt;                    &lt;img id=&quot;img01&quot; src=&quot;../../static/img/demo-detail02.png&quot; alt=&quot;&quot;&gt;                &lt;/div&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;div class=&quot;pact-sign&quot; v-show=&quot;isSubmit&quot; @click=&quot;sign()&quot;&gt;提交&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import BScroll from &apos;better-scroll&apos;    export default {        data() {            return {                contractImg: &apos;&apos;,                isSubmit: true,                Show: true            }        },        created() {            this.$nextTick(()=&gt;{ //异步执行                setTimeout(() =&gt; {                    let containImg = document.getElementById(&quot;img01&quot;).offsetHeight;                    let bodyHeight = document.body.clientHeight;                    let distance = bodyHeight-containImg;                    let scrollHeight = containImg-distance;                    this.meunScroll=new BScroll(this.$refs.menuWrapper,{});//初始化better-scroll插件                    this.meunScroll.scrollTo(0,-scrollHeight); //页面加载完滚动到某个位置                }, 100)              });            this.$nextTick(function(){                document.getElementsByTagName(&quot;img&quot;)[0].onload =function() {                    document.body.addEventListener(&apos;touchmove&apos;, function (e) {                        e.preventDefault() // 阻止默认的处理方式(阻止下拉滑动的效果)                    }, {passive: false}) // passive 参数不能省略，用来兼容ios和android                }            });              },        beforeCreate() {            document.title = &apos;签署确认&apos;;        },    }&lt;/script&gt;&lt;style scoped&gt;*{    margin: 0;    padding: 0;}body, html {    height: 100%;    width: 100%;    background-color: #fff;}.container {    width: 100%;    height: 100%;}.contain-img {    width: 100%;    height: 100%;    position: absolute;    /* overflow: scroll;    -webkit-overflow-scrolling : touch; */}.container img {    width: 100%;    height: 100%;}.pact-sign {    width: 40px;    height: 40px;    line-height: 40px;    position: fixed;    bottom: 40px;    right: 20px;    border-radius: 50%;    background-color: #409EFF;    text-align: center;    color: #ffffff;    z-index: 10;}.img01, .img02 {    position: relative;    overflow: hidden;}&lt;/style&gt;</code></pre><h4 id="1-3-prop以及attr的使用"><a href="#1-3-prop以及attr的使用" class="headerlink" title="1.3 prop以及attr的使用"></a>1.3 prop以及attr的使用</h4><pre><code>使用attr获取checked属性、disabled属性、select属性，如果这些属性默认选中可以取到值，如果未选中值返回undefined，使用prop则可以解决这些问题官方文档建议：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()；</code></pre><h4 id="1-4-npm打包卡死问题"><a href="#1-4-npm打包卡死问题" class="headerlink" title="1.4 npm打包卡死问题"></a>1.4 npm打包卡死问题</h4><pre><code>修改为淘宝源：（npm config set registry http://registry.cnpmjs.org）；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、element-ui-的使用总结&quot;&gt;&lt;a href=&quot;#一、element-ui-的使用总结&quot; class=&quot;headerlink&quot; title=&quot;一、element ui 的使用总结&quot;&gt;&lt;/a&gt;一、element ui 的使用总结&lt;/h3&gt;&lt;h4 id=&quot;1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript权威指南理解片一</title>
    <link href="https://www.23ybob.club/2018/06/24/cjvqhlsn30005rcvb04cai0gk/"/>
    <id>https://www.23ybob.club/2018/06/24/cjvqhlsn30005rcvb04cai0gk/</id>
    <published>2018-06-24T09:38:29.000Z</published>
    <updated>2019-03-04T09:33:48.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h2><pre><code>eval函数执行另一段javascript代码;eval(&quot;function f() {return x + 1}&quot;);//eval函数只有一个参数，如果参数不是字符串则直接返回这个函数console.log(eval(11)); //11//如果参数是字符串则会将字符串当做javascript代码进行编译执行//并且返回最后一个表达式或语句得值，如果最后一个表达式或语句没有值则返回undefined；//eval使用的作用域是调用他的作用域；如果eval调用了全局函数，则返回的是全局变量的值，如果eval调用了局部函数，他会返回局部变量的值；var geval = eval;var x = &quot;global&quot;, y = &quot;global&quot;;function f() {    var x = &quot;local &quot;;    eval(&quot;x += &apos;changed&apos;;&quot;) //改变局部变量x的值    return x;}function g() {    var y = &quot;local&quot;;    geval(&quot;y += &apos; changed&apos;;&quot;); //改变全局变量y的值    return y;}console.log(f(), x); //local changed globalconsole.log(g(), y); //local global changed</code></pre><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><pre><code>x &gt; 0 ? x : -x 条件运算符的操作数可以是任意类型，第一个操作符如果是真值，那么返回第二个操作符的结果，如果第一个操作符是假值，则返回第三个操作符的结果；</code></pre><h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;eval函数&quot;&gt;&lt;a href=&quot;#eval函数&quot; class=&quot;headerlink&quot; title=&quot;eval函数&quot;&gt;&lt;/a&gt;eval函数&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;eval函数执行另一段javascript代码;

eval(&amp;quot;function 
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.23ybob.club/tags/javascript/"/>
    
  </entry>
  
</feed>
