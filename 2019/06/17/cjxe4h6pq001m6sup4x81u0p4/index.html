<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Abriams blog"><meta name="keywords" content="前端， 移动互联网, vue"><title>javascript设计模式与开发实践十二（享元模式） | 淡笑忘、祈一世凡恋</title><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript设计模式与开发实践十二（享元模式）</h1><a id="logo" href="/.">淡笑忘、祈一世凡恋</a><p class="description">进步的源泉来源于坚持不懈</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">javascript设计模式与开发实践十二（享元模式）</h1><div class="post-meta"><a href="/2019/06/17/cjxe4h6pq001m6sup4x81u0p4/#comments" class="comment-count"></a><p><span class="date">Jun 17, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript 中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。</p>
<p>享元模式的概念初听起来并不太好理解，所以在深入讲解之前，我们先看一个例子。</p>
<h2 id="一、-初识享元模式"><a href="#一、-初识享元模式" class="headerlink" title="一、 初识享元模式"></a>一、 初识享元模式</h2><p>假设有个内衣工厂，目前的产品有 50 种男式内衣和 50 种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。 正常情况下需要 50 个男模特和 50 个女模特，然后让他们每人分别穿上一件内衣来拍照。不使用享元模式的情况下，在程序里也许会这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Model = <span class="function"><span class="keyword">function</span> (<span class="params">sex, underwear</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.underwear = underwear;</span><br><span class="line">&#125;;</span><br><span class="line">Model.prototype.takePhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sex= '</span> + <span class="keyword">this</span>.sex + <span class="string">' underwear='</span> + <span class="keyword">this</span>.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> maleModel = <span class="keyword">new</span> Model(<span class="string">'male'</span>, <span class="string">'underwear'</span> + i);</span><br><span class="line">    maleModel.takePhoto();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">var</span> femaleModel = <span class="keyword">new</span> Model(<span class="string">'female'</span>, <span class="string">'underwear'</span> + j);</span><br><span class="line">    femaleModel.takePhoto();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要得到一张照片，每次都需要传入 sex 和 underwear 参数，如上所述，现在一共有 50 种男内衣和 50 种女内衣，所以一共会产生 100 个对象。如果将来生产了 10000 种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。</p>
<p>下面我们来考虑一下如何优化这个场景。虽然有 100 种内衣，但很显然并不需要 50 个男模特和 50 个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照。</p>
<p>现在来改写一下代码，既然只需要区别男女模特，那我们先把 underwear 参数从构造函数中移除，构造函数只接收 sex 参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Model = <span class="function"><span class="keyword">function</span> (<span class="params">sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;;</span><br><span class="line">Model.prototype.takePhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sex= '</span> + <span class="keyword">this</span>.sex + <span class="string">' underwear='</span> + <span class="keyword">this</span>.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//分别创建一个男模特对象和一个女模特对象：</span></span><br><span class="line"><span class="keyword">var</span> maleModel = <span class="keyword">new</span> Model(<span class="string">'male'</span>),</span><br><span class="line">    femaleModel = <span class="keyword">new</span> Model(<span class="string">'female'</span>);</span><br><span class="line"><span class="comment">//给男模特依次穿上所有的男装，并进行拍照：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">    maleModel.underwear = <span class="string">'underwear'</span> + i;</span><br><span class="line">    maleModel.takePhoto();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//同样，给女模特依次穿上所有的女装，并进行拍照：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++) &#123;</span><br><span class="line">    femaleModel.underwear = <span class="string">'underwear'</span> + j;</span><br><span class="line">    femaleModel.takePhoto();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，改进之后的代码，只需要两个对象便完成了同样的功能。</p>
<h2 id="二、-内部状态与外部状态"><a href="#二、-内部状态与外部状态" class="headerlink" title="二、 内部状态与外部状态"></a>二、 内部状态与外部状态</h2><p>12.1 节的这个例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。</p>
<blockquote>
<ul>
<li>内部状态存储于对象内部。</li>
<li>内部状态可以被一些对象共享。</li>
<li>内部状态独立于具体的场景，通常不会改变。</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。</li>
</ul>
</blockquote>
<p>这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并储存在外部。 </p>
<p>剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。</p>
<p>在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要 2 个对象。</p>
<p>使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常被划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，模特的性别就可以作为内部状态储存在共享对象的内部。而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。</p>
<h2 id="三、-享元模式的通用结构"><a href="#三、-享元模式的通用结构" class="headerlink" title="三、 享元模式的通用结构"></a>三、 享元模式的通用结构</h2><p>前面的示例初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中还存在以下两个问题。</p>
<blockquote>
<ul>
<li>我们通过构造函数显式 new 出了男女两个 model 对象，在其他系统中，也许并不是一开始就需要所有的共享对象。</li>
<li>给 model 对象手动设置了 underwear 外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。</li>
</ul>
</blockquote>
<p>我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。</p>
<h2 id="四、-文件上传的例子"><a href="#四、-文件上传的例子" class="headerlink" title="四、 文件上传的例子"></a>四、 文件上传的例子</h2><p>在微云上传模块的开发中，我们曾经借助享元模式提升了程序的性能。下面我们就讲述这个例子。</p>
<h3 id="4-1-对象爆炸"><a href="#4-1-对象爆炸" class="headerlink" title="4.1 对象爆炸"></a>4.1 对象爆炸</h3><p>在微云上传模块的开发中，存在对象爆炸的问题。微云的文件上传功能虽然可以选择依照队列，一个一个地排队上传，但也支持同时选择 2000 个文件。每一个文件都对应着一个JavaScript 上传对象的创建，在第一版开发中，的确往程序里同时 new 了 2000 个 upload 对象，结果可想而知，Chrome 中还勉强能够支撑，IE 下直接进入假死状态。 </p>
<p>微云支持好几种上传方式，比如浏览器插件、Flash 和表单上传等，为了简化例子，我们先假设只有插件和 Flash 这两种。不论是插件上传，还是 Flash 上传，原理都是一样的，当用户选择了文件之后，插件和 Flash 都会通知调用 Window 下的一个全局 JavaScript 函数，它的名字是startUpload，用户选择的文件列表被组合成一个数组 files 塞进该函数的参数列表里，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.startUpload = <span class="function"><span class="keyword">function</span> (<span class="params">uploadType, files</span>) </span>&#123; <span class="comment">// uploadType 区分是控件还是 flash</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, file; file = files[i++];) &#123;</span><br><span class="line">        <span class="keyword">var</span> uploadObj = <span class="keyword">new</span> Upload(uploadType, file.fileName, file.fileSize);</span><br><span class="line">        uploadObj.init(id++); <span class="comment">// 给 upload 对象设置一个唯一的 id</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当用户选择完文件之后，startUpload 函数会遍历 files 数组来创建对应的 upload 对象。接下来定义 Upload 构造函数，它接受 3 个参数，分别是插件类型、文件名和文件大小。这些信息都已经被插件组装在 files 数组里返回，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span> (<span class="params">uploadType, fileName, fileSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadType = uploadType;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="keyword">this</span>.dom = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    <span class="keyword">this</span>.dom.innerHTML =</span><br><span class="line">        <span class="string">'&lt;span&gt;文件名称:'</span> + <span class="keyword">this</span>.fileName + <span class="string">', 文件大小: '</span> + <span class="keyword">this</span>.fileSize + <span class="string">'&lt;/span&gt;'</span> +</span><br><span class="line">        <span class="string">'&lt;button class="delFile"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">    <span class="keyword">this</span>.dom.querySelector(<span class="string">'.delFile'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        that.delFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.dom);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样为了简化示例，我们暂且去掉了 upload 对象的其他功能，只保留删除文件的功能，对应的方法是 Upload.prototype.delFile。该方法中有一个逻辑：当被删除的文小于 3000 KB 时，该文同样为了简化示例，我们暂且去掉了 upload 对象的其他功能，只留删除文件的功能，对应的方法是 Upload.prototype.delFile。该方法中有一逻辑：当被删除的文件小于 3000 KB 时，该文件将被直接删除。否则页面中会弹出一个提示框，提示用户是否确认要删除该文件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.delFile = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileSize &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.confirm(<span class="string">'确定要删除该文件吗? '</span> + <span class="keyword">this</span>.fileName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来分别创建 3 个插件上传对象和 3 个 Flash 上传对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">startUpload(<span class="string">'plugin'</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'1.txt'</span>,</span><br><span class="line">        fileSize: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'2.html'</span>,</span><br><span class="line">        fileSize: <span class="number">3000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'3.txt'</span>,</span><br><span class="line">        fileSize: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line">startUpload(<span class="string">'flash'</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'4.txt'</span>,</span><br><span class="line">        fileSize: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'5.html'</span>,</span><br><span class="line">        fileSize: <span class="number">3000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'6.txt'</span>,</span><br><span class="line">        fileSize: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>当点击删除最后一个文件时，可以看到弹出了是否确认删除的提示。</p>
<h3 id="4-2-享元模式重构文件上传"><a href="#4-2-享元模式重构文件上传" class="headerlink" title="4.2 享元模式重构文件上传"></a>4.2 享元模式重构文件上传</h3><p>上一节的代码是第一版的文件上传，在这段代码里有多少个需要上传的文件，就一共创建了多少个 upload 对象，接下来我们用享元模式重构它。</p>
<p>首先，我们需要确认插件类型 uploadType 是内部状态，那为什么单单 uploadType 是内部状态呢？前面讲过，划分内部状态和外部状态的关键主要有以下几点。</p>
<blockquote>
<ul>
<li>内部状态储存于对象内部。</li>
<li>内部状态可以被一些对象共享。</li>
<li>内部状态独立于具体的场景，通常不会改变。</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。</li>
</ul>
</blockquote>
<p>在文件上传的例子里，upload 对象必须依赖 uploadType 属性才能工作，这是因为插件上传、Flash 上传、表单上传的实际工作原理有很大的区别，它们各自调用的接口也是完全不一样的，必须在对象创建之初就明确它是什么类型的插件，才可以在程序的运行过程中，让它们分别调用各自的 start、pause、cancel、del 等方法。</p>
<p>实际上在微云的真实代码中，虽然插件和 Flash 上传对象最终创建自一个大的工厂类，但它们实际上根据 uploadType 值的不同，分别是来自于两个不同类的对象。（在目前的例子中，为了简化代码，我们把插件和 Flash 的构造函数合并成了一个。）</p>
<p>一旦明确了 uploadType，无论我们使用什么方式上传，这个上传对象都是可以被任何文件共用的。而 fileName 和 fileSize 是根据场景而变化的，每个文件的 fileName 和 fileSize 都不一样，fileName 和 fileSize 没有办法被共享，它们只能被划分为外部状态。</p>
<h3 id="4-3-剥离外部状态"><a href="#4-3-剥离外部状态" class="headerlink" title="4.3 剥离外部状态"></a>4.3 剥离外部状态</h3><p>明确了 uploadType 作为内部状态之后，我们再把其他的外部状态从构造函数中抽离出来，Upload 构造函数中只保留 uploadType 参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span> (<span class="params">uploadType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadType = uploadType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Upload.prototype.init 函数也不再需要，因为 upload 对象初始化的工作被放在了 uploadManager.add函数里面，接下来只需要定义 Upload.prototype.del 函数即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.delFile = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    uploadManager.setExternalState(id, <span class="keyword">this</span>); <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileSize &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.confirm(<span class="string">'确定要删除该文件吗? '</span> + <span class="keyword">this</span>.fileName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在开始删除文件之前，需要读取文件的实际大小，而文件的实际大小被储存在外部管理器uploadManager 中，所以在这里需要通过 uploadManager.setExternalState 方法给共享对象设置正确的 fileSize，上段代码中的(1)处表示把当前 id 对应的对象的外部状态都组装到共享对象中。</p>
<h3 id="4-4-工厂进行对象实例化"><a href="#4-4-工厂进行对象实例化" class="headerlink" title="4.4 工厂进行对象实例化"></a>4.4 工厂进行对象实例化</h3><p>接下来定义一个工厂来创建 upload 对象，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象，否则创建一个新的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UploadFactory = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> createdFlyWeightObjs = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        create: <span class="function"><span class="keyword">function</span> (<span class="params">uploadType</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (createdFlyWeightObjs[uploadType]) &#123;</span><br><span class="line">                <span class="keyword">return</span> createdFlyWeightObjs[uploadType];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> createdFlyWeightObjs[uploadType] = <span class="keyword">new</span> Upload(uploadType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="4-5-管理器封装外部状态"><a href="#4-5-管理器封装外部状态" class="headerlink" title="4.5 管理器封装外部状态"></a>4.5 管理器封装外部状态</h3><p>现在我们来完善前面提到的 uploadManager 对象，它负责向 UploadFactory 提交创建对象的请求，并用一个 uploadDatabase 对象保存所有 upload 对象的外部状态，以便在程序运行过程中给upload 共享对象设置外部状态，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uploadManager = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> uploadDatabase = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"> id, uploadType, fileName, fileSize </span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> flyWeightObj = UploadFactory.create( uploadType );</span><br><span class="line">            <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> );</span><br><span class="line">            dom.innerHTML =</span><br><span class="line">            <span class="string">'&lt;span&gt;文件名称:'</span>+ fileName +<span class="string">', 文件大小: '</span>+ fileSize +<span class="string">'&lt;/span&gt;'</span> +</span><br><span class="line">            <span class="string">'&lt;button class="delFile"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">            dom.querySelector( <span class="string">'.delFile'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                flyWeightObj.delFile( id );</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">document</span>.body.appendChild( dom );</span><br><span class="line">            uploadDatabase[ id ] = &#123;</span><br><span class="line">                fileName: fileName,</span><br><span class="line">                fileSize: fileSize,</span><br><span class="line">                dom: dom</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> flyWeightObj ;</span><br><span class="line">        &#125;,</span><br><span class="line">        setExternalState: <span class="function"><span class="keyword">function</span>(<span class="params"> id, flyWeightObj </span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> uploadData = uploadDatabase[ id ];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> uploadData )&#123;</span><br><span class="line">                flyWeightObj[ i ] = uploadData[ i ];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>然后是开始触发上传动作的 startUpload 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.startUpload = <span class="function"><span class="keyword">function</span>(<span class="params"> uploadType, files </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, file; file = files[ i++ ]; )&#123;</span><br><span class="line">        <span class="keyword">var</span> uploadObj = uploadManager.add( ++id, uploadType, file.fileName, file.fileSize );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后是测试时间，运行下面的代码后，可以发现运行结果跟用享元模式重构之前一致：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">startUpload( <span class="string">'plugin'</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'1.txt'</span>,</span><br><span class="line">        fileSize: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'2.html'</span>,</span><br><span class="line">        fileSize: <span class="number">3000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'3.txt'</span>,</span><br><span class="line">        fileSize: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line">startUpload( <span class="string">'flash'</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'4.txt'</span>,</span><br><span class="line">        fileSize: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'5.html'</span>,</span><br><span class="line">        fileSize: <span class="number">3000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: <span class="string">'6.txt'</span>, </span><br><span class="line">        fileSize: <span class="number">5000</span></span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>享元模式重构之前的代码里一共创建了 6个 upload 对象，而通过享元模式重构之后，对象的数量减少为 2，更幸运的是， 就算现在同时上传 2000个文件，需要创建的 upload 对象数量依然是 2。</p>
<h2 id="五、-享元模式的适用性"><a href="#五、-享元模式的适用性" class="headerlink" title="五、 享元模式的适用性"></a>五、 享元模式的适用性</h2><p>享元模式是一种很好的性能优化方案，但它也会带来一些复杂性的问题，从前面两组代码的比较可以看到，使用了享元模式之后，我们需要分别多维护一个 factory 对象和一个 manager 对象，在大部分不必要使用享元模式的环境下，这些开销是可以避免的。</p>
<p>享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时便可以使用享元模式。</p>
<blockquote>
<ul>
<li>一个程序中使用了大量的相似对象。</li>
<li>由于使用了大量对象，造成很大的内存开销。</li>
<li>对象的大多数状态都可以变为外部状态。</li>
<li>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。</li>
</ul>
</blockquote>
<p>可以看到，文件上传的例子完全符合这四点。</p>
<h2 id="六、-再谈内部状态和外部状态"><a href="#六、-再谈内部状态和外部状态" class="headerlink" title="六、 再谈内部状态和外部状态"></a>六、 再谈内部状态和外部状态</h2><p>如果顺利的话，通过前面的例子我们已经了解了内部状态和外部状态的概念以及享元模式的工作原理。我们知道，实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。现在来考虑两种极端的情况，即对象没有外部状态和没有内部状态的时候。 </p>
<h3 id="6-1-没有内部状态的享元"><a href="#6-1-没有内部状态的享元" class="headerlink" title="6.1 没有内部状态的享元"></a>6.1 没有内部状态的享元</h3><p>在文件上传的例子中，我们分别进行过插件调用和 Flash 调用，即 startUpload( ‘plugin’, [] )和 startUpload( flash, [] )，导致程序中创建了内部状态不同的两个共享对象。也许你会奇怪，在文件上传程序里，一般都会提前通过特性检测来选择一种上传方式，如果浏览器支持插件就用插件上传，如果不支持插件，就用 Flash 上传。那么，什么情况下既需要插件上传又需要 Flash 上传呢？</p>
<p>实际上这个需求是存在的，很多网盘都提供了极速上传（控件）与普通上传（Flash）两种模式，如果极速上传不好使（可能是没有安装控件或者控件损坏），用户还可以随时切换到普通上传模式，所以这里确实是需要同时存在两个不同的 upload 共享对象。</p>
<p>但不是每个网站都必须做得如此复杂，很多小一些的网站就只支持单一的上传方式。假设我们是这个网站的开发者，不需要考虑极速上传与普通上传之间的切换，这意味着在之前的代码中作为内部状态的 uploadType 属性是可以删除掉的。</p>
<p>在继续使用享元模式的前提下，构造函数 Upload 就变成了无参数的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>其他属性如 fileName、fileSize、dom 依然可以作为外部状态保存在共享对象外部。在uploadType 作为内部状态的时候，它可能为控件，也可能为 Flash，所以当时最多可以组合出两个共享对象。而现在已经没有了内部状态，这意味着只需要唯一的一个共享对象。现在我们要改写创建享元对象的工厂，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UploadFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> uploadObj;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( uploadObj )&#123;</span><br><span class="line">            <span class="keyword">return</span> uploadObj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uploadObj = <span class="keyword">new</span> Upload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>管理器部分的代码不需要改动，还是负责剥离和组装外部状态。可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂。虽然这时候的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，我们依然倾向于称之为享元模式。</p>
<h3 id="6-2-没有外部状态的享元"><a href="#6-2-没有外部状态的享元" class="headerlink" title="6.2 没有外部状态的享元"></a>6.2 没有外部状态的享元</h3><p>网上许多资料中，经常把 Java 或者 C#的字符串看成享元，这种说法是否正确呢？我们看看下面这段 Java 代码，来分析一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代码</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main( <span class="built_in">String</span> args[] )&#123;</span><br><span class="line">        <span class="built_in">String</span> a1 = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">"a"</span> ).intern();</span><br><span class="line">        <span class="built_in">String</span> a2 = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">"a"</span> ).intern();</span><br><span class="line">        System.out.println( a1 == a2 ); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段 Java 代码里，分别 new 了两个字符串对象 a1 和 a2。intern 是一种对象池技术， new String(“a”).intern()的含义如下。</p>
<blockquote>
<ul>
<li>如果值为 a 的字符串对象已经存在于对象池中，则返回这个对象的引用。</li>
<li>反之，将字符串 a 的对象添加进对象池，并返回这个对象的引用。</li>
</ul>
</blockquote>
<p>所以 a1 == a2 的结果是 true，但这并不是使用了享元模式的结果，享元模式的关键是区别内部状态和外部状态。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象。这里并没有剥离外部状态的过程，a1 和 a2 指向的完全就是同一个对象，所以如果没有外部状态的分离，即使这里使用了共享的技术，但并不是一个纯粹的享元模式。</p>
<h2 id="七、-对象池"><a href="#七、-对象池" class="headerlink" title="七、 对象池"></a>七、 对象池</h2><p>我们在前面已经提到了 Java 中 String 的对象池，下面就来学习这种共享的技术。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接 new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入池子等待被下次获取。</p>
<p>对象池的原理很好理解，比如我们组人手一本《JavaScript 权威指南》，从节约的角度来讲，这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书还回图书馆。如果同时有三个人要看这本书，而现在图书馆里只有两本，那我们再马上去书店买一本放入图书馆。</p>
<p>对象池技术的应用非常广泛，HTTP 连接池和数据库连接池都是其代表应用。在 Web 前端开发中，对象池使用最多的场景大概就是跟 DOM 有关的操作。很多空间和时间都消耗在了 DOM节点上，如何避免频繁地创建和删除 DOM 节点就成了一个有意义的话题。</p>
<h3 id="7-1-对象池实现"><a href="#7-1-对象池实现" class="headerlink" title="7.1 对象池实现"></a>7.1 对象池实现</h3><p>假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它 toolTip。如图 12-2 所示。</p>
<p><img src="/2019/06/17/cjxe4h6pq001m6sup4x81u0p4/flyweightPattern-01.png" alt="对象池图示"></p>
<p>在搜索我家附近地图的时候，页面里出现了 2 个小气泡。当我再搜索附近的兰州拉面馆时，页面中出现了 6 个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2 个小气泡删除掉，而是把它们放进对象池。这样在第二次的搜索结果页面里，我们只需要再创建 4 个小气泡而不是 6 个，如图 12-3 所示。</p>
<p><img src="/2019/06/17/cjxe4h6pq001m6sup4x81u0p4/flyweightPattern-02.png" alt="对象池图示"></p>
<p>先定义一个获取小气泡节点的工厂，作为对象池的数组成为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create 表示获取一个 div 节点，recover 表示回收一个 div 节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toolTipFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTipPool = []; <span class="comment">// toolTip 对象池</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ( toolTipPool.length === <span class="number">0</span> )&#123; <span class="comment">// 如果对象池为空</span></span><br><span class="line">                <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement( <span class="string">'div'</span> ); <span class="comment">// 创建一个 dom</span></span><br><span class="line">                <span class="built_in">document</span>.body.appendChild( div );</span><br><span class="line">                <span class="keyword">return</span> div;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果对象池里不为空</span></span><br><span class="line">                <span class="keyword">return</span> toolTipPool.shift(); <span class="comment">// 则从对象池中取出一个 dom</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        recover: <span class="function"><span class="keyword">function</span>(<span class="params"> tooltipDom </span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> toolTipPool.push( tooltipDom ); <span class="comment">// 对象池回收 dom</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>现在把时钟拨回进行第一次搜索的时刻，目前需要创建 2 个小气泡节点，为了方便回收，用一个数组 ary 来记录它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, str; str = [ <span class="string">'A'</span>, <span class="string">'B'</span> ][ i++ ]; )&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTip = toolTipFactory.create();</span><br><span class="line">    toolTip.innerHTML = str;</span><br><span class="line">    ary.push( toolTip );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你愿意稍稍测试一下，可以看到页面中出现了 innerHTML 分别为 A 和 B 的两个 div 节点。接下来假设地图需要开始重新绘制，在此之前要把这两个节点回收进对象池：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, toolTip; toolTip = ary[ i++ ]; )&#123;</span><br><span class="line">    toolTipFactory.recover( toolTip );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再创建 6 个小气泡：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, str; str = [ <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span> ][ i++ ]; )&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTip = toolTipFactory.create();</span><br><span class="line">    toolTip.innerHTML = str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在再测试一番，页面中出现了内容分别为 A、B、C、D、E、F 的 6 个节点，上一次创建好的节点被共享给了下一次操作。对象池跟享元模式的思想有点相似，虽然 innerHTML 的值 A、B、C、D 等也可以看成节点的外部状态，但在这里我们并没有主动分离内部状态和外部状态的过程。</p>
<h3 id="7-2-通用对象池实现"><a href="#7-2-通用对象池实现" class="headerlink" title="7.2 通用对象池实现"></a>7.2 通用对象池实现</h3><p>我们还可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectPoolFactory = <span class="function"><span class="keyword">function</span>(<span class="params"> createObjFn </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectPool = [];</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = objectPool.length === <span class="number">0</span> ?</span><br><span class="line">            createObjFn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ) : objectPool.shift();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;,</span><br><span class="line">        recover: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</span><br><span class="line">            objectPool.push( obj ); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在利用 objectPoolFactory 来创建一个装载一些 iframe 的对象池：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeFactory = objectPoolFactory( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement( <span class="string">'iframe'</span> );</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild( iframe );</span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        iframe.onload = <span class="literal">null</span>; <span class="comment">// 防止 iframe 重复加载的 bug</span></span><br><span class="line">        iframeFactory.recover( iframe ); <span class="comment">// iframe 加载完成之后回收节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> iframe1 = iframeFactory.create();</span><br><span class="line">iframe1.src = <span class="string">'http:// baidu.com'</span>;</span><br><span class="line"><span class="keyword">var</span> iframe2 = iframeFactory.create();</span><br><span class="line">iframe2.src = <span class="string">'http:// QQ.com'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe3 = iframeFactory.create();</span><br><span class="line">    iframe3.src = <span class="string">'http:// 163.com'</span>;</span><br><span class="line">&#125;, <span class="number">3000</span> );</span><br></pre></td></tr></table></figure>
<p>对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。本章用享元模式完成了一个文件上传的程序，其实也可以用对象池+事件委托来代替实现。</p>
<h2 id="八、-小结"><a href="#八、-小结" class="headerlink" title="八、 小结"></a>八、 小结</h2><p>享元模式是为解决性能问题而生的模式，这跟大部分模式的诞生原因都不一样。在一个存在大量相似对象的系统中，享元模式可以很好地解决大量对象带来的性能问题。</p>
<script type="text/javascript" src="/js/jquery.js?v=2.0.1" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>坚持原创技术分享，您的支持将鼓励我继续创作！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/images/weChatMoney.png" title="微信打赏" alt="微信打赏"><img src="/images/alipayMoney.png" title="支付宝打赏" alt="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/06/26/cjxe4h6ok001a6sup3emenbqo/" class="pre">javascript设计模式与开发实践十三（职责链模式）</a><a href="/2019/06/08/cjxe4h6pt001q6sup35ombyfl/" class="next">javascript设计模式与开发实践十一（模板方法模式）</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODk0OS8xNTQ3Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、-初识享元模式"><span class="toc-text">一、 初识享元模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、-内部状态与外部状态"><span class="toc-text">二、 内部状态与外部状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、-享元模式的通用结构"><span class="toc-text">三、 享元模式的通用结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、-文件上传的例子"><span class="toc-text">四、 文件上传的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-对象爆炸"><span class="toc-text">4.1 对象爆炸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-享元模式重构文件上传"><span class="toc-text">4.2 享元模式重构文件上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-剥离外部状态"><span class="toc-text">4.3 剥离外部状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-工厂进行对象实例化"><span class="toc-text">4.4 工厂进行对象实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-管理器封装外部状态"><span class="toc-text">4.5 管理器封装外部状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、-享元模式的适用性"><span class="toc-text">五、 享元模式的适用性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、-再谈内部状态和外部状态"><span class="toc-text">六、 再谈内部状态和外部状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-没有内部状态的享元"><span class="toc-text">6.1 没有内部状态的享元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-没有外部状态的享元"><span class="toc-text">6.2 没有外部状态的享元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、-对象池"><span class="toc-text">七、 对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-对象池实现"><span class="toc-text">7.1 对象池实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-通用对象池实现"><span class="toc-text">7.2 通用对象池实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、-小结"><span class="toc-text">八、 小结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/26/cjxe4h6ok001a6sup3emenbqo/">javascript设计模式与开发实践十三（职责链模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/cjxe4h6pq001m6sup4x81u0p4/">javascript设计模式与开发实践十二（享元模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/08/cjxe4h6pt001q6sup35ombyfl/">javascript设计模式与开发实践十一（模板方法模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/cjxe4h6pn001i6supay96kr7r/">javascript设计模式与开发实践十（组合模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/cjxe4h6po001k6supznqh2zf5/">javascript设计模式与开发实践九（命令模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/cjxe4h6q8001y6sup332iemsd/">javascript设计模式与开发实践八（发布—订阅模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/24/cjxe4h6jr000n6supbjgopyqk/">javascript设计模式与开发实践七（迭代器模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/cjxe4h6ps001o6sup1sxmit0e/">javascript设计模式与开发实践六（代理模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/cjxe4h6qa00206supxae1b389/">javascript设计模式与开发实践五（策略模式 ）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/21/cjxe4h6oi00166supv7shju7q/">javascript设计模式与开发实践四（单例模式）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/js实现拖拽/" style="font-size: 15px;">js实现拖拽</a> <a href="/tags/前端历史/" style="font-size: 15px;">前端历史</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/slot/" style="font-size: 15px;">slot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github-pages/" style="font-size: 15px;">github pages</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 新浪微博</i></div><iframe width="100%" height="400" frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1" class="share_self"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Abriams/Abriams.github.io" title="github地址" target="_blank">github地址</a><ul></ul><a href="https://weibo.com/u/6110018783/home?wvr=5" title="微博" target="_blank">微博</a><ul></ul><a href="https://juejin.im/timeline" title="掘金" target="_blank">掘金</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Abriams.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b1cc44eb56a7dbf6192c0702e5b38b08";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>