<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Abriams blog"><meta name="keywords" content="前端， 移动互联网, vue"><title>javascript数据结构与算法六（集合） | 淡笑忘、祈一世凡恋</title><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript数据结构与算法六（集合）</h1><a id="logo" href="/.">淡笑忘、祈一世凡恋</a><p class="description">进步的源泉来源于坚持不懈</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">javascript数据结构与算法六（集合）</h1><div class="post-meta"><a href="/2019/02/28/cjsu000d50011z4vbj8av4nzf/#comments" class="comment-count"></a><p><span class="date">Feb 28, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、构建数据集合"><a href="#一、构建数据集合" class="headerlink" title="一、构建数据集合"></a>一、构建数据集合</h2><p>集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。 </p>
<p>在深入学习集合的计算机科学实现之前，我们先看看它的数学概念。在数学中，集合是一组不同的对象（的集）。</p>
<p>比如说，一个由大于或等于0的整数组成的自然数集合：N = {0, 1, 2, 3, 4, 5, 6, …}。集合中的对象列表用“{}”（大括号）包围。</p>
<p>还有一个概念叫空集。空集就是不包含任何元素的集合。比如24和29之间的素数集合。由于24和29之间没有素数（除了1和自身，没有其他正因数的大于1的自然数），这个集合就是空集。空集用“{ }”表示。</p>
<p>你也可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。</p>
<p>在数学中，集合也有并集、交集、差集等基本操作。在本片文章中我们也会介绍这些操作</p>
<h2 id="二、创建集合"><a href="#二、创建集合" class="headerlink" title="二、创建集合"></a>二、创建集合</h2><p>首先创建set类，Set类的骨架如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个非常重要的细节，我们使用对象而不是数组来表示集合（items）。但也可以用数组实现。在这里我们用对象来实现，稍微有点儿不一样，也学习一下实现相似数据结构的新方<br>法。同时，JavaScript的对象不允许一个键指向两个不同的属性，也保证了集合里的元素都是唯一的。</p>
<p>接下来，需要声明一些集合可用的方法（我们会尝试模拟与ECMAScript 6实现相同的Set类）。</p>
<blockquote>
<p>add(value)：向集合添加一个新的项。<br>delete(value)：从集合移除一个值。<br>has(value)：如果值在集合中，返回true，否则返回false。<br>clear()：移除集合中的所有项。<br>size()：返回集合所包含元素的数量。与数组的length属性类似。<br>values()：返回一个包含集合中所有值的数组。</p>
</blockquote>
<h3 id="2-1-has-value-方法"><a href="#2-1-has-value-方法" class="headerlink" title="2.1 has(value)方法"></a>2.1 has(value)方法</h3><p>首先要实现的是has(value)方法。这是因为它会被add、remove等其他方法调用。下面看看它的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value <span class="keyword">in</span> items;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>既然我们使用对象来存储集合的值，就可以用JavaScript的in操作符来验证给定的值是否是items对象的属性。</p>
<p>但这个方法还有更好的实现方式，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.hasOwnProperty(value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有JavaScript对象都有hasOwnProperty方法。这个方法返回一个表明对象是否具有特定属性的布尔值。</p>
<h3 id="2-2-add方法"><a href="#2-2-add方法" class="headerlink" title="2.2 add方法"></a>2.2 add方法</h3><p>接下来要实现add方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value))&#123;</span><br><span class="line">        items[value] = value; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于给定的value，可以检查它是否存在于集合中。如果不存在，就把value添加到集合中（行{1}），返回true，表示添加了这个值。如果集合中已经有这个值，就返回false，表示没有添加它。</p>
<p>添加一个值的时候，把它同时作为键和值保存，因为这样有利于查找这个值。</p>
<h3 id="2-3-remove-和-clear-方法"><a href="#2-3-remove-和-clear-方法" class="headerlink" title="2.3 remove 和 clear 方法"></a>2.3 remove 和 clear 方法</h3><p>下面要实现remove方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.has(value))&#123;</span><br><span class="line">    <span class="keyword">delete</span> items[value]; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在remove方法中，我们会验证给定的value是否存在于集合中。如果存在，就从集合中移除value（行{2}），返回true，表示值被移除；否则返回false。</p>
<p>既然用对象来存储集合的items对象，就可以简单地使用delete操作符从items对象中移除属性（行{2}）。</p>
<p>使用Set类的示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>); <span class="comment">//true</span></span><br><span class="line">set.add(<span class="number">2</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>如果想移除集合中的所有值，可以用clear方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    items = &#123;&#125;; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要重置items对象，需要做的只是把一个空对象重新赋值给它（行{3}）。我们也可以迭代集合，用remove方法依次移除所有的值，但既然有更简单的方法，那样做就太麻烦了</p>
<h3 id="2-4-size-方法"><a href="#2-4-size-方法" class="headerlink" title="2.4 size 方法"></a>2.4 size 方法</h3><p>下一个要实现的是size方法（返回集合中有多少项）。这个方法有三种实现方式。</p>
<p>第一种方法是使用一个length变量，每当使用add或remove方法时控制它，就像在上一章中使用LinkedList类一样。</p>
<p>第二种方法，使用JavaScript内建的Object类的一个内建函数（ECMAScript 5以上版本）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript的Object类有一个keys方法，它返回一个包含给定对象所有属性的数组。在这种情况下，可以使用这个数组的length属性（行{4}）来返回items对象的属性个数。以上代码只能在现代浏览器中运行（比如IE9以上版本、Firefox 4以上版本、Chrome 5以上版本、Opera 12以上版本、Safari 5以上版本，等等）。</p>
<p>第三种方法是手动提取items对象的每一个属性，记录属性的个数并返回这个数字。这个方法可以在任何浏览器上运行，和之前的代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sizeLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(items.hasOwnProperty(key)) <span class="comment">//&#123;6&#125;</span></span><br><span class="line">        ++count; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>遍历items对象的所有属性（行{5}），检查它们是否是对象自身的属性（避免重复计数——行{6}）。如果是，就递增count变量的值（行{7}），最后在方法结束时返回这个数字。</p>
<p>不能简单地使用for-in语句遍历items对象的属性，并递增count变量的值。还需要使用hasOwnProperty方法（以验证items对象具有该属性），因为对象的原型包含了额外的属性（属性既有继承自JavaScript的Object类的，也有属于对象自身，未用于数据结构的）。</p>
<h3 id="2-5-values-方法"><a href="#2-5-values-方法" class="headerlink" title="2.5 values 方法"></a>2.5 values 方法</h3><p>values方法也应用了相同的逻辑，提取items对象的所有属性，以数组的形式返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> items) &#123; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (items.hasOwnProperty(key)) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">            values.push(items[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先遍历items对象的所有属性（行{7}），把它们添加一个数组中（行{8}），并返回这个数组。该方法类似于我们开发的sizeLegacy方法，但我们添加一个数组，而不是计算属性个数。</p>
<h3 id="2-6-使用-Set-类"><a href="#2-6-使用-Set-类" class="headerlink" title="2.6 使用 Set 类"></a>2.6 使用 Set 类</h3><p>现在数据结构已经完成了，执行Set类的方法，测试我们的Set类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出["1"]</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">1</span>)); <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size()); <span class="comment">//输出1 </span></span><br><span class="line">set.add(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出["1", "2"]</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">2</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size()); <span class="comment">//2</span></span><br><span class="line">set.remove(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出["2"]</span></span><br><span class="line">set.remove(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">//输出[]</span></span><br></pre></td></tr></table></figure>
<h2 id="三、-集合操作"><a href="#三、-集合操作" class="headerlink" title="三、 集合操作"></a>三、 集合操作</h2><p>对集合可以进行如下操作。</p>
<blockquote>
<p>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。<br>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。<br>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。<br>子集：验证一个给定集合是否是另一集合的子集。</p>
</blockquote>
<h3 id="3-1-并集"><a href="#3-1-并集" class="headerlink" title="3.1 并集"></a>3.1 并集</h3><p>并集的数学概念是集合A和集合B的并集，表示为：</p>
<blockquote>
<p>A∪B</p>
</blockquote>
<p>该集合定义如下：</p>
<blockquote>
<p>A∪B = { x | x ∈ A∨x ∈ B } </p>
</blockquote>
<p>意思是x（元素）存在于A中，或x存在于B中。下图展示了并集操作：</p>
<p><img src="/2019/02/28/cjsu000d50011z4vbj8av4nzf/union-01.png" alt="并集图示"></p>
<p>现在来实现Set类的union方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//union 方法</span></span><br><span class="line"><span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values(); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        unionSet.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values = otherSet.values(); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        unionSet.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先需要创建一个新的集合，代表两个集合的并集（行{1}）。接下来，获取第一个集合（当前的Set类实例）所有的值（values），遍历并全部添加到代表并集的集合中（行{2}）。然后对第二个集合做同样的事（行{3}）。最后返回结果。</p>
<p>测试一下上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line">setB.add(<span class="number">5</span>);</span><br><span class="line">setB.add(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> unionAB = setA.union(setB);</span><br><span class="line"><span class="built_in">console</span>.log(unionAB.values());  <span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>输出为[“1”, “2”, “3”, “4”, “5”, “6”]。注意元素3同时存在于A和B中，它在结果的集合中只出现一次。</p>
<h3 id="3-2-交集"><a href="#3-2-交集" class="headerlink" title="3.2 交集"></a>3.2 交集</h3><p>交集的数学概念是集合A和集合B的交集，表示为：</p>
<blockquote>
<p>A∩B</p>
</blockquote>
<p>该集合定义如下：</p>
<blockquote>
<p>A∩B = { x | x ∈ A∧x ∈ B } </p>
</blockquote>
<p>意思是x（元素）存在于A中，且x存在于B中。下图展示了交集操作：</p>
<p><img src="/2019/02/28/cjsu000d50011z4vbj8av4nzf/intersection-01.png" alt="交集图示"></p>
<p>现在来实现Set类的intersection方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;values.length; i++)&#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (otherSet.has(values[i]))&#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            intersectionSet.add(values[i]); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>intersection方法需要找到当前Set实例中，所有也存在于给定Set实例中的元素。首先创建一个新的Set实例，这样就能用它返回共有的元素（行{1}）。接下来，遍历当前Set实例所有的值（行{2}），验证它们是否也存在于otherSet实例（行{3}）之中。可以用前面实现的has方法来验证元素是否存在于Set实例中。然后，如果这个值也存在于另一个Set实例中，就将其添加到创建的intersectionSet变量中（行{4}），最后返回它。</p>
<p>测试一下intersection方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> intersectionAB = setA.intersection(setB);</span><br><span class="line"><span class="built_in">console</span>.log(intersectionAB.values());</span><br></pre></td></tr></table></figure>
<p>输出为[“2”, “3”]，因为2和3同时存在于两个集合中。</p>
<h3 id="3-3-差集"><a href="#3-3-差集" class="headerlink" title="3.3 差集"></a>3.3 差集</h3><p>差集的数学概念是集合A和集合B的差集，表示为：AB，定义如下图：</p>
<p><img src="/2019/02/28/cjsu000d50011z4vbj8av4nzf/difference-01.png" alt="差集图示"></p>
<p>意思是x（元素）存在于A中，且x不存在于B中。下图展示了集合A和B的差集操作：</p>
<p><img src="/2019/02/28/cjsu000d50011z4vbj8av4nzf/difference-02.png" alt="差集图示"></p>
<p>现在来实现Set类的difference方法： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (!otherSet.has(values[i])) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            differenceSet.add(values[i]); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>intersection方法会得到所有同时存在于两个集合中的值。而difference方法会得到所有存在于集合A但不存在于B的值。因此这两个方法在实现上唯一的区别就是行{3}。只获取不存在于otherSet实例中的值，而不是也存在于其中的值。行{1}、{2}和{4}是完全相同的。</p>
<p>测试difference方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> differenceAB = setA.difference(setB);</span><br><span class="line"><span class="built_in">console</span>.log(differenceAB.values());</span><br></pre></td></tr></table></figure>
<p>输出为[“1”]，因为1是唯一一个仅存在于setA的元素。</p>
<h3 id="3-4-子集"><a href="#3-4-子集" class="headerlink" title="3.4 子集"></a>3.4 子集</h3><p>子集的数学概念是集合A是集合B的子集（或集合B包含了A），表示为</p>
<blockquote>
<p>A⊆B</p>
</blockquote>
<p>该集合定义如下：</p>
<p>∀x { x ∈ A → x ∈ B } </p>
<p>意思是集合A中的每一个x（元素），也需要存在于B中。下图展示了集合A是集合B的子集：</p>
<p><img src="/2019/02/28/cjsu000d50011z4vbj8av4nzf/difference-01.png" alt="差集图示"></p>
<p>现在来实现Set类的subset方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size()) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(values[i])) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先需要验证的是当前Set实例的大小。如果当前实例中的元素比otherSet实例更多，它就不是一个子集（行{1}）。子集的元素个数需要小于或等于要比较的集合。</p>
<p>接下来要遍历集合中的所有元素（行{2}），验证这些元素也存在于otherSet中（行{3}）。如果有任何元素不存在于otherSet中，就意味着它不是一个子集，返回false（行{4}）。如果所有元素都存在于otherSet中，行{4}就不会被执行，那么就返回true（行{5}）。</p>
<p>检验一下上面的代码效果如何：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>); </span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">1</span>);</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setC = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setC.add(<span class="number">2</span>);</span><br><span class="line">setC.add(<span class="number">3</span>);</span><br><span class="line">setC.add(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(setA.subset(setB));</span><br><span class="line"><span class="built_in">console</span>.log(setA.subset(setC));</span><br></pre></td></tr></table></figure>
<p>我们有三个集合：setA是setB的子集（因此输出为true），然而setA不是setC的子集（setC只包含了setA中的2，而不包含1），因此输出为false。</p>
<h2 id="四、-ES6——Set-类"><a href="#四、-ES6——Set-类" class="headerlink" title="四、 ES6——Set 类"></a>四、 ES6——Set 类</h2><p>我们先看看原生的Set类怎么用。</p>
<p>还是用我们原来测试Set类的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">// 输出@Iterator</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">1</span>)); <span class="comment">// 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>
<p>和我们的Set不同，ES6的Set的values方法返回Iterator（第2章提到过），而不是值构成的数组。另一个区别是，我们实现的size方法返回set中存储的值的个数，而ES6的Set则有一个size属性。</p>
<p>可以用delete方法删除set中的元素：</p>
<p>set.delete(1); </p>
<p>clear方法会重置set数据结构，这跟我们实现的功能一样</p>
<h3 id="4-1-ES6-Set-类的操作"><a href="#4-1-ES6-Set-类的操作" class="headerlink" title="4.1 ES6 Set 类的操作"></a>4.1 ES6 Set 类的操作</h3><p>我们的Set类实现了并集、交集、差集、子集等数学操作，然而ES6原生的Set并没有这些功能。不过，有需要的话，我们也可以模拟。</p>
<p>我们的例子会用到下面两个集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setA.add(<span class="number">1</span>);</span><br><span class="line">setA.add(<span class="number">2</span>);</span><br><span class="line">setA.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">setB.add(<span class="number">2</span>);</span><br><span class="line">setB.add(<span class="number">3</span>);</span><br><span class="line">setB.add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="4-1-1-模拟并集操作"><a href="#4-1-1-模拟并集操作" class="headerlink" title="4.1.1 模拟并集操作"></a>4.1.1 模拟并集操作</h4><p>我们可以创建一个新的集合，用来添加两个集合中所有的元素（行{1}）。迭代这两个集合（行{2}、行{3}），把所有元素都添加到并集的集合中。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unionAb = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setA) unionAb.add(x); <span class="comment">//&#123;2&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setB) unionAb.add(x); <span class="comment">//&#123;3&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-模拟交集操作"><a href="#4-1-2-模拟交集操作" class="headerlink" title="4.1.2 模拟交集操作"></a>4.1.2 模拟交集操作</h4><p>模拟交集操作需要创建一个辅助函数，来生成包含setA和setB都有的元素的新集合（行{1}）。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intersection = <span class="function"><span class="keyword">function</span>(<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (setB.has(x)) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            intersectionSet.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> intersectionAB = intersection(setA, setB);</span><br></pre></td></tr></table></figure>
<p>交集可以用更简单的语法实现，代码如下：</p>
<blockquote>
<p>intersectionAb = new Set([x for (x of setA) if (setB.has(x))]); </p>
</blockquote>
<p>这和intersection函数的效果完全一样。</p>
<h4 id="4-1-3-模拟差集操作"><a href="#4-1-3-模拟差集操作" class="headerlink" title="4.1.3 模拟差集操作"></a>4.1.3 模拟差集操作</h4><p>交集操作创建的集合包含setA和setB都有的元素，差集操作创建的集合包含的则是setA有而setB没有的元素。看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> difference = <span class="function"><span class="keyword">function</span>(<span class="params">setA, setB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> setA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!setB.has(x)) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            differenceSet.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> differenceAB = difference(setA, setB);</span><br></pre></td></tr></table></figure>
<p>intersection函数和difference函数只有行{1}不同，因为差集中只添加setA有而setB没有的元素。</p>
<p>差集也可以用更简单的语法实现，代码如下：</p>
<blockquote>
<p>differenceAB = new Set([x for (x of setA) if (!setB.has(x))]); </p>
</blockquote>
<p>目前只有Firefox支持简化的语法，但在所有支持ES6的现代浏览器中都可以执行difference函数</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>在这片文章中，我们学习了如何从头实现一个与ECMAScript 6中定义的类似的Set类。我们还介绍了在其他编程语言的集合数据结构的实现中不常见的一些方法，比如并集、交集、差集和子集。因此，相比于其他编程语言目前的Set实现，我们实现了一个非常完备的Set类。</p>
<script type="text/javascript" src="/js/jquery.js?v=2.0.1" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>坚持原创技术分享，您的支持将鼓励我继续创作！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/images/weChatMoney.png" title="微信打赏" alt="微信打赏"><img src="/images/alipayMoney.png" title="支付宝打赏" alt="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/03/01/cjsu000gi0015z4vbxr3vo4rt/" class="pre">javascript数据结构与算法七（字典和散列表）</a><a href="/2019/02/26/cjsu000gh0014z4vb6m5b7ln3/" class="next">javascript数据结构与算法五（链表）</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODk0OS8xNTQ3Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、构建数据集合"><span class="toc-text">一、构建数据集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、创建集合"><span class="toc-text">二、创建集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-has-value-方法"><span class="toc-text">2.1 has(value)方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-add方法"><span class="toc-text">2.2 add方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-remove-和-clear-方法"><span class="toc-text">2.3 remove 和 clear 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-size-方法"><span class="toc-text">2.4 size 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-values-方法"><span class="toc-text">2.5 values 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-使用-Set-类"><span class="toc-text">2.6 使用 Set 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、-集合操作"><span class="toc-text">三、 集合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-并集"><span class="toc-text">3.1 并集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-交集"><span class="toc-text">3.2 交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-差集"><span class="toc-text">3.3 差集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-子集"><span class="toc-text">3.4 子集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、-ES6——Set-类"><span class="toc-text">四、 ES6——Set 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-ES6-Set-类的操作"><span class="toc-text">4.1 ES6 Set 类的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-模拟并集操作"><span class="toc-text">4.1.1 模拟并集操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-模拟交集操作"><span class="toc-text">4.1.2 模拟交集操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-模拟差集操作"><span class="toc-text">4.1.3 模拟差集操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、小结"><span class="toc-text">五、小结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/cjstzzzqu0000z4vbgca4clkl/">hashtable</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/cjsu000gi0015z4vbxr3vo4rt/">javascript数据结构与算法七（字典和散列表）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/cjsu000d50011z4vbj8av4nzf/">javascript数据结构与算法六（集合）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/26/cjsu000gh0014z4vb6m5b7ln3/">javascript数据结构与算法五（链表）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/20/cjsu000cd000tz4vbihcqk085/">javascript数据结构与算法四（队列）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/19/cjsu000c7000mz4vb4fnemf7t/">javascript数据结构与算法三（栈）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/cjsu000d40010z4vbjf2s5gzu/">javascript数据结构与算法二（数组的使用）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/13/cjstzzzs80005z4vbx8coo3x8/">javascript数据结构与算法一（javascript基础）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/cjstzzzsb0009z4vbx5l4ywae/">工作中遇到的问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/cjstzzzs90006z4vb67w9pabj/">vue slot使用小结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/js实现拖拽/" style="font-size: 15px;">js实现拖拽</a> <a href="/tags/前端历史/" style="font-size: 15px;">前端历史</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/slot/" style="font-size: 15px;">slot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github-pages/" style="font-size: 15px;">github pages</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 新浪微博</i></div><iframe width="100%" height="400" frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1" class="share_self"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Abriams/Abriams.github.io" title="github地址" target="_blank">github地址</a><ul></ul><a href="https://weibo.com/u/6110018783/home?wvr=5" title="微博" target="_blank">微博</a><ul></ul><a href="https://juejin.im/timeline" title="掘金" target="_blank">掘金</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Abriams.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b1cc44eb56a7dbf6192c0702e5b38b08";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>