<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Abriams blog"><meta name="keywords" content="前端， 移动互联网, vue"><title>javascript数据结构与算法十一（算法模式） | 淡笑忘、祈一世凡恋</title><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript数据结构与算法十一（算法模式）</h1><a id="logo" href="/.">淡笑忘、祈一世凡恋</a><p class="description">进步的源泉来源于坚持不懈</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">javascript数据结构与算法十一（算法模式）</h1><div class="post-meta"><a href="/2019/03/30/cjxb963zy001u38upamupk9rz/#comments" class="comment-count"></a><p><span class="date">Mar 30, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h2><p>递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。</p>
<p>递归函数是像下面这样能够直接调用自身的方法或函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFunction</span>(<span class="params">someParam</span>)</span>&#123;</span><br><span class="line">    recursiveFunction(someParam);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>能够像下面这样间接调用自身的函数，也是递归函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFunction1</span>(<span class="params">someParam</span>)</span>&#123;</span><br><span class="line">    recursiveFunction2(someParam);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFunction2</span>(<span class="params">someParam</span>)</span>&#123;</span><br><span class="line">    recursiveFunction1(someParam);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设现在必须要执行recursiveFunction，结果是什么？单单就上述情况而言，它会一直执行下去。因此，每个递归函数都必须要有边界条件，即一个不再递归调用的条件（停止点），以防止无限递归。</p>
<h3 id="1-1-JavaScript-调用栈大小的限制"><a href="#1-1-JavaScript-调用栈大小的限制" class="headerlink" title="1.1 JavaScript 调用栈大小的限制"></a>1.1 JavaScript 调用栈大小的限制</h3><p>如果忘记加上用以停止函数递归调用的边界条件，会发生什么呢？递归并不会无限地执行下去；浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error）。</p>
<p>每个浏览器都有自己的上限，可用以下代码测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    recursiveFn(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    recursiveFn();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    alert(<span class="string">'i = '</span> + i + <span class="string">' error: '</span> + ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Chrome v37中，这个函数执行了20 955次，而后浏览器抛出错误RangeError: Maximumcall stack size exceeded（超限错误：超过最大调用栈大小）。在Firefox v27中，函数执行了343 429次，然后浏览器抛出错误 InternalError: too much recursion（内部错误：递归次数过多）。</p>
<p>ECMAScript 6有尾调用优化（tail call optimization）。如果函数内最后一个操作是调用函数（就像示例中{1}的那行），会通过“跳转指令”（jump） 而不是“子程序调用”（subroutine call）来控制。也就是说，在ECMAScript 6中，这里的代码可以一直执行下去。所以，具有停止递归的边界条件非常重要。</p>
<h3 id="1-2-斐波那契数列"><a href="#1-2-斐波那契数列" class="headerlink" title="1.2 斐波那契数列"></a>1.2 斐波那契数列</h3><p>斐波那契数列的定义如下：</p>
<blockquote>
<p>1和2的斐波那契数是 1；<br>n（n&gt;2）的斐波那契数是(n-1)的斐波那契数加上(n-2)的斐波那契数。</p>
</blockquote>
<p>那么，让我们开始实现斐波那契函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span> || num === <span class="number">2</span>)&#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>边界条件是已知的，1和2的斐波那契数（行{1}）是1。现在，让我们完成斐波那契函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span> || num === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(num - <span class="number">1</span>) + fibonacci(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经知道，当n大于2时，Fibonacci(n)等于Fibonacci(n-1)+Fibonacci(n-2)。</p>
<p>现在，斐波那契函数实现完毕。让我们试着找出6的斐波那契数，其会产生如下函数调用</p>
<p><img src="/2019/03/30/cjxb963zy001u38upamupk9rz/algorithMpattern-01.png" alt="斐波那契函数示意图"></p>
<p>我们也可以用非递归的方式实现斐波那契函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n1 = <span class="number">1</span>,</span><br><span class="line">    n2 = <span class="number">1</span>,</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i&lt;=num; i++)&#123;</span><br><span class="line">        n = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为何用递归呢？更快吗？递归并不比普通版本更快，反倒更慢。但要知道，递归更容易理解，并且它所需的代码量更少。</p>
<p>在ECMAScript 6中，因为尾调用优化的缘故，递归并不会更慢。但是在其他语言中，递归通常更慢。</p>
<p>所以，我们用递归，通常是因为它更容易解决问题。</p>
<h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><p>动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p>
<p>之前提到过几次动态规划技术。用动态规划解决的一个问题就是深度优先搜索。</p>
<p>要注意动态规划和分而治之（归并排序和快速排序算法中用到的那种）是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。</p>
<p>另一个例子是上一节解决的斐波那契问题。我们将斐波那契问题分解成如该节图示的小问题。</p>
<p>用动态规划解决问题时，要遵循三个重要步骤：</p>
<blockquote>
<p>(1) 定义子问题；<br>(2) 实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；<br>(3) 识别并求解出边界条件。</p>
</blockquote>
<p>能用动态规划解决的一些著名的问题如下。</p>
<blockquote>
<p>背包问题：给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。<br>最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。<br>矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。<br>硬币找零：给出面额为d1…dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。<br>图的全源最短路径：对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。我们在前面已经学习过这个问题的Floyd-Warshall算法。</p>
</blockquote>
<h3 id="2-1-最少硬币找零问题"><a href="#2-1-最少硬币找零问题" class="headerlink" title="2.1 最少硬币找零问题"></a>2.1 最少硬币找零问题</h3><p>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找到所需的最少的硬币个数。</p>
<p>例如，美国有以下面额（硬币）：d1=1，d2=5，d3=10，d4=25。</p>
<p>如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（1美分）。</p>
<p>如何将这个解答转化成算法？</p>
<p>最少硬币找零的解决方案是找到n所需的最小硬币数。但要做到这一点，首先得找到对每个x&lt;n的解。然后，我们将解建立在更小的值的解的基础上。</p>
<p>来看看算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinCoinChange</span>(<span class="params">coins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coins = coins; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.makeChange = <span class="function"><span class="keyword">function</span> (<span class="params">amount</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!amount) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache[amount]) &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            <span class="keyword">return</span> cache[amount];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> min = [], newMin, newAmount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">                <span class="keyword">var</span> coin = coins[i];</span><br><span class="line">                newAmount = amount - coin; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (newAmount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    newMin = me.makeChange(newAmount); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    newAmount &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">                    (newMin.length &lt; min.length - <span class="number">1</span> || !min.length)<span class="comment">//&#123;9&#125;</span></span><br><span class="line">                    &amp;&amp; (newMin.length || !newAmount)) <span class="comment">//&#123;10&#125;)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                    min = [coin].concat(newMin); <span class="comment">//&#123;11&#125;</span></span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'new Min '</span> + min + <span class="string">' for '</span> + amount); </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (cache[amount] = min); <span class="comment">//&#123;12&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了更有条理，我们创建了一个类，解决给定面额的最少硬币找零问题。让我们一步步解读这个算法。</p>
<p>MinCoinChange类接收coins参数（行{1}），该参数代表问题中的面额。对美国的硬币系统而言，它是[1, 5, 10, 25]。我们可以随心所欲传递任何面额。此外，为了更加高效且不重复计算值，我们使用了cache（行{2}）。</p>
<p>接下来是makeChange方法，它也是一个递归函数，找零问题由它解决。首先，若amount不为正（&lt; 0），就返回空数组（行{3}）；方法执行结束后，会返回一个数组，包含用来找零的各个面额的硬币数量（最少硬币数）。接着，检查cache缓存。若结果已缓存（行{4}），则直接返回结果；否则，执行算法。</p>
<p>我们基于coins参数（面额）解决问题。因此，对每个面额（行{5}），我们都计算newAmount（行{6}）的值，它的值会一直减小，直到能找零的最小钱数（别忘了本算法对所有的x &lt; amount都会计算makeChange结果）。若newAmount是合理的值（正值），我们也会计算它的找零结果（行{7}）。</p>
<p>最后，我们判断newAmount是否有效，minValue（最少硬币数）是否是最优解，与此同时minValue和newAmount是否是合理的值（{行10}）。若以上判断都成立，意味着有一个比之前更优的答案（行{11}。以5美分为例，可以给5便士或者1个5美分镍币，1个5美分镍币是最优解）。最后，返回最终结果（行{12}）。</p>
<p>测试一下这个算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCoinChange = <span class="keyword">new</span> MinCoinChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(minCoinChange.makeChange(<span class="number">36</span>));</span><br></pre></td></tr></table></figure>
<p>要知道，如果我们检查cache变量，会发现它存储了从1到36美分的所有结果。以上代码的结果是[1, 10, 25]。</p>
<p>本节的源码中会有几行多余的代码，输出算法的步骤。例如，使用面额[1, 3, 4]，并对钱数6执行算法，会产生以下输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Min <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">1</span> <span class="keyword">for</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span> <span class="keyword">for</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">3</span> <span class="keyword">for</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">3</span> <span class="keyword">for</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">4</span> <span class="keyword">for</span> <span class="number">4</span> </span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">4</span> <span class="keyword">for</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span> <span class="keyword">for</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">new</span> Min <span class="number">3</span>,<span class="number">3</span> <span class="keyword">for</span> <span class="number">6</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>所以，找零钱数为6时，最佳答案是两枚价值为3的硬币。</p>
<h3 id="2-2-背包问题"><a href="#2-2-背包问题" class="headerlink" title="2.2 背包问题"></a>2.2 背包问题</h3><p>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重W的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大。</p>
<p>下面是一个例子：</p>
<table>
<thead>
<tr>
<th>物 品#</th>
<th>重 量</th>
<th>价 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>考虑背包能够携带的重量只有5。对于这个例子，我们可以说最佳解决方案是往背包里装入物品1和物品2，这样，总重量为5，总价值为7。</p>
<p>这个问题有两个版本。0-1版本只能往背包里装完整的物品，而分数背包问题则允许装入分数物品。在这个例子里，我们将处理该问题的0-1版本。动态规划对分数版本无能为力，但稍后要学习的贪心算法可以解决它。</p>
<p>我们来看看下面这个背包算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapSack</span>(<span class="params">capacity, weights, values, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, w, a, b, kS = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        kS[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt;= capacity; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || w == <span class="number">0</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">                kS[i][w] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &lt;= w) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                a = values[i - <span class="number">1</span>] + kS[i - <span class="number">1</span>][w - weights[i - <span class="number">1</span>]];</span><br><span class="line">                b = kS[i - <span class="number">1</span>][w];</span><br><span class="line">                kS[i][w] = (a &gt; b) ? a : b; <span class="comment">//&#123;4&#125; max(a,b)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                kS[i][w] = kS[i - <span class="number">1</span>][w]; <span class="comment">//&#123;5&#125; </span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kS[n][capacity]; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看这个算法是如何工作的。</p>
<blockquote>
<p>行{1}：首先，初始化将用于寻找解决方案的矩阵ks[n+1][capacity+1]。</p>
</blockquote>
<blockquote>
<p>行{2}：忽略矩阵的第一列和第一行，只处理索引不为0的列和行。</p>
</blockquote>
<blockquote>
<p>行{3}：物品i的重量必须小于约束（capacity）才有可能成为解决方案的一部分；否则，总重量就会超出背包能够携带的重量，这是不可能发生的。发生这种情况时，只要忽略它，用之前的值就可以了（行{5}）。</p>
</blockquote>
<blockquote>
<p>行{4}：当找到可以构成解决方案的物品时，选择价值最大的那个。</p>
</blockquote>
<blockquote>
<p>行{6}：最后，问题的解决方案就在这个二维表格右下角的最后一个格子里。</p>
</blockquote>
<p>我们可以用开头的例子来测试这个算法：</p>
<p>下图举例说明了例子中kS矩阵的构造：</p>
<p><img src="/2019/03/30/cjxb963zy001u38upamupk9rz/algorithMpattern-02.png" alt="背包问题函数示意图"></p>
<p>请注意，这个算法只输出背包携带物品价值的最大值，而不列出实际的物品。我们可以增加下面的附加函数来找出构成解决方案的物品：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findValues</span>(<span class="params">n, capacity, kS, weights, values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = n, k = capacity; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'解决方案包含以下物品：'</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kS[i][k] !== kS[i - <span class="number">1</span>][k]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'物品'</span> + i + <span class="string">'，重量：'</span> + weights[i - <span class="number">1</span>] + <span class="string">'，价值：'</span> + values[i - <span class="number">1</span>]);</span><br><span class="line">            i--;</span><br><span class="line">            k = k - kS[i][k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在knapsack函数的行{6}之前调用这个函数。执行完整的算法，会得到如下输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方案包含以下物品：</span><br><span class="line"><span class="number">88</span> 物品<span class="number">2</span>，重量：<span class="number">3</span>，价值：<span class="number">4</span></span><br><span class="line"><span class="number">88</span> 物品<span class="number">1</span>，重量：<span class="number">2</span>，价值：<span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-最长公共子序列"><a href="#2-3-最长公共子序列" class="headerlink" title="2.3 最长公共子序列"></a>2.3 最长公共子序列</h3><p>另一个经常被当作编程挑战问题的动态规划问题是最长公共子序列（LCS）：找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。</p>
<p>考虑如下例子：</p>
<p><img src="/2019/03/30/cjxb963zy001u38upamupk9rz/algorithMpattern-03.png" alt="案例示意图"></p>
<p>再看看下面这个算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lcs</span>(<span class="params">wordX, wordY</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = wordX.length,</span><br><span class="line">        n = wordY.length,</span><br><span class="line">        l = [],</span><br><span class="line">        i, j, a, b;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        l[i] = [];</span><br><span class="line">        <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            l[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                l[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordX[i - <span class="number">1</span>] == wordY[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                l[i][j] = l[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = l[i - <span class="number">1</span>][j];</span><br><span class="line">                b = l[i][j - <span class="number">1</span>];</span><br><span class="line">                l[i][j] = (a &gt; b) ? a : b; <span class="comment">//max(a, b)</span></span><br><span class="line">                <span class="comment">//&#123;4&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">return</span> l[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较背包问题和LCS算法，我们会发现两者非常相似。这项从顶部开始构建解决方案的技术被称为记忆，而解决方案就在表格或矩阵的右下角。</p>
<p>像背包问题算法一样，这种方法只输出LCS的长度，而不包含LCS的实际结果。要提取这个信息，需要对算法稍作修改，声明一个新的solution矩阵。如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lcs</span>(<span class="params">wordX, wordY</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = wordX.length,</span><br><span class="line">        n = wordY.length,</span><br><span class="line">        l = [],</span><br><span class="line">        i, j, a, b;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        l[i] = [];</span><br><span class="line">        solution[i] = [];<span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            l[i][j] = <span class="number">0</span>;</span><br><span class="line">            solution[i][j] = <span class="string">'0'</span>;<span class="comment">//&#123;2&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                l[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordX[i - <span class="number">1</span>] == wordY[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                l[i][j] = l[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                solution[i][j] = <span class="string">'diagonal'</span>;<span class="comment">//&#123;3&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a = l[i - <span class="number">1</span>][j];</span><br><span class="line">                b = l[i][j - <span class="number">1</span>];</span><br><span class="line">                l[i][j] = (a &gt; b) ? a : b; <span class="comment">//max(a, b)</span></span><br><span class="line">                solution[i][j]=(l[i][j] == l[i<span class="number">-1</span>][j]) ? <span class="string">'top'</span> : <span class="string">'left'</span>;<span class="comment">//&#123;4&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printSolution(solution, l, wordX, wordY, m, n);<span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">return</span> l[m][n];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//printSolution函数如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSolution</span>(<span class="params">solution, l, wordX, wordY, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = m, b = n, i, j,</span><br><span class="line">    x = solution[a][b],</span><br><span class="line">    answer = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span> (x !== <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solution[a][b] === <span class="string">'diagonal'</span>) &#123;</span><br><span class="line">            answer = wordX[a - <span class="number">1</span>] + answer;</span><br><span class="line">            a--;</span><br><span class="line">            b--; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (solution[a][b] === <span class="string">'left'</span>) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (solution[a][b] === <span class="string">'top'</span>) &#123;</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">        x = solution[a][b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'lcs: '</span> + answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当解矩阵的方向为对角线时，我们可以将字符添加到答案中。</p>
<p>如果用’acbaed’和’abcadf’两个字符串执行上面的算法，我们将得到输出4。用于构建结果的矩阵l看起来像下面这样。我们也可以用附加的算法来跟踪LCS的值（如下图高亮所示）。</p>
<p><img src="/2019/03/30/cjxb963zy001u38upamupk9rz/algorithMpattern-04.png" alt="最长公共子序列执行示意图"></p>
<p>通过上面的矩阵，我们知道LCS算法的结果是长度为4的acad。</p>
<h3 id="2-4-矩阵链相乘"><a href="#2-4-矩阵链相乘" class="headerlink" title="2.4 矩阵链相乘"></a>2.4 矩阵链相乘</h3><p>矩阵链相乘是另一个可以用动态规划解决的著名问题。这个问题是要找出一组矩阵相乘的最佳方式（顺序）。</p>
<p>让我们试着更好地理解这个问题。n行m列的矩阵A和m行p列的矩阵B相乘，结果是n行p列的矩阵C。</p>
<p>考虑我们想做A<em>B</em>C*D的乘法。因为乘法满足结合律，所以我们可以让这些矩阵以任意顺序相乘。因此，考虑如下情况：</p>
<blockquote>
<p>A是一个10行100列的矩阵<br>B是一个100行5列的矩阵<br>C是一个5行50列的矩阵<br>D是一个50行1列的矩阵</p>
</blockquote>
<p>A<em>B</em>C*D的结果是一个10行1列的矩阵</p>
<p>在这个例子里，相乘的方式有五种。</p>
<blockquote>
<p>(1) (A(B(CD)))：乘法运算的次数是1750次。<br>(2) ((AB)(CD))：乘法运算的次数是5300次。<br>(3) (((AB)C)D)：乘法运算的次数是8000次。<br>(4) ((A(BC))D)：乘法运算的次数是75 500次。<br>(5) (A((BC)D))：乘法运算的次数是31 000次。</p>
</blockquote>
<p>相乘的顺序不一样，要进行的乘法运算总数也有很大差异。那么，要如何构建一个算法，求出最少的乘法运算操作次数？矩阵链相乘的算法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matrixChainOrder</span>(<span class="params">p, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, k, l, q, m = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        m[i] = [];</span><br><span class="line">        m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">2</span>; l &lt; n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            j = i + l - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                q = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j]; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (q &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = q;</span><br><span class="line">                    <span class="comment">//&#123;2&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个算法中最重要的是行{1}，神奇之处全都在这一行。它计算了给定括号顺序的乘法运算次数，并将值保存在辅助矩阵m中。</p>
<p>对开头的例子执行上面的算法，会得到结果7500；正如我们前面提到的，这是最少的操作次数。看看这个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = [<span class="number">10</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">1</span>],</span><br><span class="line">n = p.length;</span><br><span class="line"><span class="built_in">console</span>.log(matrixChainOrder(p, n)); <span class="comment">//1750</span></span><br></pre></td></tr></table></figure>
<p>然而，这个算法也不会给出最优解的括号顺序。为了得到这些信息，我们可以对代码做一些改动。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matrixChainOrder</span>(<span class="params">p, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, j, k, l, q, m = [];</span><br><span class="line">    <span class="keyword">var</span> s = [];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        s[i] = [];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            s[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        m[i] = [];</span><br><span class="line">        m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">2</span>; l &lt; n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            j = i + l - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                q = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j]; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (q &lt; m[i][j]) &#123;</span><br><span class="line">                    m[i][j] = q;</span><br><span class="line">                    s[i][j] = k; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printOptimalParenthesis(s, <span class="number">1</span>, n - <span class="number">1</span>); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printOptimalParenthesis</span>(<span class="params">s, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"A["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"("</span>);</span><br><span class="line">        printOptimalParenthesis(s, i, s[i][j]);</span><br><span class="line">        printOptimalParenthesis(s, s[i][j] + <span class="number">1</span>, j);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> p = [<span class="number">10</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">1</span>],</span><br><span class="line">n = p.length;</span><br><span class="line"><span class="built_in">console</span>.log(matrixChainOrder(p, n));</span><br></pre></td></tr></table></figure>
<p>执行修改后的算法，也能得到括号的最佳顺序(A<a href="A[2](A[3]A[4]">1</a>))，并可以转化为(A(B(CD)))。</p>
<h2 id="三、-贪心算法"><a href="#三、-贪心算法" class="headerlink" title="三、 贪心算法"></a>三、 贪心算法</h2><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。</p>
<p>我们来看看如何用贪心算法解决前面的最少硬币找零问题和背包问题。（我们已经介绍了一些其他的贪心算法，比如Dijkstra算法、Prim算法和Kruskal算法。）</p>
<h3 id="3-1-最少硬币找零问题"><a href="#3-1-最少硬币找零问题" class="headerlink" title="3.1 最少硬币找零问题"></a>3.1 最少硬币找零问题</h3><p>最少硬币找零问题也能用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。</p>
<p>来看看算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinCoinChange</span>(<span class="params">coins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coins = coins; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.makeChange = <span class="function"><span class="keyword">function</span> (<span class="params">amount</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> change = [],</span><br><span class="line">            total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = coins.length; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">var</span> coin = coins[i];</span><br><span class="line">            <span class="keyword">while</span> (total + coin &lt;= amount) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                change.push(coin); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">                total += coin; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> change;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不说贪心版本的MinCoinChange比动态规划版本的简单多了。和动态规划方法相似，我们传递面额参数，实例化MinCoinChange（行{1}）。</p>
<p>对每个面额（行{2}——从大到小），把它的值和total相加后，total需要小于amount（行{3}）。我们会将当前面额coin添加到结果中（行{4}），也会将它和total相加（行{5}）。</p>
<p>如你所见，这个解法很简单。从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。</p>
<p>用和DP方法同样的测试代码测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCoinChange = <span class="keyword">new</span> MinCoinChange([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(minCoinChange.makeChange(<span class="number">36</span>));</span><br></pre></td></tr></table></figure>
<p>结果依然是[25, 10, 1]，和用DP得到的一样。下图阐释了算法的执行过程：</p>
<p><img src="/2019/03/30/cjxb963zy001u38upamupk9rz/algorithMpattern-05.png" alt="贪心算法最少硬币找零问题执行示意图"></p>
<p>然而，如果用[1, 3, 4]面额执行贪心算法，会得到结果[4, 1, 1]。如果用动态规划的解法，会得到最优的结果[3, 3]。</p>
<p>比起动态规划算法而言，贪心算法更简单、更快。然而，如我们所见，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</p>
<h3 id="3-2-分数背包问题"><a href="#3-2-分数背包问题" class="headerlink" title="3.2 分数背包问题"></a>3.2 分数背包问题</h3><p>求解分数背包问题的算法与动态规划版本稍有不同。在0-1背包问题中，只能向背包里装入完整的物品，而在分数背包问题中，我们可以装入分数的物品。我们用前面用过的例子来比较两者的差异，如下所示：</p>
<table>
<thead>
<tr>
<th>物 品#</th>
<th>重 量</th>
<th>价 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>在动态规划的例子里，我们考虑背包能够携带的重量只有5。而在这个例子里，我们可以说最佳解决方案是往背包里装入物品1和物品2，总重量为5，总价值为7。</p>
<p>如果在分数背包问题中考虑相同的容量，得到的结果是一样的。因此，我们考虑容量为6的情况。</p>
<p>在这种情况下，解决方案是装入物品1和物品2，还有25%的物品3。这样，重量为6的物品总价值为8.25。</p>
<p>我们来看看下面这个算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapSack</span>(<span class="params">capacity, values, weights</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = values.length,</span><br><span class="line">        load = <span class="number">0</span>, i = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (weights[i] &lt;= (capacity - load)) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            val += values[i];</span><br><span class="line">            load += weights[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> r = (capacity - load) / weights[i]; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            val += r * values[i];</span><br><span class="line">            load += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是对算法的解释。</p>
<blockquote>
<p>行{1}：总重量少于背包容量，继续迭代，装入物品。<br>行{2}：如果物品可以完整地装入背包，就将其价值和重量分别计入背包已装入物品的总价值（val）和总重量（load）。<br>行{3}：如果物品不能完整地装入背包，计算能够装入部分的比例（r）。</p>
</blockquote>
<p>如果在0-1背包问题中考虑同样的容量6，我们就会看到，物品1和物品3组成了解决方案。在这种情况下，对同一个问题应用不同的解决方法，会得到两种不同的结果。</p>
<p>测试以上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    weights = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    capacity = <span class="number">5</span>,</span><br><span class="line">    n = values.length;</span><br><span class="line"><span class="built_in">console</span>.log(knapSack(capacity, values, weights)) <span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<h2 id="四、-函数式编程简介"><a href="#四、-函数式编程简介" class="headerlink" title="四、 函数式编程简介"></a>四、 函数式编程简介</h2><p>到目前为止，我们在本书中所用的编程范式都是命令式编程。在命令式编程中，我们按部就班地编写程序代码，详细描述要完成的事情以及完成的顺序。</p>
<p>在本节中，我们会介绍一种新的范式，叫作函数式编程。函数式编程是一种曾经主要用于学术领域的范式，多亏了Python和Ruby等现代语言，它才开始在行业开发者中流行起来。值得欣慰的是，借助ES6的能力，JavaScript也能够进行函数式编程。</p>
<h3 id="4-1-函数式编程与命令式编程"><a href="#4-1-函数式编程与命令式编程" class="headerlink" title="4.1 函数式编程与命令式编程"></a>4.1 函数式编程与命令式编程</h3><p>以函数式范式进行开发并不简单；关键在于习惯这种范式的机制。我们编写一个例子来说明差异。</p>
<p>假设我们想打印一个数组中所有的元素。我们可以用命令式编程，声明的函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printArray = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">printArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们迭代数组，打印每一项。</p>
<p>现在，我们试着把这个例子转换成函数式编程。在函数式编程中，函数就是摇滚明星。我们关注的重点是需要描述什么，而不是如何描述。回到这一句：“我们迭代数组，打印每一项”。那么，我们首先要关注的是迭代数据，然后进行操作，即打印数组项。下面的函数负责迭代数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forEach = <span class="function"><span class="keyword">function</span> (<span class="params">array, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        action(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，我们要创建另一个负责把数组元素打印到控制台的函数（考虑为回调函数），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logItem = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，像下面这样使用声明的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], logItem);</span><br></pre></td></tr></table></figure>
<p>只需要上面这一行代码，我们就能描述我们要把数组的每一项打印到控制台。这是我们的第一个函数式编程的例子！</p>
<p>有几点要注意：</p>
<blockquote>
<p>主要目标是描述数据，以及要对数据应用的转换；<br>程序执行顺序的重要性很低，而在命令式编程中，步骤和顺序是非常重要的；<br>函数和数据集合是函数式编程的核心；<br>在函数式编程中，我们可以使用和滥用函数和递归，而在命令式编程中，则使用循环、赋值、条件和函数。</p>
</blockquote>
<h3 id="4-2-ES2015-和函数式编程"><a href="#4-2-ES2015-和函数式编程" class="headerlink" title="4.2 ES2015 和函数式编程"></a>4.2 ES2015 和函数式编程</h3><p>有了ES2015的新功能，用JavaScript进行函数式编程变得更加容易了。我们来看一个例子。</p>
<p>考虑我们要找出数组中最小的值。要用命令式编程完成这个任务，只要迭代数组，检查当前的最小值是否大于数组元素；如果是，就更新最小值，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMinArray = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> minValue = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minValue &gt; array[i]) &#123;</span><br><span class="line">            minValue = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(findMinArray([<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>])); <span class="comment">//输出4</span></span><br></pre></td></tr></table></figure>
<p>用函数式编程完成相同的任务，可以使用Math.min函数，传入所有要比较的数组元素。我们可以像下面的例子里这样，使用ES2015的解构操作符（…），把数组转换成单个的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> min_ = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(...array)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(min_([<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>])); <span class="comment">//输出4</span></span><br></pre></td></tr></table></figure>
<p>使用ES2015的箭头函数，我们可以进一步简化上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> min = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Math</span>.min(...arr);</span><br><span class="line"><span class="built_in">console</span>.log(min([<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]));</span><br></pre></td></tr></table></figure>
<h3 id="4-3-JavaScript-函数式工具箱——-map、filter-和-reduce"><a href="#4-3-JavaScript-函数式工具箱——-map、filter-和-reduce" class="headerlink" title="4.3 JavaScript 函数式工具箱—— map、filter 和 reduce"></a>4.3 JavaScript 函数式工具箱—— map、filter 和 reduce</h3><p>map、filter和reduce函数是函数式编程的基础。</p>
<p>我们可以使用map函数，把一个数据集合转换或映射成另一个数据集合。先看一个命令式编程的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> daysOfWeek = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Monday'</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Tuesday'</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Wednesday'</span>, <span class="attr">value</span>: <span class="number">7</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> daysOfWeekValues_ = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; daysOfWeek.length; i++) &#123;</span><br><span class="line">    daysOfWeekValues_.push(daysOfWeek[i].value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再以函数式编程来考虑同样的例子，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> daysOfWeekValues = daysOfWeek.map(<span class="function"><span class="keyword">function</span>(<span class="params">day</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> day.value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(daysOfWeekValues);</span><br></pre></td></tr></table></figure>
<p>我们可以使用filter函数过滤一个集合的值。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> positiveNumbers_ = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> positive = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            positive.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positive;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(positiveNumbers_([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>]));</span><br></pre></td></tr></table></figure>
<p>我们可以把同样的代码写成函数式的，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> positiveNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(positiveNumbers([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>]));</span><br></pre></td></tr></table></figure>
<p>我们也可以使用reduce函数，把一个集合归约成一个特定的值。比如，对一个数组中的值求和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumValues = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        total += array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sumValues([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]));</span><br></pre></td></tr></table></figure>
<p>上面的代码也可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum_ = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sum_([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]));</span><br></pre></td></tr></table></figure>
<p>我们还可以把这些函数与ES2015的功能结合起来，比如解构操作符和箭头函数，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="built_in">console</span>.log(sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]));</span><br></pre></td></tr></table></figure>
<p>我们再看另一个例子。考虑我们需要写一个函数，把几个数组连接起来。为此，可以创建另一个数组，用于存放其他数组的元素。我们可以执行以下命令式的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> mergeArrays_ = <span class="function"><span class="keyword">function</span> (<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = arrays.length,</span><br><span class="line">        newArray = [],</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arrays[i].length; j++) &#123;</span><br><span class="line">            newArray[k++] = arrays[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(mergeArrays_([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>]]));</span><br></pre></td></tr></table></figure>
<p>注意，在这个例子中，我们声明了变量，还使用了循环。现在，我们用JavaScript函数式编程把上面的代码重写如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeArraysConcat = <span class="function"><span class="keyword">function</span> (<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arrays.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">p, n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.concat(n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(mergeArraysConcat([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>]]));</span><br></pre></td></tr></table></figure>
<p>上面的代码完成了同样的任务，但它是面向函数的。我们也可以用ES2015使代码更加精简，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> mergeArrays = <span class="function">(<span class="params">...arrays</span>) =&gt;</span> [].concat(...arrays);</span><br><span class="line">    <span class="built_in">console</span>.log(mergeArrays([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>])); </span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-JavaScript-函数式类库和数据结构"><a href="#4-4-JavaScript-函数式类库和数据结构" class="headerlink" title="4.4 JavaScript 函数式类库和数据结构"></a>4.4 JavaScript 函数式类库和数据结构</h3><p>有一些很棒的JavaScript类库借助工具函数和函数式数据结构，对函数式编程提供支持。通过下面的列表，你可以找到一些最有名的JavaScript函数式类库。</p>
<blockquote>
<p>Underscode.js：<a href="http://underscorejs.org/" target="_blank" rel="noopener">http://underscorejs.org/</a><br>Bilby.js：<a href="http://bilby.brianmckenna.org/" target="_blank" rel="noopener">http://bilby.brianmckenna.org/</a><br>Lazy.js：<a href="http://danieltao.com/lazy.js/" target="_blank" rel="noopener">http://danieltao.com/lazy.js/</a><br>Bacon.js：<a href="https://baconjs.github.io/" target="_blank" rel="noopener">https://baconjs.github.io/</a><br>Fn.js：<a href="http://eliperelman.com/fn.js/" target="_blank" rel="noopener">http://eliperelman.com/fn.js/</a><br>Functional.js：<a href="http://functionaljs.com/" target="_blank" rel="noopener">http://functionaljs.com/</a><br>Ramda.js：<a href="http://ramdajs.com/0.20.1/index.html" target="_blank" rel="noopener">http://ramdajs.com/0.20.1/index.html</a><br>Mori：<a href="http://swannodette.github.io/mori/" target="_blank" rel="noopener">http://swannodette.github.io/mori/</a> </p>
</blockquote>
<script type="text/javascript" src="/js/jquery.js?v=2.0.1" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>坚持原创技术分享，您的支持将鼓励我继续创作！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/images/weChatMoney.png" title="微信打赏" alt="微信打赏"><img src="/images/alipayMoney.png" title="支付宝打赏" alt="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/04/12/cjxb963tq000q38up62q8utcf/" class="pre">javascript数据结构与算法十二（算法复杂度）</a><a href="/2019/03/18/cjxb963yp001g38upugrji4zc/" class="next">javascript数据结构与算法十（排序和搜索算法）</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODk0OS8xNTQ3Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、递归"><span class="toc-text">一、递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-JavaScript-调用栈大小的限制"><span class="toc-text">1.1 JavaScript 调用栈大小的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-斐波那契数列"><span class="toc-text">1.2 斐波那契数列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、动态规划"><span class="toc-text">二、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-最少硬币找零问题"><span class="toc-text">2.1 最少硬币找零问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-背包问题"><span class="toc-text">2.2 背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-最长公共子序列"><span class="toc-text">2.3 最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-矩阵链相乘"><span class="toc-text">2.4 矩阵链相乘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、-贪心算法"><span class="toc-text">三、 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-最少硬币找零问题"><span class="toc-text">3.1 最少硬币找零问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-分数背包问题"><span class="toc-text">3.2 分数背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、-函数式编程简介"><span class="toc-text">四、 函数式编程简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-函数式编程与命令式编程"><span class="toc-text">4.1 函数式编程与命令式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ES2015-和函数式编程"><span class="toc-text">4.2 ES2015 和函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-JavaScript-函数式工具箱——-map、filter-和-reduce"><span class="toc-text">4.3 JavaScript 函数式工具箱—— map、filter 和 reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-JavaScript-函数式类库和数据结构"><span class="toc-text">4.4 JavaScript 函数式类库和数据结构</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/cjxb963tt000u38uprgkjwd1u/">javascript设计模式与开发实践十二（享元模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/08/cjxb963yy001o38upg71bfm02/">javascript设计模式与开发实践十一（模板方法模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/cjxb963yr001i38updwtse7tw/">javascript设计模式与开发实践十（组合模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/29/cjxb963yt001k38upc9sz9n70/">javascript设计模式与开发实践九（命令模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/28/cjxb96401001w38upj0wm4v5r/">javascript设计模式与开发实践八（发布—订阅模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/24/cjxb963tj000l38upxnvd8kv3/">javascript设计模式与开发实践七（迭代器模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/cjxb963yv001m38upim3k1op0/">javascript设计模式与开发实践六（代理模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/cjxb96402001y38up999uarvs/">javascript设计模式与开发实践五（策略模式 ）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/21/cjxb963vp001a38upu5dbnee1/">javascript设计模式与开发实践四（单例模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/07/cjxb9640f002138uphr08v3sr/">javascript设计模式与开发实践三（闭包和高阶函数）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/js实现拖拽/" style="font-size: 15px;">js实现拖拽</a> <a href="/tags/前端历史/" style="font-size: 15px;">前端历史</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/slot/" style="font-size: 15px;">slot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github-pages/" style="font-size: 15px;">github pages</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 新浪微博</i></div><iframe width="100%" height="400" frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1" class="share_self"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Abriams/Abriams.github.io" title="github地址" target="_blank">github地址</a><ul></ul><a href="https://weibo.com/u/6110018783/home?wvr=5" title="微博" target="_blank">微博</a><ul></ul><a href="https://juejin.im/timeline" title="掘金" target="_blank">掘金</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Abriams.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b1cc44eb56a7dbf6192c0702e5b38b08";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>