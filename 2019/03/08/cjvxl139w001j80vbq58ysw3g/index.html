<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Abriams blog"><meta name="keywords" content="前端， 移动互联网, vue"><title>javascript数据结构与算法九（图） | 淡笑忘、祈一世凡恋</title><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript数据结构与算法九（图）</h1><a id="logo" href="/.">淡笑忘、祈一世凡恋</a><p class="description">进步的源泉来源于坚持不懈</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">javascript数据结构与算法九（图）</h1><div class="post-meta"><a href="/2019/03/08/cjvxl139w001j80vbq58ysw3g/#comments" class="comment-count"></a><p><span class="date">Mar 08, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、图的相关术语"><a href="#一、图的相关术语" class="headerlink" title="一、图的相关术语"></a>一、图的相关术语</h2><p>图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。</p>
<p>任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。</p>
<p>我们还可以使用图来表示道路、航班以及通信状态，如下图所示：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-01.png" alt="数据结构-图示例"></p>
<p>让我们来学习一下图在数学及技术上的概念。</p>
<p>一个图G = (V, E)由以下元素组成。</p>
<blockquote>
<p>V：一组顶点<br>E：一组边，连接V中的顶点</p>
</blockquote>
<p>下图表示一个图：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-02.png" alt="数据结构-图示例"></p>
<p>在着手实现算法之前，让我们先了解一下图的一些术语。</p>
<p>由一条边连接在一起的顶点称为相邻顶点。比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。</p>
<p>一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此，A的度为3；E和其他两个顶点相连，因此，E的度为2。</p>
<p>路径是顶点v1, v2,…,vk的一个连续序列，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。</p>
<p>简单路径要求不包含重复的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如A D C A（最后一个顶点重新回到A）。</p>
<p>如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。</p>
<h3 id="1-1-有向图和无向图"><a href="#1-1-有向图和无向图" class="headerlink" title="1.1 有向图和无向图"></a>1.1 有向图和无向图</h3><p>图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-03.png" alt="数据结构-图示例"></p>
<p>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的，而A和B不是强连通的。</p>
<p>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-04.png" alt="加权图示例"></p>
<p>我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。</p>
<h2 id="二、-图的表示"><a href="#二、-图的表示" class="headerlink" title="二、 图的表示"></a>二、 图的表示</h2><p>从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。</p>
<h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0，如下图所示：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-05.png" alt="邻接矩阵示例"></p>
<p>不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而2维数组不太灵活。</p>
<h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-06.png" alt="邻接矩阵示例"></p>
<p>尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质（例如，要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。在本书的示例中，我们将会使用邻接表表示法。</p>
<h3 id="2-3-关联矩阵"><a href="#2-3-关联矩阵" class="headerlink" title="2.3 关联矩阵"></a>2.3 关联矩阵</h3><p>我们还可以用关联矩阵来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-07.png" alt="关联矩阵示意图"></p>
<p>关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。</p>
<h2 id="三、创建Graph类"><a href="#三、创建Graph类" class="headerlink" title="三、创建Graph类"></a>三、创建Graph类</h2><p>照例，我们声明类的骨架：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = []; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">var</span> adjList = <span class="keyword">new</span> Dictionary(); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一个数组来存储图中所有顶点的名字（行{1}），以及一个字典（在第7章中已经实现）来存储邻接表（行{2}）。字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和adjList字典两者都是我们Graph类的私有属性。</p>
<p>接着，我们将实现两个方法：一个用来向图中添加一个新的顶点（因为图实例化后是空的），另外一个方法用来添加顶点之间的边。我们先实现addVertex方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addVertex = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    vertices.push(v); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    adjList.set(v, []); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法接受顶点v作为参数。我们将该顶点添加到顶点列表中（行{3}），并且在邻接表中，设置顶点v作为键对应的字典值为一个空数组（行{4}）。</p>
<p>现在，我们来实现addEdge方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEdge = <span class="function"><span class="keyword">function</span>(<span class="params">v, w</span>)</span>&#123;</span><br><span class="line">    adjList.get(v).push(w); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    adjList.get(w).push(v); <span class="comment">//&#123;6&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法接受两个顶点作为参数。首先，通过将w加入到v的邻接表中，我们添加了一条自顶点v到顶点w的边。如果你想实现一个有向图，则行{5}就足够了。由于本章中大多数的例子都是基于无向图的，我们需要添加一条自w向v的边（行{6}）。</p>
<p>为了更方便一些，让我们来实现一下Graph类的toString方法，以便于在控制台输出图。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;vertices.length; i++)&#123; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">        s += vertices[i] + <span class="string">' -&gt; '</span>;</span><br><span class="line">        <span class="keyword">var</span> neighbors = adjList.get(vertices[i]); <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;neighbors.length; j++)&#123; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">            s += neighbors[j] + <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="string">'\n'</span>; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们为邻接表表示法构建了一个字符串。首先，迭代vertices数组列表（行{10}），将顶点的名字加入字符串中。接着，取得该顶点的邻接表（行{11}），同样也迭代该邻接表（行{12}），将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符（行{13}），这样就可以在控制台看到一个漂亮的输出了。运行如下代码：</p>
<p>测试以上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"><span class="keyword">var</span> myVertices = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>]; <span class="comment">//&#123;7&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;myVertices.length; i++)&#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">    graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">//&#123;9&#125;</span></span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'C'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'H'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'E'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'F'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'E'</span>, <span class="string">'I'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(graph.toString());</span><br></pre></td></tr></table></figure>
<p>为方便起见，我们创建了一个数组，包含所有我们想添加到图中的顶点（行{7}）。接下来，我们只要遍历vertices数组并将其中的值逐一添加到我们的图中（行{8}）。最后，我们添加想要的边（行{9}）。这段代码将会创建一个图，也就是到目前为止本章的示意图所使用的。</p>
<p>输出如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B C D</span><br><span class="line">B -&gt; A E F</span><br><span class="line">C -&gt; A D G</span><br><span class="line">D -&gt; A C G H</span><br><span class="line">E -&gt; B I</span><br><span class="line">F -&gt; B</span><br><span class="line">G -&gt; C D</span><br><span class="line">H -&gt; D</span><br><span class="line">I -&gt; E</span><br></pre></td></tr></table></figure>
<p>一个漂亮的邻接表！从该输出中，我们知道顶点A有这几个相邻顶点：B、C和D。</p>
<h2 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h2><p>和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。</p>
<p>在实现算法之前，让我们来更好地理解一下图遍历的思想方法。</p>
<p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</p>
<p>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
<p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>
<p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构。</p>
<table>
<thead>
<tr>
<th>算 法</th>
<th>数据结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>深度优先搜索</td>
<td>栈</td>
<td>通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td>
</tr>
<tr>
<td>广度优先搜索</td>
<td>队列</td>
<td>通过将顶点存入队列中，最先入队列的顶点先被探索</td>
</tr>
</tbody>
</table>
<p>当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。</p>
<blockquote>
<p>白色：表示该顶点还没有被访问。<br>灰色：表示该顶点被访问过，但并未被探索过。<br>黑色：表示该顶点被访问过且被完全探索过。</p>
</blockquote>
<p>这就是之前提到的务必访问每个顶点最多两次的原因。</p>
<h3 id="4-1-广度优先搜索"><a href="#4-1-广度优先搜索" class="headerlink" title="4.1 广度优先搜索"></a>4.1 广度优先搜索</h3><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-08.png" alt="广度优先遍历"></p>
<p>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。</p>
<p>(1) 创建一个队列Q。<br>(2) 将v标注为被发现的（灰色），并将v入队列Q。<br>(3) 如果Q非空，则运行以下步骤：<br>    (a) 将u从Q中出队列；<br>    (b) 将标注u为被发现的（灰色）；<br>    (c) 将u所有未被访问过的邻点（白色）入队列；<br>    (d) 将u标注为已被探索的（黑色）。</p>
<p>让我们来实现广度优先搜索算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initializeColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">        color[vertices[i]] = <span class="string">'white'</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">this</span>.bfs = <span class="function"><span class="keyword">function</span> (<span class="params">v, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(), <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    queue = <span class="keyword">new</span> Queue(); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    queue.enqueue(v); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">var</span> u = queue.dequeue(), <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            neighbors = adjList.get(u); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">        color[u] = <span class="string">'grey'</span>; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">            <span class="keyword">var</span> w = neighbors[i]; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">                color[w] = <span class="string">'grey'</span>; <span class="comment">// &#123;12&#125;</span></span><br><span class="line">                queue.enqueue(w); <span class="comment">// &#123;13&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = <span class="string">'black'</span>; <span class="comment">// &#123;14&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (callback) &#123; <span class="comment">// &#123;15&#125;</span></span><br><span class="line">            callback(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>广度优先搜索和深度优先搜索都需要标注被访问过的顶点。为此，我们将使用一个辅助数组color。由于当算法开始执行时，所有的顶点颜色都是白色（行{1}），所以我们可以创建一个辅助函数initializeColor，为这两个算法执行此初始化操作。</p>
<p>让我们深入学习广度优先搜索方法的实现。我们要做的第一件事情是用initializeColor函数来将color数组初始化为white（行{2}）。我们还需要声明和创建一个Queue实例（行{3}），它将会存储待访问和待探索的顶点。</p>
<p>照着本章开头解释过的步骤，bfs方法接受一个顶点作为算法的起始点。起始顶点是必要的，我们将此顶点入队列（行{4}）。</p>
<p>如果队列非空（行{5}），我们将通过出队列（行{6}）操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表（行{7}）。该顶点将被标注为grey（行{8}），表示我们发现了它（但还未完成对其的探索）。</p>
<p>对于u（行{9}）的每个邻点，我们取得其值（该顶点的名字——行{10}），如果它还未被访问过（颜色为white——行{11}），则将其标注为我们已经发现了它（颜色设置为grey——行<br>{12}），并将这个顶点加入队列中（行{13}），这样当其从队列中出列的时候，我们可以完成对其的探索。</p>
<p>当完成探索该顶点和其相邻顶点后，我们将该顶点标注为已探索过的（颜色设置为black——行{14}）。</p>
<p>我们实现的这个bfs方法也接受一个回调（我们在第8章中遍历树时使用了一个相似的方法）。这个参数是可选的，如果我们传递了回调函数（行{15}），会用到它。</p>
<p>让我们执行下面这段代码来测试一下这个算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printNode</span>(<span class="params">value</span>)</span>&#123; <span class="comment">//&#123;16&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Visited vertex: '</span> + value); <span class="comment">//&#123;17&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">graph.bfs(myVertices[<span class="number">0</span>], printNode); <span class="comment">//&#123;18&#125;</span></span><br></pre></td></tr></table></figure>
<p>首先，我们声明了一个回调函数（行{16}），它仅仅在浏览器控制台上输出已经被完全探索过的顶点的名字。接着，我们会调用bfs方法，给它传递第一个顶点（A——从本章开头声明的myVertices数组）和回调函数。当我们执行这段代码时，该算法会在浏览器控制台输出下示的结果：</p>
<blockquote>
<p>Visited vertex: A<br>Visited vertex: B<br>Visited vertex: C<br>Visited vertex: D<br>Visited vertex: E<br>Visited vertex: F<br>Visited vertex: G<br>Visited vertex: H<br>Visited vertex: I </p>
</blockquote>
<p>顶点被访问的顺序和本节开头的示意图中所展示的一致。</p>
<h4 id="4-1-1-使用BFS寻找最短路径"><a href="#4-1-1-使用BFS寻找最短路径" class="headerlink" title="4.1.1 使用BFS寻找最短路径"></a>4.1.1 使用BFS寻找最短路径</h4><p>到目前为止，我们只展示了BFS算法的工作原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面这个问题。</p>
<p>给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。</p>
<p>对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改bfs方法以返回给我们一些信息：</p>
<ul>
<li>从v到u的距离d[u]；</li>
<li>前溯点pred[u]，用来推导出从v到其他每个顶点u的最短路径。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.BFS = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(),</span><br><span class="line">        queue = <span class="keyword">new</span> Queue(),</span><br><span class="line">        d = [], <span class="comment">//&#123;1&#125; </span></span><br><span class="line">        pred = []; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    queue.enqueue(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        d[vertices[i]] = <span class="number">0</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        pred[vertices[i]] = <span class="literal">null</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">var</span> u = queue.dequeue(),</span><br><span class="line">            neighbors = adjList.get(u);</span><br><span class="line">        color[u] = <span class="string">'grey'</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> w = neighbors[i];</span><br><span class="line">            <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123;</span><br><span class="line">                color[w] = <span class="string">'grey'</span>;</span><br><span class="line">                d[w] = d[u] + <span class="number">1</span>; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                pred[w] = u; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color[u] = <span class="string">'black'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        distances: d,</span><br><span class="line">        predecessors: pred</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>让我们来看看改进过的广度优先方法的实现：</p>
<p>我们还需要声明数组d（行{1}）来表示距离，以及pred数组来表示前溯点。下一步则是对图中的每一个顶点，用0来初始化数组d（行{4}），用null来初始化数组pred。</p>
<p>当我们发现顶点u的邻点w时，则设置w的前溯点值为u（行{7}）。我们还通过给d[u]加1来设置v和w之间的距离（u是w的前溯点，d[u]的值已经有了）。</p>
<p>方法最后返回了一个包含d和pred的对象（行{8}）。</p>
<p>现在，我们可以再次执行BFS方法，并将其返回值存在一个变量中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortestPathA = graph.BFS(myVertices[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(shortestPathA);</span><br></pre></td></tr></table></figure>
<p>对顶点A执行BFS方法，以下将会是输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distances: [A: <span class="number">0</span>, <span class="attr">B</span>: <span class="number">1</span>, <span class="attr">C</span>: <span class="number">1</span>, <span class="attr">D</span>: <span class="number">1</span>, <span class="attr">E</span>: <span class="number">2</span>, <span class="attr">F</span>: <span class="number">2</span>, <span class="attr">G</span>: <span class="number">2</span>, <span class="attr">H</span>: <span class="number">2</span> , <span class="attr">I</span>: <span class="number">3</span>],</span><br><span class="line">predecessors: [A: <span class="literal">null</span>, <span class="attr">B</span>: <span class="string">"A"</span>, <span class="attr">C</span>: <span class="string">"A"</span>, <span class="attr">D</span>: <span class="string">"A"</span>, <span class="attr">E</span>: <span class="string">"B"</span>, <span class="attr">F</span>: <span class="string">"B"</span>, <span class="attr">G</span>: <span class="string">"C"</span>, <span class="attr">H</span>: <span class="string">"D"</span>, <span class="attr">I</span>: <span class="string">"E"</span>]</span><br></pre></td></tr></table></figure>
<p>这意味着顶点A与顶点B、C和D的距离为1；与顶点E、F、G和H的距离为2；与顶点I的距离为3。</p>
<p>通过前溯点数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fromVertex = myVertices[<span class="number">0</span>]; <span class="comment">//&#123;9&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; myVertices.length; i++) &#123; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">    <span class="keyword">var</span> toVertex = myVertices[i], <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        path = <span class="keyword">new</span> Stack(); <span class="comment">//&#123;12&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> v = toVertex; v !== fromVertex;v = shortestPathA.predecessors[v]) &#123; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">        path.push(v); <span class="comment">//&#123;14&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    path.push(fromVertex); <span class="comment">//&#123;15&#125;</span></span><br><span class="line">    <span class="keyword">var</span> s = path.pop(); <span class="comment">//&#123;16&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (!path.isEmpty()) &#123; <span class="comment">//&#123;17&#125;</span></span><br><span class="line">        s += <span class="string">' - '</span> + path.pop(); <span class="comment">//&#123;18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(s); <span class="comment">//&#123;19&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用顶点A作为源顶点（行{9}）。对于每个其他顶点（除了顶点A——行{10}），我们会计算顶点A到它的路径。我们从顶点数组得到toVertex（行{11}），然后会创建一个栈来存储路径值（行{12}）。</p>
<p>接着，我们追溯toVertex到fromVertex的路径（行{13}）。变量v被赋值为其前溯点的值，这样我们能够反向追溯这条路径。将变量v添加到栈中（行{14}）。最后，源顶点也会被添加到栈中，以得到完整路径。</p>
<p>这之后，我们创建了一个s字符串，并将源顶点赋值给它（它是最后一个加入栈中的，所以它是第一个被弹出的项 ——行{16}）。当栈是非空的，我们就从栈中移出一个项并将其拼接到字符串s的后面（行{18}）。最后（行{19}）在控制台上输出路径。</p>
<p>执行该代码段，我们会得到如下输出：</p>
<blockquote>
<p>A - B<br>A - C<br>A - D<br>A - B - E<br>A - B - F<br>A - C - G<br>A - D - H<br>A - B - E - I </p>
</blockquote>
<p>这里，我们得到了从顶点A到图中其他顶点的最短路径（衡量标准是边的数量）。</p>
<h4 id="4-1-2-深入学习最短路径算法"><a href="#4-1-2-深入学习最短路径算法" class="headerlink" title="4.1.2 深入学习最短路径算法"></a>4.1.2 深入学习最短路径算法</h4><p>本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法），广度优先搜索未必合适。</p>
<p>举些例子，Dijkstra算法解决了单源最短路径问题。Bellman-Ford算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，它用经验法则来加速搜索过程。Floyd-Warshall算法解决了求所有顶点对间的最短路径这一问题。</p>
<p>如文章开头提到的，图是一个广泛的主题，对最短路径问题及其变种问题，我们有很多的解决方案。但在开始学习这些其他解决方案前，我们需要掌握好图的基本概念，这是本章涵盖的内容。而这些其他解决方案则不会在本章讲述，但你可以自行探索图的奇妙世界</p>
<h3 id="4-2深度优先搜索"><a href="#4-2深度优先搜索" class="headerlink" title="4.2深度优先搜索"></a>4.2深度优先搜索</h3><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-09.png" alt="深度优先搜索示意图"></p>
<p>深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。</p>
<p>要访问顶点v，照如下步骤做。</p>
<blockquote>
<p>(1) 标注v为被发现的（灰色）。<br>(2) 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。</p>
</blockquote>
<p>如你所见，深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。</p>
<p>让我们来实现一下深度优先算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dfs = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(); <span class="comment">//&#123;1&#125; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (color[vertices[i]] === <span class="string">'white'</span>) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            dfsVisit(vertices[i], color, callback); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dfsVisit = <span class="function"><span class="keyword">function</span> (<span class="params">u, color, callback</span>) </span>&#123;</span><br><span class="line">    color[u] = <span class="string">'grey'</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (callback) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">        callback(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> neighbors = adjList.get(u); <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        <span class="keyword">var</span> w = neighbors[i]; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">            dfsVisit(w, color, callback); <span class="comment">//&#123;11&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = <span class="string">'black'</span>; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，我们创建颜色数组（行{1}），并用值white为图中的每个顶点对其做初始化，广度优先搜索也这么做的。接着，对于图实例中每一个未被访问过的顶点（行{2}和{3}），我们调用私有的递归函数dfsVisit，传递的参数为顶点、颜色数组以及回调函数（行{4}）。</p>
<p>当访问u顶点时，我们标注其为被发现的（grey——行{5}）。如果有callback函数的话（行{6}），则执行该函数输出已访问过的顶点。接下来一步是取得包含顶点u所有邻点的列表（行{7}）。对于顶点u的每一个未被访问过（颜色为white——行{10}和行{8}）的邻点w（行{9}），我们将调用dfsVisit函数，传递w和其他参数（行{11}——添加顶点w入栈，这样接下来就能访问它）。最后，在该顶点和邻点按深度访问之后，我们回退，意思是该顶点已被完全探索，并将其标注为black（行{12}）。</p>
<p>让我们执行下面的代码段来测试一下dfs方法：</p>
<p>输出如下：</p>
<blockquote>
<p>Visited vertex: A<br>Visited vertex: B<br>Visited vertex: E<br>Visited vertex: I<br>Visited vertex: F<br>Visited vertex: C<br>Visited vertex: D<br>Visited vertex: G<br>Visited vertex: H </p>
</blockquote>
<p>这个顺序和本节开头处示意图所展示的一致。下面这个示意图展示了该算法每一步的执行过程：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-10.png" alt="深度优先搜索执行过程示意图"></p>
<p>在我们示例所用的图中，行{4}只会被执行一次，因为所有其他的顶点都有路径到第一个调用dfsVisit函数的顶点（顶点A）。如果顶点B第一个调用函数，则行{4}将会为其他顶点再执行一次（比如顶点A）。</p>
<h4 id="4-2-1-深度优先搜索"><a href="#4-2-1-深度优先搜索" class="headerlink" title="4.2.1 深度优先搜索"></a>4.2.1 深度优先搜索</h4><p>到目前为止，我们只是展示了深度优先搜索算法的工作原理。我们可以用该算法做更多的事情，而不只是输出被访问顶点的顺序。</p>
<p>对于给定的图G，我们希望深度优先搜索算法遍历图G的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。我们可以修改dfs方法来返回给我们一些信息：</p>
<blockquote>
<p>顶点u的发现时间d[u]；<br>当顶点u被标注为黑色时，u的完成探索时间f[u]；<br>顶点u的前溯点p[u]。</p>
</blockquote>
<p>让我们来看看改进了的DFS方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="number">0</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line"><span class="keyword">this</span>.DFS = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = initializeColor(), <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        d = [],</span><br><span class="line">        f = [],</span><br><span class="line">        p = [];</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        f[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">        d[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">        p[vertices[i]] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[vertices[i]] === <span class="string">'white'</span>) &#123;</span><br><span class="line">            DFSVisit(vertices[i], color, d, f, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        discovery: d,</span><br><span class="line">        finished: f,</span><br><span class="line">        predecessors: p</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> DFSVisit = <span class="function"><span class="keyword">function</span> (<span class="params">u, color, d, f, p</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'discovered '</span> + u);</span><br><span class="line">    color[u] = <span class="string">'grey'</span>;</span><br><span class="line">    d[u] = ++time; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="keyword">var</span> neighbors = adjList.get(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> w = neighbors[i];</span><br><span class="line">        <span class="keyword">if</span> (color[w] === <span class="string">'white'</span>) &#123;</span><br><span class="line">            p[w] = u; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">            DFSVisit(w, color, d, f, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[u] = <span class="string">'black'</span>;</span><br><span class="line">    f[u] = ++time; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'explored '</span> + u);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要一个变量来要追踪发现时间和完成探索时间（行{1}）。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他JavaScript方法（将变量作为引用传递的意思是如果该变量在其他方法内部被修改，新值会在原始变量中反映出来）。接下来，我们声明数组d、f和p（行{2}）。我们需要为图的每一个顶点来初始化这些数组（行{3}）。在这个方法结尾处返回这些值（行{4}），之后我们要用到它们。</p>
<p>当一个顶点第一次被发现时，我们追踪其发现时间（行{5}）。当它是由引自顶点u的边而被发现的，我们追踪它的前溯点（行{6}）。最后，当这个顶点被完全探索后，我们追踪其完成时间（行{7}）。</p>
<p>深度优先算法背后的思想是什么？边是从最近发现的顶点u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法回退到u被发现的地方去探索其他的边。这个过程持续到我们发现了所有从原始顶点能够触及的顶点。如果还留有任何其他未被发现的顶点，我们对新源顶点重复这个过程。重复该算法，直到图中所有的顶点都被探索了。</p>
<p>对于改进过的深度优先搜索，有两点需要我们注意：</p>
<blockquote>
<p>时间（time）变量值的范围只可能在图顶点数量的一倍到两倍之间；<br>对于所有的顶点u，d[u]&lt;f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）。</p>
</blockquote>
<p>在这两个假设下，我们有如下的规则：</p>
<blockquote>
<p>1 ≤ d [u] &lt; f [u] ≤ 2|V| </p>
</blockquote>
<p>如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-11.png" alt="深度优先搜索执行过程示意图"></p>
<h4 id="4-2-2-拓扑排序——使用深度优先搜索"><a href="#4-2-2-拓扑排序——使用深度优先搜索" class="headerlink" title="4.2.2 拓扑排序——使用深度优先搜索"></a>4.2.2 拓扑排序——使用深度优先搜索</h4><p>给定下图，假定每个顶点都是一个我们需要去执行的任务：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-12.png" alt="深度优先搜索执行过程示意图"></p>
<p>这是一个有向图，意味着任务的执行是有顺序的。例如，任务F不能在任务A之前执行。注意这个图没有环，意味着这是一个无环图。所以，我们可以说该图是一个有向无环图（DAG）。</p>
<p>当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting，英文亦写作topsort或是toposort）。在日常生活中，这个问题在不同情形下都会出现。例如，当我们开始学习一门计算机科学课程，在学习某些知识之前得按顺序完成一些知识储备（你不可以在上算法I前先上算法II）。当我们在开发一个项目时，需要按顺序执行一些步骤，例如，首先我们得从客户那里得到需求，接着开发客户要求的东西，最后交付项目。你不能先交付项目再去收集需求。</p>
<p>拓扑排序只能应用于DAG。那么，如何使用深度优先搜索来实现拓扑排序呢？让我们在本节开头的示意图上执行一下深度优先搜索。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = <span class="keyword">new</span> Graph();</span><br><span class="line">myVertices = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;myVertices.length; i++)&#123;</span><br><span class="line">graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'C'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'E'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'F'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'F'</span>, <span class="string">'E'</span>);</span><br><span class="line"><span class="keyword">var</span> result = graph.DFS();</span><br></pre></td></tr></table></figure>
<p>这段代码将创建图，添加边，执行改进版本的深度优先搜索算法，并将结果保存到result变量。下图展示了深度优先搜索算法执行后，该图的发现和完成时间</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-13.png" alt="拓扑排序示意图"></p>
<p>现在要做的仅仅是以倒序来排序完成时间数组，这便得出了该图的拓扑排序：</p>
<blockquote>
<p>B - A - D - C - F - E  </p>
</blockquote>
<p>注意之前的拓扑排序结果仅是多种可能性之一。如果我们稍微修改一下算法，就会有不同的结果，比如下面这个结果也是众多其他可能性中的一个：</p>
<blockquote>
<p>A - B - C - D - F - E </p>
</blockquote>
<h2 id="五、-最短路径算法"><a href="#五、-最短路径算法" class="headerlink" title="五、 最短路径算法"></a>五、 最短路径算法</h2><p>设想你要从街道地图上的A点，通过可能的最短路径到达B点。举例来说，从洛杉矶的圣莫尼卡大道到好莱坞大道，如下图所示：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-14.png" alt="最短路径演示"></p>
<p>这种问题在生活中非常常见，我们（特别是生活在大城市的人们）会求助于苹果地图、谷歌地图、Waze等应用程序。当然，我们也有其他的考虑，如时间或路况，但根本的问题仍然是：从A到B的最短路径是什么？</p>
<p>我们可以用图来解决这个问题，相应的算法被称为最短路径。本节我们将介绍两种非常著名的算法，即Dijkstra算法和Floyd-Warshall算法。</p>
<h3 id="5-1-Dijkstra-算法"><a href="#5-1-Dijkstra-算法" class="headerlink" title="5.1 Dijkstra 算法"></a>5.1 Dijkstra 算法</h3><p>Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。</p>
<p>考虑下图：</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-15.png" alt="Dijkstra 算法示意图"></p>
<p>我们来看看如何找到顶点A和其余顶点之间的最短路径。但首先，我们需要声明表示上图的邻接矩阵，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]];</span><br></pre></td></tr></table></figure>
<p>现在，通过下面的代码来看看Dijkstra算法是如何工作的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dijkstra = <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dist = [],</span><br><span class="line">        visited = [],</span><br><span class="line">        length = <span class="keyword">this</span>.graph.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        dist[i] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[src] = <span class="number">0</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">var</span> u = minDistance(dist, visited); <span class="comment">//&#123;4&#125; </span></span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; <span class="keyword">this</span>.graph[u][v] != <span class="number">0</span> &amp;&amp; dist[u] != <span class="built_in">Number</span>.MAX_SAFE_INTEGER &amp;&amp; dist[u] + <span class="keyword">this</span>.graph[u][v] &lt; dist[v]) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                dist[v] = dist[u] + <span class="keyword">this</span>.graph[u][v]; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是对算法过程的描述。</p>
<blockquote>
<p>行{1}：首先，把所有的距离（dist）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），将visited[]初始化为false。<br>行{2}：然后，把源顶点到自己的距离设为0。<br>行{3}：接下来，要找出到其余顶点的最短路径。<br>行{4}：为此，我们需要从尚未处理的顶点中选出距离最近的顶点。<br>行{5}：把选出的顶点标为visited，以免重复计算。<br>行{6}：如果找到更短的路径，则更新最短路径的值（行{7}）。<br>行{8}：处理完所有顶点后，返回从源顶点（src）到图中其他顶点最短路径的结果。</p>
</blockquote>
<p>要计算顶点间的minDistance，就要搜索dist数组中的最小值，返回它在数组中的索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">dist, visited</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min = INF, minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[v] == <span class="literal">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">        min = dist[v];</span><br><span class="line">            minIndex = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对本节开始的图执行以上算法，会得到如下输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-Floyd-Warshall-算法"><a href="#5-2-Floyd-Warshall-算法" class="headerlink" title="5.2 Floyd-Warshall 算法"></a>5.2 Floyd-Warshall 算法</h3><p>Floyd-Warshall算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。</p>
<p>Floyd-Warshall算法实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.floydWarshall = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dist = [],</span><br><span class="line">        length = <span class="keyword">this</span>.graph.length,</span><br><span class="line">        i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">            dist[i] = [];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                dist[i][j] = <span class="keyword">this</span>.graph[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; length; k++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">                        dist[i][j] = dist[i][k] + dist[k][j]; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">下面是对算法过程的描述:</span><br><span class="line"></span><br><span class="line">&gt; 行&#123;<span class="number">1</span>&#125;：首先，把dist数组初始化为每个顶点之间的权值，因为i到j可能的最短距离就是这些顶点间的权值。</span><br><span class="line">&gt; 行&#123;<span class="number">2</span>&#125;：通过k，得到i途径顶点<span class="number">0</span>至k，到达j的最短路径。</span><br><span class="line">&gt; 行&#123;<span class="number">3</span>&#125;：判断i经过顶点k到达j的路径是否比已有的最短路径更短。</span><br><span class="line">&gt; 行&#123;<span class="number">4</span>&#125;：如果是更短的路径，则更新最短路径的值。</span><br><span class="line"></span><br><span class="line">行&#123;<span class="number">3</span>&#125;是Floyd-Warshall算法的核心。对本节开始的图执行以上算法，会得到如下输出：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">    0 2 3 6 4 6</span></span><br><span class="line"><span class="string">    INF 0 1 4 2 4</span></span><br><span class="line"><span class="string">    INF INF 0 6 3 5</span></span><br><span class="line"><span class="string">    INF INF INF 0 INF 2 </span></span><br><span class="line"><span class="string">    INF INF INF 3 0 2</span></span><br><span class="line"><span class="string">    INF INF INF INF INF 0</span></span><br></pre></td></tr></table></figure>
<p>其中，INF代表顶点i到j的最短路径不存在。</p>
<p>对图中每一个顶点执行Dijkstra算法，也可以得到相同的结果。</p>
<h2 id="六、-最小生成树"><a href="#六、-最小生成树" class="headerlink" title="六、 最小生成树"></a>六、 最小生成树</h2><p>最小生成树（MST）问题是网络设计中常见的问题。想象一下，你的公司有几间办公室，要以最低的成本实现办公室电话线路相互连通，以节省资金，最好的办法是什么？</p>
<p>这也可以应用于岛桥问题。设想你要在n个岛屿之间建造桥梁，想用最低的成本实现所有岛屿相互连通。</p>
<p>这两个问题都可以用MST算法来解决，其中的办公室或者岛屿可以表示为图中的一个顶点，边代表成本。这里我们有一个图的例子，其中较粗的边是一个MST的解决方案。</p>
<p><img src="/2019/03/08/cjvxl139w001j80vbq58ysw3g/Graph-16.png" alt="Dijkstra 算法示意图"></p>
<h3 id="6-1-Prim-算法"><a href="#6-1-Prim-算法" class="headerlink" title="6.1 Prim 算法"></a>6.1 Prim 算法</h3><p>Prim算法是一种求解加权无向连通图的MST问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>
<p>现在，通过下面的代码来看看Prim算法是如何工作的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.prim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = [],</span><br><span class="line">        key = [],</span><br><span class="line">        visited = [];</span><br><span class="line">        length = <span class="keyword">this</span>.graph.length,</span><br><span class="line">        i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        key[i] = INF;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="keyword">var</span> u = minKey(key, visited); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        visited[u] = <span class="literal">true</span>; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.graph[u][v] &amp;&amp; visited[v] == <span class="literal">false</span> &amp;&amp; <span class="keyword">this</span>.graph[u][v] &lt; key[v]) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            parent[v] = u; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            key[v] = <span class="keyword">this</span>.graph[u][v]; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是对算法过程的描述。</p>
<blockquote>
<p>行{1}：首先，把所有顶点（key）初始化为无限大（JavaScript最大的数INF = Number.MAX_SAFE_INTEGER），visited[]初始化为false。<br>行{2}：其次，选择第一个key作为第一个顶点，同时，因为第一个顶点总是MST的根节点，所以parent[0] = -1。<br>行{3}：然后，对所有顶点求MST。<br>行{4}：从未处理的顶点集合中选出key值最小的顶点（与Dijkstra算法中使用的函数一样，只是名字不同）。<br>行{5}：把选出的顶点标为visited，以免重复计算。<br>行{6}：如果得到更小的权值，则保存MST路径（parent，行{7}）并更新其权值（行{8}）。<br>行{9}：处理完所有顶点后，返回包含MST的结果。</p>
</blockquote>
<p>比较Prim算法和Dijkstra算法，我们会发现除了行{7}和行{8}之外，两者非常相似。行{7}用parent数组保存MST的结果。行{8}用key数组保存权值最小的边，而在Dijkstra算法中，用dist数组保存距离。我们可以修改Dijkstra算法，加入parent数组。这样，就可以在求出距离的同时得到路径。</p>
<p>对如下的图执行以上算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>]];</span><br></pre></td></tr></table></figure>
<p>我们会得到如下输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Edge Weight</span><br><span class="line"><span class="number">0</span> - <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> - <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> - <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> - <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> - <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="6-1-Kruskal-算法"><a href="#6-1-Kruskal-算法" class="headerlink" title="6.1 Kruskal 算法"></a>6.1 Kruskal 算法</h3><p>和Prim算法类似，Kruskal算法也是一种求加权无向连通图的MST的贪心算法。</p>
<p>现在，通过下面的代码来看看Kruskal算法是如何工作的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.kruskal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="keyword">this</span>.graph.length,</span><br><span class="line">    parent = [], cost,</span><br><span class="line">    ne = <span class="number">0</span>, a, b, u, v, i, j, min;</span><br><span class="line">    cost = initializeCost(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (ne &lt; length<span class="number">-1</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, min = INF; i &lt; length; i++) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class="line">                    min = cost[i][j];</span><br><span class="line">                    u = i;</span><br><span class="line">                    v = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        u = find(u, parent); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        v = find(v, parent); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (union(u, v, parent)) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">            ne++;</span><br><span class="line">        &#125;</span><br><span class="line">        cost[u][v] = cost[v][u] = INF; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是对算法过程的描述。</p>
<blockquote>
<p>行{1}：首先，把邻接矩阵的值复制到cost数组，以方便修改且可以保留原始值行{7}。<br>行{2}：当MST的边数小于顶点总数减1时。<br>行{3}：找出权值最小的边。<br>行{4}和行{5}：检查MST中是否已存在这条边，以避免环路。<br>行{6}：如果u和v是不同的边，则将其加入MST。<br>行{7}：从列表中移除这些边，以免重复计算。<br>行{8}：返回MST。</p>
</blockquote>
<p>下面是find函数的定义。它能防止MST出现环路：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find = <span class="function"><span class="keyword">function</span>(<span class="params">i, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[i]) &#123;</span><br><span class="line">        i = parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>union函数的定义如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> union = <span class="function"><span class="keyword">function</span>(<span class="params">i, j, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">        parent[j] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个算法有几种变体。这取决于对边的权值排序时所使用的数据结构（如优先队列），以及图是如何表示的。</p>
<script type="text/javascript" src="/js/jquery.js?v=2.0.1" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>坚持原创技术分享，您的支持将鼓励我继续创作！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/images/weChatMoney.png" title="微信打赏" alt="微信打赏"><img src="/images/alipayMoney.png" title="支付宝打赏" alt="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/03/18/cjvxl139h001f80vb6h0usjmu/" class="pre">javascript数据结构与算法十（排序和搜索算法）</a><a href="/2019/02/28/cjvxl139v001i80vb7lpuo58w/" class="next">javascript数据结构与算法八（树）</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODk0OS8xNTQ3Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、图的相关术语"><span class="toc-text">一、图的相关术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-有向图和无向图"><span class="toc-text">1.1 有向图和无向图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、-图的表示"><span class="toc-text">二、 图的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-邻接矩阵"><span class="toc-text">2.1 邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-邻接表"><span class="toc-text">2.2 邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-关联矩阵"><span class="toc-text">2.3 关联矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、创建Graph类"><span class="toc-text">三、创建Graph类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、图的遍历"><span class="toc-text">四、图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-广度优先搜索"><span class="toc-text">4.1 广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-使用BFS寻找最短路径"><span class="toc-text">4.1.1 使用BFS寻找最短路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-深入学习最短路径算法"><span class="toc-text">4.1.2 深入学习最短路径算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2深度优先搜索"><span class="toc-text">4.2深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-深度优先搜索"><span class="toc-text">4.2.1 深度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-拓扑排序——使用深度优先搜索"><span class="toc-text">4.2.2 拓扑排序——使用深度优先搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、-最短路径算法"><span class="toc-text">五、 最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Dijkstra-算法"><span class="toc-text">5.1 Dijkstra 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Floyd-Warshall-算法"><span class="toc-text">5.2 Floyd-Warshall 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、-最小生成树"><span class="toc-text">六、 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Prim-算法"><span class="toc-text">6.1 Prim 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Kruskal-算法"><span class="toc-text">6.1 Kruskal 算法</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/21/cjvxl138a001980vba2xe67su/">javascript设计模式与开发实践四（单例模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/08/cjvxl133i000a80vb87ocov1d/">javascript设计模式与开发实践五（策略模式 ）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/07/cjvxl13ap001o80vbf3qwgcwi/">javascript设计模式与开发实践三（闭包和高阶函数）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/29/cjvxl1388001580vbsxzuwmfj/">javascript设计模式与开发实践二（this、call 和 apply）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/cjvxl13ax001q80vbyf10135m/">javascript设计模式与开发实践一（面向对象的JavaScript ）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/12/cjvxl134i000r80vb7tdd9766/">javascript数据结构与算法十二（算法复杂度）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/30/cjvxl139z001l80vbvwzcwltg/">javascript数据结构与算法十一（算法模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/18/cjvxl139h001f80vb6h0usjmu/">javascript数据结构与算法十（排序和搜索算法）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/cjvxl139w001j80vbq58ysw3g/">javascript数据结构与算法九（图）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/cjvxl139v001i80vb7lpuo58w/">javascript数据结构与算法八（树）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/js实现拖拽/" style="font-size: 15px;">js实现拖拽</a> <a href="/tags/前端历史/" style="font-size: 15px;">前端历史</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/slot/" style="font-size: 15px;">slot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github-pages/" style="font-size: 15px;">github pages</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 新浪微博</i></div><iframe width="100%" height="400" frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1" class="share_self"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Abriams/Abriams.github.io" title="github地址" target="_blank">github地址</a><ul></ul><a href="https://weibo.com/u/6110018783/home?wvr=5" title="微博" target="_blank">微博</a><ul></ul><a href="https://juejin.im/timeline" title="掘金" target="_blank">掘金</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Abriams.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b1cc44eb56a7dbf6192c0702e5b38b08";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>