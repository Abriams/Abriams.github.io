<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Abriams blog"><meta name="keywords" content="前端， 移动互联网, vue"><title>javascript数据结构与算法七（字典和散列表） | 淡笑忘、祈一世凡恋</title><link rel="stylesheet" type="text/css" href="/css/donate.css"><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">javascript数据结构与算法七（字典和散列表）</h1><a id="logo" href="/.">淡笑忘、祈一世凡恋</a><p class="description">进步的源泉来源于坚持不懈</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">javascript数据结构与算法七（字典和散列表）</h1><div class="post-meta"><a href="/2019/01/18/cjvasuird0016ckvbis2b71yf/#comments" class="comment-count"></a><p><span class="date">Jan 18, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>字典和散也是用来存储唯一值（不重复的值）的数据结构。</p>
<p>集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同。</p>
<h2 id="一、-字典"><a href="#一、-字典" class="headerlink" title="一、 字典"></a>一、 字典</h2><p>前面已经学习过，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。</p>
<h3 id="1-1-创建字典"><a href="#1-1-创建字典" class="headerlink" title="1.1 创建字典"></a>1.1 创建字典</h3><p>首先创建Dictionary类的骨架：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与Set类类似，我们将在一个Object的实例而不是数组中存储元素。然后，我们需要声明一些映射/字典所能使用的方法。</p>
<blockquote>
<p>set(key,value)：向字典中添加新元素。<br>delete(key)：通过使用键值来从字典中移除键值对应的数据值。<br>has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。<br>get(key)：通过键值查找特定的数值并返回。<br>clear()：将这个字典中的所有元素全部删除。<br>size()：返回字典所包含元素的数量。与数组的length属性类似。<br>keys()：将字典所包含的所有键名以数组形式返回。<br>values()：将字典所包含的所有数值以数组形式返回。</p>
</blockquote>
<h4 id="1-1-1-has-和-set-方法"><a href="#1-1-1-has-和-set-方法" class="headerlink" title="1.1.1 has 和 set 方法"></a>1.1.1 has 和 set 方法</h4><p>我们首先来实现has(key)方法。之所以要先实现这个方法，是因为它会被set和remove等其他方法调用。我们可以通过如下代码来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> items;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法的实现和我们之前在Set类中的实现是一样的。我们使用JavaScript中的in操作符来验证一个key是否是items对象的一个属性。</p>
<p>然后是set方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    items[key] = value; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该方法接受一个key和一个value作为参数。我们直接将value设为items对象的key属性的值。它可以用来给字典添加一个新的值，或者用来更新一个已有的值。</p>
<h4 id="1-1-2-delete方法"><a href="#1-1-2-delete方法" class="headerlink" title="1.1.2 delete方法"></a>1.1.2 delete方法</h4><p>接下来，我们实现delete方法。它和Set类中的delete方法很相似，唯一的不同点在于我们将先搜索key（而不是value）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.delete= <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">        <span class="keyword">delete</span> items[key];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们可以使用JavaScript的delete操作符来从items对象中移除key属性。</p>
<h4 id="1-1-3-get和values方法"><a href="#1-1-3-get和values方法" class="headerlink" title="1.1.3 get和values方法"></a>1.1.3 get和values方法</h4><p>如果我们想在字典中查找一个特定的项，并检索它的值，可以使用下面的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>get方法首先会验证我们想要检索的值是否存在（通过查找key值），如果存在，将返回该值，反之将返回一个undefined值（请记住undefined值和null值是不一样的</p>
<p>下一个是values方法。这个方法以数组的形式返回字典中所有values实例的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> items) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">            values.push(items[key]) <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们遍历items对象的所有属性值（行{1}）。为了确定值存在，我们使用has函数来验证key确实存在，然后将它的值加入values数组（行{2}）。最后，我们就能返回所有找到的值。</p>
<p>我们不能仅仅使用for-in语句来遍历items对象的所有属性，还需要使用hasOwnProperty方法（验证items对象是否包含某个属性），因为对象的原型也会包含对象的其他属性（JavaScript基本的Object类中的属性将会被继承，并存在于当前对象中，而对于这个数据结构来说，我们并不需要它们）。</p>
<h4 id="1-1-4-clear、size、keys和getItems方法"><a href="#1-1-4-clear、size、keys和getItems方法" class="headerlink" title="1.1.4 clear、size、keys和getItems方法"></a>1.1.4 clear、size、keys和getItems方法</h4><p>clear和size 方法与前面介绍的Set类中对应的方法是完全一样的。</p>
<p>keys方法返回在Dictionary类中所有用于标识值的键名。要取出一个JavaScript对象中所有的键名，可以把这个对象作为参数传入Object类的keys方法（到目前为止，书中创建的类，包括Dictionary在内，都是JavaScript对象），如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.keys = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> object.keys(items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来验证items属性的输出值。我们可以实现一个返回items变量的方法，叫作getItems：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getItems = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-5-使用Dictionary"><a href="#1-1-5-使用Dictionary" class="headerlink" title="1.1.5 使用Dictionary"></a>1.1.5 使用Dictionary</h4><p>首先，我们来创建一个Dictionary类的实例，然后给它添加三条电子邮件地址。我们将会使用这个dictionary实例来实现一个电子邮件地址簿。</p>
<p>使用我们创建的类来执行如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> Dictionary();</span><br><span class="line">dictionary.set(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">dictionary.set(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">dictionary.set(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br></pre></td></tr></table></figure>
<p>如果执行了如下代码，输出结果将会是true：</p>
<blockquote>
<p>console.log(dictionary.has(‘Gandalf’)); </p>
</blockquote>
<p>下面的代码将会输出3，因为我们向字典实例中添加了三个元素：</p>
<blockquote>
<p>console.log(dictionary.size()); </p>
</blockquote>
<p>现在，执行下面的几行代码：</p>
<blockquote>
<p>console.log(dictionary.keys());<br>console.log(dictionary.values());<br>console.log(dictionary.get(‘Tyrion’)); </p>
</blockquote>
<p>输出结果分别如下所示：</p>
<blockquote>
<p>[“Gandalf”, “John”, “Tyrion”]<br>[“<a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a>“, “<a href="mailto:johnsnow@email.com" target="_blank" rel="noopener">johnsnow@email.com</a>“, “<a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a>“]<br><a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a> </p>
</blockquote>
<p>最后，再执行几行代码：</p>
<blockquote>
<p>dictionary.delete(‘John’);</p>
</blockquote>
<p>再执行下面的代码：</p>
<blockquote>
<p>console.log(dictionary.keys());<br>console.log(dictionary.values());<br>console.log(dictionary.getItems());</p>
</blockquote>
<p>输出结果如下所示：</p>
<blockquote>
<p>[“Gandalf”, “Tyrion”]<br>[“<a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a>“, “<a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a>“]<br>Object {Gandalf: “<a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a>“, Tyrion:”<a href="mailto:tyrion@email.com" target="_blank" rel="noopener">tyrion@email.com</a>“}</p>
</blockquote>
<p>移除了一个元素后，现在的dictionary实例中只包含两个元素了。</p>
<h2 id="二、-散列表"><a href="#二、-散列表" class="headerlink" title="二、 散列表"></a>二、 散列表</h2><p>接下来我们会学到HashTable类，也叫HashMap类，它是Dictionary类的一种散列表实现方式。</p>
<p>散列算法的作用是尽可能快地在数据结构中找到一个值。在前面我们已经知道如果要在数据结构中获得一个值（使用get方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址</p>
<p>举个例子，我们继续使用字典中的案例使用电子邮件地址簿。我们将要使用最常见的散列函数——“lose lose”散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。</p>
<p><img src="/2019/01/18/cjvasuird0016ckvbis2b71yf/hashTable-01.png" alt="“lose lose”函数示例"></p>
<h3 id="2-1-创建散列表"><a href="#2-1-创建散列表" class="headerlink" title="2.1 创建散列表"></a>2.1 创建散列表</h3><p>我们将使用数组来表示我们的数据结构，该数据结构的图表（“lose lose”）所用的非常相似。</p>
<p>和之前一样，我们从搭建类的骨架开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> table = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，给类添加一些方法。我们给每个类实现三个基本方法</p>
<blockquote>
<p>put(key,value)：向散列表增加一个新的项（也能更新散列表）。<br>remove(key)：根据键值从散列表中移除值。<br>get(key)：返回根据键值检索到的特定的值。</p>
</blockquote>
<p>在实现这三个方法之前，要实现的第一个方法是散列函数，它是HashTable类中的一个私有方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loseloseHashCode = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">0</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        hash += key.charCodeAt(i); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">37</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给定一个key参数，我们就能根据组成key的每个字符的ASCII码值的和得到一个数字。所以，首先需要一个变量来存储这个总和（行{1}）。然后，遍历key（行{2}）并将从ASCII表中查到的每个字符对应的ASCII值加到hash变量中（可以使用JavaScript的String类中的charCodeAt方法——行{3}）。最后，返回hash值。为了得到比较小的数值，我们会使用hash值和一个任意数做除法的余数（mod）。</p>
<p>现在，有了散列函数，我们就可以实现put方法了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key); <span class="comment">//&#123;5&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(position + <span class="string">' - '</span> + key); <span class="comment">//&#123;6&#125;</span></span><br><span class="line">    table[position] = value; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，根据给定的key，我们需要根据所创建的散列函数计算出它在表中的位置（行{5}）。为了便于展示信息，我们将计算出的位置输出至控制台（行{6}）。由于它不是必需的，我们也可以将这行代码移除。然后要做的，是将value参数添加到用散列函数计算出的对应的位置上。（行{7}）。</p>
<p>从HashTable实例中查找一个值也很简单。为此，我们将会实现一个get方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> table[loseloseHashCode(key)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，我们会使用所创建的散列函数来求出给定key所对应的位置。这个函数会返回值的位置，因此我们所要做的就是根据这个位置从数组table中获得这个值。</p>
<p>我们要实现的最后一个方法是remove方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    table[loseloseHashCode(key)] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要从HashTable实例中移除一个元素，只需要求出元素的位置（可以使用散列函数来获取）并赋值为undefined。</p>
<p>对于HashTable类来说，我们不需要像ArrayList类一样从table数组中将位置也移除。由于元素分布于整个数组范围内，一些位置会没有任何元素占据，并默认为undefined值。我们也不能将位置本身从数组中移除（这会改变其他元素的位置），否则，当下次需要获得或移除一个元素的时候，这个元素会不在我们用散列函数求出的位置上。</p>
<h3 id="2-2-使用-HashTable-类"><a href="#2-2-使用-HashTable-类" class="headerlink" title="2.2 使用 HashTable 类"></a>2.2 使用 HashTable 类</h3><p>让我们执行一些代码来测试HashTable类:</p>
<blockquote>
<p>var hash = new HashTable();<br>hash.put(‘Gandalf’, <a href="mailto:&#39;gandalf@email.com" target="_blank" rel="noopener">&#39;gandalf@email.com</a>‘);<br>hash.put(‘John’, <a href="mailto:&#39;johnsnow@email.com" target="_blank" rel="noopener">&#39;johnsnow@email.com</a>‘);<br>hash.put(‘Tyrion’, <a href="mailto:&#39;tyrion@email.com" target="_blank" rel="noopener">&#39;tyrion@email.com</a>‘); </p>
</blockquote>
<p>执行上述代码，会在控制台中获得如下输出：</p>
<blockquote>
<p>19 - Gandalf<br>29 - John<br>16 - Tyrion </p>
</blockquote>
<p>下面的图表展现了包含这三个元素的HashTable数据结构：</p>
<p><img src="/2019/01/18/cjvasuird0016ckvbis2b71yf/hashTable-02.png" alt="HashTable数据结构展示"></p>
<p>现在来测试get方法：</p>
<blockquote>
<p>console.log(hash.get(‘Gandalf’));<br>console.log(hash.get(‘Loiane’)); </p>
</blockquote>
<p>获得如下的输出：</p>
<blockquote>
<p><a href="mailto:gandalf@email.com" target="_blank" rel="noopener">gandalf@email.com</a><br>undefined </p>
</blockquote>
<p>由于Gandalf是一个在散列表中存在的键，get方法将会返回它的值。而由于Loiane是一个不存在的键，当我们试图在数组中根据位置获取值的时候（一个由散列函数生成的位置），返回值将会是undefined（即不存在）。</p>
<p>然后，我们试试从散列表中移除Gandalf：</p>
<blockquote>
<p>hash.remove(‘Gandalf’);<br>console.log(hash.get(‘Gandalf’)); </p>
</blockquote>
<p>由于Gandalf不再存在于表中，hash.get(‘Gandalf’)方法将会在控制台上给出undefined的输出结果。</p>
<h3 id="2-3-散列表和散列集合"><a href="#2-3-散列表和散列集合" class="headerlink" title="2.3 散列表和散列集合"></a>2.3 散列表和散列集合</h3><p>散列表和散列映射是一样的，我们学习过这种数据结构了。</p>
<p>在一些编程语言中，还有一种叫作散列集合的实现。散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是散列函数。我们可以重用本章实现HashTable的所有代码来实现散列集合，不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储唯一的不重复的值。</p>
<h3 id="2-4-处理散列表中的冲突"><a href="#2-4-处理散列表中的冲突" class="headerlink" title="2.4 处理散列表中的冲突"></a>2.4 处理散列表中的冲突</h3><p>有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。例如，我们看看下面的代码会得到怎样的输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> HashTable();</span><br><span class="line">hash.put(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Aaron'</span>, <span class="string">'aaron@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Donnie'</span>, <span class="string">'donnie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Ana'</span>, <span class="string">'ana@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jonathan'</span>, <span class="string">'jonathan@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jamie'</span>, <span class="string">'jamie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Sue'</span>, <span class="string">'sue@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Mindy'</span>, <span class="string">'mindy@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Paul'</span>, <span class="string">'paul@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Nathan'</span>, <span class="string">'nathan@email.com'</span>);</span><br></pre></td></tr></table></figure>
<p>注意，Tyrion和Aaron有相同的散列值（16）。Donnie和Ana有相同的散列值（13），Jonathan、Jamie和Sue有相同的散列值（5），Mindy和Paul也有相同的散列值（32）。</p>
<p>那HashTable实例会怎样呢？执行之前的代码后散列表中会有哪些值呢？</p>
<p>为了获得结果，我们来实现一个叫作print的辅助方法，它会在控制台上输出HashTable中的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; ++i) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (table[i] !== <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">            <span class="built_in">console</span>.log(i + <span class="string">": "</span> + table[i]);<span class="comment">//&#123;3&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在来使用这个方法：</p>
<blockquote>
<p>hash.print(); </p>
</blockquote>
<p>在控制台上得到如下的输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>: sue              @email.com</span><br><span class="line"><span class="number">10</span>: nathan@email.com</span><br><span class="line"><span class="number">13</span>: ana@email.com</span><br><span class="line"><span class="number">16</span>: aaron@email.com</span><br><span class="line"><span class="number">19</span>: gandalf@email.com</span><br><span class="line"><span class="number">29</span>: johnsnow@email.com</span><br><span class="line"><span class="number">32</span>: paul@email.com</span><br></pre></td></tr></table></figure>
<p>Jonathan、Jamie和Sue有相同的散列值，也就是5。由于Sue是最后一个被添加的，Sue将是在HashTable实例中占据位置5的元素。首先，Jonathan会占据这个位置，然后Jamie会覆<br>盖它，然后Sue会再次覆盖。这对于其他发生冲突的元素来说也是一样的。</p>
<p>使用一个数据结构来保存数据的目的显然不是去丢失这些数据，而是通过某种方法将它们全部保存起来。因此，当这种情况发生的时候就要去解决它。处理冲突有几种方法：分离链接、线性探查和双散列法。在本节中，我们会介绍前两种方法。</p>
<h4 id="2-4-1-分离链接"><a href="#2-4-1-分离链接" class="headerlink" title="2.4.1 分离链接"></a>2.4.1 分离链接</h4><p>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。</p>
<p>例如，我们在之前的测试代码中使用分离链接的话，输出结果将会是这样：</p>
<p><img src="/2019/01/18/cjvasuird0016ckvbis2b71yf/hashTable-03.png" alt="分离链接展示"></p>
<p>在位置5上，将会有包含三个元素的LinkedList实例；在位置13、16和32上，将会有包含两个元素的LinkedList实例；在位置10、19和29上，将会有包含单个元素的LinkedList实例。</p>
<p>对于分离链接和线性探查来说，只需要重写三个方法：put、get和remove。这三个方法在每种技术实现中都是不同的。</p>
<p>为了实现一个使用了分离链接的HashTable实例，我们需要一个新的辅助类来表示将要加入LinkedList实例的元素。我们管它叫ValuePair类（在HashTable类内部定义）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ValuePair = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'['</span> + <span class="keyword">this</span>.key + <span class="string">' - '</span> + <span class="keyword">this</span>.value + <span class="string">']'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类只会将key和value存储在一个Object实例中。我们也重写了toString方法，以便之后在浏览器控制台中输出结果。</p>
<ol>
<li>put方法</li>
</ol>
<p>我们来实现第一个方法，put方法，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] == <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">        table[position] = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    table[position].append(<span class="keyword">new</span> ValuePair(key, value)); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，将验证要加入新元素的位置是否已经被占据（行{1}）。如果这个位置是第一次被加入元素，我们会在这个位置上初始化一个LinkedList类的实例（你已经在第5章中学习过）。然后，使用第5章中实现的append方法向LinkedList实例中添加一个ValuePair实例（键和值）（行{2}）。</p>
<ol start="2">
<li>(2) get方法</li>
</ol>
<p>然后，我们实现用来获取特定值的get方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;3&#125;</span></span><br><span class="line">        <span class="comment">//遍历链表来寻找键/值</span></span><br><span class="line">        <span class="keyword">var</span> current = table[position].getHead(); <span class="comment">//&#123;4&#125;</span></span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123; <span class="comment">//&#123;5&#125;</span></span><br><span class="line">            <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;6&#125;</span></span><br><span class="line">                <span class="keyword">return</span> current.element.value; <span class="comment">//&#123;7&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查元素在链表第一个或最后一个节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">            <span class="keyword">return</span> current.element.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们要做的第一个验证，是确定在特定的位置上是否有元素存在（行{3}）。如果没有，则返回一个undefined表示在HashTable实例中没有找到这个值（行{10}）。如果在这个位置上有值存在，我们知道这是一个LinkedList实例。现在要做的是遍历这个链表来寻找我们需要的元素。在遍历之前先要获取链表表头的引用（行{4}），然后就可以从链表的头部遍历到尾部（行{5}，current.next将会是null）。</p>
<p>Node链表包含next指针和element属性。而element属性又是ValuePair的实例，所以它又有value和key属性。可以通过current.element.key来获得Node链表的key属性，并通过比较它来确定它是否就是我们要找的键（行{6}）。（这就是要使用ValuePair这个辅助类来存储元素的原因。我们不能简单地存储值本身，这样就不能确定哪个值对应着特定的键。）如果key值相同，就返回Node的值（行{7}）；如果不相同，就继续遍历链表，访问下一个节点（行{8}）。</p>
<p>如果要找的元素是链表的第一个或最后一个节点，那么就不会进入while循环的内部。因此，需要在行{9}处理这种特殊的情况</p>
<ol start="3">
<li>remove方法</li>
</ol>
<p>使用分离链接法从HashTable实例中移除一个元素和之前在本章实现的remove方法有一些不同。现在使用的是链表，我们需要从链表中移除一个元素。来看看remove方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> current = table[position].getHead();</span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;11&#125;</span></span><br><span class="line">                table[position].remove(current.element); <span class="comment">//&#123;12&#125;</span></span><br><span class="line">                <span class="keyword">if</span> (table[position].isEmpty()) &#123; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">                    table[position] = <span class="literal">undefined</span>; <span class="comment">//&#123;14&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//&#123;15&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否为第一个或最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (current.element.key === key) &#123; <span class="comment">//&#123;16&#125;</span></span><br><span class="line">            table[position].remove(current.element);</span><br><span class="line">            <span class="keyword">if</span> (table[position].isEmpty()) &#123;</span><br><span class="line">                table[position] = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//&#123;17&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在remove方法中，我们使用和get方法一样的步骤找到要找的元素。遍历LinkedList实例时，如果链表中的current元素就是要找的元素（行{11}），使用remove方法将其从链表中移<br>除。然后进行一步额外的验证：如果链表为空了（行{13}——链表中不再有任何元素了），就将散列表这个位置的值设为undefined（行{14}），这样搜索一个元素或打印它的内容的时候，就可以跳过这个位置了。最后，返回true表示这个元素已经被移除（行{15}）或者在最后返回false表示这个元素在散列表中不存在（行{17}）。同样，需要和get方法一样，处理元素在第一个或最后一个的情况（行{16}）。</p>
<p>重写了这三个方法后，我们就拥有了一个使用了分离链接法来处理冲突的HashMap实例。</p>
<h4 id="2-4-1-线性探查"><a href="#2-4-1-线性探查" class="headerlink" title="2.4.1 线性探查"></a>2.4.1 线性探查</h4><p>另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推</p>
<p>然后重写put、get、remove方法</p>
<ol>
<li>put方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (table[position] == <span class="literal">undefined</span>) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        table[position] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = ++position; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        <span class="keyword">while</span> (table[index] != <span class="literal">undefined</span>) &#123; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">            index++; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = <span class="keyword">new</span> ValuePair(key, value); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和之前一样，先获得由散列函数生成的位置（行{1}），然后验证这个位置是否有元素存在（如果这个位置被占据了，将会通过行{2}的验证）。如果没有元素存在，就在这个位置加入新元素（行{3}——一个ValuePair的实例）。</p>
<p>如果这个位置已经被占据了，需要找到下一个没有被占据的位置（position的值是undefined），因此我们声明一个index变量并赋值为position+1（行{4}——在变量名前使用自增运算符++会先递增变量值然后再将其赋值给index）。然后验证这个位置是否被占据（行{5}），如果被占据了，继续将index递增（行{6}），直到找到一个没有被占据的位置。然后要做的，就是将值分配到这个位置（行{7}）。</p>
<p>如果再次执行插入数据的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> HashTable();</span><br><span class="line">hash.put(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Aaron'</span>, <span class="string">'aaron@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Donnie'</span>, <span class="string">'donnie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Ana'</span>, <span class="string">'ana@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jonathan'</span>, <span class="string">'jonathan@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Jamie'</span>, <span class="string">'jamie@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Sue'</span>, <span class="string">'sue@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Mindy'</span>, <span class="string">'mindy@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Paul'</span>, <span class="string">'paul@email.com'</span>);</span><br><span class="line">hash.put(<span class="string">'Nathan'</span>, <span class="string">'nathan@email.com'</span>);</span><br></pre></td></tr></table></figure>
<p>下图展示使用了线性探查的散列表的最终结果：</p>
<p><img src="/2019/01/18/cjvasuird0016ckvbis2b71yf/hashTable-04.png" alt="分离链接展示"></p>
<p>让我们来模拟一下散列表中的插入操作。</p>
<p>(1) 试着插入Gandalf。它的散列值是19，由于散列表刚刚被创建，位置19还是空的——可以在这里插入数据。<br>(2) 试着在位置29插入John。它也是空的，所以可以插入这个姓名。<br>(3) 试着在位置16插入Tyrion。它是空的，所以可以插入这个姓名。<br>(4) 试着插入Aaron，它的散列值也是16。位置16已经被Tyrion占据了，所以需要检查索引值为position+1的位置（16+1）。位置17是空的，所以可以在位置17插入Aaron。<br>(5) 接着，试着在位置13插入Donnie。它是空的，所以可以插入这个姓名。<br>(6) 想在位置13插入Ana，但是这个位置被占据了。因此在位置14进行尝试，它是空的，所以可以在这里插入姓名。<br>(7) 然后，在位置5插入Jonathan，这个位置是空的，所以可以插入这个姓名。<br>(8) 试着在位置5插入Jamie，但是这个位置被占了。所以跳至位置6，这个位置是空的，因此可以在这个位置插入姓名。<br>(9) 试着在位置5插入Sue，但是位置被占据了。所以跳至位置6，但也被占了。接着跳至位置7，这里是空的，所以可以在这里插入姓名。以此类推。</p>
<ol start="2">
<li>get方法</li>
</ol>
<p>现在插入了所有的元素，让我们实现get方法来获取它们的值吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123; <span class="comment">//&#123;8&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (table[position].key === key) &#123; <span class="comment">//&#123;9&#125;</span></span><br><span class="line">            <span class="keyword">return</span> table[position].value; <span class="comment">//&#123;10&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> index = ++position;</span><br><span class="line">            <span class="keyword">while</span> (table[index] === <span class="literal">undefined</span> || table[index].key !== key) &#123; <span class="comment">//&#123;11&#125;</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (table[index].key === key) &#123; <span class="comment">//&#123;12&#125;</span></span><br><span class="line">                <span class="keyword">return</span> table[index].value; <span class="comment">//&#123;13&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">//&#123;14&#125;                     </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要获得一个键对应的值，先要确定这个键存在（行{8}）。如果这个键不存在，说明要查找的值不在散列表中，因此可以返回undefined（行{14}）。如果这个键存在，需要检查我们要找的值是否就是这个位置上的值（行{9}）。如果是，就返回这个值（行{10}）。</p>
<p>如果不是，就在散列表中的下一个位置继续查找，直到找到一个键值与我们要找的键值相同的元素（行{11}）。然后，验证一下当前项就是我们要找的项（行{12}——只是为了确认一下）并且将它的值返回（行{13}）。</p>
<p>我们无法确定要找的元素实际上在哪个位置，这就是使用ValuePair来表示HashTable元素的原因。</p>
<ol start="3">
<li>remove方法</li>
</ol>
<p>remove方法和get方法基本相同，不同之处在于行{10}和{13}，它们将会由下面的代码代替：</p>
<blockquote>
<p>table[index] = undefined;</p>
</blockquote>
<p>要移除一个元素，只需要给其赋值为undefined，来表示这个位置不再被占据并且可以在必要时接受一个新元素。</p>
<h3 id="2-5-创建更好的散列函数"><a href="#2-5-创建更好的散列函数" class="headerlink" title="2.5 创建更好的散列函数"></a>2.5 创建更好的散列函数</h3><p>我们实现的“lose lose”散列函数并不是一个表现良好的散列函数，因为它会产生太多的冲突。如果我们使用这个函数的话，会产生各种各样的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。我们可以在网上找到一些不同的实现方法，或者也可以实现自己的散列函数。</p>
<p>另一个可以实现的比“lose lose”更好的散列函数是djb2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> djb2HashCode = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">5381</span>; <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123; <span class="comment">//&#123;2&#125;</span></span><br><span class="line">        hash = hash * <span class="number">33</span> + key.charCodeAt(i); <span class="comment">//&#123;3&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">1013</span>; <span class="comment">//&#123;4&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它包括初始化一个hash变量并赋值为一个质数（行{1}——大多数实现都使用5381），然后迭代参数key（行{2}），将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加（行{3}）。</p>
<p>最后，我们将使用相加的和与另一个随机质数（比我们认为的散列表的大小要大——在本例中，我们认为散列表的大小为1000）相除的余数。</p>
<p>如果再次执行插入数据的代码，这将是使用djb2HashCode代替loseloseHashCode的最终结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">798</span> - Gandalf</span><br><span class="line"><span class="number">838</span> - John</span><br><span class="line"><span class="number">624</span> - Tyrion</span><br><span class="line"><span class="number">215</span> - Aaron</span><br><span class="line"><span class="number">278</span> - Donnie</span><br><span class="line"><span class="number">925</span> - Ana</span><br><span class="line"><span class="number">288</span> - Jonathan</span><br><span class="line"><span class="number">962</span> - Jamie</span><br><span class="line"><span class="number">502</span> - Sue</span><br><span class="line"><span class="number">804</span> - Mindy</span><br><span class="line"><span class="number">54</span> - Paul</span><br><span class="line"><span class="number">223</span> - Nathan</span><br></pre></td></tr></table></figure>
<p>这并不是最好的散列函数，但这是最受社区推崇的散列函数之一。</p>
<h2 id="三、es6——Map类"><a href="#三、es6——Map类" class="headerlink" title="三、es6——Map类"></a>三、es6——Map类</h2><p>我们看看原生的Map类怎么用。</p>
<p>还是用我们原来测试Dictionary类的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'Gandalf'</span>, <span class="string">'gandalf@email.com'</span>);</span><br><span class="line">map.set(<span class="string">'John'</span>, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">map.set(<span class="string">'Tyrion'</span>, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'Gandalf'</span>)); <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">//输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">//输出["Gandalf", "John", "Tyrion"]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values()); <span class="comment">//输出["gandalf@email.com", s"johnsnow@email.com", "tyrion@email.com"]</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'Tyrion'</span>)); <span class="comment">//输出tyrion@email.com</span></span><br></pre></td></tr></table></figure>
<p>和我们的Dictionary类不同，ES6的Map类的values方法和keys方法都返回Iterator（第2章提到过），而不是值或键构成的数组。另一个区别是，我们实现的size方法返回字典中存储的值的个数，而ES6的Map类则有一个size属性。</p>
<p>删除map中的元素可以用delete方法：</p>
<blockquote>
<p>map.delete(‘John’);</p>
</blockquote>
<p>clear方法会重置map数据结构，这跟我们在Dictionary类里实现的一样。</p>
<h2 id="四、ES6——WeakMap-类和-WeakSet-类"><a href="#四、ES6——WeakMap-类和-WeakSet-类" class="headerlink" title="四、ES6——WeakMap 类和 WeakSet 类"></a>四、ES6——WeakMap 类和 WeakSet 类</h2><p>除了Set和Map这两种新的数据结构，ES6还增加了它们的弱化版本，WeakSet和WeakMap。</p>
<p>基本上，Map和Set与其弱化版本之间仅有的区别是：</p>
<ul>
<li><p>WeakSet或WeakMap类没有entries、keys和values等方法；</p>
</li>
<li><p>只能用对象作为键。</p>
</li>
</ul>
<p>创建和使用这两个类主要是为了性能。WeakSet和WeakMap是弱化的（用对象作为键），没有强引用的键。这使得JavaScript的垃圾回收器可以从中清除整个入口。</p>
<p>另一个优点是，必须用键才可以取出值。这些类没有entries、keys和values等迭代器方法，因此，除非你知道键，否则没有办法取出值。这印证了我们在前面的做法，即使用WeakMap类封装ES6类的私有属性。</p>
<p>使用WeakMap类的例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">var</span> ob1 = &#123;<span class="attr">name</span>:<span class="string">'Gandalf'</span>&#125;, <span class="comment">//&#123;1&#125;</span></span><br><span class="line">ob2 = &#123;<span class="attr">name</span>:<span class="string">'John'</span>&#125;,</span><br><span class="line">ob3 = &#123;<span class="attr">name</span>:<span class="string">'Tyrion'</span>&#125;;</span><br><span class="line">map.set(ob1, <span class="string">'gandalf@email.com'</span>); <span class="comment">//&#123;2&#125;</span></span><br><span class="line">map.set(ob2, <span class="string">'johnsnow@email.com'</span>);</span><br><span class="line">map.set(ob3, <span class="string">'tyrion@email.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(ob1)); <span class="comment">//&#123;3&#125; 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(ob3)); <span class="comment">//&#123;4&#125; 输出tyrion@email.com</span></span><br><span class="line">map.delete(ob2); <span class="comment">//&#123;5&#125;</span></span><br></pre></td></tr></table></figure>
<p>WeakMap类也可以用set方法，但不能使用数字、字符串、布尔值等基本数据类型，需要将名字转换为对象（行{1}和行{2}）。搜索（行{3}）、读取（行{4}）和删除值（行{5}），也要传入作为键的对象。同样的逻辑也适用于WeakSet类。</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>在本节中，我们学习了字典的相关知识，了解了如何添加、移除和获取元素以及其他的一些方法。我们还了解了字典和集合的不同之处。</p>
<p>我们也学习了散列运算，怎样创建一个散列表（或者说散列映射）数据结构，如何添加、移除和获取元素，以及如何创建散列函数。我们学习了怎样使用两种不同的方法解决散列表中的冲突问题。</p>
<p>我们还介绍了如何使用ES6的Map、WeakMap和WeakSet类。</p>
<script type="text/javascript" src="/js/jquery.js?v=2.0.1" async></script><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><div class="donate_txt"> &uarr;<br>坚持原创技术分享，您的支持将鼓励我继续创作！<br></div></div><div id="donate_guide" class="donate_bar center hidden pay"><img src="/images/weChatMoney.png" title="微信打赏" alt="微信打赏"><img src="/images/alipayMoney.png" title="支付宝打赏" alt="支付宝打赏"></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
    $('#donate_board').addClass('hidden');
    $('#donate_guide').removeClass('hidden');
}</script></div></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/02/28/cjvasuisn0019ckvb3bu8e97g/" class="pre">javascript数据结构与算法八（树）</a><a href="/2018/12/28/cjvasuinx0012ckvbzht2qt6y/" class="next">javascript数据结构与算法六（集合）</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODk0OS8xNTQ3Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、-字典"><span class="toc-text">一、 字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-创建字典"><span class="toc-text">1.1 创建字典</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-has-和-set-方法"><span class="toc-text">1.1.1 has 和 set 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-delete方法"><span class="toc-text">1.1.2 delete方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-get和values方法"><span class="toc-text">1.1.3 get和values方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-clear、size、keys和getItems方法"><span class="toc-text">1.1.4 clear、size、keys和getItems方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-使用Dictionary"><span class="toc-text">1.1.5 使用Dictionary</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、-散列表"><span class="toc-text">二、 散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-创建散列表"><span class="toc-text">2.1 创建散列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-使用-HashTable-类"><span class="toc-text">2.2 使用 HashTable 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-散列表和散列集合"><span class="toc-text">2.3 散列表和散列集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-处理散列表中的冲突"><span class="toc-text">2.4 处理散列表中的冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-分离链接"><span class="toc-text">2.4.1 分离链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-线性探查"><span class="toc-text">2.4.1 线性探查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-创建更好的散列函数"><span class="toc-text">2.5 创建更好的散列函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、es6——Map类"><span class="toc-text">三、es6——Map类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、ES6——WeakMap-类和-WeakSet-类"><span class="toc-text">四、ES6——WeakMap 类和 WeakSet 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、小结"><span class="toc-text">五、小结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/05/cjvasuimq000lckvbs9g1rqas/">javascript数据结构与算法十（排序和搜索算法）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/08/cjvasuiso001ackvbvhv71kkg/">javascript数据结构与算法九（图）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/28/cjvasuisn0019ckvb3bu8e97g/">javascript数据结构与算法八（树）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/cjvasuird0016ckvbis2b71yf/">javascript数据结构与算法七（字典和散列表）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/28/cjvasuinx0012ckvbzht2qt6y/">javascript数据结构与算法六（集合）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/cjvasuirc0015ckvbotb483d3/">javascript数据结构与算法五（链表）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/12/cjvasuimy000uckvbtjaxods3/">javascript数据结构与算法四（队列）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/cjvasuimt000nckvb2wi0e10c/">javascript数据结构与算法三（栈）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/cjvasuinv0011ckvba2omrsut/">javascript数据结构与算法二（数组的使用）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/16/cjvasui2d0003ckvb4s6mrhpa/">javascript数据结构与算法一（javascript基础）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/js实现拖拽/" style="font-size: 15px;">js实现拖拽</a> <a href="/tags/前端历史/" style="font-size: 15px;">前端历史</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/slot/" style="font-size: 15px;">slot</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github-pages/" style="font-size: 15px;">github pages</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-weibo"> 新浪微博</i></div><iframe width="100%" height="400" frameborder="0" scrolling="no" src="https://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=6110018783&amp;verifier=e6a8e226&amp;dpc=1" class="share_self"></iframe></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Abriams/Abriams.github.io" title="github地址" target="_blank">github地址</a><ul></ul><a href="https://weibo.com/u/6110018783/home?wvr=5" title="微博" target="_blank">微博</a><ul></ul><a href="https://juejin.im/timeline" title="掘金" target="_blank">掘金</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Abriams.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b1cc44eb56a7dbf6192c0702e5b38b08";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>